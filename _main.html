<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Advanced R" />
<meta property="og:url" content="http://adv-r.hadley.nz/" />
<meta property="og:image" content="http://adv-r.hadley.nz/cover.png" />
<meta property="og:description" content="The book is designed primarily for R users who want to improve their programming skills and understanding of the language. It should also be useful for programmers coming to R from other languages, as it explains some of R’s quirks and shows how some parts that seem horrible do have a positive side." />

<meta name="author" content="Hadley Wickham" />


<meta name="description" content="The book is designed primarily for R users who want to improve their programming skills and understanding of the language. It should also be useful for programmers coming to R from other languages, as it explains some of R’s quirks and shows how some parts that seem horrible do have a positive side.">

<title>Advanced R</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  window.PagedConfig = {
    before: () => {
      return new Promise((resolve, reject) => {
        var script = document.createElement("script");
        script.type = "text/javascript";
        var src = "true";
        if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
        if (location.protocol !== "file:" && /^https?:/.test(src))
          src = src.replace(/^https?:/, '');
        script.src = src;
        window.MathJax = {
          AuthorInit: () => {
            MathJax.Hub.Register.StartupHook("Begin", () => {
              MathJax.Hub.Queue(resolve);
            });
          }
        };
        document.getElementsByTagName("head")[0].appendChild(script);
      });
    }
  };
</script>

<link href="_main_files/paged-0.1.2/css/crc-page.css" rel="stylesheet" />
<link href="_main_files/paged-0.1.2/css/default-page.css" rel="stylesheet" />
<link href="_main_files/paged-0.1.2/css/default.css" rel="stylesheet" />
<link href="_main_files/paged-0.1.2/css/crc.css" rel="stylesheet" />
<script src="_main_files/paged-0.1.2/js/config.js"></script>
<script src="_main_files/paged-0.1.2/js/paged.js"></script>
<script src="_main_files/paged-0.1.2/js/hooks.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Advanced R</h1>
<h2 class="author">Hadley Wickham</h2>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<h1 class="toc-title">Contents</h1>
<ul>
<li><a href="#welcome">Welcome</a><ul>
<li><a href="#license">License</a></li>
<li><a href="#other-books">Other books</a></li>
</ul></li>
<li><a href="#preface">Preface</a></li>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#why-r"><span class="toc-section-number">1.1</span> Why R?</a></li>
<li><a href="#who-should-read"><span class="toc-section-number">1.2</span> Who should read this book</a></li>
<li><a href="#what-you-will-get"><span class="toc-section-number">1.3</span> What you will get out of this book</a></li>
<li><a href="#what-you-will-not-learn"><span class="toc-section-number">1.4</span> What you will not learn</a></li>
<li><a href="#meta-techniques"><span class="toc-section-number">1.5</span> Meta-techniques</a></li>
<li><a href="#recommended-reading"><span class="toc-section-number">1.6</span> Recommended reading</a></li>
<li><a href="#getting-help"><span class="toc-section-number">1.7</span> Getting help</a></li>
<li><a href="#intro-ack"><span class="toc-section-number">1.8</span> Acknowledgments</a></li>
<li><a href="#conventions"><span class="toc-section-number">1.9</span> Conventions</a></li>
<li><a href="#colophon"><span class="toc-section-number">1.10</span> Colophon</a></li>
</ul></li>
<li class="part"><span><b>I Foundations</b></span></li>
<li><a href="#foundations-intro">Introduction</a></li>
<li><a href="#names-values"><span class="toc-section-number">2</span> Names and values</a><ul>
<li><a href="#introduction-1"><span class="toc-section-number">2.1</span> Introduction</a><ul>
<li><a href="#quiz">Quiz</a></li>
<li><a href="#outline">Outline</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#sources">Sources</a></li>
</ul></li>
<li><a href="#binding-basics"><span class="toc-section-number">2.2</span> Binding basics</a><ul>
<li><a href="#non-syntactic"><span class="toc-section-number">2.2.1</span> Non-syntactic names</a></li>
<li><a href="#exercises"><span class="toc-section-number">2.2.2</span> Exercises</a></li>
</ul></li>
<li><a href="#copy-on-modify"><span class="toc-section-number">2.3</span> Copy-on-modify</a><ul>
<li><a href="#tracemem"><span class="toc-section-number">2.3.1</span> <code>tracemem()</code></a></li>
<li><a href="#function-calls"><span class="toc-section-number">2.3.2</span> Function calls</a></li>
<li><a href="#list-references"><span class="toc-section-number">2.3.3</span> Lists</a></li>
<li><a href="#df-modify"><span class="toc-section-number">2.3.4</span> Data frames</a></li>
<li><a href="#character-vectors"><span class="toc-section-number">2.3.5</span> Character vectors</a></li>
<li><a href="#exercises-1"><span class="toc-section-number">2.3.6</span> Exercises</a></li>
</ul></li>
<li><a href="#object-size"><span class="toc-section-number">2.4</span> Object size</a><ul>
<li><a href="#exercises-2"><span class="toc-section-number">2.4.1</span> Exercises</a></li>
</ul></li>
<li><a href="#modify-in-place"><span class="toc-section-number">2.5</span> Modify-in-place</a><ul>
<li><a href="#single-binding"><span class="toc-section-number">2.5.1</span> Objects with a single binding</a></li>
<li><a href="#env-modify"><span class="toc-section-number">2.5.2</span> Environments</a></li>
<li><a href="#exercises-3"><span class="toc-section-number">2.5.3</span> Exercises</a></li>
</ul></li>
<li><a href="#gc"><span class="toc-section-number">2.6</span> Unbinding and the garbage collector</a></li>
<li><a href="#names-values-answers"><span class="toc-section-number">2.7</span> Answers</a></li>
</ul></li>
<li><a href="#vectors-chap"><span class="toc-section-number">3</span> Vectors</a><ul>
<li><a href="#introduction-2"><span class="toc-section-number">3.1</span> Introduction</a><ul>
<li><a href="#quiz-1">Quiz</a></li>
<li><a href="#outline-1">Outline</a></li>
</ul></li>
<li><a href="#atomic-vectors"><span class="toc-section-number">3.2</span> Atomic vectors</a><ul>
<li><a href="#scalars"><span class="toc-section-number">3.2.1</span> Scalars</a></li>
<li><a href="#atomic-constructing"><span class="toc-section-number">3.2.2</span> Making longer vectors with <code>c()</code></a></li>
<li><a href="#testing-and-coercion"><span class="toc-section-number">3.2.3</span> Testing and coercion</a></li>
<li><a href="#exercises-4"><span class="toc-section-number">3.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#attributes"><span class="toc-section-number">3.3</span> Attributes</a><ul>
<li><a href="#getting-and-setting"><span class="toc-section-number">3.3.1</span> Getting and setting</a></li>
<li><a href="#attr-names"><span class="toc-section-number">3.3.2</span> Names</a></li>
<li><a href="#attr-dims"><span class="toc-section-number">3.3.3</span> Dimensions</a></li>
<li><a href="#exercises-5"><span class="toc-section-number">3.3.4</span> Exercises</a></li>
</ul></li>
<li><a href="#s3-atomic-vectors"><span class="toc-section-number">3.4</span> S3 atomic vectors</a><ul>
<li><a href="#factors"><span class="toc-section-number">3.4.1</span> Factors</a></li>
<li><a href="#dates"><span class="toc-section-number">3.4.2</span> Dates</a></li>
<li><a href="#date-times"><span class="toc-section-number">3.4.3</span> Date-times</a></li>
<li><a href="#durations"><span class="toc-section-number">3.4.4</span> Durations</a></li>
<li><a href="#exercises-6"><span class="toc-section-number">3.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#lists"><span class="toc-section-number">3.5</span> Lists</a><ul>
<li><a href="#list-creating"><span class="toc-section-number">3.5.1</span> Creating</a></li>
<li><a href="#list-types"><span class="toc-section-number">3.5.2</span> Testing and coercion</a></li>
<li><a href="#list-array"><span class="toc-section-number">3.5.3</span> Matrices and arrays</a></li>
<li><a href="#exercises-7"><span class="toc-section-number">3.5.4</span> Exercises</a></li>
</ul></li>
<li><a href="#tibble"><span class="toc-section-number">3.6</span> Data frames and tibbles</a><ul>
<li><a href="#df-create"><span class="toc-section-number">3.6.1</span> Creating</a></li>
<li><a href="#rownames"><span class="toc-section-number">3.6.2</span> Row names</a></li>
<li><a href="#printing"><span class="toc-section-number">3.6.3</span> Printing</a></li>
<li><a href="#safe-subsetting"><span class="toc-section-number">3.6.4</span> Subsetting</a></li>
<li><a href="#df-test-coerce"><span class="toc-section-number">3.6.5</span> Testing and coercing</a></li>
<li><a href="#list-columns"><span class="toc-section-number">3.6.6</span> List columns</a></li>
<li><a href="#matrix-and-data-frame-columns"><span class="toc-section-number">3.6.7</span> Matrix and data frame columns</a></li>
<li><a href="#exercises-8"><span class="toc-section-number">3.6.8</span> Exercises</a></li>
</ul></li>
<li><a href="#null"><span class="toc-section-number">3.7</span> <code>NULL</code></a></li>
<li><a href="#data-structure-answers"><span class="toc-section-number">3.8</span> Answers</a></li>
</ul></li>
<li><a href="#subsetting"><span class="toc-section-number">4</span> Subsetting</a><ul>
<li><a href="#introduction-3"><span class="toc-section-number">4.1</span> Introduction</a><ul>
<li><a href="#quiz-2">Quiz</a></li>
<li><a href="#outline-2">Outline</a></li>
</ul></li>
<li><a href="#subset-multiple"><span class="toc-section-number">4.2</span> Selecting multiple elements</a><ul>
<li><a href="#atomic-vectors-1"><span class="toc-section-number">4.2.1</span> Atomic vectors</a></li>
<li><a href="#lists-1"><span class="toc-section-number">4.2.2</span> Lists</a></li>
<li><a href="#matrix-subsetting"><span class="toc-section-number">4.2.3</span> Matrices and arrays</a></li>
<li><a href="#df-subsetting"><span class="toc-section-number">4.2.4</span> Data frames and tibbles</a></li>
<li><a href="#simplify-preserve"><span class="toc-section-number">4.2.5</span> Preserving dimensionality</a></li>
<li><a href="#exercises-9"><span class="toc-section-number">4.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#subset-single"><span class="toc-section-number">4.3</span> Selecting a single element</a><ul>
<li><a href="#section"><span class="toc-section-number">4.3.1</span> <code>[[</code></a></li>
<li><a href="#section-1"><span class="toc-section-number">4.3.2</span> <code>$</code></a></li>
<li><a href="#subsetting-oob"><span class="toc-section-number">4.3.3</span> Missing/out of bounds indices</a></li>
<li><a href="#and-slot"><span class="toc-section-number">4.3.4</span> <code>@</code> and <code>slot()</code></a></li>
<li><a href="#exercises-10"><span class="toc-section-number">4.3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#subassignment"><span class="toc-section-number">4.4</span> Subsetting and assignment</a></li>
<li><a href="#applications"><span class="toc-section-number">4.5</span> Applications</a><ul>
<li><a href="#lookup-tables"><span class="toc-section-number">4.5.1</span> Lookup tables (character subsetting)</a></li>
<li><a href="#matching-merging"><span class="toc-section-number">4.5.2</span> Matching and merging by hand (integer subsetting)</a></li>
<li><a href="#random-samplesbootstraps-integer-subsetting"><span class="toc-section-number">4.5.3</span> Random samples/bootstraps (integer subsetting)</a></li>
<li><a href="#ordering-integer-subsetting"><span class="toc-section-number">4.5.4</span> Ordering (integer subsetting)</a></li>
<li><a href="#expanding-aggregated-counts-integer-subsetting"><span class="toc-section-number">4.5.5</span> Expanding aggregated counts (integer subsetting)</a></li>
<li><a href="#removing-columns-from-data-frames-character-subsetting"><span class="toc-section-number">4.5.6</span> Removing columns from data frames (character subsetting)</a></li>
<li><a href="#selecting-rows-based-on-a-condition-logical-subsetting"><span class="toc-section-number">4.5.7</span> Selecting rows based on a condition (logical subsetting)</a></li>
<li><a href="#boolean-algebra-vs.sets-logical-integer-subsetting"><span class="toc-section-number">4.5.8</span> Boolean algebra vs. sets (logical &amp; integer subsetting)</a></li>
<li><a href="#exercises-11"><span class="toc-section-number">4.5.9</span> Exercises</a></li>
</ul></li>
<li><a href="#subsetting-answers"><span class="toc-section-number">4.6</span> Answers</a></li>
</ul></li>
<li><a href="#control-flow"><span class="toc-section-number">5</span> Control flow</a><ul>
<li><a href="#introduction-4"><span class="toc-section-number">5.1</span> Introduction</a><ul>
<li><a href="#quiz-3">Quiz</a></li>
<li><a href="#outline-3">Outline</a></li>
</ul></li>
<li><a href="#choices"><span class="toc-section-number">5.2</span> Choices</a><ul>
<li><a href="#invalid-inputs"><span class="toc-section-number">5.2.1</span> Invalid inputs</a></li>
<li><a href="#vectorised-if"><span class="toc-section-number">5.2.2</span> Vectorised if</a></li>
<li><a href="#switch"><span class="toc-section-number">5.2.3</span> <code>switch()</code> statement</a></li>
<li><a href="#exercises-12"><span class="toc-section-number">5.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#loops"><span class="toc-section-number">5.3</span> Loops</a><ul>
<li><a href="#common-pitfalls"><span class="toc-section-number">5.3.1</span> Common pitfalls</a></li>
<li><a href="#for-family"><span class="toc-section-number">5.3.2</span> Related tools</a></li>
<li><a href="#exercises-13"><span class="toc-section-number">5.3.3</span> Exercises</a></li>
</ul></li>
<li><a href="#control-flow-answers"><span class="toc-section-number">5.4</span> Answers</a></li>
</ul></li>
<li><a href="#functions"><span class="toc-section-number">6</span> Functions</a><ul>
<li><a href="#introduction-5"><span class="toc-section-number">6.1</span> Introduction</a><ul>
<li><a href="#quiz-4">Quiz</a></li>
<li><a href="#outline-4">Outline</a></li>
</ul></li>
<li><a href="#function-fundamentals"><span class="toc-section-number">6.2</span> Function fundamentals</a><ul>
<li><a href="#fun-components"><span class="toc-section-number">6.2.1</span> Function components</a></li>
<li><a href="#primitive-functions"><span class="toc-section-number">6.2.2</span> Primitive functions</a></li>
<li><a href="#first-class-functions"><span class="toc-section-number">6.2.3</span> First-class functions</a></li>
<li><a href="#invoking-a-function"><span class="toc-section-number">6.2.4</span> Invoking a function</a></li>
<li><a href="#exercises-14"><span class="toc-section-number">6.2.5</span> Exercises</a></li>
</ul></li>
<li><a href="#function-composition"><span class="toc-section-number">6.3</span> Function composition</a></li>
<li><a href="#lexical-scoping"><span class="toc-section-number">6.4</span> Lexical scoping</a><ul>
<li><a href="#name-masking"><span class="toc-section-number">6.4.1</span> Name masking</a></li>
<li><a href="#functions-vs.variables"><span class="toc-section-number">6.4.2</span> Functions vs. variables</a></li>
<li><a href="#fresh-start"><span class="toc-section-number">6.4.3</span> A fresh start</a></li>
<li><a href="#dynamic-lookup"><span class="toc-section-number">6.4.4</span> Dynamic lookup</a></li>
<li><a href="#exercises-15"><span class="toc-section-number">6.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#lazy-evaluation"><span class="toc-section-number">6.5</span> Lazy evaluation</a><ul>
<li><a href="#promises"><span class="toc-section-number">6.5.1</span> Promises</a></li>
<li><a href="#default-arguments"><span class="toc-section-number">6.5.2</span> Default arguments</a></li>
<li><a href="#missing-arguments"><span class="toc-section-number">6.5.3</span> Missing arguments</a></li>
<li><a href="#exercises-16"><span class="toc-section-number">6.5.4</span> Exercises</a></li>
</ul></li>
<li><a href="#fun-dot-dot-dot"><span class="toc-section-number">6.6</span> <code>...</code> (dot-dot-dot)</a><ul>
<li><a href="#exercises-17"><span class="toc-section-number">6.6.1</span> Exercises</a></li>
</ul></li>
<li><a href="#exiting-a-function"><span class="toc-section-number">6.7</span> Exiting a function</a><ul>
<li><a href="#implicit-vs.explicit-returns"><span class="toc-section-number">6.7.1</span> Implicit vs. explicit returns</a></li>
<li><a href="#invisible"><span class="toc-section-number">6.7.2</span> Invisible values</a></li>
<li><a href="#errors"><span class="toc-section-number">6.7.3</span> Errors</a></li>
<li><a href="#on-exit"><span class="toc-section-number">6.7.4</span> Exit handlers</a></li>
<li><a href="#exercises-18"><span class="toc-section-number">6.7.5</span> Exercises</a></li>
</ul></li>
<li><a href="#function-forms"><span class="toc-section-number">6.8</span> Function forms</a><ul>
<li><a href="#prefix-transform"><span class="toc-section-number">6.8.1</span> Rewriting to prefix form</a></li>
<li><a href="#prefix-form"><span class="toc-section-number">6.8.2</span> Prefix form</a></li>
<li><a href="#infix-functions"><span class="toc-section-number">6.8.3</span> Infix functions</a></li>
<li><a href="#replacement-functions"><span class="toc-section-number">6.8.4</span> Replacement functions</a></li>
<li><a href="#special-forms"><span class="toc-section-number">6.8.5</span> Special forms</a></li>
<li><a href="#exercises-19"><span class="toc-section-number">6.8.6</span> Exercises</a></li>
</ul></li>
<li><a href="#function-answers"><span class="toc-section-number">6.9</span> Quiz answers</a></li>
</ul></li>
<li><a href="#environments"><span class="toc-section-number">7</span> Environments</a><ul>
<li><a href="#introduction-6"><span class="toc-section-number">7.1</span> Introduction</a><ul>
<li><a href="#quiz-5">Quiz</a></li>
<li><a href="#outline-5">Outline</a></li>
<li><a href="#prerequisites-1">Prerequisites</a></li>
</ul></li>
<li><a href="#env-basics"><span class="toc-section-number">7.2</span> Environment basics</a><ul>
<li><a href="#basics"><span class="toc-section-number">7.2.1</span> Basics</a></li>
<li><a href="#important-environments"><span class="toc-section-number">7.2.2</span> Important environments</a></li>
<li><a href="#parents"><span class="toc-section-number">7.2.3</span> Parents</a></li>
<li><a href="#super-assignment--"><span class="toc-section-number">7.2.4</span> Super assignment, <code>&lt;&lt;-</code></a></li>
<li><a href="#getting-and-setting-1"><span class="toc-section-number">7.2.5</span> Getting and setting</a></li>
<li><a href="#advanced-bindings"><span class="toc-section-number">7.2.6</span> Advanced bindings</a></li>
<li><a href="#exercises-20"><span class="toc-section-number">7.2.7</span> Exercises</a></li>
</ul></li>
<li><a href="#env-recursion"><span class="toc-section-number">7.3</span> Recursing over environments</a><ul>
<li><a href="#exercises-21"><span class="toc-section-number">7.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#special-environments"><span class="toc-section-number">7.4</span> Special environments</a><ul>
<li><a href="#search-path"><span class="toc-section-number">7.4.1</span> Package environments and the search path</a></li>
<li><a href="#function-environments"><span class="toc-section-number">7.4.2</span> The function environment</a></li>
<li><a href="#namespaces"><span class="toc-section-number">7.4.3</span> Namespaces</a></li>
<li><a href="#execution-environments"><span class="toc-section-number">7.4.4</span> Execution environments</a></li>
<li><a href="#exercises-22"><span class="toc-section-number">7.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#call-stack"><span class="toc-section-number">7.5</span> The call stack</a><ul>
<li><a href="#simple-call-stacks"><span class="toc-section-number">7.5.1</span> Simple call stacks</a></li>
<li><a href="#lazy-call-stack"><span class="toc-section-number">7.5.2</span> Lazy evaluation</a></li>
<li><a href="#frames"><span class="toc-section-number">7.5.3</span> Frames</a></li>
<li><a href="#dynamic-scope"><span class="toc-section-number">7.5.4</span> Dynamic scope</a></li>
<li><a href="#exercises-23"><span class="toc-section-number">7.5.5</span> Exercises</a></li>
</ul></li>
<li><a href="#explicit-envs"><span class="toc-section-number">7.6</span> As data structures</a></li>
<li><a href="#env-answers"><span class="toc-section-number">7.7</span> Quiz answers</a></li>
</ul></li>
<li><a href="#conditions"><span class="toc-section-number">8</span> Conditions</a><ul>
<li><a href="#introduction-7"><span class="toc-section-number">8.1</span> Introduction</a><ul>
<li><a href="#quiz-6">Quiz</a></li>
<li><a href="#outline-6">Outline</a></li>
<li><a href="#prerequisites-2"><span class="toc-section-number">8.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#signalling-conditions"><span class="toc-section-number">8.2</span> Signalling conditions</a><ul>
<li><a href="#errors-1"><span class="toc-section-number">8.2.1</span> Errors</a></li>
<li><a href="#warnings"><span class="toc-section-number">8.2.2</span> Warnings</a></li>
<li><a href="#messages"><span class="toc-section-number">8.2.3</span> Messages</a></li>
<li><a href="#exercises-24"><span class="toc-section-number">8.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#ignoring-conditions"><span class="toc-section-number">8.3</span> Ignoring conditions</a></li>
<li><a href="#handling-conditions"><span class="toc-section-number">8.4</span> Handling conditions</a><ul>
<li><a href="#condition-objects"><span class="toc-section-number">8.4.1</span> Condition objects</a></li>
<li><a href="#exiting-handlers"><span class="toc-section-number">8.4.2</span> Exiting handlers</a></li>
<li><a href="#calling-handlers"><span class="toc-section-number">8.4.3</span> Calling handlers</a></li>
<li><a href="#call-stacks"><span class="toc-section-number">8.4.4</span> Call stacks</a></li>
<li><a href="#exercises-25"><span class="toc-section-number">8.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#custom-conditions"><span class="toc-section-number">8.5</span> Custom conditions</a><ul>
<li><a href="#motivation"><span class="toc-section-number">8.5.1</span> Motivation</a></li>
<li><a href="#signalling"><span class="toc-section-number">8.5.2</span> Signalling</a></li>
<li><a href="#handling"><span class="toc-section-number">8.5.3</span> Handling</a></li>
<li><a href="#exercises-26"><span class="toc-section-number">8.5.4</span> Exercises</a></li>
</ul></li>
<li><a href="#condition-applications"><span class="toc-section-number">8.6</span> Applications</a><ul>
<li><a href="#failure-value"><span class="toc-section-number">8.6.1</span> Failure value</a></li>
<li><a href="#try-success-failure"><span class="toc-section-number">8.6.2</span> Success and failure values</a></li>
<li><a href="#resignal"><span class="toc-section-number">8.6.3</span> Resignal</a></li>
<li><a href="#record"><span class="toc-section-number">8.6.4</span> Record</a></li>
<li><a href="#no-default-behaviour"><span class="toc-section-number">8.6.5</span> No default behaviour</a></li>
<li><a href="#exercises-27"><span class="toc-section-number">8.6.6</span> Exercises</a></li>
</ul></li>
<li><a href="#conditions-answers"><span class="toc-section-number">8.7</span> Quiz answers</a></li>
</ul></li>
<li class="part"><span><b>II Functional programming</b></span></li>
<li><a href="#fp">Introduction</a><ul>
<li><a href="#functional-programming-languages">Functional programming languages</a></li>
<li><a href="#functional-style">Functional style</a></li>
</ul></li>
<li><a href="#functionals"><span class="toc-section-number">9</span> Functionals</a><ul>
<li><a href="#introduction-8"><span class="toc-section-number">9.1</span> Introduction</a><ul>
<li><a href="#outline-7">Outline</a></li>
<li><a href="#prerequisites-3">Prerequisites</a></li>
</ul></li>
<li><a href="#map"><span class="toc-section-number">9.2</span> My first functional: <code>map()</code></a><ul>
<li><a href="#map-atomic"><span class="toc-section-number">9.2.1</span> Producing atomic vectors</a></li>
<li><a href="#purrr-shortcuts"><span class="toc-section-number">9.2.2</span> Anonymous functions and shortcuts</a></li>
<li><a href="#passing-arguments"><span class="toc-section-number">9.2.3</span> Passing arguments with <code>...</code></a></li>
<li><a href="#argument-names"><span class="toc-section-number">9.2.4</span> Argument names</a></li>
<li><a href="#change-argument"><span class="toc-section-number">9.2.5</span> Varying another argument</a></li>
<li><a href="#exercises-28"><span class="toc-section-number">9.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#purrr-style"><span class="toc-section-number">9.3</span> Purrr style</a></li>
<li><a href="#map-variants"><span class="toc-section-number">9.4</span> Map variants</a><ul>
<li><a href="#modify"><span class="toc-section-number">9.4.1</span> Same type of output as input: <code>modify()</code></a></li>
<li><a href="#map2"><span class="toc-section-number">9.4.2</span> Two inputs: <code>map2()</code> and friends</a></li>
<li><a href="#no-outputs-walk-and-friends"><span class="toc-section-number">9.4.3</span> No outputs: <code>walk()</code> and friends</a></li>
<li><a href="#iterating-over-values-and-indices"><span class="toc-section-number">9.4.4</span> Iterating over values and indices</a></li>
<li><a href="#pmap"><span class="toc-section-number">9.4.5</span> Any number of inputs: <code>pmap()</code> and friends</a></li>
<li><a href="#exercises-29"><span class="toc-section-number">9.4.6</span> Exercises</a></li>
</ul></li>
<li><a href="#reduce"><span class="toc-section-number">9.5</span> Reduce</a><ul>
<li><a href="#basics-1"><span class="toc-section-number">9.5.1</span> Basics</a></li>
<li><a href="#accumulate"><span class="toc-section-number">9.5.2</span> Accumulate</a></li>
<li><a href="#output-types"><span class="toc-section-number">9.5.3</span> Output types</a></li>
<li><a href="#multiple-inputs"><span class="toc-section-number">9.5.4</span> Multiple inputs</a></li>
<li><a href="#map-reduce"><span class="toc-section-number">9.5.5</span> Map-reduce</a></li>
</ul></li>
<li><a href="#predicate-functionals"><span class="toc-section-number">9.6</span> Predicate functionals</a><ul>
<li><a href="#basics-2"><span class="toc-section-number">9.6.1</span> Basics</a></li>
<li><a href="#predicate-map"><span class="toc-section-number">9.6.2</span> Map variants</a></li>
<li><a href="#exercises-30"><span class="toc-section-number">9.6.3</span> Exercises</a></li>
</ul></li>
<li><a href="#base-functionals"><span class="toc-section-number">9.7</span> Base functionals</a><ul>
<li><a href="#matrices-and-arrays"><span class="toc-section-number">9.7.1</span> Matrices and arrays</a></li>
<li><a href="#mathematical"><span class="toc-section-number">9.7.2</span> Mathematical</a></li>
<li><a href="#exercises-31"><span class="toc-section-number">9.7.3</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#function-factories"><span class="toc-section-number">10</span> Function factories</a><ul>
<li><a href="#introduction-9"><span class="toc-section-number">10.1</span> Introduction</a><ul>
<li><a href="#outline-8">Outline</a></li>
<li><a href="#prerequisites-4">Prerequisites</a></li>
</ul></li>
<li><a href="#factory-fundamentals"><span class="toc-section-number">10.2</span> Factory fundamentals</a><ul>
<li><a href="#environments-1"><span class="toc-section-number">10.2.1</span> Environments</a></li>
<li><a href="#diagram-conventions"><span class="toc-section-number">10.2.2</span> Diagram conventions</a></li>
<li><a href="#forcing-evaluation"><span class="toc-section-number">10.2.3</span> Forcing evaluation</a></li>
<li><a href="#stateful-funs"><span class="toc-section-number">10.2.4</span> Stateful functions</a></li>
<li><a href="#factory-pitfalls"><span class="toc-section-number">10.2.5</span> Garbage collection</a></li>
<li><a href="#exercises-32"><span class="toc-section-number">10.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#graph-fact"><span class="toc-section-number">10.3</span> Graphical factories</a><ul>
<li><a href="#labelling"><span class="toc-section-number">10.3.1</span> Labelling</a></li>
<li><a href="#histogram-bins"><span class="toc-section-number">10.3.2</span> Histogram bins</a></li>
<li><a href="#ggsave"><span class="toc-section-number">10.3.3</span> <code>ggsave()</code></a></li>
<li><a href="#exercises-33"><span class="toc-section-number">10.3.4</span> Exercises</a></li>
</ul></li>
<li><a href="#stat-fact"><span class="toc-section-number">10.4</span> Statistical factories</a><ul>
<li><a href="#box-cox-transformation"><span class="toc-section-number">10.4.1</span> Box-Cox transformation</a></li>
<li><a href="#bootstrap-generators"><span class="toc-section-number">10.4.2</span> Bootstrap generators</a></li>
<li><a href="#MLE"><span class="toc-section-number">10.4.3</span> Maximum likelihood estimation</a></li>
<li><a href="#exercises-34"><span class="toc-section-number">10.4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#functional-factories"><span class="toc-section-number">10.5</span> Function factories + functionals</a><ul>
<li><a href="#exercises-35"><span class="toc-section-number">10.5.1</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#function-operators"><span class="toc-section-number">11</span> Function operators</a><ul>
<li><a href="#introduction-10"><span class="toc-section-number">11.1</span> Introduction</a><ul>
<li><a href="#outline-9">Outline</a></li>
<li><a href="#prerequisites-5">Prerequisites</a></li>
</ul></li>
<li><a href="#existing-fos"><span class="toc-section-number">11.2</span> Existing function operators</a><ul>
<li><a href="#safely"><span class="toc-section-number">11.2.1</span> Capturing errors with <code>purrr::safely()</code></a></li>
<li><a href="#memoise"><span class="toc-section-number">11.2.2</span> Caching computations with <code>memoise::memoise()</code></a></li>
<li><a href="#exercises-36"><span class="toc-section-number">11.2.3</span> Exercises</a></li>
</ul></li>
<li><a href="#fo-case-study"><span class="toc-section-number">11.3</span> Case study: creating your own function operators</a><ul>
<li><a href="#exercises-37"><span class="toc-section-number">11.3.1</span> Exercises</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>III Object oriented programming</b></span></li>
<li><a href="#oo">Introduction</a><ul>
<li><a href="#oop-systems">OOP systems</a></li>
<li><a href="#oop-in-r">OOP in R</a></li>
<li><a href="#sloop">sloop</a></li>
</ul></li>
<li><a href="#base-types"><span class="toc-section-number">12</span> Base types</a><ul>
<li><a href="#introduction-11"><span class="toc-section-number">12.1</span> Introduction</a><ul>
<li><a href="#outline-10">Outline</a></li>
</ul></li>
<li><a href="#base-vs-oo"><span class="toc-section-number">12.2</span> Base vs OO objects</a></li>
<li><a href="#base-types-2"><span class="toc-section-number">12.3</span> Base types</a><ul>
<li><a href="#numeric-type"><span class="toc-section-number">12.3.1</span> Numeric type</a></li>
</ul></li>
</ul></li>
<li><a href="#s3"><span class="toc-section-number">13</span> S3</a><ul>
<li><a href="#introduction-12"><span class="toc-section-number">13.1</span> Introduction</a><ul>
<li><a href="#outline-11">Outline</a></li>
<li><a href="#prerequisites-6">Prerequisites</a></li>
</ul></li>
<li><a href="#s3-basics"><span class="toc-section-number">13.2</span> Basics</a><ul>
<li><a href="#exercises-38"><span class="toc-section-number">13.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#s3-classes"><span class="toc-section-number">13.3</span> Classes</a><ul>
<li><a href="#s3-constructor"><span class="toc-section-number">13.3.1</span> Constructors</a></li>
<li><a href="#validators"><span class="toc-section-number">13.3.2</span> Validators</a></li>
<li><a href="#helpers"><span class="toc-section-number">13.3.3</span> Helpers</a></li>
<li><a href="#exercises-39"><span class="toc-section-number">13.3.4</span> Exercises</a></li>
</ul></li>
<li><a href="#s3-methods"><span class="toc-section-number">13.4</span> Generics and methods</a><ul>
<li><a href="#method-dispatch"><span class="toc-section-number">13.4.1</span> Method dispatch</a></li>
<li><a href="#finding-methods"><span class="toc-section-number">13.4.2</span> Finding methods</a></li>
<li><a href="#s3-arguments"><span class="toc-section-number">13.4.3</span> Creating methods</a></li>
<li><a href="#exercises-40"><span class="toc-section-number">13.4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#object-styles"><span class="toc-section-number">13.5</span> Object styles</a><ul>
<li><a href="#exercises-41"><span class="toc-section-number">13.5.1</span> Exercises</a></li>
</ul></li>
<li><a href="#s3-inheritance"><span class="toc-section-number">13.6</span> Inheritance</a><ul>
<li><a href="#nextmethod"><span class="toc-section-number">13.6.1</span> <code>NextMethod()</code></a></li>
<li><a href="#s3-subclassing"><span class="toc-section-number">13.6.2</span> Allowing subclassing</a></li>
<li><a href="#exercises-42"><span class="toc-section-number">13.6.3</span> Exercises</a></li>
</ul></li>
<li><a href="#s3-dispatch"><span class="toc-section-number">13.7</span> Dispatch details</a><ul>
<li><a href="#implicit-class"><span class="toc-section-number">13.7.1</span> S3 and base types</a></li>
<li><a href="#internal-generics"><span class="toc-section-number">13.7.2</span> Internal generics</a></li>
<li><a href="#group-generics"><span class="toc-section-number">13.7.3</span> Group generics</a></li>
<li><a href="#double-dispatch"><span class="toc-section-number">13.7.4</span> Double dispatch</a></li>
<li><a href="#exercises-43"><span class="toc-section-number">13.7.5</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#r6"><span class="toc-section-number">14</span> R6</a><ul>
<li><a href="#introduction-13"><span class="toc-section-number">14.1</span> Introduction</a><ul>
<li><a href="#outline-12">Outline</a></li>
<li><a href="#prerequisites-7">Prerequisites</a></li>
</ul></li>
<li><a href="#r6-classes"><span class="toc-section-number">14.2</span> Classes and methods</a><ul>
<li><a href="#method-chaining"><span class="toc-section-number">14.2.1</span> Method chaining</a></li>
<li><a href="#r6-important-methods"><span class="toc-section-number">14.2.2</span> Important methods</a></li>
<li><a href="#adding-methods-after-creation"><span class="toc-section-number">14.2.3</span> Adding methods after creation</a></li>
<li><a href="#inheritance"><span class="toc-section-number">14.2.4</span> Inheritance</a></li>
<li><a href="#introspection"><span class="toc-section-number">14.2.5</span> Introspection</a></li>
<li><a href="#exercises-44"><span class="toc-section-number">14.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#r6-access"><span class="toc-section-number">14.3</span> Controlling access</a><ul>
<li><a href="#privacy"><span class="toc-section-number">14.3.1</span> Privacy</a></li>
<li><a href="#active-fields"><span class="toc-section-number">14.3.2</span> Active fields</a></li>
<li><a href="#exercises-45"><span class="toc-section-number">14.3.3</span> Exercises</a></li>
</ul></li>
<li><a href="#r6-semantics"><span class="toc-section-number">14.4</span> Reference semantics</a><ul>
<li><a href="#reasoning"><span class="toc-section-number">14.4.1</span> Reasoning</a></li>
<li><a href="#finalizer"><span class="toc-section-number">14.4.2</span> Finalizer</a></li>
<li><a href="#r6-fields"><span class="toc-section-number">14.4.3</span> R6 fields</a></li>
<li><a href="#exercises-46"><span class="toc-section-number">14.4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#why-r6"><span class="toc-section-number">14.5</span> Why R6?</a></li>
</ul></li>
<li><a href="#s4"><span class="toc-section-number">15</span> S4</a><ul>
<li><a href="#introduction-14"><span class="toc-section-number">15.1</span> Introduction</a><ul>
<li><a href="#outline-13">Outline</a></li>
<li><a href="#learning-more">Learning more</a></li>
<li><a href="#prerequisites-8">Prerequisites</a></li>
</ul></li>
<li><a href="#s4-basics"><span class="toc-section-number">15.2</span> Basics</a><ul>
<li><a href="#exercises-47"><span class="toc-section-number">15.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#s4-classes"><span class="toc-section-number">15.3</span> Classes</a><ul>
<li><a href="#inheritance-1"><span class="toc-section-number">15.3.1</span> Inheritance</a></li>
<li><a href="#introspection-1"><span class="toc-section-number">15.3.2</span> Introspection</a></li>
<li><a href="#redefinition"><span class="toc-section-number">15.3.3</span> Redefinition</a></li>
<li><a href="#helper"><span class="toc-section-number">15.3.4</span> Helper</a></li>
<li><a href="#validator"><span class="toc-section-number">15.3.5</span> Validator</a></li>
<li><a href="#exercises-48"><span class="toc-section-number">15.3.6</span> Exercises</a></li>
</ul></li>
<li><a href="#s4-generics"><span class="toc-section-number">15.4</span> Generics and methods</a><ul>
<li><a href="#signature"><span class="toc-section-number">15.4.1</span> Signature</a></li>
<li><a href="#methods"><span class="toc-section-number">15.4.2</span> Methods</a></li>
<li><a href="#show-method"><span class="toc-section-number">15.4.3</span> Show method</a></li>
<li><a href="#accessors"><span class="toc-section-number">15.4.4</span> Accessors</a></li>
<li><a href="#exercises-49"><span class="toc-section-number">15.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#s4-dispatch"><span class="toc-section-number">15.5</span> Method dispatch</a><ul>
<li><a href="#single-dispatch"><span class="toc-section-number">15.5.1</span> Single dispatch</a></li>
<li><a href="#multiple-inheritance"><span class="toc-section-number">15.5.2</span> Multiple inheritance</a></li>
<li><a href="#multiple-dispatch"><span class="toc-section-number">15.5.3</span> Multiple dispatch</a></li>
<li><a href="#multiple-dispatch-and-multiple-inheritance"><span class="toc-section-number">15.5.4</span> Multiple dispatch and multiple inheritance</a></li>
<li><a href="#exercises-50"><span class="toc-section-number">15.5.5</span> Exercises</a></li>
</ul></li>
<li><a href="#s4-s3"><span class="toc-section-number">15.6</span> S4 and S3</a><ul>
<li><a href="#classes"><span class="toc-section-number">15.6.1</span> Classes</a></li>
<li><a href="#generics"><span class="toc-section-number">15.6.2</span> Generics</a></li>
<li><a href="#exercises-51"><span class="toc-section-number">15.6.3</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#oo-tradeoffs"><span class="toc-section-number">16</span> Trade-offs</a><ul>
<li><a href="#introduction-15"><span class="toc-section-number">16.1</span> Introduction</a><ul>
<li><a href="#outline-14">Outline</a></li>
<li><a href="#prerequisites-9">Prerequisites</a></li>
</ul></li>
<li><a href="#s3-s4"><span class="toc-section-number">16.2</span> S4 vs S3</a></li>
<li><a href="#s3-r6"><span class="toc-section-number">16.3</span> R6 vs S3</a><ul>
<li><a href="#namespacing"><span class="toc-section-number">16.3.1</span> Namespacing</a></li>
<li><a href="#threading-state"><span class="toc-section-number">16.3.2</span> Threading state</a></li>
<li><a href="#tradeoffs-pipe"><span class="toc-section-number">16.3.3</span> Method chaining</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>IV Metaprogramming</b></span></li>
<li><a href="#introduction-16">Introduction</a></li>
<li><a href="#meta-big-picture"><span class="toc-section-number">17</span> Big picture</a><ul>
<li><a href="#introduction-17"><span class="toc-section-number">17.1</span> Introduction</a><ul>
<li><a href="#outline-15">Outline</a></li>
<li><a href="#prerequisites-10">Prerequisites</a></li>
</ul></li>
<li><a href="#code-data"><span class="toc-section-number">17.2</span> Code is data</a></li>
<li><a href="#code-tree"><span class="toc-section-number">17.3</span> Code is a tree</a></li>
<li><a href="#coding-code"><span class="toc-section-number">17.4</span> Code can generate code</a></li>
<li><a href="#eval-intro"><span class="toc-section-number">17.5</span> Evaluation runs code</a></li>
<li><a href="#eval-funs"><span class="toc-section-number">17.6</span> Customising evaluation with functions</a></li>
<li><a href="#eval-data"><span class="toc-section-number">17.7</span> Customising evaluation with data</a></li>
<li><a href="#quosure-intro"><span class="toc-section-number">17.8</span> Quosures</a></li>
</ul></li>
<li><a href="#expressions"><span class="toc-section-number">18</span> Expressions</a><ul>
<li><a href="#introduction-18"><span class="toc-section-number">18.1</span> Introduction</a><ul>
<li><a href="#outline-16">Outline</a></li>
<li><a href="#prerequisites-11">Prerequisites</a></li>
</ul></li>
<li><a href="#ast"><span class="toc-section-number">18.2</span> Abstract syntax trees</a><ul>
<li><a href="#drawing"><span class="toc-section-number">18.2.1</span> Drawing</a></li>
<li><a href="#non-code-components"><span class="toc-section-number">18.2.2</span> Non-code components</a></li>
<li><a href="#infix-calls"><span class="toc-section-number">18.2.3</span> Infix calls</a></li>
<li><a href="#exercises-52"><span class="toc-section-number">18.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#expression-details"><span class="toc-section-number">18.3</span> Expressions</a><ul>
<li><a href="#constants"><span class="toc-section-number">18.3.1</span> Constants</a></li>
<li><a href="#symbols"><span class="toc-section-number">18.3.2</span> Symbols</a></li>
<li><a href="#calls"><span class="toc-section-number">18.3.3</span> Calls</a></li>
<li><a href="#summary"><span class="toc-section-number">18.3.4</span> Summary</a></li>
<li><a href="#exercises-53"><span class="toc-section-number">18.3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#grammar"><span class="toc-section-number">18.4</span> Parsing and grammar</a><ul>
<li><a href="#operator-precedence"><span class="toc-section-number">18.4.1</span> Operator precedence</a></li>
<li><a href="#associativity"><span class="toc-section-number">18.4.2</span> Associativity</a></li>
<li><a href="#parsing"><span class="toc-section-number">18.4.3</span> Parsing and deparsing</a></li>
<li><a href="#exercises-54"><span class="toc-section-number">18.4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#ast-funs"><span class="toc-section-number">18.5</span> Walking the AST with recursive functions</a><ul>
<li><a href="#finding-f-and-t"><span class="toc-section-number">18.5.1</span> Finding F and T</a></li>
<li><a href="#finding-all-variables-created-by-assignment"><span class="toc-section-number">18.5.2</span> Finding all variables created by assignment</a></li>
<li><a href="#exercises-55"><span class="toc-section-number">18.5.3</span> Exercises</a></li>
</ul></li>
<li><a href="#expression-special"><span class="toc-section-number">18.6</span> Specialised data structures</a><ul>
<li><a href="#pairlists"><span class="toc-section-number">18.6.1</span> Pairlists</a></li>
<li><a href="#empty-symbol"><span class="toc-section-number">18.6.2</span> Missing arguments</a></li>
<li><a href="#expression-vectors"><span class="toc-section-number">18.6.3</span> Expression vectors</a></li>
</ul></li>
</ul></li>
<li><a href="#quasiquotation"><span class="toc-section-number">19</span> Quasiquotation</a><ul>
<li><a href="#introduction-19"><span class="toc-section-number">19.1</span> Introduction</a><ul>
<li><a href="#outline-17">Outline</a></li>
<li><a href="#prerequisites-12">Prerequisites</a></li>
<li><a href="#related-work">Related work</a></li>
</ul></li>
<li><a href="#quasi-motivation"><span class="toc-section-number">19.2</span> Motivation</a><ul>
<li><a href="#vocabulary"><span class="toc-section-number">19.2.1</span> Vocabulary</a></li>
<li><a href="#exercises-56"><span class="toc-section-number">19.2.2</span> Exercises</a></li>
</ul></li>
<li><a href="#quoting"><span class="toc-section-number">19.3</span> Quoting</a><ul>
<li><a href="#capturing-expressions"><span class="toc-section-number">19.3.1</span> Capturing expressions</a></li>
<li><a href="#capturing-symbols"><span class="toc-section-number">19.3.2</span> Capturing symbols</a></li>
<li><a href="#with-base-r"><span class="toc-section-number">19.3.3</span> With base R</a></li>
<li><a href="#substitution"><span class="toc-section-number">19.3.4</span> Substitution</a></li>
<li><a href="#summary-1"><span class="toc-section-number">19.3.5</span> Summary</a></li>
<li><a href="#exercises-57"><span class="toc-section-number">19.3.6</span> Exercises</a></li>
</ul></li>
<li><a href="#unquoting"><span class="toc-section-number">19.4</span> Unquoting</a><ul>
<li><a href="#unquoting-one-argument"><span class="toc-section-number">19.4.1</span> Unquoting one argument</a></li>
<li><a href="#unquoting-a-function"><span class="toc-section-number">19.4.2</span> Unquoting a function</a></li>
<li><a href="#unquote-missing"><span class="toc-section-number">19.4.3</span> Unquoting a missing argument</a></li>
<li><a href="#unquoting-in-special-forms"><span class="toc-section-number">19.4.4</span> Unquoting in special forms</a></li>
<li><a href="#unquoting-many-arguments"><span class="toc-section-number">19.4.5</span> Unquoting many arguments</a></li>
<li><a href="#the-polite-fiction-of"><span class="toc-section-number">19.4.6</span> The polite fiction of <code>!!</code></a></li>
<li><a href="#non-standard-ast"><span class="toc-section-number">19.4.7</span> Non-standard ASTs</a></li>
<li><a href="#exercises-58"><span class="toc-section-number">19.4.8</span> Exercises</a></li>
</ul></li>
<li><a href="#base-nonquote"><span class="toc-section-number">19.5</span> Non-quoting</a></li>
<li><a href="#tidy-dots"><span class="toc-section-number">19.6</span> Dot-dot-dot (<code>...</code>)</a><ul>
<li><a href="#examples"><span class="toc-section-number">19.6.1</span> Examples</a></li>
<li><a href="#exec"><span class="toc-section-number">19.6.2</span> <code>exec()</code></a></li>
<li><a href="#dots_list"><span class="toc-section-number">19.6.3</span> <code>dots_list()</code></a></li>
<li><a href="#do-call"><span class="toc-section-number">19.6.4</span> With base R</a></li>
<li><a href="#exercises-59"><span class="toc-section-number">19.6.5</span> Exercises</a></li>
</ul></li>
<li><a href="#expr-case-studies"><span class="toc-section-number">19.7</span> Case studies</a><ul>
<li><a href="#lobstrast"><span class="toc-section-number">19.7.1</span> <code>lobstr::ast()</code></a></li>
<li><a href="#map-reduce-to-generate-code"><span class="toc-section-number">19.7.2</span> Map-reduce to generate code</a></li>
<li><a href="#slicing-an-array"><span class="toc-section-number">19.7.3</span> Slicing an array</a></li>
<li><a href="#new-function"><span class="toc-section-number">19.7.4</span> Creating functions</a></li>
<li><a href="#exercises-60"><span class="toc-section-number">19.7.5</span> Exercises</a></li>
</ul></li>
<li><a href="#history"><span class="toc-section-number">19.8</span> History</a></li>
</ul></li>
<li><a href="#evaluation"><span class="toc-section-number">20</span> Evaluation</a><ul>
<li><a href="#introduction-20"><span class="toc-section-number">20.1</span> Introduction</a><ul>
<li><a href="#outline-18">Outline</a></li>
<li><a href="#prerequisites-13">Prerequisites</a></li>
</ul></li>
<li><a href="#eval"><span class="toc-section-number">20.2</span> Evaluation basics</a><ul>
<li><a href="#application-local"><span class="toc-section-number">20.2.1</span> Application: <code>local()</code></a></li>
<li><a href="#application-source"><span class="toc-section-number">20.2.2</span> Application: <code>source()</code></a></li>
<li><a href="#gotcha-function"><span class="toc-section-number">20.2.3</span> Gotcha: <code>function()</code></a></li>
<li><a href="#exercises-61"><span class="toc-section-number">20.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#quosures"><span class="toc-section-number">20.3</span> Quosures</a><ul>
<li><a href="#creating"><span class="toc-section-number">20.3.1</span> Creating</a></li>
<li><a href="#evaluating"><span class="toc-section-number">20.3.2</span> Evaluating</a></li>
<li><a href="#quosure-dots"><span class="toc-section-number">20.3.3</span> Dots</a></li>
<li><a href="#quosure-impl"><span class="toc-section-number">20.3.4</span> Under the hood</a></li>
<li><a href="#nested-quosures"><span class="toc-section-number">20.3.5</span> Nested quosures</a></li>
<li><a href="#exercises-62"><span class="toc-section-number">20.3.6</span> Exercises</a></li>
</ul></li>
<li><a href="#data-masks"><span class="toc-section-number">20.4</span> Data masks</a><ul>
<li><a href="#basics-3"><span class="toc-section-number">20.4.1</span> Basics</a></li>
<li><a href="#pronouns"><span class="toc-section-number">20.4.2</span> Pronouns</a></li>
<li><a href="#subset"><span class="toc-section-number">20.4.3</span> Application: <code>subset()</code></a></li>
<li><a href="#application-transform"><span class="toc-section-number">20.4.4</span> Application: transform</a></li>
<li><a href="#select"><span class="toc-section-number">20.4.5</span> Application: <code>select()</code></a></li>
<li><a href="#exercises-63"><span class="toc-section-number">20.4.6</span> Exercises</a></li>
</ul></li>
<li><a href="#tidy-evaluation"><span class="toc-section-number">20.5</span> Using tidy evaluation</a><ul>
<li><a href="#quoting-and-unquoting"><span class="toc-section-number">20.5.1</span> Quoting and unquoting</a></li>
<li><a href="#handling-ambiguity"><span class="toc-section-number">20.5.2</span> Handling ambiguity</a></li>
<li><a href="#quoting-and-ambiguity"><span class="toc-section-number">20.5.3</span> Quoting and ambiguity</a></li>
<li><a href="#exercises-64"><span class="toc-section-number">20.5.4</span> Exercises</a></li>
</ul></li>
<li><a href="#base-evaluation"><span class="toc-section-number">20.6</span> Base evaluation</a><ul>
<li><a href="#substitute"><span class="toc-section-number">20.6.1</span> <code>substitute()</code></a></li>
<li><a href="#match.call"><span class="toc-section-number">20.6.2</span> <code>match.call()</code></a></li>
<li><a href="#exercises-65"><span class="toc-section-number">20.6.3</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#translation"><span class="toc-section-number">21</span> Translating R code</a><ul>
<li><a href="#introduction-21"><span class="toc-section-number">21.1</span> Introduction</a><ul>
<li><a href="#outline-19">Outline</a></li>
<li><a href="#prerequisites-14">Prerequisites</a></li>
</ul></li>
<li><a href="#html"><span class="toc-section-number">21.2</span> HTML</a><ul>
<li><a href="#goal"><span class="toc-section-number">21.2.1</span> Goal</a></li>
<li><a href="#escaping"><span class="toc-section-number">21.2.2</span> Escaping</a></li>
<li><a href="#basic-tag-functions"><span class="toc-section-number">21.2.3</span> Basic tag functions</a></li>
<li><a href="#tag-functions"><span class="toc-section-number">21.2.4</span> Tag functions</a></li>
<li><a href="#html-env"><span class="toc-section-number">21.2.5</span> Processing all tags</a></li>
<li><a href="#exercises-66"><span class="toc-section-number">21.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#latex"><span class="toc-section-number">21.3</span> LaTeX</a><ul>
<li><a href="#latex-mathematics"><span class="toc-section-number">21.3.1</span> LaTeX mathematics</a></li>
<li><a href="#goal-1"><span class="toc-section-number">21.3.2</span> Goal</a></li>
<li><a href="#to_math"><span class="toc-section-number">21.3.3</span> <code>to_math</code>()</a></li>
<li><a href="#known-symbols"><span class="toc-section-number">21.3.4</span> Known symbols</a></li>
<li><a href="#unknown-symbols"><span class="toc-section-number">21.3.5</span> Unknown symbols</a></li>
<li><a href="#known-functions"><span class="toc-section-number">21.3.6</span> Known functions</a></li>
<li><a href="#unknown-functions"><span class="toc-section-number">21.3.7</span> Unknown functions</a></li>
<li><a href="#exercises-67"><span class="toc-section-number">21.3.8</span> Exercises</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>V Techniques</b></span></li>
<li><a href="#introduction-22">Introduction</a></li>
<li><a href="#debugging"><span class="toc-section-number">22</span> Debugging</a><ul>
<li><a href="#introduction-23"><span class="toc-section-number">22.1</span> Introduction</a><ul>
<li><a href="#outline-20">Outline</a></li>
</ul></li>
<li><a href="#debugging-strategy"><span class="toc-section-number">22.2</span> Overall approach</a></li>
<li><a href="#traceback"><span class="toc-section-number">22.3</span> Locate the error</a><ul>
<li><a href="#debug-lazy"><span class="toc-section-number">22.3.1</span> Lazy evaluation</a></li>
</ul></li>
<li><a href="#browser"><span class="toc-section-number">22.4</span> The interactive debugger</a><ul>
<li><a href="#browser-commands"><span class="toc-section-number">22.4.1</span> <code>browser()</code> commands</a></li>
<li><a href="#alternatives"><span class="toc-section-number">22.4.2</span> Alternatives</a></li>
<li><a href="#debug-compiled"><span class="toc-section-number">22.4.3</span> Compiled code</a></li>
</ul></li>
<li><a href="#non-interactive-debugging"><span class="toc-section-number">22.5</span> Non-interactive debugging</a><ul>
<li><a href="#dump.frames"><span class="toc-section-number">22.5.1</span> <code>dump.frames()</code></a></li>
<li><a href="#print-debugging"><span class="toc-section-number">22.5.2</span> Print debugging</a></li>
<li><a href="#rmarkdown"><span class="toc-section-number">22.5.3</span> RMarkdown</a></li>
</ul></li>
<li><a href="#non-error-failures"><span class="toc-section-number">22.6</span> Non-error failures</a></li>
</ul></li>
<li><a href="#perf-measure"><span class="toc-section-number">23</span> Measuring performance</a><ul>
<li><a href="#introduction-24"><span class="toc-section-number">23.1</span> Introduction</a><ul>
<li><a href="#outline-21">Outline</a></li>
<li><a href="#prerequisites-15">Prerequisites</a></li>
</ul></li>
<li><a href="#profiling"><span class="toc-section-number">23.2</span> Profiling</a><ul>
<li><a href="#visualising-profiles"><span class="toc-section-number">23.2.1</span> Visualising profiles</a></li>
<li><a href="#memory-profiling"><span class="toc-section-number">23.2.2</span> Memory profiling</a></li>
<li><a href="#limitations"><span class="toc-section-number">23.2.3</span> Limitations</a></li>
<li><a href="#exercises-68"><span class="toc-section-number">23.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#microbenchmarking"><span class="toc-section-number">23.3</span> Microbenchmarking</a><ul>
<li><a href="#benchmark-results"><span class="toc-section-number">23.3.1</span> <code>bench::mark()</code> results</a></li>
<li><a href="#interpreting-results"><span class="toc-section-number">23.3.2</span> Interpreting results</a></li>
<li><a href="#exercises-69"><span class="toc-section-number">23.3.3</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#perf-improve"><span class="toc-section-number">24</span> Improving performance</a><ul>
<li><a href="#introduction-25"><span class="toc-section-number">24.1</span> Introduction</a><ul>
<li><a href="#outline-22">Outline</a></li>
<li><a href="#prerequisites-16">Prerequisites</a></li>
</ul></li>
<li><a href="#code-organisation"><span class="toc-section-number">24.2</span> Code organisation</a></li>
<li><a href="#already-solved"><span class="toc-section-number">24.3</span> Check for existing solutions</a><ul>
<li><a href="#exercises-70"><span class="toc-section-number">24.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#be-lazy"><span class="toc-section-number">24.4</span> Do as little as possible</a><ul>
<li><a href="#mean"><span class="toc-section-number">24.4.1</span> <code>mean()</code></a></li>
<li><a href="#as.data.frame"><span class="toc-section-number">24.4.2</span> <code>as.data.frame()</code></a></li>
<li><a href="#exercises-71"><span class="toc-section-number">24.4.3</span> Exercises</a></li>
</ul></li>
<li><a href="#vectorise"><span class="toc-section-number">24.5</span> Vectorise</a><ul>
<li><a href="#exercises-72"><span class="toc-section-number">24.5.1</span> Exercises</a></li>
</ul></li>
<li><a href="#avoid-copies"><span class="toc-section-number">24.6</span> Avoid copies</a></li>
<li><a href="#t-test"><span class="toc-section-number">24.7</span> Case study: t-test</a></li>
<li><a href="#more-techniques"><span class="toc-section-number">24.8</span> Other techniques</a></li>
</ul></li>
<li><a href="#rcpp"><span class="toc-section-number">25</span> Rewriting R code in C++</a><ul>
<li><a href="#introduction-26"><span class="toc-section-number">25.1</span> Introduction</a><ul>
<li><a href="#outline-23">Outline</a></li>
<li><a href="#prerequisites-17">Prerequisites</a></li>
</ul></li>
<li><a href="#rcpp-intro"><span class="toc-section-number">25.2</span> Getting started with C++</a><ul>
<li><a href="#no-inputs-scalar-output"><span class="toc-section-number">25.2.1</span> No inputs, scalar output</a></li>
<li><a href="#scalar-input-scalar-output"><span class="toc-section-number">25.2.2</span> Scalar input, scalar output</a></li>
<li><a href="#vector-input-scalar-output"><span class="toc-section-number">25.2.3</span> Vector input, scalar output</a></li>
<li><a href="#vector-input-vector-output"><span class="toc-section-number">25.2.4</span> Vector input, vector output</a></li>
<li><a href="#sourceCpp"><span class="toc-section-number">25.2.5</span> Using sourceCpp</a></li>
<li><a href="#exercises-73"><span class="toc-section-number">25.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#rcpp-classes"><span class="toc-section-number">25.3</span> Other classes</a><ul>
<li><a href="#lists-and-data-frames"><span class="toc-section-number">25.3.1</span> Lists and data frames</a></li>
<li><a href="#functions-rcpp"><span class="toc-section-number">25.3.2</span> Functions</a></li>
<li><a href="#attributes-1"><span class="toc-section-number">25.3.3</span> Attributes</a></li>
</ul></li>
<li><a href="#rcpp-na"><span class="toc-section-number">25.4</span> Missing values</a><ul>
<li><a href="#scalars-1"><span class="toc-section-number">25.4.1</span> Scalars</a></li>
<li><a href="#strings"><span class="toc-section-number">25.4.2</span> Strings</a></li>
<li><a href="#boolean"><span class="toc-section-number">25.4.3</span> Boolean</a></li>
<li><a href="#vectors-rcpp"><span class="toc-section-number">25.4.4</span> Vectors</a></li>
<li><a href="#exercises-74"><span class="toc-section-number">25.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#stl"><span class="toc-section-number">25.5</span> The STL</a><ul>
<li><a href="#using-iterators"><span class="toc-section-number">25.5.1</span> Using iterators</a></li>
<li><a href="#algorithms"><span class="toc-section-number">25.5.2</span> Algorithms</a></li>
<li><a href="#data-structures-rcpp"><span class="toc-section-number">25.5.3</span> Data structures</a></li>
<li><a href="#vectors-stl"><span class="toc-section-number">25.5.4</span> Vectors</a></li>
<li><a href="#sets"><span class="toc-section-number">25.5.5</span> Sets</a></li>
<li><a href="#map-1"><span class="toc-section-number">25.5.6</span> Map</a></li>
<li><a href="#exercises-75"><span class="toc-section-number">25.5.7</span> Exercises</a></li>
</ul></li>
<li><a href="#rcpp-case-studies"><span class="toc-section-number">25.6</span> Case studies</a><ul>
<li><a href="#gibbs-sampler"><span class="toc-section-number">25.6.1</span> Gibbs sampler</a></li>
<li><a href="#r-vectorisation-vs.c-vectorisation"><span class="toc-section-number">25.6.2</span> R vectorisation vs. C++ vectorisation</a></li>
</ul></li>
<li><a href="#rcpp-package"><span class="toc-section-number">25.7</span> Using Rcpp in a package</a></li>
<li><a href="#rcpp-more"><span class="toc-section-number">25.8</span> Learning more</a></li>
<li><a href="#acknowledgments"><span class="toc-section-number">25.9</span> Acknowledgments</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>
</div>

<div id="welcome" class="section level1 unnumbered">
<h1>Welcome</h1>
<p><img src="cover.png" width="250" height="366" align="right" alt="Cover image" /></p>
<p>This is the website for work-in-progress 2nd edition of <strong>“Advanced R<span id="fn1" class="footnote" data-pagedown-footnote-number="1" style="white-space: pre-line;"><a href="http://amzn.com/1466586966?tag=devtools-20" class="uri">http://amzn.com/1466586966?tag=devtools-20</a></span>”</strong>, a book in Chapman &amp; Hall’s R Series. The book is designed primarily for R users who want to improve their programming skills and understanding of the language. It should also be useful for programmers coming to R from other languages, as it explains some of R’s quirks and shows how some parts that seem horrible do have a positive side.</p>
<p>This edition is a work in progress. If you’re looking for the electronic version of the 1st edition, you can find it online at <a href="http://adv-r.had.co.nz/" class="uri">http://adv-r.had.co.nz/</a>.</p>
<div id="license" class="section level2 unnumbered">
<h2>License</h2>
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons Licence" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a></p>
<p>This work, as a whole, is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
<p>The code contained in this book is simultaneously available under the MIT license<span id="fn2" class="footnote" data-pagedown-footnote-number="2" style="white-space: pre-line;"><a href="https://opensource.org/licenses/MIT" class="uri">https://opensource.org/licenses/MIT</a></span>; this means that you are free to use it in your own packages, as long as you cite the source.</p>
</div>
<div id="other-books" class="section level2 unnumbered">
<h2>Other books</h2>
<p>You may also be interested in:</p>
<ul>
<li><p><strong>“R for Data Science<span id="fn3" class="footnote" data-pagedown-footnote-number="3" style="white-space: pre-line;"><a href="http://r4ds.had.co.nz/" class="uri">http://r4ds.had.co.nz/</a></span>”</strong> which introduces you to R
as a tool for doing data science, focussing on a consistent
set of packages known as the tidyverse.</p></li>
<li><p><strong>“R Packages<span id="fn4" class="footnote" data-pagedown-footnote-number="4" style="white-space: pre-line;"><a href="http://r-pkgs.had.co.nz/" class="uri">http://r-pkgs.had.co.nz/</a></span>”</strong> which teaches you
how to make the most of R’s fantastic package system.</p></li>
</ul>
<!--chapter:end:index.Rmd-->
</div>
</div>
<div id="preface" class="section level1 unnumbered">
<h1>Preface</h1>
<p>Welcome to the 2nd edition of Advanced R. I had three main goals for this edition:</p>
<ul>
<li><p>Improve coverage of important concepts that I fully understood only after
the publication of the 1st edition.</p></li>
<li><p>Reduce coverage of topics time has shown to be less useful, or that I think
are really exciting but turn out not to be that practical.</p></li>
<li><p>Generally make the material easier to understand with better text, clearer
code, and many more diagrams.</p></li>
</ul>
<p>If you’re familiar with the 1st edition, this preface describes the major changes so that you can focus your reading on the new areas. If you’re reading a printed version of this book you’ll notice one big change very quickly: Advanced R is now in colour! This has considerably improved the syntax highlighting of code chunks, and made it much easier to create helpful diagrams. I have taken advantage of this and included over 100 new diagrams throughout the book.</p>
<p>Another big change in this version is the use of packages, particularly rlang<span id="fn5" class="footnote" data-pagedown-footnote-number="5" style="white-space: pre-line;"><a href="http://rlang.r-lib.org" class="uri">http://rlang.r-lib.org</a></span>, which provides a clean interface to low-level data structures and operations. The 1st edition used base R functions almost exclusively, which created some pedagogical challenges because many functions evolved independently over multiple years, making it hard to see the big underlying ideas hidden amongst the incidental variations in function names and arguments. I continue to show base equivalents in sidebars, footnotes, and where needed, in individual sections, but if you want to see the purest base R expression of the ideas in this book, I recommend reading the 1st edition, which you can find online at <a href="http://adv-r.had.co.nz" class="uri">http://adv-r.had.co.nz</a>.</p>
<p>The foundations of R have not changed in the five years since the 1st edition, but my understanding of them certainly has. Thus, the overall structure of “Foundations” has remained roughly the same, but many of the individual chapters have been considerably improved:</p>
<ul>
<li><p>Chapter <a href="#names-values">2</a>, “Names and values”, is a brand new chapter
that helps you understand the difference between objects and names of
objects. This helps you more accurately predict when R will make a copy of
a data structure, and lays important groundwork to understand functional
programming.</p></li>
<li><p>Chapter <a href="#vectors-chap">3</a>, “Vectors” (previously called data structures),
and has been rewritten to focus on vector types like integers, factors, and
data frames. It contains more details of important S3 vectors (like dates
and date-times), discusses the data frame variation provided by the
tibble<span id="fn6" class="footnote" data-pagedown-footnote-number="6" style="white-space: pre-line;"><a href="https://tibble.tidyverse.org" class="uri">https://tibble.tidyverse.org</a></span>, and generally reflect my improved
understand of vector data types.</p></li>
<li><p>Chapter <a href="#subsetting">4</a>, “Subsetting”, now distinguishes between <code>[</code> and
<code>[[</code> by their intention: <code>[</code> extracts many values and <code>[[</code> extracts a
single value (previously they were characterised by whether they “simplified”
or “preserved”). Section <a href="#subset-single">4.3</a> draws the “train” to help you
understand how <code>[[</code> works with lists, and introduces new functions that
provide more consistent behaviour for out-of-bounds indices.</p></li>
<li><p>Chapter <a href="#control-flow">5</a>, “Control flow”, is a new chapter: somehow
I previously managed to forget about such important tools like <code>if</code> and
<code>for</code>!</p></li>
<li><p>Chapter <a href="#functions">6</a>, “Functions”, has an improved ordering,
introduces the pipe (<code>%&gt;%</code>) as a third way to compose functions (Section
<a href="#function-composition">6.3</a>), and has considerably improved coverage of
function forms (Section <a href="#function-forms">6.8</a>).</p></li>
<li><p>Chapter <a href="#environments">7</a>, “Environments”, has a reorganised treatment of
special environments (Section <a href="#special-environments">7.4</a>), and a much improved
discussion of the call stack (Section <a href="#call-stack">7.5</a>).</p></li>
<li><p>Chapter <a href="#conditions">8</a>, “Conditions”, contains material previously
in “Exceptions and debugging”, and much new content on how R’s condition
system works. It also shows you how to create your own custom condition
classes (Section <a href="#custom-conditions">8.5</a>).</p></li>
</ul>
<p>The chapters following foundations have been re-organised around the three most important programming paradigms in R: functional programming, object oriented programming, and metaprogramming.</p>
<ul>
<li><p>Functional programming is now more cleanly divided into the three main
techniques: “Functionals” (Chapter <a href="#functionals">9</a>), “Function
factories” (Chapter <a href="#function-factories">10</a>), and “Function operators”
(Chapter <a href="#function-operators">11</a>). I’ve focussed in on ideas that have
practical applications in data science and reduced the amount of pure theory.</p>
<p>These chapters now use functions provided by the purrr package, which allow
me to focus more on the underlying ideas and less on the incidental
details. This also lead to a considerable simplification of the function
operators chapter since a major use was to work around the absence of <code>...</code>
in base functionals.</p></li>
<li><p>Object oriented programming (OOP) now forms a major section of the book with
completely new chapters on base types (Chapter <a href="#base-types">12</a>),
S3 (Chapter <a href="#s3">13</a>), S4 (Chapter <a href="#s4">15</a>), R6 (Chapter <a href="#r6">14</a>),
and the tradeoffs between the systems (Chapter <a href="#oo-tradeoffs">16</a>).</p>
<p>These chapters focus on how the different object systems work,
not how to use them effectively. This is unfortunate, but necessary, because
many of the technical details are not described elsewhere, and effective use
of OOP needs a whole book of its own.</p></li>
<li><p>Metaprogramming (previously called “computing on the language”) describes the
suite of tools that you can use to generate code with code. Compared to the
1st edition this material has been substantially expanded and now focusses on
“tidy evaluation”, a set of ideas and theory that that make metaprogramming
safe, well-principled, and accessible to many more R programmers.
Chapter <a href="#expressions">18</a>, “Expressions”, describes the underlying data
structures; Chapter <a href="#quasiquotation">19</a>, “Quasiquotation”, quoting and
unquoting; Chapter <a href="#evaluation">20</a>, “Evaluation”, evaluating code in
special environments; and Chapter <a href="#translation">21</a>, “Translations”, pulls
all the themes together to show how you might translate from one
(programming) language to another.</p></li>
</ul>
<p>The final section of the book pulls together the chapters on programming techniques: profiling, measuring and improving performance, and Rcpp. The contents are very similar to the first edition, although the organisation is a little different. I have made light updates throughout these chapters particularly to use newer packges (microbenchmark -&gt; bench, lineprof -&gt; profvis), but the majority of the text is the same.</p>
<p>While the 2nd edition has mostly expanded coverage of existing material, there were five chapters that have been removed:</p>
<ul>
<li><p>The vocabulary chapter has been removed because it was always a bit of an odd
duck, and there are more effective ways to present vocabulary lists than in a
book chapter.</p></li>
<li><p>The style chapter has been replaced with an online style guide,
<a href="http://style.tidyverse.org/" class="uri">http://style.tidyverse.org/</a>. The style guide is paired with the new
styler<span id="fn7" class="footnote" data-pagedown-footnote-number="7" style="white-space: pre-line;"><a href="http://styler.r-lib.org/" class="uri">http://styler.r-lib.org/</a></span> package which can automatically apply many of the rules.</p></li>
<li><p>The C chapter has been moved to a new repo,
<a href="https://github.com/hadley/r-internals" class="uri">https://github.com/hadley/r-internals</a>, which, over time, will provide
a guide to writing C code that work’s with R’s data structures.</p></li>
<li><p>The memory chapter has been removed. Much of the material has been integrated
into Chapter <a href="#names-values">2</a> and the remainder felt excessively technical
and not that important to understand.</p></li>
<li><p>The chapter on R’s performance as a language was removed. This delivered
few actionable insights, and easily becomes out date as R itself changes.</p></li>
</ul>
<!--chapter:end:Preface.Rmd-->
</div>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>I have now been programming in R for over 15 years, and have been doing it full-time for the last five years. This has given me the luxury of time to spend understanding how the language works. This book is my attempt to pass on what I’ve learned so that you can understand the intricacies of R as quickly and painlessly as possible. Reading it will help you avoid the mistakes I’ve made and dead ends I’ve gone down, and will teach you useful tools, techniques, and idioms that can help you to attack many types of problems. In the process, I hope to show that, despite its sometimes frustrating quirks, R is, at its heart, an elegant and beautiful language, well tailored for data science.</p>
<div id="why-r" class="section level2">
<h2><span class="header-section-number">1.1</span> Why R?</h2>
<p>If you are new to R, you might wonder what makes learning such a quirky language worthwhile. To me, some of the best features are:</p>
<ul>
<li><p>It’s free, open source, and available on every major platform. As a result, if
you do your analysis in R, anyone can easily replicate it, regardless of
where they live or how much money they earn.</p></li>
<li><p>R has a diverse and welcoming community, both online (e.g.
the #rstats twitter community<span id="fn8" class="footnote" data-pagedown-footnote-number="8" style="white-space: pre-line;"><a href="https://twitter.com/search?q=%23rstats" class="uri">https://twitter.com/search?q=%23rstats</a></span>) and in person (like the
many R meetups<span id="fn9" class="footnote" data-pagedown-footnote-number="9" style="white-space: pre-line;"><a href="https://www.meetup.com/topics/r-programming-language/" class="uri">https://www.meetup.com/topics/r-programming-language/</a></span>). Two particularly inspiring community groups are
rweekly newsletter<span id="fn10" class="footnote" data-pagedown-footnote-number="10" style="white-space: pre-line;"><a href="https://rweekly.org" class="uri">https://rweekly.org</a></span> which makes it easy to keep up to date with
R, and R-Ladies<span id="fn11" class="footnote" data-pagedown-footnote-number="11" style="white-space: pre-line;"><a href="http://r-ladies.org" class="uri">http://r-ladies.org</a></span> which has made a wonderfully welcoming community
for women and other minority genders.</p></li>
<li><p>A massive set of packages for statistical modelling, machine learning,
visualisation, and importing and manipulating data. Whatever model or
graphic you’re trying to do, chances are that someone has already tried
to do it and you can learn from their efforts.</p></li>
<li><p>Powerful tools for communicating your results. RMarkdown<span id="fn12" class="footnote" data-pagedown-footnote-number="12" style="white-space: pre-line;"><a href="https://rmarkdown.rstudio.com" class="uri">https://rmarkdown.rstudio.com</a></span> makes
it easy to turn your results into R packages into HTML, PDFs, Word documents,
PowerPoint presentations, dashboards and more. Shiny<span id="fn13" class="footnote" data-pagedown-footnote-number="13" style="white-space: pre-line;"><a href="http://shiny.rstudio.com" class="uri">http://shiny.rstudio.com</a></span> allows you to
make beautiful interactive apps without any knowledge of HTML or javascript.</p></li>
<li><p>RStudio, the IDE<span id="fn14" class="footnote" data-pagedown-footnote-number="14" style="white-space: pre-line;"><a href="http://www.rstudio.com/ide/" class="uri">http://www.rstudio.com/ide/</a></span>, provides an integrated
development environment, tailored to the needs of data science, interactive
data analysis, and statistical programming.</p></li>
<li><p>Cutting edge tools. Researchers in statistics and machine learning will often
publish an R package to accompany their articles. This means immediate
access to the very latest statistical techniques and implementations.</p></li>
<li><p>Deep-seated language support for data analysis. This includes features
like missing values, data frames, and vectorisation.</p></li>
<li><p>A strong foundation of functional programming. The ideas of functional
programming are well suited to the challenges of data science, and the
R language is functional at heart, and provides many primitives needed
for effective functional programming.</p></li>
<li><p>RStudio, the company<span id="fn15" class="footnote" data-pagedown-footnote-number="15" style="white-space: pre-line;"><a href="https://www.rstudio.com" class="uri">https://www.rstudio.com</a></span>, which makes money by
selling professional products to teams of R users, and turns around and
invests much of that money back into the open source community (over 50%
of software engineers at RStudio work on open source projects). I work for
RStudio because I fundamentally believe in its mission.</p></li>
<li><p>Powerful metaprogramming facilities. R’s metaprogramming capabilities allow
you to write magically succinct and concise functions and provide an excellent
environment for designing domain-specific languages like ggplot2, dplyr,
data.table, and more.</p></li>
<li><p>The ease with which R can connect to high-performance programming languages
like C, Fortran, and C++.</p></li>
</ul>
<p>Of course, R is not perfect. R’s biggest challenge (and opportunity!) is that most R users are not programmers. This means that:</p>
<ul>
<li><p>Much of the R code you’ll see in the wild is written in haste to solve
a pressing problem. As a result, code is not very elegant, fast, or easy to
understand. Most users do not revise their code to address these shortcomings.</p></li>
<li><p>Compared to other programming languages, the R community is more focussed on
results than processes. Knowledge of software engineering best practices is
patchy. For example, not enough R programmers use source code control or
automated testing.</p></li>
<li><p>Metaprogramming is a double-edged sword. Too many R functions use
tricks to reduce the amount of typing at the cost of making code that
is hard to understand and that can fail in unexpected ways.</p></li>
<li><p>Inconsistency is rife across contributed packages, and even within base R.
You are confronted with over 25 years of evolution every time you use R,
and this can make learning R tough because there are so many special cases to
remember.</p></li>
<li><p>R is not a particularly fast programming language, and poorly written R code
can be terribly slow. R is also a profligate user of memory.</p></li>
</ul>
<p>Personally, I think these challenges create a great opportunity for experienced programmers to have a profound positive impact on R and the R community. R users do care about writing high quality code, particularly for reproducible research, but they don’t yet have the skills to do so. I hope this book will not only help more R users to become R programmers, but also encourage programmers from other languages to contribute to R.</p>
</div>
<div id="who-should-read" class="section level2">
<h2><span class="header-section-number">1.2</span> Who should read this book</h2>
<p>This book is aimed at two complementary audiences:</p>
<ul>
<li><p>Intermediate R programmers who want to dive deeper into R, understand how
the language works, and learn new strategies for solving diverse problems.</p></li>
<li><p>Programmers from other languages who are learning R and want to understand
why R works the way it does.</p></li>
</ul>
<p>To get the most out of this book, you’ll need to have written a decent amount of code in R or another programming language. You should be familiar with the basics of data analysis (i.e. data import, manipulation, and visualisation), have written a number of functions, and be familiar with the installation and use of CRAN packages.</p>
<p>This book walks the narrow line between being a reference book (primarily used for lookup), and being linearly readable. This involves some tradeoffs, because it’s difficult to linearise material while still keeping related materials together, and some concepts are much easier to explain if you’re already familiar with specific technical vocabulary. I’ve tried to use footnotes and cross-references to make sure you can still make sense even if you just dip your toes in a chapter.</p>
</div>
<div id="what-you-will-get" class="section level2">
<h2><span class="header-section-number">1.3</span> What you will get out of this book</h2>
<p>This book delivers the knowledge that I think an advanced R programmer should possess: a deep understanding of the fundamentals coupled with a broad vocabulary that means that you can tactically learn more about a topic when needed.</p>
<p>After reading this book, you will:</p>
<ul>
<li><p>Be familiar with the foundations of R. You will understand complex data types
and the best ways to perform operations on them. You will have a deep
understanding of how functions work, you’ll know what environments are, and
how to make use of the condition system.</p></li>
<li><p>Understand what functional programming means, and why it is a useful tool for
data science. You’ll be able to quickly learn how to use existing tools, and
have the knowledge to create your own functional tools when needed.</p></li>
<li><p>Know about R’s rich variety of object-oriented systems. You’ll be most
familiar with S3, but you’ll know of S4 and R6 and where to look for more
information when needed.</p></li>
<li><p>Appreciate the double-edged sword of metaprogramming. You’ll be able to
create functions that use tidy evaluation, saving typing and creating elegant
code to express important operations. You’ll also understand the dangers
and when to avoid it.</p></li>
<li><p>Have a good intuition for which operations in R are slow or use a lot of
memory. You’ll know how to use profiling to pinpoint performance
bottlenecks, and you’ll know enough C++ to convert slow R functions to
fast C++ equivalents.</p></li>
</ul>
</div>
<div id="what-you-will-not-learn" class="section level2">
<h2><span class="header-section-number">1.4</span> What you will not learn</h2>
<p>This book is about R the programming language, not R the data analysis tool. If you are looking to improve your data science skills, I instead recommend that you learn about the tidyverse<span id="fn16" class="footnote" data-pagedown-footnote-number="16" style="white-space: pre-line;"><a href="https://www.tidyverse.org/" class="uri">https://www.tidyverse.org/</a></span>, a collection of consistent packages developed by me and my colleagues. In this book you’ll learn the techniques used to develop the tidyverse packages; if you want to instead learn how to use them, I recommend “R for Data Science”<span id="fn17" class="footnote" data-pagedown-footnote-number="17" style="white-space: pre-line;"><a href="http://r4ds.had.co.nz/" class="uri">http://r4ds.had.co.nz/</a></span>.</p>
<p>If you want to share your R code with others, you will need to make an R package. This allows you to bundle code along with documentation and unit tests, and easily distribute it via CRAN. In my opinion, the easiest way to develop packages is with devtools<span id="fn18" class="footnote" data-pagedown-footnote-number="18" style="white-space: pre-line;"><a href="http://devtools.r-lib.org" class="uri">http://devtools.r-lib.org</a></span>, roxygen2<span id="fn19" class="footnote" data-pagedown-footnote-number="19" style="white-space: pre-line;"><a href="http://klutometis.github.io/roxygen/" class="uri">http://klutometis.github.io/roxygen/</a></span>, testthat<span id="fn20" class="footnote" data-pagedown-footnote-number="20" style="white-space: pre-line;"><a href="http://testthat.r-lib.org" class="uri">http://testthat.r-lib.org</a></span>, and usethis<span id="fn21" class="footnote" data-pagedown-footnote-number="21" style="white-space: pre-line;"><a href="http://usethis.r-lib.org" class="uri">http://usethis.r-lib.org</a></span>. You can learn about using these packages to make your own package in “R packages”<span id="fn22" class="footnote" data-pagedown-footnote-number="22" style="white-space: pre-line;"><a href="http://r-pkgs.had.co.nz/" class="uri">http://r-pkgs.had.co.nz/</a></span>.</p>
</div>
<div id="meta-techniques" class="section level2">
<h2><span class="header-section-number">1.5</span> Meta-techniques</h2>
<p>There are two meta-techniques that are tremendously helpful for improving your skills as an R programmer: reading source code and adopting a scientific mindset.</p>
<p>Reading source code is important because it will help you write better code. A great place to start developing this skill is to look at the source code of the functions and packages you use most often. You’ll find things that are worth emulating in your own code and you’ll develop a sense of taste for what makes good R code. You will also see things that you don’t like, either because its virtues are not obvious or it offends your sensibilities. Such code is nonetheless valuable, because it helps make concrete your opinions on good and bad code.</p>
<p>A scientific mindset is extremely helpful when learning R. If you don’t understand how something works, develop a hypothesis, design some experiments, run them, and record the results. This exercise is extremely useful since if you can’t figure something out and need to get help, you can easily show others what you tried. Also, when you learn the right answer, you’ll be mentally prepared to update your world view.</p>
</div>
<div id="recommended-reading" class="section level2">
<h2><span class="header-section-number">1.6</span> Recommended reading</h2>
<p>Because the R community mostly consists of data scientists, not computer scientists, there are relatively few books that go deep in the technical underpinnings of R. In my personal journey to understand R, I’ve found it particularly helpful to use resources from other programming languages. R has aspects of both functional and object-oriented (OO) programming languages. Learning how these concepts are expressed in R will help you leverage your existing knowledge of other programming languages, and will help you identify areas where you can improve.</p>
<p>To understand why R’s object systems work the way they do, I found “The Structure and Interpretation of Computer Programs”<span id="fn23" class="footnote" data-pagedown-footnote-number="23" style="white-space: pre-line;">You can read it online for free at <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html" class="uri">https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html</a></span> <span class="citation">(Abelson, Sussman, and Sussman <a href="#ref-SICP">1996</a>)</span> (SICP) by Harold Abelson and Gerald Jay Sussman, to be particularly helpful. It’s a concise but deep book, and after reading it, I felt for the first time that I could actually design my own object-oriented system. The book was my first introduction to the encapsulated paradigm of object oriented programming found in R, and it helped me understand the strengths and weaknesses of this system. SICP also teaches the functional mindset where you create functions that are simple individually, and which become powerful when composed together.</p>
<p>To understand the trade-offs that R has made compared to other programming languages, I found “Concepts, Techniques and Models of Computer Programming” <span class="citation">(Van-Roy and Haridi <a href="#ref-ctmcp">2004</a>)</span> extremely helpful. It helped me understand that R’s copy-on-modify semantics make it substantially easier to reason about code, and that while its current implementation is not particularly efficient, it is a solvable problem.</p>
<p>If you want to learn to be a better programmer, there’s no place better to turn than “The Pragmatic Programmer” <span class="citation">(Hunt and Thomas <a href="#ref-pragprog">1990</a>)</span> by Andrew Hunt and David Thomas. This book is language agnostic, and provides great advice for how to be a better programmer.</p>
</div>
<div id="getting-help" class="section level2">
<h2><span class="header-section-number">1.7</span> Getting help</h2>
<p>
</p>
<p>Currently, there are three main venues to get help when you’re stuck and can’t figure out what’s causing the problem: RStudio Community<span id="fn24" class="footnote" data-pagedown-footnote-number="24" style="white-space: pre-line;"><a href="https://community.rstudio.com/" class="uri">https://community.rstudio.com/</a></span>, StackOverflow<span id="fn25" class="footnote" data-pagedown-footnote-number="25" style="white-space: pre-line;"><a href="http://stackoverflow.com" class="uri">http://stackoverflow.com</a></span> and the R-help mailing list<span id="fn26" class="footnote" data-pagedown-footnote-number="26" style="white-space: pre-line;"><a href="https://stat.ethz.ch/mailman/listinfo/r-help" class="uri">https://stat.ethz.ch/mailman/listinfo/r-help</a></span>. You can get fantastic help in each venue, but they do have their own cultures and expectations. It’s usually a good idea to spend a little time lurking, learning about community expectations, before you put up your first post.</p>
<p>Some good general advice:</p>
<ul>
<li><p>Make sure you have the latest version of R and of the package (or packages)
you are having problems with. It may be that your problem is the result of
a recently fixed bug.</p></li>
<li><p>Spend some time creating a <strong>repr</strong>oducible <strong>ex</strong>ample, or reprex.
This will help others help you, and often leads to a solution without
asking others, because in the course of making the problem reproducible you
often figure out the root cause. I highly recommend learning and using
the reprex<span id="fn27" class="footnote" data-pagedown-footnote-number="27" style="white-space: pre-line;"><a href="https://reprex.tidyverse.org/" class="uri">https://reprex.tidyverse.org/</a></span> package.</p></li>
</ul>
<!-- GVW: is someone going to go through once you're done and create a glossary? If you've flagged things like "reprex" in bold, it ought to be easy to find terms. -->
</div>
<div id="intro-ack" class="section level2">
<h2><span class="header-section-number">1.8</span> Acknowledgments</h2>
<p>I would like to thank the many contributors to R-devel and R-help and, more recently, Stack Overflow and RStudio Community. There are too many to name individually, but I’d particularly like to thank Luke Tierney, John Chambers, Dirk Eddelbuettel, JJ Allaire, and Brian Ripley for generously giving their time and correcting my countless misunderstandings.</p>
<p>This book was written in the open<span id="fn28" class="footnote" data-pagedown-footnote-number="28" style="white-space: pre-line;"><a href="https://github.com/hadley/adv-r/" class="uri">https://github.com/hadley/adv-r/</a></span>, and chapters were advertised on twitter<span id="fn29" class="footnote" data-pagedown-footnote-number="29" style="white-space: pre-line;"><a href="https://twitter.com/hadleywickham" class="uri">https://twitter.com/hadleywickham</a></span> when complete. It is truly a community effort: many people read drafts, fixed typos, suggested improvements, and contributed content. Without those contributors, the book wouldn’t be nearly as good as it is, and I’m deeply grateful for their help. Special thanks go to Jeff Hammerbacher, Peter Li, and Greg Wilson, who all read the book from cover-to-cover and provided many fixes and suggestions.</p>
<p>A big thank you to all 374 contributors (in alphabetical order): Aaron Wolen (@aaronwolen), @absolutelyNoWarranty, Adam Hunt (@adamphunt), @agrabovsky, Alexander Grueneberg (@agrueneberg), Anthony Damico (@ajdamico), James Manton (@ajdm), Aaron Schumacher (@ajschumacher), Alan Dipert (@alandipert), Alex Brown (@alexbbrown), @alexperrone, Alex Whitworth (@alexWhitworth), Alexandros Kokkalis (@alko989), @amarchin, Amelia McNamara (@AmeliaMN), Bryce Mecum (@amoeba), Andrew Laucius (@andrewla), Andrew Bray (@andrewpbray), Andrie de Vries (@andrie), Angela Li (@angela-li), @aranlunzer, Ari Lamstein (@arilamstein), @asnr, Andy Teucher (@ateucher), Albert Vilella (@avilella), baptiste (@baptiste), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Brandon Greenwell (@bgreenwell), Brandon Hurr (@bhive01), Jason Knight (@binarybana), Brett Klamer (@bklamer), Jesse Anderson (@blindjesse), Brian Mayer (@blmayer), Benjamin L. Moore (@blmoore), Brian Diggs (@BrianDiggs), Brian S. Yandell (@byandell), @carey1024, Chip Hogg (@chiphogg), Chris Muir (@ChrisMuir), Christopher Gandrud (@christophergandrud), Clay Ford (@clayford), Colin Fay (@ColinFay), @cortinah, Cameron Plouffe (@cplouffe), Carson Sievert (@cpsievert), Craig Citro (@craigcitro), Craig Grabowski (@craiggrabowski), Christopher Roach (@croach), Peter Meilstrup (@crowding), Crt Ahlin (@crtahlin), Carlos Scheidegger (@cscheid), Colin Gillespie (@csgillespie), Christopher Brown (@ctbrown), Davor Cubranic (@cubranic), Darren Cusanovich (@cusanovich), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Dean Attali (@daattali), Dan Sullivan (@dan87134), Daniel Barnett (@daniel-barnett), Daniel (@danielruc91), Kenny Darrell (@darrkj), Tracy Nance (@datapixie), Dave Childers (@davechilders), David Rubinger (@davidrubinger), David Chudzicki (@dchudz), Deependra Dhakal (@DeependraD), Daisuke ICHIKAWA (@dichika), david kahle (@dkahle), David LeBauer (@dlebauer), David Schweizer (@dlschweizer), David Montaner (@dmontaner), @dmurdoch, Zhuoer Dong (@dongzhuoer), Doug Mitarotonda (@dougmitarotonda), Jonathan Hill (@Dripdrop12), @drtjc, Julian During (@duju211), @duncanwadsworth, @eaurele, Dirk Eddelbuettel (@eddelbuettel), @EdFineOKL, Eduard Szöcs (@EDiLD), Edwin Thoen (@EdwinTh), Ethan Heinzen (@eheinzen), @eijoac, Joel Schwartz (@eipi10), Eric Ronald Legrand (@elegrand), Ellis Valentiner (@ellisvalentiner), Emil Hvitfeldt (@EmilHvitfeldt), Emil Rehnberg (@EmilRehnberg), Daniel Lee (@erget), Eric C. Anderson (@eriqande), Enrico Spinielli (@espinielli), @etb, David Hajage (@eusebe), Fabian Scheipl (@fabian-s), @flammy0530, François Michonneau (@fmichonneau), Francois Pepin (@fpepin), Frank Farach (@frankfarach), @freezby, Frans van Dunné (@FvD), @fyears, @gagnagaman, Garrett Grolemund (@garrettgman), Gavin Simpson (@gavinsimpson), @gezakiss7, @gggtest, Gökçen Eraslan (@gokceneraslan), Georg Russ (@gr650), @grasshoppermouse, Gregor Thomas (@gregorp), Garrett See (@gsee), Ari Friedman (@gsk3), Gunnlaugur Thor Briem (@gthb), Greg Wilson (@gvwilson), Hadley Wickham (@hadley), Hamed (@hamedbh), Jeff Hammerbacher (@hammer), Harley Day (@harleyday), @hassaad85, @helmingstay, Henning (@henningsway), Henrik Bengtsson (@HenrikBengtsson), Ching Boon (@hoscb), @hplieninger, Iain Dillingham (@iaindillingham), @IanKopacka, Ian Lyttle (@ijlyttle), Ilan Man (@ilanman), Imanuel Costigan (@imanuelcostigan), Thomas Bürli (@initdch), Os Keyes (@Ironholds), @irudnyts, i (@isomorphisms), Irene Steves (@isteves), Jan Gleixner (@jan-glx), Jannes Muenchow (@jannes-m), Jason Asher (@jasonasher), Jason Davies (@jasondavies), Chris (@jastingo), jcborras (@jcborras), John Blischak (@jdblischak), @jeharmse, Lukas Burk (@jemus42), Jennifer (Jenny) Bryan (@jennybc), Justin Jent (@jentjr), Jeston (@JestonBlu), Jim Hester (@jimhester), @JimInNashville, @jimmyliu2017, Jim Vine (@jimvine), Jinlong Yang (@jinlong25), J.J. Allaire (@jjallaire), @JMHay, Jochen Van de Velde (@jochenvdv), Johann Hibschman (@johannh), John Baumgartner (@johnbaums), John Horton (@johnjosephhorton), @johnthomas12, Jon Calder (@jonmcalder), Jon Harmon (@jonthegeek), Julia Gustavsen (@jooolia), JorneBiccler (@JorneBiccler), Jeffrey Arnold (@jrnold), Joyce Robbins (@jtr13), Juan Manuel Truppia (@juancentro), Kevin Markham (@justmarkham), john verzani (@jverzani), Michael Kane (@kaneplusplus), Bart Kastermans (@kasterma), Kevin D’Auria (@kdauria), Karandeep Singh (@kdpsingh), Ken Williams (@kenahoo), Kendon Bell (@kendonB), Kent Johnson (@kent37), Kevin Ushey (@kevinushey), 电线杆 (@kfeng123), Karl Forner (@kforner), Kirill Sevastyanenko (@kirillseva), Brian Knaus (@knausb), Kirill Müller (@krlmlr), Kriti Sen Sharma (@ksens), Kai Tang (唐恺） (@ktang), Kevin Wright (@kwstat), <a href="mailto:suo.lawrence.liu@gmail.com" class="email">suo.lawrence.liu@gmail.com</a> (@Lawrence-Liu), @ldfmrails, Kevin Kainan Li (@legendre6891), Rachel Severson (@leighseverson), Laurent Gatto (@lgatto), C. Jason Liang (@liangcj), Steve Lianoglou (@lianos), Likan (@likanzhan), @lindbrook, Lingbing Feng (@Lingbing), Marcel Ramos (@LiNk-NY), Zhongpeng Lin (@linzhp), Lionel Henry (@lionel-), Lluís (@llrs), myq (@lrcg), Luke W Johnston (@lwjohnst86), Kevin Lynagh (@lynaghk), @MajoroMask, Malcolm Barrett (@malcolmbarrett), @mannyishere, @mascaretti, Matt (@mattbaggott), Matthew Grogan (@mattgrogan), @matthewhillary, Matthieu Gomez (@matthieugomez), Matt Malin (@mattmalin), Mauro Lepore (@maurolepore), Max Ghenis (@MaxGhenis), Maximilian Held (@maxheld83), Michal Bojanowski (@mbojan), Mark Rosenstein (@mbrmbr), Michael Sumner (@mdsumner), Jun Mei (@meijun), merkliopas (@merkliopas), mfrasco (@mfrasco), Michael Bach (@michaelbach), Michael Bishop (@MichaelMBishop), Michael Buckley (@michaelmikebuckley), Michael Quinn (@michaelquinn32), @miguelmorin, Michael (@mikekaminsky), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), @mjsduncan, Mamoun Benghezal (@MoBeng), Matt Pettis (@mpettis), Martin Morgan (@mtmorgan), Guy Dawson (@Mullefa), Nacho Caballero (@nachocab), Natalya Rapstine (@natalya-patrikeeva), Nick Carchedi (@ncarchedi), Pascal Burkhard (@Nenuial), Noah Greifer (@ngreifer), Nicholas Vasile (@nickv9), Nikos Ignatiadis (@nignatiadis), Nina Munkholt Jakobsen (@nmjakobsen), Xavier Laviron (@norival), Nick Pullen (@nstjhp), Oge Nnadi (@ogennadi), Oliver Paisley (@oliverpaisley), Pariksheet Nanda (@omsai), Øystein Sørensen (@osorensen), Paul (@otepoti), Otho Mantegazza (@othomantegazza), Dewey Dunnington (@paleolimbot), Parker Abercrombie (@parkerabercrombie), Patrick Hausmann (@patperu), Patrick Miller (@patr1ckm), Patrick Werkmeister (@Patrick01), @paulponcet, @pdb61, Tom Crockett (@pelotom), @pengyu, Jeremiah (@perryjer1), Peter Hickey (@PeteHaitch), Phil Chalmers (@philchalmers), Jose Antonio Magaña Mesa (@picarus), Pierre Casadebaig (@picasa), Antonio Piccolboni (@piccolbo), Pierre Roudier (@pierreroudier), Poor Yorick (@pooryorick), Marie-Helene Burle (@prosoitos), Peter Schulam (@pschulam), John (@quantbo), Quyu Kong (@qykong), Ramiro Magno (@ramiromagno), Ramnath Vaidyanathan (@ramnathv), Kun Ren (@renkun-ken), Richard Reeve (@richardreeve), Richard Cotton (@richierocks), Robert M Flight (@rmflight), R. Mark Sharp (@rmsharp), Robert Krzyzanowski (@robertzk), @robiRagan, Romain François (@romainfrancois), Ross Holmberg (@rossholmberg), Ricardo Pietrobon (@rpietro), @rrunner, Ryan Walker (@rtwalker), @rubenfcasal, Rob Weyant (@rweyant), Rumen Zarev (@rzarev), Nan Wang (@sailingwave), Samuel Perreault (@samperochkin), @sbgraves237, Scott Kostyshak (@scottkosty), Scott Leishman (@scttl), Sean Hughes (@seaaan), Sean Anderson (@seananderson), Sean Carmody (@seancarmody), Sebastian (@sebastian-c), Matthew Sedaghatfar (@sedaghatfar), @see24, Sven E. Templer (@setempler), @sflippl, @shabbybanks, Steven Pav (@shabbychef), Shannon Rush (@shannonrush), S’busiso Mkhondwane (@sibusiso16), Sigfried Gold (@Sigfried), Simon O’Hanlon (@simonohanlon101), Simon Potter (@sjp), Leo Razoumov (@slonik-az), Richard M. Smith (@Smudgerville), Steve (@SplashDance), Scott Ritchie (@sritchie73), Tim Cole (@statist7), @ste-fan, @stephens999, Steve Walker (@stevencarlislewalker), Stefan Widgren (@stewid), Homer Strong (@strongh), Dirk (@surmann), Sebastien Vigneau (@svigneau), Scott Warchal (@Swarchal), Steven Nydick (@swnydick), Taekyun Kim (@taekyunk), Tal Galili (@talgalili), @Tazinho, Tyler Bradley (@tbradley1013), Tom B (@tbuckl), @tdenes, @thomasherbig, Thomas (@thomaskern), Thomas Lin Pedersen (@thomasp85), Thomas Zumbrunn (@thomaszumbrunn), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Nagler (@tnagler), Anton Antonov (@tonytonov), Ben Torvaney (@Torvaney), Jeff Allen (@trestletech), Tyler Rinker (@trinker), Chitu Okoli (@Tripartio), Kirill Tsukanov (@tskir), Terence Teo (@tteo), Tim Triche, Jr. (@ttriche), @tyhenkaline, Tyler Ritchie (@tylerritchie), Tyler Littlefield (@tyluRp), Varun Agrawal (@varun729), Vijay Barve (@vijaybarve), Victor (@vkryukov), Vaidotas Zemlys-Balevičius (@vzemlys), Winston Chang (@wch), Linda Chin (@wchi144), Welliton Souza (@Welliton309), Gregg Whitworth (@whitwort), Will Beasley (@wibeasley), William R Bauer (@WilCrofter), William Doane (@WilDoane), Sean Wilkinson (@wilkinson), Christof Winter (@winterschlaefer), Bill Carver (@wmc3), Wolfgang Huber (@wolfganghuber), Krishna Sankar (@xsankar), Yihui Xie (@yihui), yang (@yiluheihei), Yoni Ben-Meshulam (@yoni), @yuchouchen, Yuqi Liao (@yuqiliao), Hiroaki Yutani (@yutannihilation), Zachary Foster (@zachary-foster), @zachcp, @zackham, Sergio Oller (@zeehio), Edward Cho (@zerokarmaleft), Albert Zhao (@zxzb).</p>
</div>
<div id="conventions" class="section level2">
<h2><span class="header-section-number">1.9</span> Conventions</h2>
<p>Throughout this book I use <code>f()</code> to refer to functions, <code>g</code> to refer to variables and function parameters, and <code>h/</code> to paths.</p>
<p>Larger code blocks intermingle input and output. Output is commented (<code>#&gt;</code>) so that if you have an electronic version of the book, e.g., <a href="https://adv-r.hadley.nz/" class="uri">https://adv-r.hadley.nz/</a>, you can easily copy and paste examples into R.</p>
<p>Many examples use random numbers. These are made reproducible by <code>set.seed(1014)</code>, which is executed automatically at the start of each chapter.</p>
</div>
<div id="colophon" class="section level2">
<h2><span class="header-section-number">1.10</span> Colophon</h2>
<p>This book was written in bookdown<span id="fn30" class="footnote" data-pagedown-footnote-number="30" style="white-space: pre-line;"><a href="http://bookdown.org/" class="uri">http://bookdown.org/</a></span> inside RStudio<span id="fn31" class="footnote" data-pagedown-footnote-number="31" style="white-space: pre-line;"><a href="http://www.rstudio.com/ide/" class="uri">http://www.rstudio.com/ide/</a></span>. The website<span id="fn32" class="footnote" data-pagedown-footnote-number="32" style="white-space: pre-line;"><a href="https://adv-r.hadley.nz/" class="uri">https://adv-r.hadley.nz/</a></span> is hosted with netlify<span id="fn33" class="footnote" data-pagedown-footnote-number="33" style="white-space: pre-line;"><a href="http://netlify.com/" class="uri">http://netlify.com/</a></span>, and automatically updated after every commit by travis-ci<span id="fn34" class="footnote" data-pagedown-footnote-number="34" style="white-space: pre-line;"><a href="https://travis-ci.org/" class="uri">https://travis-ci.org/</a></span>. The complete source is available from GitHub<span id="fn35" class="footnote" data-pagedown-footnote-number="35" style="white-space: pre-line;"><a href="https://github.com/hadley/adv-r" class="uri">https://github.com/hadley/adv-r</a></span>. Code in the printed book is set in inconsolata<span id="fn36" class="footnote" data-pagedown-footnote-number="36" style="white-space: pre-line;"><a href="http://levien.com/type/myfonts/inconsolata.html" class="uri">http://levien.com/type/myfonts/inconsolata.html</a></span>. Emoji images in the printed book come from the open-licensed Twitter Emoji<span id="fn37" class="footnote" data-pagedown-footnote-number="37" style="white-space: pre-line;"><a href="https://github.com/twitter/twemoji" class="uri">https://github.com/twitter/twemoji</a></span>.</p>
<p>This version of the book was built with the following version of R and packages.</p>
<table>
<thead>
<tr class="header">
<th align="left">setting</th>
<th align="left">value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">version</td>
<td align="left">R version 3.5.2 (2017-01-27)</td>
</tr>
<tr class="even">
<td align="left">os</td>
<td align="left">Ubuntu 14.04.5 LTS</td>
</tr>
<tr class="odd">
<td align="left">system</td>
<td align="left">x86_64, linux-gnu</td>
</tr>
<tr class="even">
<td align="left">ui</td>
<td align="left">X11</td>
</tr>
<tr class="odd">
<td align="left">language</td>
<td align="left">(EN)</td>
</tr>
<tr class="even">
<td align="left">collate</td>
<td align="left">en_US.UTF-8</td>
</tr>
<tr class="odd">
<td align="left">ctype</td>
<td align="left">en_US.UTF-8</td>
</tr>
<tr class="even">
<td align="left">tz</td>
<td align="left">UTC</td>
</tr>
<tr class="odd">
<td align="left">date</td>
<td align="left">2019-01-24</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">package</th>
<th align="left">version</th>
<th align="left">source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">assertthat</td>
<td align="left">0.2.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">backports</td>
<td align="left">1.1.3</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">base64enc</td>
<td align="left">0.1-3</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">beeswarm</td>
<td align="left">0.2.3</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">bench</td>
<td align="left">1.0.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">BH</td>
<td align="left">1.69.0-1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">bindr</td>
<td align="left">0.1.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">bindrcpp</td>
<td align="left">0.2.2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">bit</td>
<td align="left">1.1-14</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">bit64</td>
<td align="left">0.9-7</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">blob</td>
<td align="left">1.1.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">bookdown</td>
<td align="left">0.9</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">cli</td>
<td align="left">1.0.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">codetools</td>
<td align="left">0.2-15</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">colorspace</td>
<td align="left">1.4-0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">crayon</td>
<td align="left">1.3.4</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">DBI</td>
<td align="left">1.0.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">dbplyr</td>
<td align="left">1.3.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">desc</td>
<td align="left">1.2.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">digest</td>
<td align="left">0.6.18</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">dplyr</td>
<td align="left">0.7.8</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">emo</td>
<td align="left">0.0.0.9000</td>
<td align="left">Github (hadley/emo@02a5206)</td>
</tr>
<tr class="odd">
<td align="left">evaluate</td>
<td align="left">0.12</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">fansi</td>
<td align="left">0.4.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">ggbeeswarm</td>
<td align="left">0.6.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">ggplot2</td>
<td align="left">3.1.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">glue</td>
<td align="left">1.3.0.9000</td>
<td align="left">Github (tidyverse/glue@0549457)</td>
</tr>
<tr class="even">
<td align="left">gtable</td>
<td align="left">0.2.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">highr</td>
<td align="left">0.7</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">htmltools</td>
<td align="left">0.3.6</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">htmlwidgets</td>
<td align="left">1.3</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">jsonlite</td>
<td align="left">1.6</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">knitr</td>
<td align="left">1.21</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">labeling</td>
<td align="left">0.3</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">lattice</td>
<td align="left">0.20-38</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">lazyeval</td>
<td align="left">0.2.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">lobstr</td>
<td align="left">1.0.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">lubridate</td>
<td align="left">1.7.4</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">magrittr</td>
<td align="left">1.5</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">markdown</td>
<td align="left">0.9</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">MASS</td>
<td align="left">7.3-51.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">Matrix</td>
<td align="left">1.2-15</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">memoise</td>
<td align="left">1.1.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">mgcv</td>
<td align="left">1.8-26</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">mime</td>
<td align="left">0.6</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">munsell</td>
<td align="left">0.5.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">nlme</td>
<td align="left">3.1-137</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">pillar</td>
<td align="left">1.3.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">pkgconfig</td>
<td align="left">2.0.2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">plogr</td>
<td align="left">0.2.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">plyr</td>
<td align="left">1.8.4</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">png</td>
<td align="left">0.1-7</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">praise</td>
<td align="left">1.0.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">prettyunits</td>
<td align="left">1.0.2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">profmem</td>
<td align="left">0.5.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">profvis</td>
<td align="left">0.3.5</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">purrr</td>
<td align="left">0.2.5</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">R6</td>
<td align="left">2.3.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">RColorBrewer</td>
<td align="left">1.1-2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">Rcpp</td>
<td align="left">1.0.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">reshape2</td>
<td align="left">1.4.3</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">rlang</td>
<td align="left">0.3.1.9000</td>
<td align="left">Github (r-lib/rlang@02bff45)</td>
</tr>
<tr class="odd">
<td align="left">rmarkdown</td>
<td align="left">1.11</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">rprojroot</td>
<td align="left">1.3-2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">RSQLite</td>
<td align="left">2.1.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">scales</td>
<td align="left">1.0.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">sessioninfo</td>
<td align="left">1.1.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">sloop</td>
<td align="left">1.0.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">stringi</td>
<td align="left">1.2.4</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">stringr</td>
<td align="left">1.3.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">testthat</td>
<td align="left">2.0.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">tibble</td>
<td align="left">2.0.1</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">tidyr</td>
<td align="left">0.8.2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">tidyselect</td>
<td align="left">0.2.5</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">tinytex</td>
<td align="left">0.10</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">utf8</td>
<td align="left">1.1.4</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">vctrs</td>
<td align="left">0.1.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">vipor</td>
<td align="left">0.4.5</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">viridisLite</td>
<td align="left">0.3.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">withr</td>
<td align="left">2.1.2</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">xfun</td>
<td align="left">0.4</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="even">
<td align="left">yaml</td>
<td align="left">2.2.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
<tr class="odd">
<td align="left">zeallot</td>
<td align="left">0.1.0</td>
<td align="left">CRAN (R 3.5.2)</td>
</tr>
</tbody>
</table>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ruler</span>()
<span class="co">#&gt; ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+</span>
<span class="co">#&gt; 123456789012345678901234567890123456789012345678901234567890123456789012345</span></code></pre>
<!--chapter:end:Introduction.Rmd-->
</div>
</div>
<div id="part-foundations" class="section level1 unnumbered">
<h1><span class="header-section-number">I</span> Foundations</h1>
</div>
<div id="foundations-intro" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>To start your journey in mastering R, the following six chapters will help you learn what I consider to be the foundational components of R. I expect that you’ve already seen many of these pieces before, but you probably have not studied them deeply. To help check your existing knowledge, each chapter starts with a quiz; if you get all the questions right, feel free to skip to the next chapter!</p>
<ol style="list-style-type: decimal">
<li><p>In Chapter <a href="#names-values">2</a>, you’ll learn about one of the most
important distinctions you haven’t previously needed to grapple with:
the difference between an object and its name. Improving your mental model
here will help you make better predictions about when R copies data
and hence which basic operations are cheap and which are expensive.</p></li>
<li><p>Every day you’ve used R, you’ve used vectors, so Chapter <a href="#vectors-chap">3</a>
will dive into the details, helping you learn how the different types of
vector fit together. You’ll also learn about attributes, which allow you to
store arbitrary metadata, and form the basis for two of R’s object
oriented programming toolkits</p></li>
<li><p>To write concise and performant R code it is important to fully appreciate
the power of subsetting with <code>[</code>, <code>[[</code> and <code>$</code>, as described in Chapter
<a href="#subsetting">4</a>. Understanding the fundamental components of subsetting
will allow you to solve new problems by combining the building blocks in
novel ways.</p></li>
<li><p>The tools of control flow allow you to only execute code under certain
conditions, or to repeatedly execute code with changing inputs. In Chapter
<a href="#control-flow">5</a>, you’ll learn the important <code>if</code> and <code>for</code> constructs,
as well as related tools like <code>switch()</code> and <code>while</code>.</p></li>
<li><p>Functions are the most important building block of R code, and in Chapter
<a href="#functions">6</a>, you’ll learn exactly how they work, including
the <strong>scoping</strong> rules, which govern how R looks up values from names.
You’ll also learn more of the details behind R’s lazy evaluation, and
how you can control what happens when you exit a function.</p></li>
<li><p>In Chapter <a href="#environments">7</a>, you’ll learn about a data structure that
is crucial for understanding how R works, but quite unimportant for data
analysis: the environment. Environments are the data structure that binds
names to values, and they power tools like package namespaces. Unlike most
programming languages, environments in R are “first class” which means that
you can manipulate them just like other objects.</p></li>
<li><p>Chapter <a href="#conditions">8</a> concludes this section of the book with a
discussion of “conditions”, the umbrella term used to describe errors,
warnings, and messages. You’ve certainly encountered these before, so in
this chapter you learn how to signal them appropriately in your own
functions, and how to handle them when signalled elsewhere.</p></li>
</ol>
<!--chapter:end:Foundations.Rmd-->
</div>
<div id="names-values" class="section level1">
<h1><span class="header-section-number">2</span> Names and values</h1>
<div id="introduction-1" class="section level2">
<h2><span class="header-section-number">2.1</span> Introduction</h2>
<p>In R, it is important to understand the distinction between an object and its name. Doing so will help you:</p>
<ul>
<li>More accurately predict the performance and memory usage of your code.</li>
<li>Write faster code by avoiding accidental copies, a major source of slow code.</li>
<li>Better understand R’s functional programming tools.</li>
</ul>
<p>The goal of this chapter is to help you understand the distinction between names and values, and when R will copy an object.</p>
<div id="quiz" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>Answer the following questions to see if you can safely skip this chapter. You can find the answers at the end of the chapter in Section <a href="#names-values-answers">2.7</a>.</p>
<ol style="list-style-type: decimal">
<li><p>Given the following data frame, how do I create a new column called “3”
that contains the sum of <code>1</code> and <code>2</code>? You may only use <code>$</code>, not <code>[[</code>.
What makes <code>1</code>, <code>2</code>, and <code>3</code> challenging as variable names?</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">runif</span>(<span class="dv">3</span>), <span class="kw">runif</span>(<span class="dv">3</span>))
<span class="kw">names</span>(df) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)</code></pre></li>
<li><p>In the following code, how much memory does <code>y</code> occupy?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e6</span>)
y &lt;-<span class="st"> </span><span class="kw">list</span>(x, x, x)</code></pre></li>
<li><p>On which line does <code>a</code> get copied in the following example?</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">2</span>)
b &lt;-<span class="st"> </span>a
b[[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="dv">10</span></code></pre></li>
</ol>
</div>
<div id="outline" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#binding-basics">2.2</a> introduces you to the distinction between
names and values, and discusses how <code>&lt;-</code> creates a binding, or reference,
between a name and a value.</p></li>
<li><p>Section <a href="#copy-on-modify">2.3</a> describes when R makes a copy: whenever you
modify a vector, you’re almost certainly creating a new, modified vector.
You’ll learn how to use <code>tracemem()</code> to figure out when a copy actually
occurs. Then you’ll explore the implications as they apply to function calls,
lists, data frames, and character vectors.</p></li>
<li><p>Section <a href="#object-size">2.4</a> explores the implications of the previous two
sections on how much memory an object occupies. Since your intuition may be
profoundly wrong and since <code>utils::object.size()</code> is unfortunately
inaccurate, you’ll learn how to use <code>lobstr::obj_size()</code>.</p></li>
<li><p>Section <a href="#modify-in-place">2.5</a> describes the two important exceptions to
copy-on-modify: with environments and values with a single name, objects are
actually modified in place.</p></li>
<li><p>Section <a href="#gc">2.6</a> concludes the chapter with a discussion of the garbage
collector, which frees up the memory used by objects no longer referenced by
a name.</p></li>
</ul>
</div>
<div id="prerequisites" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>We’ll use the lobstr<span id="fn38" class="footnote" data-pagedown-footnote-number="38" style="white-space: pre-line;"><a href="https://github.com/r-lib/lobstr" class="uri">https://github.com/r-lib/lobstr</a></span> package to dig into the internal representation of R objects.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(lobstr)</code></pre>
</div>
<div id="sources" class="section level3 unnumbered">
<h3>Sources</h3>
<p>The details of R’s memory management are not documented in a single place. Much of the information in this chapter was gleaned from a close reading of the documentation (particularly <code>?Memory</code> and <code>?gc</code>), the memory profiling<span id="fn39" class="footnote" data-pagedown-footnote-number="39" style="white-space: pre-line;"><a href="http://cran.r-project.org/doc/manuals/R-exts.html#Profiling-R-code-for-memory-use" class="uri">http://cran.r-project.org/doc/manuals/R-exts.html#Profiling-R-code-for-memory-use</a></span> section of “Writing R extensions” <span class="citation">(R Core Team <a href="#ref-r-exts">2018</a><a href="#ref-r-exts">b</a>)</span>, and the SEXPs<span id="fn40" class="footnote" data-pagedown-footnote-number="40" style="white-space: pre-line;"><a href="http://cran.r-project.org/doc/manuals/R-ints.html#SEXPs" class="uri">http://cran.r-project.org/doc/manuals/R-ints.html#SEXPs</a></span> section of “R internals” <span class="citation">(R Core Team <a href="#ref-r-ints">2018</a><a href="#ref-r-ints">a</a>)</span>. The rest I figured out by reading the C source code, performing small experiments, and asking questions on R-devel. Any mistakes are entirely mine.</p>
</div>
</div>
<div id="binding-basics" class="section level2">
<h2><span class="header-section-number">2.2</span> Binding basics</h2>
<p>

</p>
<p>Consider this code:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p>It’s easy to read it as: “create an object named ‘x’, containing the values 1, 2, and 3”. Unfortunately, that’s a simplification that will lead to inaccurate predictions about what R is actually doing behind the scenes. It’s more accurate to say that this code is doing two things:</p>
<ul>
<li>It’s creating an object, a vector of values, <code>c(1, 2, 3)</code>.</li>
<li>And it’s binding that object to a name, <code>x</code>.</li>
</ul>
<p>In other words, the object, or value, doesn’t have a name; it’s actually the name that has a value.</p>
<p>To further clarify this distinction, I’ll draw diagrams like this:</p>
<p><img src="diagrams/name-value/binding-1.png" width="160" style="display: block; margin: auto;" /></p>
<p>The name, <code>x</code>, is drawn with a rounded rectangle. It has an arrow that points to (or binds or references) the value, the vector <code>c(1, 2, 3)</code>. The arrow points in opposite direction to the assignment arrow: <code>&lt;-</code> creates a binding from the name on the left-hand side to the object on the right-hand side.</p>
<p>Thus, you can think of a name as a reference to a value. For example, if you run this code, you don’t get another copy of the value <code>c(1, 2, 3)</code>, you get another binding to the existing object:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span>x</code></pre>
<p><img src="diagrams/name-value/binding-2.png" width="170" style="display: block; margin: auto;" /></p>
<p>You might have noticed that the value <code>c(1, 2, 3)</code> has a label: <code>0x74b</code>. While the vector doesn’t have a name, I’ll occasionally need to refer to an object independent of its bindings. To make that possible, I’ll label values with a unique identifier. These identifiers have a special form that looks like the object’s memory “address”, i.e. the location in memory where the object is stored. But because the actual memory addresses changes every time the code is run, we use these identifiers instead.</p>
<p>You can access an object’s identifier with <code>lobstr::obj_addr()</code>. Doing so allows you to see that both <code>x</code> and <code>y</code> point to the same identifier:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">obj_addr</span>(x)
<span class="co">#&gt; [1] &quot;0x1882a98&quot;</span>
<span class="kw">obj_addr</span>(y)
<span class="co">#&gt; [1] &quot;0x1882a98&quot;</span></code></pre>
<p>These identifiers are long, and change every time you restart R.</p>
<p>It can take some time to get your head around the distinction between names and values, but understanding this is really helpful in functional programming where functions can have different names in different contexts.</p>
<div id="non-syntactic" class="section level3">
<h3><span class="header-section-number">2.2.1</span> Non-syntactic names</h3>
<p>

</p>
<p>R has strict rules about what constitutes a valid name. A <strong>syntactic</strong> name must consist of letters<span id="fn41" class="footnote" data-pagedown-footnote-number="41" style="white-space: pre-line;">Surprisingly, precisely what constitutes a letter is determined by your current locale. That means that the syntax of R code can actually differ from computer to computer, and that it’s possible for a file that works on one computer to not even parse on another! Avoid this problem by sticking to ASCII characters (i.e. A-Z) as much as possible.</span>, digits, <code>.</code> and <code>_</code> but can’t begin with <code>_</code> or a digit. Additionally, you can’t use any of the <strong>reserved words</strong> like <code>TRUE</code>, <code>NULL</code>, <code>if</code>, and <code>function</code> (see the complete list in <code>?Reserved</code>). A name that doesn’t follow these rules is a <strong>non-syntactic</strong> name; if you try to use them, you’ll get an error:</p>
<pre class="sourceCode r"><code class="sourceCode r">_abc &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="co">#&gt; Error: unexpected input in &quot;_&quot;</span>

<span class="cf">if</span> &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="co">#&gt; Error: unexpected assignment in &quot;if &lt;-&quot;</span></code></pre>
<p>It’s possible to override these rules and use any name, i.e., any sequence of characters, by surrounding it with backticks:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">_abc</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="st">`</span><span class="dt">_abc</span><span class="st">`</span>
<span class="co">#&gt; [1] 1</span>

<span class="st">`</span><span class="dt">if</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="st">`</span><span class="dt">if</span><span class="st">`</span>
<span class="co">#&gt; [1] 10</span></code></pre>
<p>While it’s unlikely you’d deliberately create such crazy names, you need to understand how these crazy names work because you’ll come across them, most commonly when you load data that has been created outside of R.</p>
<div class="sidebar">
<p>You <em>can</em> also create non-syntactic bindings using single or double quotes (e.g. <code>&quot;_abc&quot; &lt;- 1</code>) instead of backticks, but you shouldn’t, because you’ll have to use a different syntax to retrieve the values. The ability to use strings on the left hand side of the assignment arrow is an historical artefact, used before R supported backticks.</p>
</div>
</div>
<div id="exercises" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Explain the relationship between <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> in the following
code:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
b &lt;-<span class="st"> </span>a
c &lt;-<span class="st"> </span>b
d &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span></code></pre></li>
<li><p>The following code accesses the mean function in multiple ways. Do they all
point to the same underlying function object? Verify this with
<code>lobstr::obj_addr()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">mean
base<span class="op">::</span>mean
<span class="kw">get</span>(<span class="st">&quot;mean&quot;</span>)
<span class="kw">evalq</span>(mean)
<span class="kw">match.fun</span>(<span class="st">&quot;mean&quot;</span>)</code></pre></li>
<li><p>By default, base R data import functions, like <code>read.csv()</code>, will
automatically convert non-syntactic names to syntactic ones. Why might
this be problematic? What option allows you to suppress this behaviour</p></li>
<li><p>What rules does <code>make.names()</code> use to convert non-syntactic names into
syntactic ones?</p></li>
<li><p>I slightly simplified the rules that govern syntactic names. Why is <code>.123e1</code>
not a syntactic name? Read <code>?make.names</code> for the full details.</p></li>
</ol>
</div>
</div>
<div id="copy-on-modify" class="section level2">
<h2><span class="header-section-number">2.3</span> Copy-on-modify</h2>
<p></p>
<p>Consider the following code. It binds <code>x</code> and <code>y</code> to the same underlying value, then modifies <code>y</code>.<span id="fn42" class="footnote" data-pagedown-footnote-number="42" style="white-space: pre-line;">You may be surprised to see <code>[[</code> used to subset a numeric vector. We’ll come back to this in Section <a href="#subset-single">4.3</a>, but in brief, I think you should always use <code>[[</code> when you are getting or setting a single element.</span></p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
y &lt;-<span class="st"> </span>x

y[[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="dv">4</span>
x
<span class="co">#&gt; [1] 1 2 3</span></code></pre>
<p>Modifying <code>y</code> clearly didn’t modify <code>x</code>. So what happened to the shared binding? While the value associated with <code>y</code> changed, the original object did not. Instead, R created a new object, <code>0xcd2</code>, a copy of <code>0x74b</code> with one value changed, then rebound <code>y</code> to that object.</p>
<p><img src="diagrams/name-value/binding-3.png" width="160" style="display: block; margin: auto;" /></p>
<p>This behaviour is called <strong>copy-on-modify</strong>. Understanding it will radically improve your intuition about the performance of R code. A related way to describe this behaviour is to say that R objects are unchangeable, or <strong>immutable</strong>. However, I’ll generally avoid that term because there are a couple of important exceptions to copy-on-modify that you’ll learn about in Section <a href="#modify-in-place">2.5</a>.</p>
<p>When exploring copy-on-modify behaviour interactively, be aware that you’ll get different results inside of RStudio. That’s because the environment pane must make a reference to each object in order to display information about it. This distorts your interactive exploration but doesn’t affect code inside of functions, and so doesn’t affect performance during data analysis. For experimentation, I recommend either running R directly from the terminal, or using RMarkdown (like this book).</p>
<div id="tracemem" class="section level3">
<h3><span class="header-section-number">2.3.1</span> <code>tracemem()</code></h3>

<p>You can see when an object gets copied with the help of <code>base::tracemem()</code>. Once you call that function with an object, you’ll get the object’s current address:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="kw">cat</span>(<span class="kw">tracemem</span>(x), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
<span class="co">#&gt; &lt;0x7f80c0e0ffc8&gt; </span></code></pre>
<p>From then on, whenever that object is copied, <code>tracemem()</code> will print a message telling you which object was copied, its new address, and the sequence of calls that led to the copy:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span>x
y[[<span class="dv">3</span>]] &lt;-<span class="st"> </span>4L
<span class="co">#&gt; tracemem[0x7f80c0e0ffc8 -&gt; 0x7f80c4427f40]: </span></code></pre>
<p>If you modify <code>y</code> again, it won’t get copied. That’s because the new object now only has a single name bound to it, so R applies modify-in-place optimisation. We’ll come back to this in Section <a href="#modify-in-place">2.5</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">y[[<span class="dv">3</span>]] &lt;-<span class="st"> </span>5L

<span class="kw">untracemem</span>(y)</code></pre>
<p><code>untracemem()</code> is the opposite of <code>tracemem()</code>; it turns tracing off.</p>
</div>
<div id="function-calls" class="section level3">
<h3><span class="header-section-number">2.3.2</span> Function calls</h3>
<p>The same rules for copying also apply to function calls. Take this code:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(a) {
  a
}

x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="kw">cat</span>(<span class="kw">tracemem</span>(x), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
<span class="co">#&gt; &lt;0x3ec4658&gt;</span>

z &lt;-<span class="st"> </span><span class="kw">f</span>(x)
<span class="co"># there&#39;s no copy here!</span>

<span class="kw">untracemem</span>(x)</code></pre>
<p>While <code>f()</code> is running, the <code>a</code> inside the function points to the same value as the <code>x</code> does outside the function:</p>
<p><img src="diagrams/name-value/binding-f1.png" width="250" style="display: block; margin: auto;" /></p>
<p>You’ll learn more about the conventions used in this diagram in Section <a href="#execution-environments">7.4.4</a>. In brief: the function <code>f()</code> is depicted by the yellow object on the right. It has a formal argument, <code>a</code>, which becomes a binding (indicated by dotted black line) in the execution environment (the gray box) when the function is run.</p>
<p>Once <code>f()</code> completes, <code>x</code> and <code>z</code> will point to the same object. <code>0x74b</code> never gets copied because it never gets modified. If <code>f()</code> did modify <code>x</code>, R would create a new copy, and then <code>z</code> would bind that object.</p>
<p><img src="diagrams/name-value/binding-f2.png" width="170" style="display: block; margin: auto;" /></p>
</div>
<div id="list-references" class="section level3">
<h3><span class="header-section-number">2.3.3</span> Lists</h3>

<p></p>
<p>It’s not just names (i.e. variables) that point to values; elements of lists do too. Take this list, which is superficially very similar to the numeric vector above:</p>
<pre class="sourceCode r"><code class="sourceCode r">l1 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p>This list is more complex because instead of storing the values itself, it instead stores references to them:</p>
<p><img src="diagrams/name-value/list.png" width="189" style="display: block; margin: auto;" /></p>
<p>This is particularly important when we modify a list:</p>
<pre class="sourceCode r"><code class="sourceCode r">l2 &lt;-<span class="st"> </span>l1</code></pre>
<p><img src="diagrams/name-value/l-modify-1.png" width="189" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">l2[[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="dv">4</span></code></pre>
<p><img src="diagrams/name-value/l-modify-2.png" width="222" style="display: block; margin: auto;" /></p>
<p>Like vectors, lists use copy-on-modify behaviour; the original list is left unchanged, and R creates a modified copy. This, however, is a <strong>shallow</strong> copy: the list object and its bindings are copied, but the values pointed to by the bindings are not. The opposite of a shallow copy is a deep copy where the contents of every reference are copied. Prior to R 3.1.0, copies were always deep copies.</p>
<p>To see values that are shared across lists, use <code>lobstr::ref()</code>. <code>ref()</code> prints the memory address of each object, along with a local ID so that you can easily cross-reference shared components.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ref</span>(l1, l2)
<span class="co">#&gt; █ [1:0x18437c8] &lt;list&gt; </span>
<span class="co">#&gt; ├─[2:0x6c93108] &lt;dbl&gt; </span>
<span class="co">#&gt; ├─[3:0x6c930d0] &lt;dbl&gt; </span>
<span class="co">#&gt; └─[4:0x6c93098] &lt;dbl&gt; </span>
<span class="co">#&gt;  </span>
<span class="co">#&gt; █ [5:0x70a5528] &lt;list&gt; </span>
<span class="co">#&gt; ├─[2:0x6c93108] </span>
<span class="co">#&gt; ├─[3:0x6c930d0] </span>
<span class="co">#&gt; └─[6:0x712dda0] &lt;dbl&gt;</span></code></pre>
</div>
<div id="df-modify" class="section level3">
<h3><span class="header-section-number">2.3.4</span> Data frames</h3>
<p>Data frames are lists of vectors, so copy-on-modify has important consequences when you modify a data frame. Take this data frame as an example:</p>
<pre class="sourceCode r"><code class="sourceCode r">d1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">6</span>), <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">3</span>))</code></pre>
<p><img src="diagrams/name-value/dataframe.png" width="165" style="display: block; margin: auto;" /></p>
<p>If you modify a column, only <em>that</em> column needs to be modified; the others will still point to their original references:</p>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span>d1
d2[, <span class="dv">2</span>] &lt;-<span class="st"> </span>d2[, <span class="dv">2</span>] <span class="op">*</span><span class="st"> </span><span class="dv">2</span></code></pre>
<p><img src="diagrams/name-value/d-modify-c.png" width="212" style="display: block; margin: auto;" /></p>
<p>However, if you modify a row, every column is modified, which means every column must be copied:</p>
<pre class="sourceCode r"><code class="sourceCode r">d3 &lt;-<span class="st"> </span>d1
d3[<span class="dv">1</span>, ] &lt;-<span class="st"> </span>d3[<span class="dv">1</span>, ] <span class="op">*</span><span class="st"> </span><span class="dv">3</span></code></pre>
<p><img src="diagrams/name-value/d-modify-r.png" width="326" style="display: block; margin: auto;" /></p>
</div>
<div id="character-vectors" class="section level3">
<h3><span class="header-section-number">2.3.5</span> Character vectors</h3>
<p></p>
<p>The final place that R uses references is with character vectors<span id="fn43" class="footnote" data-pagedown-footnote-number="43" style="white-space: pre-line;">Confusingly, a character vector is a vector of strings, not individual characters.</span>. I usually draw character vectors like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;d&quot;</span>)</code></pre>
<p><img src="diagrams/name-value/character.png" width="241" style="display: block; margin: auto;" /></p>
<p>But this is a polite fiction. R actually uses a <strong>global string pool</strong> where each element of a character vector is a pointer to a unique string in the pool:</p>
<p><img src="diagrams/name-value/character-2.png" width="250" style="display: block; margin: auto;" /></p>
<p>You can request that <code>ref()</code> show these references by setting the <code>character</code> argument to <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ref</span>(x, <span class="dt">character =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; █ [1:0x3e268f8] &lt;chr&gt; </span>
<span class="co">#&gt; ├─[2:0xee8758] &lt;string: &quot;a&quot;&gt; </span>
<span class="co">#&gt; ├─[2:0xee8758] </span>
<span class="co">#&gt; ├─[3:0x2aa2630] &lt;string: &quot;abc&quot;&gt; </span>
<span class="co">#&gt; └─[4:0x139eaf0] &lt;string: &quot;d&quot;&gt;</span></code></pre>
<p>This has a profound impact on the amount of memory a character vector uses but is otherwise generally unimportant, so elsewhere in the book I’ll draw character vectors as if the strings lived inside a vector.</p>
</div>
<div id="exercises-1" class="section level3">
<h3><span class="header-section-number">2.3.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why is <code>tracemem(1:10)</code> not useful?</p></li>
<li><p>Explain why <code>tracemem()</code> shows two copies when you run this code.
Hint: carefully look at the difference between this code and the code
shown earlier in the section.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(1L, 2L, 3L)
<span class="kw">tracemem</span>(x)

x[[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="dv">4</span></code></pre></li>
<li><p>Sketch out the relationship between the following objects:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
b &lt;-<span class="st"> </span><span class="kw">list</span>(a, a)
c &lt;-<span class="st"> </span><span class="kw">list</span>(b, a, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)</code></pre></li>
<li><p>What happens when you run this code?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
x[[<span class="dv">2</span>]] &lt;-<span class="st"> </span>x</code></pre>
<p>Draw a picture.</p></li>
</ol>
</div>
</div>
<div id="object-size" class="section level2">
<h2><span class="header-section-number">2.4</span> Object size</h2>

<p></p>
<p>You can find out how much memory an object takes with <code>lobstr::obj_size()</code><span id="fn44" class="footnote" data-pagedown-footnote-number="44" style="white-space: pre-line;">Beware of the <code>utils::object.size()</code> function. It does not correctly account for shared references and will return sizes that are too large.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">obj_size</span>(letters)
<span class="co">#&gt; 1,712 B</span>
<span class="kw">obj_size</span>(ggplot2<span class="op">::</span>diamonds)
<span class="co">#&gt; 3,456,344 B</span></code></pre>
<p>Since the elements of lists are references to values, the size of a list might be much smaller than you expect:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e6</span>)
<span class="kw">obj_size</span>(x)
<span class="co">#&gt; 8,000,048 B</span>

y &lt;-<span class="st"> </span><span class="kw">list</span>(x, x, x)
<span class="kw">obj_size</span>(y)
<span class="co">#&gt; 8,000,128 B</span></code></pre>
<p><code>y</code> is only 80 bytes<span id="fn45" class="footnote" data-pagedown-footnote-number="45" style="white-space: pre-line;">If you’re running 32-bit R, you’ll see slightly different sizes.</span> bigger than <code>x</code>. That’s the size of an empty list with three elements:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">obj_size</span>(<span class="kw">list</span>(<span class="ot">NULL</span>, <span class="ot">NULL</span>, <span class="ot">NULL</span>))
<span class="co">#&gt; 80 B</span></code></pre>
<p>Similarly, because R uses a global string pool character vectors take up less memory than you might expect: repeating a string 1000 times does not make it take up 1000 times as much memory.</p>
<pre class="sourceCode r"><code class="sourceCode r">banana &lt;-<span class="st"> &quot;bananas bananas bananas&quot;</span>
<span class="kw">obj_size</span>(banana)
<span class="co">#&gt; 136 B</span>
<span class="kw">obj_size</span>(<span class="kw">rep</span>(banana, <span class="dv">100</span>))
<span class="co">#&gt; 928 B</span></code></pre>
<p>References also make it challenging to think about the size of individual objects. <code>obj_size(x) + obj_size(y)</code> will only equal <code>obj_size(x, y)</code> if there are no shared values. Here, the combined size of <code>x</code> and <code>y</code> is the same as the size of <code>y</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">obj_size</span>(x, y)
<span class="co">#&gt; 8,000,128 B</span></code></pre>
<p>Finally, R 3.5.0 and later have a feature that might lead to surprises: ALTREP, short for <strong>alternative representation</strong>. This allows R to represent certain types of vectors very compactly. The place you are most like to see this is with <code>:</code> because instead of storing every single number in the sequence, R just stores the first and last number. This means that every sequence, no matter how large, is the same size:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">obj_size</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; 680 B</span>
<span class="kw">obj_size</span>(<span class="dv">1</span><span class="op">:</span><span class="fl">1e3</span>)
<span class="co">#&gt; 680 B</span>
<span class="kw">obj_size</span>(<span class="dv">1</span><span class="op">:</span><span class="fl">1e6</span>)
<span class="co">#&gt; 680 B</span>
<span class="kw">obj_size</span>(<span class="dv">1</span><span class="op">:</span><span class="fl">1e9</span>)
<span class="co">#&gt; 680 B</span></code></pre>
<div id="exercises-2" class="section level3">
<h3><span class="header-section-number">2.4.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In the following example, why are <code>object.size(y)</code> and <code>obj_size(y)</code>
so radically different? Consult the documentation of <code>object.size()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">runif</span>(<span class="fl">1e4</span>)), <span class="dv">100</span>)

<span class="kw">object.size</span>(y)
<span class="co">#&gt; 8005648 bytes</span>
<span class="kw">obj_size</span>(y)
<span class="co">#&gt; 80,896 B</span></code></pre></li>
<li><p>Take the following list. Why is its size somewhat misleading?</p>
<pre class="sourceCode r"><code class="sourceCode r">funs &lt;-<span class="st"> </span><span class="kw">list</span>(mean, sd, var)
<span class="kw">obj_size</span>(funs)
<span class="co">#&gt; 17,608 B</span></code></pre></li>
<li><p>Predict the output of the following code:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e6</span>)
<span class="kw">obj_size</span>(a)

b &lt;-<span class="st"> </span><span class="kw">list</span>(a, a)
<span class="kw">obj_size</span>(b)
<span class="kw">obj_size</span>(a, b)

b[[<span class="dv">1</span>]][[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">obj_size</span>(b)
<span class="kw">obj_size</span>(a, b)

b[[<span class="dv">2</span>]][[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">obj_size</span>(b)
<span class="kw">obj_size</span>(a, b)</code></pre></li>
</ol>
</div>
</div>
<div id="modify-in-place" class="section level2">
<h2><span class="header-section-number">2.5</span> Modify-in-place</h2>
<p></p>
<p>As we’ve seen above, modifying an R object usually creates a copy. There are two exceptions:</p>
<ul>
<li><p>Objects with a single binding get a special performance optimisation.</p></li>
<li><p>Environments, a special type of object, are always modified in place.</p></li>
</ul>
<div id="single-binding" class="section level3">
<h3><span class="header-section-number">2.5.1</span> Objects with a single binding</h3>
<p></p>
<p>If an object has a single name bound to it, R will modify it in place:</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre>
<p><img src="diagrams/name-value/v-inplace-1.png" width="160" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">v[[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="dv">4</span></code></pre>
<p><img src="diagrams/name-value/v-inplace-2.png" width="160" style="display: block; margin: auto;" /></p>
<p>(Note the object IDs here: <code>v</code> continues to bind to the same object, <code>0x207</code>.)</p>
<p>Two complications make predicting exactly when R applies this optimisation challenging:</p>
<ul>
<li><p>When it comes to bindings, R can currently<span id="fn46" class="footnote" data-pagedown-footnote-number="46" style="white-space: pre-line;">By the time you read this, this may have changed, as plans are afoot to improve reference counting: <a href="https://developer.r-project.org/Refcnt.html" class="uri">https://developer.r-project.org/Refcnt.html</a></span> only count 0, 1,
or many. That means that if an object has two bindings, and one goes away,
the reference count does not go back to 1: one less than many is
still many. In turn, this means that R will make copies when it sometimes
doesn’t need to.</p></li>
<li><p>Whenever you call the vast majority of functions, it makes a reference to the
object. The only exception are specially written “primitive” C functions.
These can only be written by R-core and occur mostly in the base package.</p></li>
</ul>
<p>Together, these two complications make it hard to predict whether or not a copy will occur. Instead, it’s better to determine it empirically with <code>tracemem()</code>.</p>
<p>

Let’s explore the subtleties with a case study using for loops. For loops have a reputation for being slow in R, but often that slowness is caused by every iteration of the loop creating a copy. Consider the following code. It subtracts the median from each column of a large data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">5</span> <span class="op">*</span><span class="st"> </span><span class="fl">1e4</span>), <span class="dt">ncol =</span> <span class="dv">5</span>))
medians &lt;-<span class="st"> </span><span class="kw">vapply</span>(x, median, <span class="kw">numeric</span>(<span class="dv">1</span>))

<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(medians)) {
  x[[i]] &lt;-<span class="st"> </span>x[[i]] <span class="op">-</span><span class="st"> </span>medians[[i]]
}</code></pre>
<p>This loop is surprisingly slow because each iteration of the loop copies the data frame. You can see this by using <code>tracemem()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">tracemem</span>(x), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
<span class="co">#&gt; &lt;0x7f80c429e020&gt; </span>

<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>) {
  x[[i]] &lt;-<span class="st"> </span>x[[i]] <span class="op">-</span><span class="st"> </span>medians[[i]]
}
<span class="co">#&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: </span>
<span class="co">#&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: </span>
<span class="co">#&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: </span>
<span class="co">#&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: </span>
<span class="co">#&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: </span>
<span class="co">#&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- </span>
<span class="co">#&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- </span>

<span class="kw">untracemem</span>(x)</code></pre>
<p>In fact, each iteration copies the data frame not once, not twice, but three times! Two copies are made by <code>[[.data.frame</code>, and a further copy<span id="fn47" class="footnote" data-pagedown-footnote-number="47" style="white-space: pre-line;">These copies are shallow: they only copy the reference to each individual column, not the contents of the columns. This means the performance isn’t terrible, but it’s obviously not as good as it could be.</span> is made because <code>[[.data.frame</code> is a regular function that increments the reference count of <code>x</code>.</p>
<p>We can reduce the number of copies by using a list instead of a data frame. Modifying a list uses internal C code, so the refs are not incremented and only a single copy is made:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">as.list</span>(x)
<span class="kw">cat</span>(<span class="kw">tracemem</span>(y), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
<span class="co">#&gt; &lt;0x7f80c5c3de20&gt;</span>
  
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>) {
  y[[i]] &lt;-<span class="st"> </span>y[[i]] <span class="op">-</span><span class="st"> </span>medians[[i]]
}
<span class="co">#&gt; tracemem[0x7f80c5c3de20 -&gt; 0x7f80c48de210]: </span></code></pre>
<p>While it’s not hard to determine when a copy is made, it is hard to prevent it. If you find yourself resorting to exotic tricks to avoid copies, it may be time to rewrite your function in C++, as described in Chapter <a href="#rcpp">25</a>.</p>
</div>
<div id="env-modify" class="section level3">
<h3><span class="header-section-number">2.5.2</span> Environments</h3>
<p>
</p>
<p>You’ll learn more about environments in Chapter <a href="#environments">7</a>, but it’s important to mention them here because their behaviour is different from that of other objects: environments are always modified in place. This property is sometimes described as <strong>reference semantics</strong> because when you modify an environment all existing bindings to that environment continue to have the same reference.</p>
<p>Take this environment, which we bind to <code>e1</code> and <code>e2</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">e1 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)
e2 &lt;-<span class="st"> </span>e1</code></pre>
<p><img src="diagrams/name-value/e-modify-1.png" width="184" style="display: block; margin: auto;" /></p>
<p>If we change a binding, the environment is modified in place:</p>
<pre class="sourceCode r"><code class="sourceCode r">e1<span class="op">$</span>c &lt;-<span class="st"> </span><span class="dv">4</span>
e2<span class="op">$</span>c
<span class="co">#&gt; [1] 4</span></code></pre>
<p><img src="diagrams/name-value/e-modify-2.png" width="184" style="display: block; margin: auto;" /></p>
<p>This basic idea can be used to create functions that “remember” their previous state. See Section <a href="#stateful-funs">10.2.4</a> for more details. This property is also used to implement the R6 object oriented programming system, the topic of Chapter <a href="#r6">14</a>.</p>
<p>One consequence of this is that environments can contain themselves:</p>
<pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>()
e<span class="op">$</span>self &lt;-<span class="st"> </span>e

<span class="kw">ref</span>(e)
<span class="co">#&gt; █ [1:0x1876338] &lt;env&gt; </span>
<span class="co">#&gt; └─self = [1:0x1876338]</span></code></pre>
<p><img src="diagrams/name-value/e-self.png" width="142" style="display: block; margin: auto;" /></p>
<p>This is a unique property of environments!</p>
</div>
<div id="exercises-3" class="section level3">
<h3><span class="header-section-number">2.5.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Explain why the following code doesn’t create a circular list.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>()
x[[<span class="dv">1</span>]] &lt;-<span class="st"> </span>x</code></pre></li>
<li><p>Wrap the two methods for subtracting medians into two functions, then
use the ‘bench’ package <span class="citation">(Hester <a href="#ref-bench">2018</a>)</span> to carefully compare their speeds. How does
performance change as the number of columns increase?</p></li>
<li><p>What happens if you attempt to use <code>tracemem()</code> on an environment?</p></li>
</ol>
</div>
</div>
<div id="gc" class="section level2">
<h2><span class="header-section-number">2.6</span> Unbinding and the garbage collector</h2>
<p>

</p>
<p>Consider this code:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span></code></pre>
<p><img src="diagrams/name-value/unbinding-1.png" width="160" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">2</span><span class="op">:</span><span class="dv">4</span></code></pre>
<p><img src="diagrams/name-value/unbinding-2.png" width="160" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rm</span>(x)</code></pre>
<p><img src="diagrams/name-value/unbinding-3.png" width="160" style="display: block; margin: auto;" /></p>
<p>We created two objects, but by the time the code finishes, neither object is bound to a name. How do these objects get deleted? That’s the job of the <strong>garbage collector</strong>, or GC for short. The GC frees up memory by deleting R objects that are no longer used, and by requesting more memory from the operating system if needed.</p>
<p>R uses a <strong>tracing</strong> GC. This means it traces every object that’s reachable from the global<span id="fn48" class="footnote" data-pagedown-footnote-number="48" style="white-space: pre-line;">And every environment in the current call stack.</span> environment, and all objects that are, in turn, reachable from those objects (i.e. the references in lists and environments are searched recursively). The garbage collector does not use the modify-in-place reference count described above. While these two ideas are closely related, the internal data structures are optimised for different use cases.</p>
<p>The garbage collector (GC) runs automatically whenever R needs more memory to create a new object. Looking from the outside, it’s basically impossible to predict when the GC will run. In fact, you shouldn’t even try. If you want to find out when the GC runs, call <code>gcinfo(TRUE)</code> and GC will print a message to the console every time it runs.</p>
<p>
You can force garbage collection by calling <code>gc()</code>. But despite what you might have read elsewhere, there’s never any <em>need</em> to call <code>gc()</code> yourself. The only reasons you might <em>want</em> to call <code>gc()</code> is to ask R to return memory to your operating system so other programs can use it, or for the side-effect that tells you how much memory is currently being used:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">gc</span>() 
<span class="co">#&gt;           used (Mb) gc trigger (Mb) max used (Mb)</span>
<span class="co">#&gt; Ncells  682246 36.5    1286114 68.7  1286114 68.7</span>
<span class="co">#&gt; Vcells 4696152 35.9   11787927 90.0 11786952 90.0</span></code></pre>
<p><code>lobstr::mem_used()</code> is a wrapper around <code>gc()</code> that prints the total number of bytes used:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mem_used</span>()
<span class="co">#&gt; 75,780,760 B</span></code></pre>
<p>This number won’t agree with the amount of memory reported by your operating system. There are three reasons:</p>
<ol style="list-style-type: decimal">
<li><p>It includes objects created by R but not by the R interpreter.</p></li>
<li><p>Both R and the operating system are lazy: they won’t reclaim memory
until it’s actually needed. R might be holding on to memory because
the OS hasn’t yet asked for it back.</p></li>
<li><p>R counts the memory occupied by objects but there may be empty gaps due to
deleted objects. This problem is known as memory fragmentation.</p></li>
</ol>
</div>
<div id="names-values-answers" class="section level2">
<h2><span class="header-section-number">2.7</span> Answers</h2>
<ol style="list-style-type: decimal">
<li><p>You must quote non-syntactic names with backticks: <code>`</code>: for example,
the variables <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">runif</span>(<span class="dv">3</span>), <span class="kw">runif</span>(<span class="dv">3</span>))
<span class="kw">names</span>(df) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)

df<span class="op">$</span><span class="st">`</span><span class="dt">3</span><span class="st">`</span> &lt;-<span class="st"> </span>df<span class="op">$</span><span class="st">`</span><span class="dt">1</span><span class="st">`</span> <span class="op">+</span><span class="st"> </span>df<span class="op">$</span><span class="st">`</span><span class="dt">2</span><span class="st">`</span></code></pre></li>
<li><p>It occupies about 8 MB.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e6</span>)
y &lt;-<span class="st"> </span><span class="kw">list</span>(x, x, x)
<span class="kw">obj_size</span>(y)
<span class="co">#&gt; 8,000,128 B</span></code></pre></li>
<li><p><code>a</code> is copied when <code>b</code> is modified, <code>b[[1]] &lt;- 10</code>.</p></li>
</ol>
<!--chapter:end:Names-values.Rmd-->
</div>
</div>
<div id="vectors-chap" class="section level1">
<h1><span class="header-section-number">3</span> Vectors</h1>
<div id="introduction-2" class="section level2">
<h2><span class="header-section-number">3.1</span> Introduction</h2>
<p>
</p>
<p>This chapter discusses the most important family of data types in base R: vectors<span id="fn49" class="footnote" data-pagedown-footnote-number="49" style="white-space: pre-line;">Collectively, all the other data types are known as “node” types, which include things like functions and environments. You’re most likely to come across this highly technical term when using <code>gc()</code>: the “N” in <code>Ncells</code> stands for nodes and the “V” in <code>Vcells</code> stands for vectors.</span>. While you’ve probably already used many (if not all) of the different types of vectors, you may not have thought deeply about how they’re interrelated. In this chapter, I won’t cover individual vectors types in too much detail, but I will show you how all the types fit together as a whole. If you need more details, you can find them in R’s documentation.</p>
<p>Vectors come in two flavours: atomic vectors and lists<span id="fn50" class="footnote" data-pagedown-footnote-number="50" style="white-space: pre-line;">A few places in R’s documentation call lists generic vectors to emphasise their difference from atomic vectors.</span>. They differ in terms of their elements’ types: for atomic vectors, all elements must have the same type; for lists, elements can have different types. While not a vector, <code>NULL</code> is closely related to vectors and often serves the role of a generic zero length vector. This diagram, which we’ll be expanding on throughout this chapter, illustrates the basic relationships:</p>
<p><img src="diagrams/vectors/summary-tree.png" width="198" style="display: block; margin: auto;" /></p>
<p>Every vector can also have <strong>attributes</strong>, which you can think of as a named list of arbitrary metadata. Two attributes are particularly important. The <strong>dim</strong>ension attribute turns vectors into matrices and arrays and the <strong>class</strong> attribute powers the S3 object system. While you’ll learn how to use S3 in Chapter <a href="#s3">13</a>), here you’ll learn about some of the most important S3 vectors: factors, date/times, data frames, and tibbles. And while 2D structures like matrices and data frames are not necessarily what come to mind when you think of vectors, you’ll also learn why R considers them to be vectors.</p>
<div id="quiz-1" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>Take this short quiz to determine if you need to read this chapter. If the answers quickly come to mind, you can comfortably skip this chapter. You can check your answers in Section <a href="#data-structure-answers">3.8</a>.</p>
<ol style="list-style-type: decimal">
<li><p>What are the four common types of atomic vectors? What are the two
rare types?</p></li>
<li><p>What are attributes? How do you get them and set them?</p></li>
<li><p>How is a list different from an atomic vector? How is a matrix different
from a data frame?</p></li>
<li><p>Can you have a list that is a matrix? Can a data frame have a column
that is a matrix?</p></li>
<li><p>How do tibbles behave differently from data frames?</p></li>
</ol>
</div>
<div id="outline-1" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#atomic-vectors">3.2</a> introduces you to the atomic vectors:
logical, integer, double, and character. These are R’s simplest data
structures.</p></li>
<li><p>Section <a href="#attributes">3.3</a> takes a small detour to discuss attributes,
R’s flexible metadata specification. The most important attributes are
names, dimensions, and class.</p></li>
<li><p>Section <a href="#s3-atomic-vectors">3.4</a> discusses the important vector types that
are built by combining atomic vectors with special attributes. These include
factors, dates, date-times, and durations.</p></li>
<li><p>Section <a href="#lists">3.5</a> dives into lists. Lists are very similar to atomic
vectors, but have one key difference: an element of a list can be any
data type, including another list. This makes them suitable for representing
hierarchical data.</p></li>
<li><p>Section <a href="#tibble">3.6</a> teaches you about data frames and tibbles, which
are used to represent rectangular data. They combine the behaviour
of lists and matrices to make a structure ideally suited for the needs
of statistical data.</p></li>
</ul>
</div>
</div>
<div id="atomic-vectors" class="section level2">
<h2><span class="header-section-number">3.2</span> Atomic vectors</h2>
<p>





</p>
<p>There are four primary types of atomic vectors: logical, integer, double, and character (which contains strings). Collectively integer and double vectors are known as numeric vectors<span id="fn51" class="footnote" data-pagedown-footnote-number="51" style="white-space: pre-line;">This is a slight simplification as R does not use “numeric” consistently, which we’ll come back to in Section <a href="#numeric-type">12.3.1</a>.</span>. There are two rare types: complex and raw. I won’t discuss them further because complex numbers are rarely needed in statistics, and raw vectors are a special type that’s only needed when handling binary data.</p>
<p><img src="diagrams/vectors/summary-tree-atomic.png" width="288" style="display: block; margin: auto;" /></p>
<div id="scalars" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Scalars</h3>
<p>






</p>
<p>Each of the four primary types has a special syntax to create an individual value, AKA a <strong>scalar</strong><span id="fn52" class="footnote" data-pagedown-footnote-number="52" style="white-space: pre-line;">Technically, the R language does not possess scalars. Everything that looks like a scalar is actually a vector of length one. This is mostly a theoretical distinction, but it does mean that expressions like <code>1[1]</code> work.</span>, and its own missing value.</p>
<ul>
<li><p>Strings are surrounded by <code>&quot;</code> (<code>&quot;hi&quot;</code>) or <code>'</code> (<code>'bye'</code>). Special characters
are escaped with <code>\</code>; see <code>?Quotes</code> for full details. The missing value
for strings is <code>NA_character_</code>.</p></li>
<li><p>Doubles can be specified in decimal (<code>0.1234</code>), scientific (<code>1.23e4</code>), or
hexadecimal (<code>0xcafe</code>) form. There are three special values unique to
doubles: <code>Inf</code>, <code>-Inf</code>, and <code>NaN</code> (not a number). These are special values
defined by the floating point standard. The missing value for doubles is
<code>NA_real_</code>.</p></li>
<li><p>Integers are written similarly to doubles but must be followed by <code>L</code><span id="fn53" class="footnote" data-pagedown-footnote-number="53" style="white-space: pre-line;"><code>L</code> is not intuitive, and you might wonder where it comes from. At the time <code>L</code> was added to R, R’s integer type was equivalent to a long integer in C, and C code could use a suffix of <code>l</code> or <code>L</code> to force a number to be a long integer. It was decided that <code>l</code> was too visually similar to <code>i</code> (used for complex numbers in R), leaving <code>L</code>.</span>
(<code>1234L</code>, <code>1e4L</code>, or <code>0xcafeL</code>), and can not include decimals. The integer
missing value is <code>NA_integer_</code>.</p></li>
<li><p>Logicals can be spelt out (<code>TRUE</code> or <code>FALSE</code>), or abbreviated (<code>T</code> or <code>F</code>).
The missing value for logicals is <code>NA</code>.</p></li>
</ul>
</div>
<div id="atomic-constructing" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Making longer vectors with <code>c()</code></h3>

<p>To create longer vectors from shorter ones, use <code>c()</code>, short for combine:</p>
<pre class="sourceCode r"><code class="sourceCode r">dbl_var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">2.5</span>, <span class="fl">4.5</span>)
int_var &lt;-<span class="st"> </span><span class="kw">c</span>(1L, 6L, 10L)
lgl_var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)
chr_var &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;these are&quot;</span>, <span class="st">&quot;some strings&quot;</span>)</code></pre>
<p>When the inputs are atomic vectors, <code>c()</code> always creates another atomic vector; i.e. it flattens:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))
<span class="co">#&gt; [1] 1 2 3 4</span></code></pre>
<p>In diagrams, I’ll depict vectors as connected rectangles, so the above code could be drawn as follows:</p>
<p><img src="diagrams/vectors/atomic.png" width="350" style="display: block; margin: auto;" /></p>
<p>You can determine the type of a vector with <code>typeof()</code><span id="fn54" class="footnote" data-pagedown-footnote-number="54" style="white-space: pre-line;">You may have heard of the related <code>mode()</code> and <code>storage.mode()</code> functions. Do not use them: they exist only for compatibility with S.</span> and its length with <code>length()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(dbl_var)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">typeof</span>(int_var)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">typeof</span>(lgl_var)
<span class="co">#&gt; [1] &quot;logical&quot;</span>
<span class="kw">typeof</span>(chr_var)
<span class="co">#&gt; [1] &quot;character&quot;</span></code></pre>
</div>
<div id="testing-and-coercion" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Testing and coercion</h3>
<p>


</p>
<p>Generally, you can <strong>test</strong> if a vector is of a given type with an <code>is.*()</code> function, but they need to be used with care. <code>is.character()</code>, <code>is.double()</code>, <code>is.integer()</code>, and <code>is.logical()</code> do what you might expect: they test if a vector is a character, double, integer, or logical. Avoid <code>is.vector()</code>, <code>is.atomic()</code>, and <code>is.numeric()</code>: they don’t test if you have a vector, atomic vector, or numeric vector; you’ll need to carefully read the docs to figure out what they actually do.</p>
<p>For atomic vectors, type is a property of the entire vector: all elements must be the same type. When you attempt to combine different types they will be <strong>coerced</strong> in a fixed order: character → double → integer → logical. For example, combining a character and an integer yields a character:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>))
<span class="co">#&gt;  chr [1:2] &quot;a&quot; &quot;1&quot;</span></code></pre>
<p>Coercion often happens automatically. Most mathematical functions (<code>+</code>, <code>log</code>, <code>abs</code>, etc.) will coerce to numeric. This coercion is particularly useful for logical vectors because <code>TRUE</code> becomes 1 and <code>FALSE</code> becomes 0.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>)
<span class="kw">as.numeric</span>(x)
<span class="co">#&gt; [1] 0 0 1</span>

<span class="co"># Total number of TRUEs</span>
<span class="kw">sum</span>(x)
<span class="co">#&gt; [1] 1</span>

<span class="co"># Proportion that are TRUE</span>
<span class="kw">mean</span>(x)
<span class="co">#&gt; [1] 0.333</span></code></pre>
<p>Generally, you can deliberately coerce by using an <code>as.*()</code> function, like <code>as.character()</code>, <code>as.double()</code>, <code>as.integer()</code>, or <code>as.logical()</code>. Failed coercion of strings generates a warning and a missing value:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.integer</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;1.5&quot;</span>, <span class="st">&quot;a&quot;</span>))
<span class="co">#&gt; Warning: NAs introduced by coercion</span>
<span class="co">#&gt; [1]  1  1 NA</span></code></pre>
</div>
<div id="exercises-4" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How do you create raw and complex scalars? (See <code>?raw</code> and
<code>?complex</code>)</p></li>
<li><p>Test your knowledge of the vector coercion rules by predicting the output of
the following uses of <code>c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">FALSE</span>)
<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>)
<span class="kw">c</span>(<span class="ot">TRUE</span>, 1L)</code></pre></li>
<li><p>Why is <code>1 == &quot;1&quot;</code> true? Why is <code>-1 &lt; FALSE</code> true? Why is <code>&quot;one&quot; &lt; 2</code> false?</p></li>
<li><p>Why is the default missing value, <code>NA</code>, a logical vector? What’s special
about logical vectors? (Hint: think about <code>c(FALSE, NA_character_)</code>.)</p></li>
<li><p>Precisely what do <code>is.atomic()</code>, <code>is.numeric()</code>, and <code>is.vector()</code> test for?</p></li>
</ol>
</div>
</div>
<div id="attributes" class="section level2">
<h2><span class="header-section-number">3.3</span> Attributes</h2>
<p></p>
<p>You might have noticed that the set of atomic vectors does not include a number of important data structures like matrices and arrays, factors and date/times. These types are built on top of atomic vectors by adding attributes. In this section, you’ll learn the basics of attributes, and how the dim attribute makes matrices and arrays. In the next section you’ll learn how the class attribute is used to create S3 vectors, including factors, dates, and date-times.</p>
<div id="getting-and-setting" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Getting and setting</h3>

<p>
</p>
<p>You can think of attributes as name-value pairs<span id="fn55" class="footnote" data-pagedown-footnote-number="55" style="white-space: pre-line;">Attributes behave like named lists, but are actually pairlists. Pairlists are functionally indistinguishable from lists, but are profoundly different under the hood. You’ll learn more about them in Section <a href="#pairlists">18.6.1</a>.</span> that attach metadata to an object. Individual attributes can be retrieved and modified with <code>attr()</code>, or retrieved en masse with <code>attributes()</code>, and set en masse with <code>structure()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span>
<span class="kw">attr</span>(a, <span class="st">&quot;x&quot;</span>) &lt;-<span class="st"> &quot;abcdef&quot;</span>
<span class="kw">attr</span>(a, <span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; [1] &quot;abcdef&quot;</span>

<span class="kw">attr</span>(a, <span class="st">&quot;y&quot;</span>) &lt;-<span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="dv">6</span>
<span class="kw">str</span>(<span class="kw">attributes</span>(a))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ x: chr &quot;abcdef&quot;</span>
<span class="co">#&gt;  $ y: int [1:3] 4 5 6</span>

<span class="co"># Or equivalently</span>
a &lt;-<span class="st"> </span><span class="kw">structure</span>(
  <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="dt">x =</span> <span class="st">&quot;abcdef&quot;</span>,
  <span class="dt">y =</span> <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>
)
<span class="kw">str</span>(<span class="kw">attributes</span>(a))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ x: chr &quot;abcdef&quot;</span>
<span class="co">#&gt;  $ y: int [1:3] 4 5 6</span></code></pre>
<p><img src="diagrams/vectors/attr.png" width="194" style="display: block; margin: auto;" /></p>
<p>Attributes should generally be thought of as ephemeral. For example, most attributes are lost by most operations:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attributes</span>(a[<span class="dv">1</span>])
<span class="co">#&gt; NULL</span>
<span class="kw">attributes</span>(<span class="kw">sum</span>(a))
<span class="co">#&gt; NULL</span></code></pre>
<p>There are only two attributes that are routinely preserved:</p>
<ul>
<li><strong>names</strong>, a character vector giving each element a name.</li>
<li><strong>dim</strong>, short for dimensions, an integer vector, used to turn vectors
into matrices or arrays.</li>
</ul>
<p>To preserve other attributes, you’ll need to create your own S3 class, the topic of Chapter <a href="#s3">13</a>.</p>
</div>
<div id="attr-names" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Names</h3>
<p>

</p>
<p>You can name a vector in three ways:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># When creating it: </span>
x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)

<span class="co"># By assigning a character vector to names()</span>
x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span>
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)

<span class="co"># Inline, with setNames():</span>
x &lt;-<span class="st"> </span><span class="kw">setNames</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))</code></pre>
<p>Avoid using <code>attr(x, &quot;names&quot;)</code> as it requires more typing and is less readable than <code>names(x)</code>. You can remove names from a vector by using <code>unname(x)</code> or <code>names(x) &lt;- NULL</code>.</p>
<p>To be technically correct, when drawing the named vector <code>x</code>, I should draw it like so:</p>
<p><img src="diagrams/vectors/attr-names-1.png" width="246" style="display: block; margin: auto;" /></p>
<p>However, names are so special and so important, that unless I’m trying specifically to draw attention to the attributes data structure, I’ll use them to label the vector directly:</p>
<p><img src="diagrams/vectors/attr-names-2.png" width="104" style="display: block; margin: auto;" /></p>
<p>To be useful with character subsetting (e.g. Section <a href="#lookup-tables">4.5.1</a>) names should be unique, and non-missing, but this is not enforced by R. Depending on how the names are set, missing names may be either <code>&quot;&quot;</code> or <code>NA_character_</code>. If all names are missing, <code>names()</code> will return <code>NULL</code>.</p>
</div>
<div id="attr-dims" class="section level3">
<h3><span class="header-section-number">3.3.3</span> Dimensions</h3>
<p>

</p>
<p>Adding a <code>dim</code> attribute to a vector allows it to behave like a 2-dimensional <strong>matrix</strong> or a multi-dimensional <strong>array</strong>. Matrices and arrays are primarily mathematical/statistical tools, not programming tools, so they’ll be used infrequently and only covered briefly in this book. Their most important feature is multidimensional subsetting, which is covered in Section <a href="#matrix-subsetting">4.2.3</a>.</p>
<p>You can create matrices and arrays with <code>matrix()</code> and <code>array()</code>, or by using the assignment form of <code>dim()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Two scalar arguments specify row and column sizes</span>
a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">3</span>)
a
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    1    3    5</span>
<span class="co">#&gt; [2,]    2    4    6</span>

<span class="co"># One vector argument to describe all dimensions</span>
b &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">12</span>, <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>))
b
<span class="co">#&gt; , , 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    1    3    5</span>
<span class="co">#&gt; [2,]    2    4    6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; , , 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]    7    9   11</span>
<span class="co">#&gt; [2,]    8   10   12</span>

<span class="co"># You can also modify an object in place by setting dim()</span>
c &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">6</span>
<span class="kw">dim</span>(c) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)
c
<span class="co">#&gt;      [,1] [,2]</span>
<span class="co">#&gt; [1,]    1    4</span>
<span class="co">#&gt; [2,]    2    5</span>
<span class="co">#&gt; [3,]    3    6</span></code></pre>
<p>Many of the functions for working with vectors have generalisations for matrices and arrays:</p>
<table>
<thead>
<tr class="header">
<th>Vector</th>
<th>Matrix</th>
<th>Array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>names()</code></td>
<td><code>rownames()</code>, <code>colnames()</code></td>
<td><code>dimnames()</code></td>
</tr>
<tr class="even">
<td><code>length()</code></td>
<td><code>nrow()</code>, <code>ncol()</code></td>
<td><code>dim()</code></td>
</tr>
<tr class="odd">
<td><code>c()</code></td>
<td><code>rbind()</code>, <code>cbind()</code></td>
<td><code>abind::abind()</code></td>
</tr>
<tr class="even">
<td>—</td>
<td><code>t()</code></td>
<td><code>aperm()</code></td>
</tr>
<tr class="odd">
<td><code>is.null(dim(x))</code></td>
<td><code>is.matrix()</code></td>
<td><code>is.array()</code></td>
</tr>
</tbody>
</table>
<p>A vector without a <code>dim</code> attribute set is often thought of as 1-dimensional, but actually has <code>NULL</code> dimensions. You also can have matrices with a single row or single column, or arrays with a single dimension. They may print similarly, but will behave differently. The differences aren’t too important, but it’s useful to know they exist in case you get strange output from a function (<code>tapply()</code> is a frequent offender). As always, use <code>str()</code> to reveal the differences.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)                   <span class="co"># 1d vector</span>
<span class="co">#&gt;  int [1:3] 1 2 3</span>
<span class="kw">str</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">1</span>)) <span class="co"># column vector</span>
<span class="co">#&gt;  int [1:3, 1] 1 2 3</span>
<span class="kw">str</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">nrow =</span> <span class="dv">1</span>)) <span class="co"># row vector</span>
<span class="co">#&gt;  int [1, 1:3] 1 2 3</span>
<span class="kw">str</span>(<span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">3</span>))         <span class="co"># &quot;array&quot; vector</span>
<span class="co">#&gt;  int [1:3(1d)] 1 2 3</span></code></pre>
</div>
<div id="exercises-5" class="section level3">
<h3><span class="header-section-number">3.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How is <code>setNames()</code> implemented? How is <code>unname()</code> implemented?
Read the source code.</p></li>
<li><p>What does <code>dim()</code> return when applied to a 1D vector?
When might you use <code>NROW()</code> or <code>NCOL()</code>?</p></li>
<li><p>How would you describe the following three objects? What makes them
different from <code>1:5</code>?</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">5</span>))
x2 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>))
x3 &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">1</span>))</code></pre></li>
<li><p>An early draft used this code to illustrate <code>structure()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">structure</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">comment =</span> <span class="st">&quot;my attribute&quot;</span>)
<span class="co">#&gt; [1] 1 2 3 4 5</span></code></pre>
<p>But when you print that object you don’t see the comment attribute.
Why? Is the attribute missing, or is there something else special about
it? (Hint: try using help.)</p></li>
</ol>
</div>
</div>
<div id="s3-atomic-vectors" class="section level2">
<h2><span class="header-section-number">3.4</span> S3 atomic vectors</h2>
<p>
</p>
<p>One of the most important vector attributes is <code>class</code>, which underlies the S3 object system. Having a class attribute turns an object into an <strong>S3 object</strong>, which means it will behave differently from a regular vector when passed to a <strong>generic</strong> function. Every S3 object is built on top of a base type, and often stores additional information in other attributes. You’ll learn the details of the S3 object system, and how to create your own S3 classes, in Chapter <a href="#s3">13</a>.</p>
<p>In this section, we’ll discuss four important S3 vectors used in base R:</p>
<ul>
<li><p>Categorical data, where values come from a fixed set of levels recorded in
<strong>factor</strong> vectors.</p></li>
<li><p>Dates (with day resolution), which are recorded in <strong>Date</strong> vectors.</p></li>
<li><p>Date-times (with second or sub-second resolution), which are stored in
<strong>POSIXct</strong> vectors.</p></li>
<li><p>Durations, which are stored in <strong>difftime</strong> vectors.</p></li>
</ul>
<p><img src="diagrams/vectors/summary-tree-s3-1.png" width="298" style="display: block; margin: auto;" /></p>
<div id="factors" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Factors</h3>

<p>A factor is a vector that can contain only predefined values. It is used to store categorical data. Factors are built on top of an integer vector with two attributes: a <code>class</code>, “factor”, which makes it behave differently from regular integer vectors, and <code>levels</code>, which defines the set of allowed values.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>))
x
<span class="co">#&gt; [1] a b b a</span>
<span class="co">#&gt; Levels: a b</span>

<span class="kw">typeof</span>(x)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">attributes</span>(x)
<span class="co">#&gt; $levels</span>
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;factor&quot;</span></code></pre>
<p><img src="diagrams/vectors/factor.png" width="246" style="display: block; margin: auto;" /></p>
<p>Factors are useful when you know the set of possible values but they’re not all present in a given dataset. In contrast to a character vector, when you tabulate a factor you’ll get counts of all categories, even unobserved ones:</p>
<pre class="sourceCode r"><code class="sourceCode r">sex_char &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>)
sex_factor &lt;-<span class="st"> </span><span class="kw">factor</span>(sex_char, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;f&quot;</span>))

<span class="kw">table</span>(sex_char)
<span class="co">#&gt; sex_char</span>
<span class="co">#&gt; m </span>
<span class="co">#&gt; 3</span>
<span class="kw">table</span>(sex_factor)
<span class="co">#&gt; sex_factor</span>
<span class="co">#&gt; m f </span>
<span class="co">#&gt; 3 0</span></code></pre>
<p>A minor variation on factors are <strong>ordered</strong> factors. In general, they behave like regular factors, but the order of the levels is meaningful (“low”, “medium”, “high”) (a property that is automatically leveraged by some modelling and visualisation functions).</p>
<pre class="sourceCode r"><code class="sourceCode r">grade &lt;-<span class="st"> </span><span class="kw">ordered</span>(<span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>))
grade
<span class="co">#&gt; [1] b b a c</span>
<span class="co">#&gt; Levels: c &lt; b &lt; a</span></code></pre>
<p>In base R<span id="fn56" class="footnote" data-pagedown-footnote-number="56" style="white-space: pre-line;">The tidyverse never automatically coerces characters to factors, and provides the forcats <span class="citation">(Wickham <a href="#ref-forcats">2018</a>)</span> package specifically for working with factors.</span> you tend to encounter factors very frequently because many base R functions (like <code>read.csv()</code> and <code>data.frame()</code>) automatically convert character vectors to factors. This is suboptimal because there’s no way for those functions to know the set of all possible levels or their correct order: the levels are a property of theory or experimental design, not of the data. Instead, use the argument <code>stringsAsFactors = FALSE</code> to suppress this behaviour, and then manually convert character vectors to factors using your knowledge of the “theoretical” data. To learn about the historical context of this behaviour, I recommend <em>stringsAsFactors: An unauthorized
biography</em><span id="fn57" class="footnote" data-pagedown-footnote-number="57" style="white-space: pre-line;"><a href="http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/" class="uri">http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/</a></span> by Roger Peng, and <em>stringsAsFactors =
&lt;sigh&gt;</em><span id="fn58" class="footnote" data-pagedown-footnote-number="58" style="white-space: pre-line;"><a href="http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh" class="uri">http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh</a></span> by Thomas Lumley.</p>
<p>While factors look like (and often behave like) character vectors, they are built on top of integers. So be careful when treating them like strings. Some string methods (like <code>gsub()</code> and <code>grepl()</code>) will automatically coerce factors to strings, others (like <code>nchar()</code>) will throw an error, and still others will (like <code>c()</code>) use the underlying integer values. For this reason, it’s usually best to explicitly convert factors to character vectors if you need string-like behaviour.</p>
</div>
<div id="dates" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Dates</h3>

<p>Date vectors are built on top of double vectors. They have class “Date” and no other attributes:</p>
<pre class="sourceCode r"><code class="sourceCode r">today &lt;-<span class="st"> </span><span class="kw">Sys.Date</span>()

<span class="kw">typeof</span>(today)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">attributes</span>(today)
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;Date&quot;</span></code></pre>
<p>The value of the double (which can be seen by stripping the class), represents the number of days since 1970-01-01<span id="fn59" class="footnote" data-pagedown-footnote-number="59" style="white-space: pre-line;">This is special date is known as the Unix Epoch.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r">date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;1970-02-01&quot;</span>)
<span class="kw">unclass</span>(date)
<span class="co">#&gt; [1] 31</span></code></pre>
</div>
<div id="date-times" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Date-times</h3>
<p>
</p>
<p>Base R<span id="fn60" class="footnote" data-pagedown-footnote-number="60" style="white-space: pre-line;">The tidyverse provides the lubridate <span class="citation">(Grolemund and Wickham <a href="#ref-lubridate">2011</a>)</span> package for working with date-times. It provides a number of convenient helpers that work with the base POSIXct type.</span> provides two ways of storing date-time information, POSIXct, and POSIXlt. These are admittedly odd names: “POSIX” is short for Portable Operating System Interface, which is a family of cross-platform standards. “ct” standards for calendar time (the <code>time_t</code> type in C), and “lt” for local time (the <code>struct tm</code> type in C). Here we’ll focus on <code>POSIXct</code>, because it’s the simplest, is built on top of an atomic vector, and is most appropriate for use in data frames. POSIXct vectors are built on top of double vectors, where the value represents the number of seconds since 1970-01-01.</p>
<pre class="sourceCode r"><code class="sourceCode r">now_ct &lt;-<span class="st"> </span><span class="kw">as.POSIXct</span>(<span class="st">&quot;2018-08-01 22:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>)
now_ct
<span class="co">#&gt; [1] &quot;2018-08-01 22:00:00 UTC&quot;</span>

<span class="kw">typeof</span>(now_ct)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">attributes</span>(now_ct)
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $tzone</span>
<span class="co">#&gt; [1] &quot;UTC&quot;</span></code></pre>
<p>The <code>tzone</code> attribute controls only how the date-time is formatted; it does not control the instant of time represented by the vector. Note that the time is not printed if it is midnight.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;Asia/Tokyo&quot;</span>)
<span class="co">#&gt; [1] &quot;2018-08-02 07:00:00 JST&quot;</span>
<span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;America/New_York&quot;</span>)
<span class="co">#&gt; [1] &quot;2018-08-01 18:00:00 EDT&quot;</span>
<span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;Australia/Lord_Howe&quot;</span>)
<span class="co">#&gt; [1] &quot;2018-08-02 08:30:00 +1030&quot;</span>
<span class="kw">structure</span>(now_ct, <span class="dt">tzone =</span> <span class="st">&quot;Europe/Paris&quot;</span>)
<span class="co">#&gt; [1] &quot;2018-08-02 CEST&quot;</span></code></pre>
</div>
<div id="durations" class="section level3">
<h3><span class="header-section-number">3.4.4</span> Durations</h3>
<p>
</p>
<p>Durations, the amount of time between two dates or date times, are stored in difftimes. Difftimes are built on top of doubles, and have a units attribute that determines how the integer should be interpreted:</p>
<pre class="sourceCode r"><code class="sourceCode r">one_week_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">as.difftime</span>(<span class="dv">1</span>, <span class="dt">units =</span> <span class="st">&quot;weeks&quot;</span>)
one_week_<span class="dv">1</span>
<span class="co">#&gt; Time difference of 1 weeks</span>

<span class="kw">typeof</span>(one_week_<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">attributes</span>(one_week_<span class="dv">1</span>)
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;difftime&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $units</span>
<span class="co">#&gt; [1] &quot;weeks&quot;</span>

one_week_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">as.difftime</span>(<span class="dv">7</span>, <span class="dt">units =</span> <span class="st">&quot;days&quot;</span>)
one_week_<span class="dv">2</span>
<span class="co">#&gt; Time difference of 7 days</span>

<span class="kw">typeof</span>(one_week_<span class="dv">2</span>)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">attributes</span>(one_week_<span class="dv">2</span>)
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;difftime&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $units</span>
<span class="co">#&gt; [1] &quot;days&quot;</span></code></pre>
</div>
<div id="exercises-6" class="section level3">
<h3><span class="header-section-number">3.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What sort of object does <code>table()</code> return? What is its type? What
attributes does it have? How does the dimensionality change as you
tabulate more variables?</p></li>
<li><p>What happens to a factor when you modify its levels?</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="kw">factor</span>(letters)
<span class="kw">levels</span>(f1) &lt;-<span class="st"> </span><span class="kw">rev</span>(<span class="kw">levels</span>(f1))</code></pre></li>
<li><p>What does this code do? How do <code>f2</code> and <code>f3</code> differ from <code>f1</code>?</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="kw">rev</span>(<span class="kw">factor</span>(letters))

f3 &lt;-<span class="st"> </span><span class="kw">factor</span>(letters, <span class="dt">levels =</span> <span class="kw">rev</span>(letters))</code></pre></li>
</ol>
</div>
</div>
<div id="lists" class="section level2">
<h2><span class="header-section-number">3.5</span> Lists</h2>
<p>

</p>
<p>Lists are a step up in complexity from atomic vectors: each element can be any type, not just vectors. Technically speaking, each element of a list is actually the same type because, as you saw in Section <a href="#list-references">2.3.3</a>, each element is really a <em>reference</em> to another object, which can be any type.</p>
<div id="list-creating" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Creating</h3>

<p>You construct lists with <code>list()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">l1 &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="st">&quot;a&quot;</span>, 
  <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), 
  <span class="kw">c</span>(<span class="fl">2.3</span>, <span class="fl">5.9</span>)
)

<span class="kw">typeof</span>(l1)
<span class="co">#&gt; [1] &quot;list&quot;</span>

<span class="kw">str</span>(l1)
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ : int [1:3] 1 2 3</span>
<span class="co">#&gt;  $ : chr &quot;a&quot;</span>
<span class="co">#&gt;  $ : logi [1:3] TRUE FALSE TRUE</span>
<span class="co">#&gt;  $ : num [1:2] 2.3 5.9</span></code></pre>
<p>Because the elements of a list are references, creating a list does not involve copying the components into the list. For this reason, the total size of a list might be smaller than you might expect.</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">obj_size</span>(mtcars)
<span class="co">#&gt; 7,208 B</span>

l2 &lt;-<span class="st"> </span><span class="kw">list</span>(mtcars, mtcars, mtcars, mtcars)
lobstr<span class="op">::</span><span class="kw">obj_size</span>(l2)
<span class="co">#&gt; 7,288 B</span></code></pre>
<p>Lists can contain complex objects so it’s not possible to pick a single visual style that works for every list. Generally I’ll draw lists like vectors, using colour to remind you of the hierarchy.</p>
<p><img src="diagrams/vectors/list.png" width="449" style="display: block; margin: auto;" /></p>
<p>Lists are sometimes called <strong>recursive</strong> vectors because a list can contain other lists. This makes them fundamentally different from atomic vectors.</p>
<pre class="sourceCode r"><code class="sourceCode r">l3 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>)))
<span class="kw">str</span>(l3)
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ :List of 1</span>
<span class="co">#&gt;   ..$ :List of 1</span>
<span class="co">#&gt;   .. ..$ : num 1</span></code></pre>
<p><img src="diagrams/vectors/list-recursive.png" width="104" style="display: block; margin: auto;" /></p>
<p><code>c()</code> will combine several lists into one. If given a combination of atomic vectors and lists, <code>c()</code> will coerce the vectors to lists before combining them. Compare the results of <code>list()</code> and <code>c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">l4 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))
l5 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))
<span class="kw">str</span>(l4)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ : num 1</span>
<span class="co">#&gt;   ..$ : num 2</span>
<span class="co">#&gt;  $ : num [1:2] 3 4</span>
<span class="kw">str</span>(l5)
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ : num 1</span>
<span class="co">#&gt;  $ : num 2</span>
<span class="co">#&gt;  $ : num 3</span>
<span class="co">#&gt;  $ : num 4</span></code></pre>
<p><img src="diagrams/vectors/list-c.png" width="241" style="display: block; margin: auto;" /></p>
</div>
<div id="list-types" class="section level3">
<h3><span class="header-section-number">3.5.2</span> Testing and coercion</h3>
<p>The <code>typeof()</code> a list is <code>list</code>. You can test for a list with <code>is.list()</code>, and coerce to a list with <code>as.list()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1 2 3</span>
<span class="kw">as.list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 3</span></code></pre>
<p>You can turn a list into an atomic vector with <code>unlist()</code>. The rules for the resulting type are complex, not well documented, and not always equivalent to what you’d get with <code>c()</code>.</p>
</div>
<div id="list-array" class="section level3">
<h3><span class="header-section-number">3.5.3</span> Matrices and arrays</h3>
<p>
</p>
<p>With atomic vectors, the dimension attribute is commonly used to create matrices. With lists, the dimension attribute can be used to create list-matrices or list-arrays:</p>
<pre class="sourceCode r"><code class="sourceCode r">l &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;a&quot;</span>, <span class="ot">TRUE</span>, <span class="fl">1.0</span>)
<span class="kw">dim</span>(l) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>)
l
<span class="co">#&gt;      [,1]      [,2]</span>
<span class="co">#&gt; [1,] Integer,3 TRUE</span>
<span class="co">#&gt; [2,] &quot;a&quot;       1</span>

l[[<span class="dv">1</span>, <span class="dv">1</span>]]
<span class="co">#&gt; [1] 1 2 3</span></code></pre>
<p>These data structures are relatively esoteric but they can be useful if you want to arrange objects in a grid-like structure. For example, if you’re running models on a spatio-temporal grid, it might be more intuitive to store the models in a 3D array that matches the grid structure.</p>
</div>
<div id="exercises-7" class="section level3">
<h3><span class="header-section-number">3.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>List all the ways that a list differs from an atomic vector.</p></li>
<li><p>Why do you need to use <code>unlist()</code> to convert a list to an
atomic vector? Why doesn’t <code>as.vector()</code> work?</p></li>
<li><p>Compare and contrast <code>c()</code> and <code>unlist()</code> when combining a
date and date-time into a single vector.</p></li>
</ol>
</div>
</div>
<div id="tibble" class="section level2">
<h2><span class="header-section-number">3.6</span> Data frames and tibbles</h2>
<p>

</p>
<p>The two most important S3 vectors built on top of lists are data frames and tibbles.</p>
<p><img src="diagrams/vectors/summary-tree-s3-2.png" width="160" style="display: block; margin: auto;" /></p>
<p>If you do data analysis in R, you’re going to be using data frames. A data frame is a named list of vectors with attributes for (column) <code>names</code>, <code>row.names</code><span id="fn61" class="footnote" data-pagedown-footnote-number="61" style="white-space: pre-line;">Row names are one of the most surprisingly complex data structures in R. They’ve also been a persistent source of performance issues over the years. The most straightforward implementation is a character or integer vector, with one element for each row. But there’s also a compact representation for “automatic” row names (consecutive integers), created by <code>.set_row_names()</code>. R 3.5 has a special way of deferring integer to character conversion that is specifically designed to speed up <code>lm()</code>; see <a href="https://svn.r-project.org/R/branches/ALTREP/ALTREP.html#deferred_string_conversions" class="uri">https://svn.r-project.org/R/branches/ALTREP/ALTREP.html#deferred_string_conversions</a> for details.</span>, and its class, “data.frame”:</p>
<pre class="sourceCode r"><code class="sourceCode r">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
<span class="kw">typeof</span>(df1)
<span class="co">#&gt; [1] &quot;list&quot;</span>

<span class="kw">attributes</span>(df1)
<span class="co">#&gt; $names</span>
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;data.frame&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $row.names</span>
<span class="co">#&gt; [1] 1 2 3</span></code></pre>
<p>In contrast to a regular list, a data frame has an additional constraint: the length of each of its vectors must be the same. This gives data frames their rectangular structure and explains why they share the properties of both matrices and lists:</p>
<ul>
<li><p>A data frame has <code>rownames()</code><span id="fn62" class="footnote" data-pagedown-footnote-number="62" style="white-space: pre-line;">Technically, you are encouraged to use <code>row.names()</code>, not <code>rownames()</code> with data frames, but this distinction is rarely important.</span> and <code>colnames()</code>. The <code>names()</code>
of a data frame are the column names.</p></li>
<li><p>A data frame has <code>nrow()</code> rows and <code>ncol()</code> columns. The <code>length()</code> of a
data frame gives the number of columns.</p></li>
</ul>
<p>Data frames are one of the biggest and most important ideas in R, and one of the things that makes R different from other programming languages. However, in the over 20 years since their creation, the ways that people use R have changed, and some of the design decisions that made sense at the time data frames were created now cause frustration.</p>
<p>This frustration lead to the creation of the tibble <span class="citation">(Müller and Wickham <a href="#ref-tibble">2018</a>)</span>, a modern reimagining of the data frame. Tibbles are designed to be (as much as possible) drop-in replacements for data frames that fix those frustrations. A concise, and fun, way to summarise the main differences is that tibbles are lazy and surly: they do less and complain more. You’ll see what that means as you work through this section.</p>
<p>Tibbles are provided by the tibble package and share the same structure as data frames. The only difference is that the class vector is longer, and includes <code>tbl_df</code>. This allows tibbles to behave differently in the key ways which we’ll discuss below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tibble)

df2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
<span class="kw">typeof</span>(df2)
<span class="co">#&gt; [1] &quot;list&quot;</span>

<span class="kw">attributes</span>(df2)
<span class="co">#&gt; $names</span>
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $row.names</span>
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></code></pre>
<div id="df-create" class="section level3">
<h3><span class="header-section-number">3.6.1</span> Creating</h3>

<p></p>
<p>You create a data frame by supplying name-vector pairs to <code>data.frame()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
)
<span class="kw">str</span>(df)
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  2 variables:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="co">#&gt;  $ y: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3</span></code></pre>
<p>Beware of the default conversion of strings to factors. Use <code>stringsAsFactors = FALSE</code> to suppress this and keep character vectors as character vectors:</p>
<pre class="sourceCode r"><code class="sourceCode r">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>),
  <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>
)
<span class="kw">str</span>(df1)
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  2 variables:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="co">#&gt;  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>Creating a tibble is similar to creating a data frame. The difference between the two is that tibbles never coerce their input (this is one feature that makes them lazy):</p>
<pre class="sourceCode r"><code class="sourceCode r">df2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
)
<span class="kw">str</span>(df2)
<span class="co">#&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:    3 obs. of  2 variables:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="co">#&gt;  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>Additionally, while data frames automatically transform non-syntactic names (unless <code>check.names = FALSE</code>), tibbles do not (although they do print non-syntactic names surrounded by <code>`</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(<span class="kw">data.frame</span>(<span class="st">`</span><span class="dt">1</span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span>))
<span class="co">#&gt; [1] &quot;X1&quot;</span>

<span class="kw">names</span>(<span class="kw">tibble</span>(<span class="st">`</span><span class="dt">1</span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span>))
<span class="co">#&gt; [1] &quot;1&quot;</span></code></pre>
<p>While every element of a data frame (or tibble) must have the same length, both <code>data.frame()</code> and <code>tibble()</code> will recycle shorter inputs. However, while data frames automatically recycle columns that are an integer multiple of the longest column, tibbles will only recycle vectors of length one.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 1</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span>
<span class="co">#&gt; 4 4 2</span>
<span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; Error in data.frame(x = 1:4, y = 1:3):</span>
<span class="co">#&gt;   arguments imply differing number of rows: 4, 3</span>

<span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 4 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     1</span>
<span class="co">#&gt; 2     2     1</span>
<span class="co">#&gt; 3     3     1</span>
<span class="co">#&gt; 4     4     1</span>
<span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)
<span class="co">#&gt; Error: Tibble columns must have consistent lengths, only values of length one are recycled:</span>
<span class="co">#&gt; * Length 2: Column `y`</span>
<span class="co">#&gt; * Length 4: Column `x`</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─tibble::tibble(x = 1:4, y = 1:2)</span>
<span class="co">#&gt;  2.   └─tibble:::lst_to_tibble(xlq$output, .rows, .name_repair, lengths = xlq$lengths)</span>
<span class="co">#&gt;  3.     └─tibble:::recycle_columns(x, .rows, lengths)</span></code></pre>
<p>There is one final difference: <code>tibble()</code> allows you to refer to variables created during construction:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
  <span class="dt">y =</span> x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
)
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2</span>
<span class="co">#&gt; 2     2     4</span>
<span class="co">#&gt; 3     3     6</span></code></pre>
<p>(Inputs are evaluated left-to-right.)</p>
<p>When drawing data frames and tibbles, rather than focussing on the implementation details, i.e. the attributes:</p>
<p><img src="diagrams/vectors/data-frame-1.png" width="255" style="display: block; margin: auto;" /></p>
<p>I’ll draw them the same way as a named list, but arrange them to emphasise their columnar structure.</p>
<p><img src="diagrams/vectors/data-frame-2.png" width="104" style="display: block; margin: auto;" /></p>
</div>
<div id="rownames" class="section level3">
<h3><span class="header-section-number">3.6.2</span> Row names</h3>

<p>Data frames allow you to label each row with a “name”, a character vector containing only unique values:</p>
<pre class="sourceCode r"><code class="sourceCode r">df3 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">age =</span> <span class="kw">c</span>(<span class="dv">35</span>, <span class="dv">27</span>, <span class="dv">18</span>),
  <span class="dt">hair =</span> <span class="kw">c</span>(<span class="st">&quot;blond&quot;</span>, <span class="st">&quot;brown&quot;</span>, <span class="st">&quot;black&quot;</span>),
  <span class="dt">row.names =</span> <span class="kw">c</span>(<span class="st">&quot;Bob&quot;</span>, <span class="st">&quot;Susan&quot;</span>, <span class="st">&quot;Sam&quot;</span>)
)
df3
<span class="co">#&gt;       age  hair</span>
<span class="co">#&gt; Bob    35 blond</span>
<span class="co">#&gt; Susan  27 brown</span>
<span class="co">#&gt; Sam    18 black</span></code></pre>
<p>You can get and set row names with <code>rownames()</code>, and you can use them to subset rows:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rownames</span>(df3)
<span class="co">#&gt; [1] &quot;Bob&quot;   &quot;Susan&quot; &quot;Sam&quot;</span>

df3[<span class="st">&quot;Bob&quot;</span>, ]
<span class="co">#&gt;     age  hair</span>
<span class="co">#&gt; Bob  35 blond</span></code></pre>
<p>Row names arise naturally if you think of data frames as 2D structures like matrices: columns (variables) have names so rows (observations) should too. Most matrices are numeric, so having a place to store character labels is important. But this analogy to matrices is misleading because matrices possess an important property that data frames do not: they are transposable. In matrices the rows and columns are interchangeable, and transposing a matrix gives you another matrix (transposing again gives you the original matrix). With data frames, however, the rows and columns are not interchangeable: the transpose of a data frame is not a data frame.</p>
<p>There are three reasons why row names are undesirable:</p>
<ul>
<li><p>Metadata is data, so storing it in a different way to the rest of the
data is fundamentally a bad idea. It also means that you need to learn
a new set of tools to work with row names; you can’t use what you already
know about manipulating columns.</p></li>
<li><p>Row names are a poor abstraction for labelling rows because they only work
when a row can be identified by a single string. This fails in many cases,
for example when you want to identify a row by a non-character vector
(e.g. a time point), or with multiple vectors (e.g. position, encoded by
latitude and longitude).</p></li>
<li><p>Row names must be unique, so any duplication of rows (e.g. from
bootstrapping) will create new row names. If you want to match rows from
before and after the transformation, you’ll need to perform complicated
string surgery.</p>
<pre class="sourceCode r"><code class="sourceCode r">df3[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>), ]
<span class="co">#&gt;       age  hair</span>
<span class="co">#&gt; Bob    35 blond</span>
<span class="co">#&gt; Bob.1  35 blond</span>
<span class="co">#&gt; Bob.2  35 blond</span></code></pre></li>
</ul>
<p>For these reasons, tibbles do not support row names. Instead the tibble package provides tools to easily convert row names into a regular column with either <code>rownames_to_column()</code>, or the <code>rownames</code> argument in <code>as_tibble()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_tibble</span>(df3, <span class="dt">rownames =</span> <span class="st">&quot;name&quot;</span>)
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   name    age hair </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt;</span>
<span class="co">#&gt; 1 Bob      35 blond</span>
<span class="co">#&gt; 2 Susan    27 brown</span>
<span class="co">#&gt; 3 Sam      18 black</span></code></pre>
</div>
<div id="printing" class="section level3">
<h3><span class="header-section-number">3.6.3</span> Printing</h3>
<p>One of the most obvious differences between tibbles and data frames is how they print. I assume that you’re already familiar with how data frames are printed, so here I’ll highlight some of the biggest differences using an example dataset included in the dplyr package:</p>
<pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span>starwars
<span class="co">#&gt; # A tibble: 87 x 13</span>
<span class="co">#&gt;    name  height  mass hair_color skin_color eye_color birth_year gender</span>
<span class="co">#&gt;    &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; </span>
<span class="co">#&gt;  1 Luke…    172    77 blond      fair       blue            19   male  </span>
<span class="co">#&gt;  2 C-3PO    167    75 &lt;NA&gt;       gold       yellow         112   &lt;NA&gt;  </span>
<span class="co">#&gt;  3 R2-D2     96    32 &lt;NA&gt;       white, bl… red             33   &lt;NA&gt;  </span>
<span class="co">#&gt;  4 Dart…    202   136 none       white      yellow          41.9 male  </span>
<span class="co">#&gt;  5 Leia…    150    49 brown      light      brown           19   female</span>
<span class="co">#&gt;  6 Owen…    178   120 brown, gr… light      blue            52   male  </span>
<span class="co">#&gt;  7 Beru…    165    75 brown      light      blue            47   female</span>
<span class="co">#&gt;  8 R5-D4     97    32 &lt;NA&gt;       white, red red             NA   &lt;NA&gt;  </span>
<span class="co">#&gt;  9 Bigg…    183    84 black      light      brown           24   male  </span>
<span class="co">#&gt; 10 Obi-…    182    77 auburn, w… fair       blue-gray       57   male  </span>
<span class="co">#&gt; # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;,</span>
<span class="co">#&gt; #   species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;</span></code></pre>
<ul>
<li><p>Tibbles only show the first 10 rows and all the columns that will fit on
screen. Additional columns are shown at the bottom.</p></li>
<li><p>Each column is labelled with its type, abbreviated to three or four letters.</p></li>
<li><p>Wide columns are truncated to avoid having a single long string occupy an
entire row. (This is still a work in progress: it’s a tricky tradeoff between
showing as many columns as possible and showing columns in their entirety.)</p></li>
<li><p>When used in console environments that support it, colour is used judiciously
to highlight important information, and de-emphasise supplemental details.</p></li>
</ul>
</div>
<div id="safe-subsetting" class="section level3">
<h3><span class="header-section-number">3.6.4</span> Subsetting</h3>
<p>As you will learn in Chapter <a href="#subsetting">4</a>, you can subset a data frame or a tibble like a 1D structure (where it behaves like a list), or a 2D structure (where it behaves like a matrix).</p>
<p>In my opinion, data frames have two undesirable subsetting behaviours:</p>
<ul>
<li><p>When you subset columns with <code>df[, vars]</code>, you will get a vector if <code>vars</code>
selects one variable, otherwise you’ll get a data frame. This is a frequent
source of bugs when using <code>[</code> in a function, unless you always remember to
use <code>df[, vars, drop = FALSE]</code>.</p></li>
<li><p>When you attempt to extract a single column with <code>df$x</code> and there is no
column <code>x</code>, a data frame will instead select any variable that starts with
<code>x</code>. If no variable starts with <code>x</code>, <code>df$x</code> will return <code>NULL</code>. This makes
it easy to select the wrong variable or to select a variable that doesn’t
exist.</p></li>
</ul>
<p>Tibbles tweak these behaviours so that a [ always returns a tibble, and a $ doesn’t do partial matching and warns if it can’t find a variable (this is what makes tibbles surly).</p>
<pre class="sourceCode r"><code class="sourceCode r">df1 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">xyz =</span> <span class="st">&quot;a&quot;</span>)
df2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">xyz =</span> <span class="st">&quot;a&quot;</span>)

<span class="kw">str</span>(df1<span class="op">$</span>x)
<span class="co">#&gt;  Factor w/ 1 level &quot;a&quot;: 1</span>
<span class="kw">str</span>(df2<span class="op">$</span>x)
<span class="co">#&gt; Warning: Unknown or uninitialised column: &#39;x&#39;.</span>
<span class="co">#&gt;  NULL</span></code></pre>
<p>A tibble’s insistence on returning a data frame from <code>[</code> can cause problems with legacy code, which often uses <code>df[, &quot;col&quot;]</code> to extract a single column. If you want a single column, I recommend using <code>df[[&quot;col&quot;]]</code>. This clearly communicates your intent, and works with both data frames and tibbles.</p>
</div>
<div id="df-test-coerce" class="section level3">
<h3><span class="header-section-number">3.6.5</span> Testing and coercing</h3>
<p>To check if an object is a data frame or tibble, use <code>is.data.frame()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.data.frame</span>(df1)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">is.data.frame</span>(df2)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>Typically, it should not matter if you have a tibble or data frame, but if you need to be certain, use <code>is_tibble()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is_tibble</span>(df1)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">is_tibble</span>(df2)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>You can coerce an object to a data frame with <code>as.data.frame()</code> or to a tibble with <code>as_tibble()</code>.</p>
</div>
<div id="list-columns" class="section level3">
<h3><span class="header-section-number">3.6.6</span> List columns</h3>
<p>
</p>
<p>Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list. This is very useful because a list can contain any other object: this means you can put any object in a data frame. This allows you to keep related objects together in a row, no matter how complex the individual objects are. You can see an application of this in the “Many Models” chapter of “R for Data Science”, <a href="http://r4ds.had.co.nz/many-models.html" class="uri">http://r4ds.had.co.nz/many-models.html</a>.</p>
<p>List-columns are allowed in data frames but you have to do a little extra work by either adding the list-column after creation or wrapping the list in <code>I()</code><span id="fn63" class="footnote" data-pagedown-footnote-number="63" style="white-space: pre-line;"><code>I()</code> is short for identity and is often used to indicate that an input should be left as is, and not automatically transformed.</span>.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
df<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)

<span class="kw">data.frame</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="dt">y =</span> <span class="kw">I</span>(<span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>))
)
<span class="co">#&gt;   x          y</span>
<span class="co">#&gt; 1 1       1, 2</span>
<span class="co">#&gt; 2 2    1, 2, 3</span>
<span class="co">#&gt; 3 3 1, 2, 3, 4</span></code></pre>
<p><img src="diagrams/vectors/data-frame-list.png" width="189" style="display: block; margin: auto;" /></p>
<p>List columns are easier to use with tibbles because they can be directly included inside tibble() and they will be printed tidily:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="dt">y =</span> <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)
)
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;       x y        </span>
<span class="co">#&gt;   &lt;int&gt; &lt;list&gt;   </span>
<span class="co">#&gt; 1     1 &lt;int [2]&gt;</span>
<span class="co">#&gt; 2     2 &lt;int [3]&gt;</span>
<span class="co">#&gt; 3     3 &lt;int [4]&gt;</span></code></pre>
</div>
<div id="matrix-and-data-frame-columns" class="section level3">
<h3><span class="header-section-number">3.6.7</span> Matrix and data frame columns</h3>
<p></p>
<p>As long as the number of rows matches the data frame, it’s also possible to have a matrix or array as a column of a data. (This requires a slight extension to our definition of a data frame: it’s not the <code>length()</code> of each column that must be equal, but the <code>NROW()</code>.) Like with list-columns, you must either add it after creation, or wrap it in <code>I()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">dfm &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span>
)
dfm<span class="op">$</span>y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dt">nrow =</span> <span class="dv">3</span>)
dfm<span class="op">$</span>z &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">b =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

<span class="kw">str</span>(dfm)
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  3 variables:</span>
<span class="co">#&gt;  $ x: num  10 20 30</span>
<span class="co">#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9</span>
<span class="co">#&gt;  $ z:&#39;data.frame&#39;:   3 obs. of  2 variables:</span>
<span class="co">#&gt;   ..$ a: int  3 2 1</span>
<span class="co">#&gt;   ..$ b: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p><img src="diagrams/vectors/data-frame-matrix.png" width="250" style="display: block; margin: auto;" /></p>
<p>Matrix and data frame columns require a little caution. Many functions that work with data frames assume that all columns are vectors. Also, the printed display can be confusing.</p>
<pre class="sourceCode r"><code class="sourceCode r">dfm[<span class="dv">1</span>, ]
<span class="co">#&gt;    x y.1 y.2 y.3 z.a z.b</span>
<span class="co">#&gt; 1 10   1   4   7   3   a</span></code></pre>
</div>
<div id="exercises-8" class="section level3">
<h3><span class="header-section-number">3.6.8</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Can you have a data frame with zero rows? What about zero columns?</p></li>
<li><p>What happens if you attempt to set rownames that are not unique?</p></li>
<li><p>If <code>df</code> is a data frame, what can you say about <code>t(df)</code>, and <code>t(t(df))</code>?
Perform some experiments, making sure to try different column types.</p></li>
<li><p>What does <code>as.matrix()</code> do when applied to a data frame with
columns of different types? How does it differ from <code>data.matrix()</code>?</p></li>
</ol>
</div>
</div>
<div id="null" class="section level2">
<h2><span class="header-section-number">3.7</span> <code>NULL</code></h2>

<p>To finish up this chapter, I want to talk about one final important data structure that’s closely related to vectors: <code>NULL</code>. <code>NULL</code> is special because it has a unique type, is always length zero, and can’t have any attributes:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; [1] &quot;NULL&quot;</span>

<span class="kw">length</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; [1] 0</span>

x &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">attr</span>(x, <span class="st">&quot;y&quot;</span>) &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="co">#&gt; Error in attr(x, &quot;y&quot;) &lt;- 1:</span>
<span class="co">#&gt;   attempt to set an attribute on NULL</span></code></pre>
<p>You can test for <code>NULL</code>s with <code>is.null()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.null</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>There are two common uses of <code>NULL</code>:</p>
<ul>
<li><p>To represent an empty vector (a vector of length zero) of arbitrary type.
For example, if you use <code>c()</code> but don’t include any arguments, you get
<code>NULL</code>, and concatenating <code>NULL</code> to a vector will leave it unchanged:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>()
<span class="co">#&gt; NULL</span></code></pre></li>
<li><p>To represent an absent vector. For example, <code>NULL</code> is often used as a
default function argument, when the argument is optional but the default
value requires some computation (see Section <a href="#missing-arguments">6.5.3</a> for
more on this). Contrast this with <code>NA</code> which is used to indicate that
an <em>element</em> of a vector is absent.</p></li>
</ul>
<p>If you’re familiar with SQL, you’ll know about relational <code>NULL</code> and might expect it to be the same as R’s. However, the database <code>NULL</code> is actually equivalent to R’s <code>NA</code>.</p>
</div>
<div id="data-structure-answers" class="section level2">
<h2><span class="header-section-number">3.8</span> Answers</h2>
<ol style="list-style-type: decimal">
<li><p>The four common types of atomic vector are logical, integer, double
and character. The two rarer types are complex and raw.</p></li>
<li><p>Attributes allow you to associate arbitrary additional metadata to
any object. You can get and set individual attributes with <code>attr(x, &quot;y&quot;)</code>
and <code>attr(x, &quot;y&quot;) &lt;- value</code>; or you can get and set all attributes at once
with <code>attributes()</code>.</p></li>
<li><p>The elements of a list can be any type (even a list); the elements of
an atomic vector are all of the same type. Similarly, every element of
a matrix must be the same type; in a data frame, different columns can have
different types.</p></li>
<li><p>You can make a “list-array” by assigning dimensions to a list. You can
make a matrix a column of a data frame with <code>df$x &lt;- matrix()</code>, or by
using <code>I()</code> when creating a new data frame <code>data.frame(x = I(matrix()))</code>.</p></li>
<li><p>Tibbles have an enhanced print method, which never coerces strings to
factors, and provide stricter subsetting methods.</p></li>
</ol>
<!--chapter:end:Vectors.Rmd-->
</div>
</div>
<div id="subsetting" class="section level1">
<h1><span class="header-section-number">4</span> Subsetting</h1>
<div id="introduction-3" class="section level2">
<h2><span class="header-section-number">4.1</span> Introduction</h2>
<p></p>
<p>R’s subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:</p>
<ul>
<li><p>There are six ways to subset atomic vectors.</p></li>
<li><p>There are three subsetting operators, <code>[[</code>, <code>[</code>, and <code>$</code>.</p></li>
<li><p>Subsetting operators interact differently with different vector
types (e.g., atomic vectors, lists, factors, matrices, and data frames).</p></li>
<li><p>Subsetting can be combined with assignment.</p></li>
</ul>
<p>Subsetting is a natural complement to <code>str()</code>. While <code>str()</code> shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you’re interested in. For large, complex objects, I highly recommend using the interactive RStudio Viewer, which you can activate with <code>View(my_object)</code>.</p>
<div id="quiz-2" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>Take this short quiz to determine if you need to read this chapter. If the answers quickly come to mind, you can comfortably skip this chapter. Check your answers in Section <a href="#subsetting-answers">4.6</a>.</p>
<ol style="list-style-type: decimal">
<li><p>What is the result of subsetting a vector with positive integers,
negative integers, a logical vector, or a character vector?</p></li>
<li><p>What’s the difference between <code>[</code>, <code>[[</code>, and <code>$</code> when applied to a list?</p></li>
<li><p>When should you use <code>drop = FALSE</code>?</p></li>
<li><p>If <code>x</code> is a matrix, what does <code>x[] &lt;- 0</code> do? How is it different from
<code>x &lt;- 0</code>?</p></li>
<li><p>How can you use a named vector to relabel categorical variables?</p></li>
</ol>
</div>
<div id="outline-2" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#subset-multiple">4.2</a> starts by teaching you about <code>[</code>.
You’ll learn the six ways to subset atomic vectors. You’ll then
learn how those six ways act when used to subset lists, matrices,
and data frames.</p></li>
<li><p>Section <a href="#subset-single">4.3</a> expands your knowledge of subsetting
operators to include <code>[[</code> and <code>$</code> and focuses on the important
principles of simplifying vs. preserving.</p></li>
<li><p>In Section <a href="#subassignment">4.4</a> you’ll learn the art of
subassignment, which combines subsetting and assignment to modify
parts of an object.</p></li>
<li><p>Section <a href="#applications">4.5</a> leads you through eight important, but
not obvious, applications of subsetting to solve problems that you
often encounter in data analysis.</p></li>
</ul>
</div>
</div>
<div id="subset-multiple" class="section level2">
<h2><span class="header-section-number">4.2</span> Selecting multiple elements</h2>

<p>Use <code>[</code> to select any number of elements from a vector. To illustrate, I’ll apply <code>[</code> to 1D atomic vectors, and then show how this generalises to more complex objects and more dimensions.</p>
<div id="atomic-vectors-1" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Atomic vectors</h3>
<p>
</p>
<p>Let’s explore the different types of subsetting with a simple vector, <code>x</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">2.1</span>, <span class="fl">4.2</span>, <span class="fl">3.3</span>, <span class="fl">5.4</span>)</code></pre>
<p>Note that the number after the decimal point represents the original position in the vector.</p>
<p>There are six things that you can use to subset a vector:</p>
<ul>
<li><p><strong>Positive integers</strong> return elements at the specified positions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 3.3 2.1</span>
x[<span class="kw">order</span>(x)]
<span class="co">#&gt; [1] 2.1 3.3 4.2 5.4</span>

<span class="co"># Duplicate indices will duplicate values</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 2.1 2.1</span>

<span class="co"># Real numbers are silently truncated to integers</span>
x[<span class="kw">c</span>(<span class="fl">2.1</span>, <span class="fl">2.9</span>)]
<span class="co">#&gt; [1] 4.2 4.2</span></code></pre></li>
<li><p><strong>Negative integers</strong> exclude elements at the specified positions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="op">-</span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">1</span>)]
<span class="co">#&gt; [1] 4.2 5.4</span></code></pre>
<p>Note that you can’t mix positive and negative integers in a single subset:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)]
<span class="co">#&gt; Error in x[c(-1, 2)]:</span>
<span class="co">#&gt;   only 0&#39;s may be mixed with negative subscripts</span></code></pre></li>
<li><p><strong>Logical vectors</strong> select elements where the corresponding logical
value is <code>TRUE</code>. This is probably the most useful type of subsetting
because you can write an expression that uses a logical vector:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 4.2</span>
x[x <span class="op">&gt;</span><span class="st"> </span><span class="dv">3</span>]
<span class="co">#&gt; [1] 4.2 3.3 5.4</span></code></pre>
<p>
In <code>x[y]</code>, what happens if <code>x</code> and <code>y</code> are different lengths? The behaviour
is controlled by the <strong>recycling rules</strong> where the shorter of the two is
“recycled” to the length of the longer. This is convenient and easy to
understand when one of <code>x</code> and <code>y</code> is length one, but I recommend avoiding
recycling for other lengths because the rules are inconsistently applied
throughout base R.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 3.3</span>
<span class="co"># Equivalent to</span>
x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 3.3</span></code></pre>
<p>Note that a missing value in the index always yields a missing value in the output:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">NA</span>, <span class="ot">FALSE</span>)]
<span class="co">#&gt; [1] 2.1 4.2  NA</span></code></pre></li>
<li><p><strong>Nothing</strong> returns the original vector. This is not useful for 1D vectors,
but, as you’ll see shortly, is very useful for matrices, data frames, and arrays.
It can also be useful in conjunction with assignment.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[]
<span class="co">#&gt; [1] 2.1 4.2 3.3 5.4</span></code></pre></li>
<li><p><strong>Zero</strong> returns a zero-length vector. This is not something you
usually do on purpose, but it can be helpful for generating test data.</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">0</span>]
<span class="co">#&gt; numeric(0)</span></code></pre></li>
<li><p>If the vector is named, you can also use <strong>character vectors</strong> to return
elements with matching names.</p>
<pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">setNames</span>(x, letters[<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]))
<span class="co">#&gt;   a   b   c   d </span>
<span class="co">#&gt; 2.1 4.2 3.3 5.4</span>
y[<span class="kw">c</span>(<span class="st">&quot;d&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>)]
<span class="co">#&gt;   d   c   a </span>
<span class="co">#&gt; 5.4 3.3 2.1</span>

<span class="co"># Like integer indices, you can repeat indices</span>
y[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>)]
<span class="co">#&gt;   a   a   a </span>
<span class="co">#&gt; 2.1 2.1 2.1</span>

<span class="co"># When subsetting with [, names are always matched exactly</span>
z &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>)
z[<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;d&quot;</span>)]
<span class="co">#&gt; &lt;NA&gt; &lt;NA&gt; </span>
<span class="co">#&gt;   NA   NA</span></code></pre></li>
</ul>
<p>NB: Factors are not treated specially when subsetting. This means that subsetting will use the underlying integer vector, not the character levels. This is typically unexpected, so you should avoid subsetting with factors:</p>
<pre class="sourceCode r"><code class="sourceCode r">y[<span class="kw">factor</span>(<span class="st">&quot;b&quot;</span>)]
<span class="co">#&gt;   a </span>
<span class="co">#&gt; 2.1</span></code></pre>
</div>
<div id="lists-1" class="section level3">
<h3><span class="header-section-number">4.2.2</span> Lists</h3>
<p>
</p>
<p>Subsetting a list works in the same way as subsetting an atomic vector. Using <code>[</code> always return a list; <code>[[</code> and <code>$</code>, as described in Section <a href="#subset-single">4.3</a>, let you pull out elements of a list.</p>
</div>
<div id="matrix-subsetting" class="section level3">
<h3><span class="header-section-number">4.2.3</span> Matrices and arrays</h3>
<p>
</p>
<p>You can subset higher-dimensional structures in three ways:</p>
<ul>
<li>With multiple vectors.</li>
<li>With a single vector.</li>
<li>With a matrix.</li>
</ul>
<p>The most common way of subsetting matrices (2D) and arrays (&gt;2D) is a simple generalisation of 1D subsetting: supply a 1D index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dt">nrow =</span> <span class="dv">3</span>)
<span class="kw">colnames</span>(a) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>)
a[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, ]
<span class="co">#&gt;      A B C</span>
<span class="co">#&gt; [1,] 1 4 7</span>
<span class="co">#&gt; [2,] 2 5 8</span>
a[<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>), <span class="kw">c</span>(<span class="st">&quot;B&quot;</span>, <span class="st">&quot;A&quot;</span>)]
<span class="co">#&gt;      B A</span>
<span class="co">#&gt; [1,] 4 1</span>
<span class="co">#&gt; [2,] 6 3</span>
a[<span class="dv">0</span>, <span class="dv">-2</span>]
<span class="co">#&gt;      A C</span></code></pre>
<p>By default, <code>[</code> simplifies the results to the lowest possible dimensionality. For example, both of the following expressions return 1D vectors. You’ll learn how to avoid “dropping” dimensions in Section <a href="#simplify-preserve">4.2.5</a>:</p>
<pre class="sourceCode r"><code class="sourceCode r">a[<span class="dv">1</span>, ]
<span class="co">#&gt; A B C </span>
<span class="co">#&gt; 1 4 7</span>
a[<span class="dv">1</span>, <span class="dv">1</span>]
<span class="co">#&gt; A </span>
<span class="co">#&gt; 1</span></code></pre>
<p>Because both matrices and arrays are just vectors with special attributes, you can subset them with a single vector, as if they were a 1D vector. Note that arrays in R are stored in column-major order:</p>
<pre class="sourceCode r"><code class="sourceCode r">vals &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;paste&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>)
vals
<span class="co">#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] </span>
<span class="co">#&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot;</span>
<span class="co">#&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot;</span>
<span class="co">#&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot;</span>
<span class="co">#&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot;</span>
<span class="co">#&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot;</span>

vals[<span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">15</span>)]
<span class="co">#&gt; [1] &quot;4,1&quot; &quot;5,3&quot;</span></code></pre>
<p>You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value, and each column corresponds to a dimension in the array. This means that you can use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3D array, and so on. The result is a vector of values:</p>
<pre class="sourceCode r"><code class="sourceCode r">select &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>, <span class="kw">c</span>(
  <span class="dv">1</span>, <span class="dv">1</span>,
  <span class="dv">3</span>, <span class="dv">1</span>,
  <span class="dv">2</span>, <span class="dv">4</span>
))
vals[select]
<span class="co">#&gt; [1] &quot;1,1&quot; &quot;3,1&quot; &quot;2,4&quot;</span></code></pre>
</div>
<div id="df-subsetting" class="section level3">
<h3><span class="header-section-number">4.2.4</span> Data frames and tibbles</h3>
<p>
</p>
<p>Data frames have the characteristics of both lists and matrices:</p>
<ul>
<li><p>When subsetting with a single index, they behave like lists and index
the columns, so <code>df[1:2]</code> selects the first two columns.</p></li>
<li><p>When subsetting with two indices, they behave like matrices, so
<code>df[1:3, ]</code> selects the first three <em>rows</em> (and all the columns)<span id="fn64" class="footnote" data-pagedown-footnote-number="64" style="white-space: pre-line;">If you’re coming from Python this is likely to be confusing, as you’d probably expect <code>df[1:3, 1:2]</code> to select three columns and two rows. Generally, R “thinks” about dimensions in terms of rows and columns while Python does so in terms of columns and rows.</span>.</p></li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])

df[df<span class="op">$</span>x <span class="op">==</span><span class="st"> </span><span class="dv">2</span>, ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 2 2 2 b</span>
df[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 3 a</span>
<span class="co">#&gt; 3 3 1 c</span>

<span class="co"># There are two ways to select columns from a data frame</span>
<span class="co"># Like a list</span>
df[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x z</span>
<span class="co">#&gt; 1 1 a</span>
<span class="co">#&gt; 2 2 b</span>
<span class="co">#&gt; 3 3 c</span>
<span class="co"># Like a matrix</span>
df[, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x z</span>
<span class="co">#&gt; 1 1 a</span>
<span class="co">#&gt; 2 2 b</span>
<span class="co">#&gt; 3 3 c</span>

<span class="co"># There&#39;s an important difference if you select a single </span>
<span class="co"># column: matrix subsetting simplifies by default, list </span>
<span class="co"># subsetting does not.</span>
<span class="kw">str</span>(df[<span class="st">&quot;x&quot;</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="kw">str</span>(df[, <span class="st">&quot;x&quot;</span>])
<span class="co">#&gt;  int [1:3] 1 2 3</span></code></pre>
<p>Subsetting a tibble with <code>[</code> always returns a tibble:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])

<span class="kw">str</span>(df[<span class="st">&quot;x&quot;</span>])
<span class="co">#&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span>
<span class="kw">str</span>(df[, <span class="st">&quot;x&quot;</span>])
<span class="co">#&gt; Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span></code></pre>
</div>
<div id="simplify-preserve" class="section level3">
<h3><span class="header-section-number">4.2.5</span> Preserving dimensionality</h3>

<p>
</p>
<p>By default, subsetting a matrix or data frame with a single number, a single name, or a logical vector containing a single <code>TRUE</code>, will simplify the returned output, i.e. it will return an object with lower dimensionality. To preserve the original dimensionality, you must use <code>drop = FALSE</code>.</p>
<ul>
<li><p>For matrices and arrays, any dimensions with length 1 will be dropped:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)
<span class="kw">str</span>(a[<span class="dv">1</span>, ])
<span class="co">#&gt;  int [1:2] 1 3</span>

<span class="kw">str</span>(a[<span class="dv">1</span>, , <span class="dt">drop =</span> <span class="ot">FALSE</span>])
<span class="co">#&gt;  int [1, 1:2] 1 3</span></code></pre></li>
<li><p>Data frames with a single column will return just that column:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">b =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)
<span class="kw">str</span>(df[, <span class="st">&quot;a&quot;</span>])
<span class="co">#&gt;  int [1:2] 1 2</span>

<span class="kw">str</span>(df[, <span class="st">&quot;a&quot;</span>, <span class="dt">drop =</span> <span class="ot">FALSE</span>])
<span class="co">#&gt; &#39;data.frame&#39;:    2 obs. of  1 variable:</span>
<span class="co">#&gt;  $ a: int  1 2</span></code></pre></li>
</ul>
<p>The default <code>drop = TRUE</code> behaviour is a common source of bugs in functions: you check your code with a data frame or matrix with multiple columns, and it works. Six months later, you (or someone else) uses it with a single column data frame and it fails with a mystifying error. When writing functions, get in the habit of always using <code>drop = FALSE</code> when subsetting a 2D object. For this reason, tibbles default to <code>drop = FALSE</code>, and <code>[</code> always returns another tibble.</p>
<p>Factor subsetting also has a <code>drop</code> argument, but its meaning is rather different. It controls whether or not levels (rather than dimensions) are preserved, and it defaults to <code>FALSE</code>. If you find you’re using <code>drop = TRUE</code> a lot it’s often a sign that you should be using a character vector instead of a factor.</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))
z[<span class="dv">1</span>]
<span class="co">#&gt; [1] a</span>
<span class="co">#&gt; Levels: a b</span>
z[<span class="dv">1</span>, drop =<span class="st"> </span><span class="ot">TRUE</span>]
<span class="co">#&gt; [1] a</span>
<span class="co">#&gt; Levels: a</span></code></pre>
</div>
<div id="exercises-9" class="section level3">
<h3><span class="header-section-number">4.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Fix each of the following common data frame subsetting errors:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[mtcars<span class="op">$</span>cyl =<span class="st"> </span><span class="dv">4</span>, ]
mtcars[<span class="op">-</span><span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, ]
mtcars[mtcars<span class="op">$</span>cyl <span class="op">&lt;=</span><span class="st"> </span><span class="dv">5</span>]
mtcars[mtcars<span class="op">$</span>cyl <span class="op">==</span><span class="st"> </span><span class="dv">4</span> <span class="op">|</span><span class="st"> </span><span class="dv">6</span>, ]</code></pre></li>
<li><p>Why does the following code yield five missing values? (Hint: why is
it different from <code>x[NA_real_]</code>?)</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
x[<span class="ot">NA</span>]
<span class="co">#&gt; [1] NA NA NA NA NA</span></code></pre></li>
<li><p>What does <code>upper.tri()</code> return? How does subsetting a matrix with it
work? Do we need any additional subsetting rules to describe its behaviour?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">outer</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">FUN =</span> <span class="st">&quot;*&quot;</span>)
x[<span class="kw">upper.tri</span>(x)]</code></pre></li>
<li><p>Why does <code>mtcars[1:20]</code> return an error? How does it differ from the
similar <code>mtcars[1:20, ]</code>?</p></li>
<li><p>Implement your own function that extracts the diagonal entries from a
matrix (it should behave like <code>diag(x)</code> where <code>x</code> is a matrix).</p></li>
<li><p>What does <code>df[is.na(df)] &lt;- 0</code> do? How does it work?</p></li>
</ol>
</div>
</div>
<div id="subset-single" class="section level2">
<h2><span class="header-section-number">4.3</span> Selecting a single element</h2>
<p>
</p>
<p>There are two other subsetting operators: <code>[[</code> and <code>$</code>. <code>[[</code> is used for extracting single items, while <code>x$y</code> is a useful shorthand for <code>x[[&quot;y&quot;]]</code>.</p>
<div id="section" class="section level3">
<h3><span class="header-section-number">4.3.1</span> <code>[[</code></h3>

<p><code>[[</code> is most important when working with lists because subsetting a list with <code>[</code> always returns a smaller list. To help make this easier to understand we can use a metaphor:</p>
<blockquote>
<p>“If list <code>x</code> is a train carrying objects, then <code>x[[5]]</code> is
the object in car 5; <code>x[4:6]</code> is a train of cars 4-6.”</p>
<p>— @RLangTip, <a href="https://twitter.com/RLangTip/status/268375867468681216" class="uri">https://twitter.com/RLangTip/status/268375867468681216</a></p>
</blockquote>
<p>Let’s use this metaphor to make a simple list:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;a&quot;</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>)</code></pre>
<p><img src="diagrams/subsetting/train.png" width="444" style="display: block; margin: auto;" /></p>
<p>When extracting a single element, you have two options: you can create a smaller train, i.e., fewer carriages, or you can extract the contents of a particular carriage. This is the difference between <code>[</code> and <code>[[</code>:</p>
<p><img src="diagrams/subsetting/train-single.png" width="444" style="display: block; margin: auto;" /></p>
<p>When extracting multiple (or even zero!) elements, you have to make a smaller train:</p>
<p><img src="diagrams/subsetting/train-multiple.png" width="444" style="display: block; margin: auto;" /></p>
<p>Because <code>[[</code> can return only a single item, you must use it with either a single positive integer or a single string. If you use a vector with <code>[[</code>, it will subset recursively, i.e. <code>x[[c(1, 2)]]</code> is equivalent to <code>x[[1]][[2]]</code>. This is a quirky feature that few know about, so I recommend avoiding it in favour of <code>purrr::pluck()</code>, which you’ll learn about in Section <a href="#subsetting-oob">4.3.3</a>.</p>
<p>While you must use <code>[[</code> when working with lists, I’d also recommend using it with atomic vectors whenever you want to extract a single value. For example, instead of writing:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(x)) {
  out[i] &lt;-<span class="st"> </span><span class="kw">fun</span>(x[i], out[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>])
}</code></pre>
<p>It’s better to write:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(x)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">fun</span>(x[[i]], out[[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>]])
}</code></pre>
<p>Doing so reinforces the expectation that you are getting and setting individual values.</p>
</div>
<div id="section-1" class="section level3">
<h3><span class="header-section-number">4.3.2</span> <code>$</code></h3>

<p><code>$</code> is a shorthand operator: <code>x$y</code> is roughly equivalent to <code>x[[&quot;y&quot;]]</code>. It’s often used to access variables in a data frame, as in <code>mtcars$cyl</code> or <code>diamonds$carat</code>. One common mistake with <code>$</code> is to use it when you have the name of a column stored in a variable:</p>
<pre class="sourceCode r"><code class="sourceCode r">var &lt;-<span class="st"> &quot;cyl&quot;</span>
<span class="co"># Doesn&#39;t work - mtcars$var translated to mtcars[[&quot;var&quot;]]</span>
mtcars<span class="op">$</span>var
<span class="co">#&gt; NULL</span>

<span class="co"># Instead use [[</span>
mtcars[[var]]
<span class="co">#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4</span></code></pre>
<p>The one important difference between <code>$</code> and <code>[[</code> is that <code>$</code> does (left-to-right) partial matching:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">abc =</span> <span class="dv">1</span>)
x<span class="op">$</span>a
<span class="co">#&gt; [1] 1</span>
x[[<span class="st">&quot;a&quot;</span>]]
<span class="co">#&gt; NULL</span></code></pre>
<p>
To help avoid this behaviour I highly recommend setting the global option <code>warnPartialMatchDollar</code> to <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">warnPartialMatchDollar =</span> <span class="ot">TRUE</span>)
x<span class="op">$</span>a
<span class="co">#&gt; Warning in x$a: partial match of &#39;a&#39; to &#39;abc&#39;</span>
<span class="co">#&gt; [1] 1</span></code></pre>
<p>(For data frames, you can also avoid this problem by using tibbles, which never do partial matching.)</p>
</div>
<div id="subsetting-oob" class="section level3">
<h3><span class="header-section-number">4.3.3</span> Missing/out of bounds indices</h3>
<p>


</p>
<p>It’s useful to understand what happens with <code>[[</code> when you use an “invalid” index. The following table summarise what happens when you subset a logical vector, list, and <code>NULL</code> with a zero-length object (like <code>NULL</code> or <code>logical()</code>), out-of-bounds values (OOB), or a missing value (e.g. <code>NA_integer_</code>) with <code>[[</code>. Each cell shows the result of subsetting the data structure named in the row by the type of index described in the column. I’ve only shown the results for logical vectors, but other atomic vectors behave similarly, returning elements of the same type.</p>
<table>
<thead>
<tr class="header">
<th><code>row[[col]]</code></th>
<th>Zero-length</th>
<th>OOB (int)</th>
<th>OOB (chr)</th>
<th>Missing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Atomic</td>
<td>Error</td>
<td>Error</td>
<td>Error</td>
<td>Error</td>
</tr>
<tr class="even">
<td>List</td>
<td>Error</td>
<td>Error</td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
</tr>
<tr class="odd">
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
<td><code>NULL</code></td>
</tr>
</tbody>
</table>
<p>If the vector being indexed is named, then the names of OOB, missing, or <code>NULL</code> components will be <code>&quot;&lt;NA&gt;&quot;</code>.</p>
<p>The inconsistencies in the table above led to the development of <code>purrr::pluck()</code> and <code>purrr::chuck()</code>. When the element is missing, <code>pluck()</code> always returns <code>NULL</code> (or the value of the <code>.default</code> argument) and <code>chuck()</code> always throws an error. The behaviour of <code>pluck()</code> makes it well suited for indexing into deeply nested data structures where the component you want may not exist (as is common when working with JSON data from web APIs). <code>pluck()</code> also allows you to mix integer and character indices, and provides an alternative default value if an item does not exist:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">a =</span> <span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),
  <span class="dt">b =</span> <span class="kw">list</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>)
)

purrr<span class="op">::</span><span class="kw">pluck</span>(x, <span class="st">&quot;a&quot;</span>, <span class="dv">1</span>)
<span class="co">#&gt; [1] 1</span>

purrr<span class="op">::</span><span class="kw">pluck</span>(x, <span class="st">&quot;c&quot;</span>, <span class="dv">1</span>)
<span class="co">#&gt; NULL</span>

purrr<span class="op">::</span><span class="kw">pluck</span>(x, <span class="st">&quot;c&quot;</span>, <span class="dv">1</span>, <span class="dt">.default =</span> <span class="ot">NA</span>)
<span class="co">#&gt; [1] NA</span></code></pre>
</div>
<div id="and-slot" class="section level3">
<h3><span class="header-section-number">4.3.4</span> <code>@</code> and <code>slot()</code></h3>
<p>There are two additional subsetting operators, which are needed for S4 objects: <code>@</code> (equivalent to <code>$</code>), and <code>slot()</code> (equivalent to <code>[[</code>). <code>@</code> is more restrictive than <code>$</code> in that it will return an error if the slot does not exist. These are described in more detail in Chapter <a href="#s4">15</a>.</p>
</div>
<div id="exercises-10" class="section level3">
<h3><span class="header-section-number">4.3.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Brainstorm as many ways as possible to extract the third value from the
<code>cyl</code> variable in the <code>mtcars</code> dataset.</p></li>
<li><p>Given a linear model, e.g., <code>mod &lt;- lm(mpg ~ wt, data = mtcars)</code>, extract
the residual degrees of freedom. Then extract the R squared from the model
summary (<code>summary(mod)</code>)</p></li>
</ol>
<!-- FIXME: more examples -->
</div>
</div>
<div id="subassignment" class="section level2">
<h2><span class="header-section-number">4.4</span> Subsetting and assignment</h2>
<p>

</p>
<p>All subsetting operators can be combined with assignment to modify selected values of an input vector: this is called subassignment. The basic form is <code>x[i] &lt;- value</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">101</span>, <span class="dv">102</span>)
x
<span class="co">#&gt; [1] 101 102   3   4   5</span></code></pre>
<p>I recommend that you should make sure that <code>length(value)</code> is the same as <code>length(x[i])</code>, and that <code>i</code> is unique. This is because, while R will recycle if needed, those rules are complex (particularly if <code>i</code> contains missing or duplicated values) and may cause problems.</p>
<p>With lists, you can use <code>x[[i]] &lt;- NULL</code> to remove a component. To add a literal <code>NULL</code>, use <code>x[i] &lt;- list(NULL)</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
x[[<span class="st">&quot;b&quot;</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">str</span>(x)
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ a: num 1</span>

y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
y[<span class="st">&quot;b&quot;</span>] &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="ot">NULL</span>)
<span class="kw">str</span>(y)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ a: num 1</span>
<span class="co">#&gt;  $ b: NULL</span></code></pre>
<p>Subsetting with nothing can be useful with assignment because it preserves the structure of the original object. Compare the following two expressions. In the first, <code>mtcars</code> remains a data frame because you are only changing the contents of <code>mtcars</code>, not <code>mtcars</code> itself. In the second, <code>mtcars</code> becomes a list because you are changing the object it is bound to.</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[] &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, as.integer)
<span class="kw">is.data.frame</span>(mtcars)
<span class="co">#&gt; [1] TRUE</span>

mtcars &lt;-<span class="st"> </span><span class="kw">lapply</span>(mtcars, as.integer)
<span class="kw">is.data.frame</span>(mtcars)
<span class="co">#&gt; [1] FALSE</span></code></pre>
</div>
<div id="applications" class="section level2">
<h2><span class="header-section-number">4.5</span> Applications</h2>
<p>The principles described above have a wide variety of useful applications. Some of the most important are described below. While many of the basic principles of subsetting have already been incorporated into functions like <code>subset()</code>, <code>merge()</code>, <code>dplyr::arrange()</code>, a deeper understanding of how those principles have been implemented will be valuable when you run into situations where the functions you need don’t exist.</p>
<div id="lookup-tables" class="section level3">
<h3><span class="header-section-number">4.5.1</span> Lookup tables (character subsetting)</h3>
<p></p>
<p>Character matching is a powerful way to create lookup tables. Say you want to convert abbreviations:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;m&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;u&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;m&quot;</span>, <span class="st">&quot;m&quot;</span>)
lookup &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">m =</span> <span class="st">&quot;Male&quot;</span>, <span class="dt">f =</span> <span class="st">&quot;Female&quot;</span>, <span class="dt">u =</span> <span class="ot">NA</span>)
lookup[x]
<span class="co">#&gt;        m        f        u        f        f        m        m </span>
<span class="co">#&gt;   &quot;Male&quot; &quot;Female&quot;       NA &quot;Female&quot; &quot;Female&quot;   &quot;Male&quot;   &quot;Male&quot;</span></code></pre>
<p>Note that if you don’t want names in the result, use <code>unname()</code> to remove them.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unname</span>(lookup[x])
<span class="co">#&gt; [1] &quot;Male&quot;   &quot;Female&quot; NA       &quot;Female&quot; &quot;Female&quot; &quot;Male&quot;   &quot;Male&quot;</span></code></pre>
</div>
<div id="matching-merging" class="section level3">
<h3><span class="header-section-number">4.5.2</span> Matching and merging by hand (integer subsetting)</h3>
<p>
</p>
<p>You can also have more complicated lookup tables with multiple columns of information. For example, suppose we have a vector of integer grades, and a table that describes their properties:</p>
<pre class="sourceCode r"><code class="sourceCode r">grades &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>)

info &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">grade =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>,
  <span class="dt">desc =</span> <span class="kw">c</span>(<span class="st">&quot;Excellent&quot;</span>, <span class="st">&quot;Good&quot;</span>, <span class="st">&quot;Poor&quot;</span>),
  <span class="dt">fail =</span> <span class="kw">c</span>(F, F, T)
)</code></pre>
<p>Then, let’s say we want to duplicate the <code>info</code> table so that we have a row for each value in <code>grades</code>. An elegant way to do this is by combining <code>match()</code> and integer subsetting (<code>match(needles, haystack)</code> returns the position where each <code>needle</code> is found in the <code>haystack</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r">id &lt;-<span class="st"> </span><span class="kw">match</span>(grades, info<span class="op">$</span>grade)
id
<span class="co">#&gt; [1] 3 2 2 1 3</span>
info[id, ]
<span class="co">#&gt;     grade      desc  fail</span>
<span class="co">#&gt; 3       1      Poor  TRUE</span>
<span class="co">#&gt; 2       2      Good FALSE</span>
<span class="co">#&gt; 2.1     2      Good FALSE</span>
<span class="co">#&gt; 1       3 Excellent FALSE</span>
<span class="co">#&gt; 3.1     1      Poor  TRUE</span></code></pre>
<p>If you’re matching on multiple columns, you’ll need to first collapse them into a single column (with e.g. <code>interaction()</code>). Typically, however, you’re better off switching to a function designed specifically for joining multiple tables like <code>merge()</code>, or <code>dplyr::left_join()</code>.</p>
</div>
<div id="random-samplesbootstraps-integer-subsetting" class="section level3">
<h3><span class="header-section-number">4.5.3</span> Random samples/bootstraps (integer subsetting)</h3>
<p>
</p>
<p>You can use integer indices to randomly sample or bootstrap a vector or data frame. Just use <code>sample(n)</code> to generate a random permutation of <code>1:n</code>, and then use the results to subset the values:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">y =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>])

<span class="co"># Randomly reorder</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df)), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 1 1 5 a</span>
<span class="co">#&gt; 4 1 2 d</span>
<span class="co">#&gt; 2 2 4 b</span>
<span class="co">#&gt; 5 2 1 e</span>
<span class="co">#&gt; 3 3 3 c</span>

<span class="co"># Select 3 random rows</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dv">3</span>), ]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 3 3 3 c</span>
<span class="co">#&gt; 2 2 4 b</span>
<span class="co">#&gt; 1 1 5 a</span>

<span class="co"># Select 6 bootstrap replicates</span>
df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dv">6</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), ]
<span class="co">#&gt;     x y z</span>
<span class="co">#&gt; 4   1 2 d</span>
<span class="co">#&gt; 4.1 1 2 d</span>
<span class="co">#&gt; 5   2 1 e</span>
<span class="co">#&gt; 1   1 5 a</span>
<span class="co">#&gt; 1.1 1 5 a</span>
<span class="co">#&gt; 2   2 4 b</span></code></pre>
<p>The arguments of <code>sample()</code> control the number of samples to extract, and also whether sampling is done with or without replacement.</p>
</div>
<div id="ordering-integer-subsetting" class="section level3">
<h3><span class="header-section-number">4.5.4</span> Ordering (integer subsetting)</h3>

<p></p>
<p><code>order()</code> takes a vector as its input and returns an integer vector describing how to order the subsetted vector<span id="fn65" class="footnote" data-pagedown-footnote-number="65" style="white-space: pre-line;">These are “pull” indices, i.e., <code>order(x)[i]</code> is an index of where each <code>x[i]</code> is located. It is not an index of where <code>x[i]</code> should be sent.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;a&quot;</span>)
<span class="kw">order</span>(x)
<span class="co">#&gt; [1] 3 1 2</span>
x[<span class="kw">order</span>(x)]
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>To break ties, you can supply additional variables to <code>order()</code>. You can also change the order from ascending to descending by using <code>decreasing = TRUE</code>. By default, any missing values will be put at the end of the vector; however, you can remove them with <code>na.last = NA</code> or put them at the front with <code>na.last = FALSE</code>.</p>
<p>For two or more dimensions, <code>order()</code> and integer subsetting makes it easy to order either the rows or columns of an object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Randomly reorder df</span>
df2 &lt;-<span class="st"> </span>df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df)), <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>]
df2
<span class="co">#&gt;   z y x</span>
<span class="co">#&gt; 3 c 3 3</span>
<span class="co">#&gt; 1 a 5 1</span>
<span class="co">#&gt; 2 b 4 2</span>
<span class="co">#&gt; 4 d 2 1</span>
<span class="co">#&gt; 5 e 1 2</span>

df2[<span class="kw">order</span>(df2<span class="op">$</span>x), ]
<span class="co">#&gt;   z y x</span>
<span class="co">#&gt; 1 a 5 1</span>
<span class="co">#&gt; 4 d 2 1</span>
<span class="co">#&gt; 2 b 4 2</span>
<span class="co">#&gt; 5 e 1 2</span>
<span class="co">#&gt; 3 c 3 3</span>
df2[, <span class="kw">order</span>(<span class="kw">names</span>(df2))]
<span class="co">#&gt;   x y z</span>
<span class="co">#&gt; 3 3 3 c</span>
<span class="co">#&gt; 1 1 5 a</span>
<span class="co">#&gt; 2 2 4 b</span>
<span class="co">#&gt; 4 1 2 d</span>
<span class="co">#&gt; 5 2 1 e</span></code></pre>
<p>You can sort vectors directly with <code>sort()</code>, or similarly `dplyr::arrange(), to sort a data frame.</p>
</div>
<div id="expanding-aggregated-counts-integer-subsetting" class="section level3">
<h3><span class="header-section-number">4.5.5</span> Expanding aggregated counts (integer subsetting)</h3>
<p>Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. <code>rep()</code> and integer subsetting make it easy to uncollapse, because we can take advantage of <code>rep()</code>s vectorisation: <code>rep(x, y)</code> repeats <code>x[i]</code> <code>y[i]</code> times.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>), <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">9</span>, <span class="dv">11</span>, <span class="dv">6</span>), <span class="dt">n =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">1</span>))
<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(df), df<span class="op">$</span>n)
<span class="co">#&gt; [1] 1 1 1 2 2 2 2 2 3</span>

df[<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(df), df<span class="op">$</span>n), ]
<span class="co">#&gt;     x  y n</span>
<span class="co">#&gt; 1   2  9 3</span>
<span class="co">#&gt; 1.1 2  9 3</span>
<span class="co">#&gt; 1.2 2  9 3</span>
<span class="co">#&gt; 2   4 11 5</span>
<span class="co">#&gt; 2.1 4 11 5</span>
<span class="co">#&gt; 2.2 4 11 5</span>
<span class="co">#&gt; 2.3 4 11 5</span>
<span class="co">#&gt; 2.4 4 11 5</span>
<span class="co">#&gt; 3   1  6 1</span></code></pre>
</div>
<div id="removing-columns-from-data-frames-character-subsetting" class="section level3">
<h3><span class="header-section-number">4.5.6</span> Removing columns from data frames (character subsetting)</h3>
<p>There are two ways to remove columns from a data frame. You can set individual columns to <code>NULL</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
df<span class="op">$</span>z &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre>
<p>Or you can subset to return only the columns you want:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">z =</span> letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
df[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)]
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span></code></pre>
<p>If you only know the columns you don’t want, use set operations to work out which columns to keep:</p>
<pre class="sourceCode r"><code class="sourceCode r">df[<span class="kw">setdiff</span>(<span class="kw">names</span>(df), <span class="st">&quot;z&quot;</span>)]
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span>
<span class="co">#&gt; 2 2 2</span>
<span class="co">#&gt; 3 3 1</span></code></pre>
</div>
<div id="selecting-rows-based-on-a-condition-logical-subsetting" class="section level3">
<h3><span class="header-section-number">4.5.7</span> Selecting rows based on a condition (logical subsetting)</h3>
<p>
</p>
<p>Because logical subsetting allows you to easily combine conditions from multiple columns, it’s probably the most commonly used technique for extracting rows out of a data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[mtcars<span class="op">$</span>gear <span class="op">==</span><span class="st"> </span><span class="dv">5</span>, ]
<span class="co">#&gt;                 mpg cyl  disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2</span>
<span class="co">#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2</span>
<span class="co">#&gt; Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4</span>
<span class="co">#&gt; Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6</span>
<span class="co">#&gt; Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8</span>

mtcars[mtcars<span class="op">$</span>gear <span class="op">==</span><span class="st"> </span><span class="dv">5</span> <span class="op">&amp;</span><span class="st"> </span>mtcars<span class="op">$</span>cyl <span class="op">==</span><span class="st"> </span><span class="dv">4</span>, ]
<span class="co">#&gt;                mpg cyl  disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2</span>
<span class="co">#&gt; Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2</span></code></pre>
<p>Remember to use the vector boolean operators <code>&amp;</code> and <code>|</code>, not the short-circuiting scalar operators <code>&amp;&amp;</code> and <code>||</code>, which are more useful inside if statements. And don’t forget De Morgan’s laws<span id="fn66" class="footnote" data-pagedown-footnote-number="66" style="white-space: pre-line;"><a href="http://en.wikipedia.org/wiki/De_Morgan&#39;s_laws" class="uri">http://en.wikipedia.org/wiki/De_Morgan's_laws</a></span>, which can be useful to simplify negations:</p>
<ul>
<li><code>!(X &amp; Y)</code> is the same as <code>!X | !Y</code></li>
<li><code>!(X | Y)</code> is the same as <code>!X &amp; !Y</code></li>
</ul>
<p>For example, <code>!(X &amp; !(Y | Z))</code> simplifies to <code>!X | !!(Y|Z)</code>, and then to <code>!X | Y | Z</code>.</p>
</div>
<div id="boolean-algebra-vs.sets-logical-integer-subsetting" class="section level3">
<h3><span class="header-section-number">4.5.8</span> Boolean algebra vs. sets (logical &amp; integer subsetting)</h3>
<p>

</p>
<p>It’s useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:</p>
<ul>
<li><p>You want to find the first (or last) <code>TRUE</code>.</p></li>
<li><p>You have very few <code>TRUE</code>s and very many <code>FALSE</code>s; a set representation
may be faster and require less storage.</p></li>
</ul>
<p><code>which()</code> allows you to convert a boolean representation to an integer representation. There’s no reverse operation in base R but we can easily create one:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">10</span>) <span class="op">&lt;</span><span class="st"> </span><span class="dv">4</span>
<span class="kw">which</span>(x)
<span class="co">#&gt; [1] 2 5 8</span>

unwhich &lt;-<span class="st"> </span><span class="cf">function</span>(x, n) {
  out &lt;-<span class="st"> </span><span class="kw">rep_len</span>(<span class="ot">FALSE</span>, n)
  out[x] &lt;-<span class="st"> </span><span class="ot">TRUE</span>
  out
}
<span class="kw">unwhich</span>(<span class="kw">which</span>(x), <span class="dv">10</span>)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE</span></code></pre>
<p>Let’s create two logical vectors and their integer equivalents, and then explore the relationship between boolean and set operations.</p>
<pre class="sourceCode r"><code class="sourceCode r">(x1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</span>
(x2 &lt;-<span class="st"> </span><span class="kw">which</span>(x1))
<span class="co">#&gt; [1]  2  4  6  8 10</span>
(y1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">%%</span><span class="st"> </span><span class="dv">5</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)
<span class="co">#&gt;  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE</span>
(y2 &lt;-<span class="st"> </span><span class="kw">which</span>(y1))
<span class="co">#&gt; [1]  5 10</span>

<span class="co"># X &amp; Y &lt;-&gt; intersect(x, y)</span>
x1 <span class="op">&amp;</span><span class="st"> </span>y1
<span class="co">#&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</span>
<span class="kw">intersect</span>(x2, y2)
<span class="co">#&gt; [1] 10</span>

<span class="co"># X | Y &lt;-&gt; union(x, y)</span>
x1 <span class="op">|</span><span class="st"> </span>y1
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE</span>
<span class="kw">union</span>(x2, y2)
<span class="co">#&gt; [1]  2  4  6  8 10  5</span>

<span class="co"># X &amp; !Y &lt;-&gt; setdiff(x, y)</span>
x1 <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span>y1
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE</span>
<span class="kw">setdiff</span>(x2, y2)
<span class="co">#&gt; [1] 2 4 6 8</span>

<span class="co"># xor(X, Y) &lt;-&gt; setdiff(union(x, y), intersect(x, y))</span>
<span class="kw">xor</span>(x1, y1)
<span class="co">#&gt;  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE</span>
<span class="kw">setdiff</span>(<span class="kw">union</span>(x2, y2), <span class="kw">intersect</span>(x2, y2))
<span class="co">#&gt; [1] 2 4 6 8 5</span></code></pre>
<p>When first learning subsetting, a common mistake is to use <code>x[which(y)]</code> instead of <code>x[y]</code>. Here the <code>which()</code> achieves nothing: it switches from logical to integer subsetting but the result is exactly the same. In more general cases, there are two important differences.</p>
<ul>
<li><p>When the logical vector contains <code>NA</code>, logical subsetting replaces these
values with <code>NA</code> while <code>which()</code> simply drops these values. It’s not uncommon
to use <code>which()</code> for this side-effect, but I don’t recommend it: nothing
about the name “which” implies the removal of missing values.</p></li>
<li><p><code>x[-which(y)]</code> is <strong>not</strong> equivalent to <code>x[!y]</code>: if <code>y</code> is all FALSE,
<code>which(y)</code> will be <code>integer(0)</code> and <code>-integer(0)</code> is still <code>integer(0)</code>, so
you’ll get no values, instead of all values.</p></li>
</ul>
<p>In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last <code>TRUE</code> value.</p>
</div>
<div id="exercises-11" class="section level3">
<h3><span class="header-section-number">4.5.9</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How would you randomly permute the columns of a data frame? (This is an
important technique in random forests.) Can you simultaneously permute
the rows and columns in one step?</p></li>
<li><p>How would you select a random sample of <code>m</code> rows from a data frame?
What if the sample had to be contiguous (i.e., with an initial row, a
final row, and every row in between)?</p></li>
<li><p>How could you put the columns in a data frame in alphabetical order?</p></li>
</ol>
</div>
</div>
<div id="subsetting-answers" class="section level2">
<h2><span class="header-section-number">4.6</span> Answers</h2>
<ol style="list-style-type: decimal">
<li><p>Positive integers select elements at specific positions, negative integers
drop elements; logical vectors keep elements at positions corresponding to
<code>TRUE</code>; character vectors select elements with matching names.</p></li>
<li><p><code>[</code> selects sub-lists: it always returns a list. If you use it with a
single positive integer, it returns a list of length one. <code>[[</code> selects
an element within a list. <code>$</code> is a convenient shorthand: <code>x$y</code> is
equivalent to <code>x[[&quot;y&quot;]]</code>.</p></li>
<li><p>Use <code>drop = FALSE</code> if you are subsetting a matrix, array, or data frame
and you want to preserve the original dimensions. You should almost
always use it when subsetting inside a function.</p></li>
<li><p>If <code>x</code> is a matrix, <code>x[] &lt;- 0</code> will replace every element with 0,
keeping the same number of rows and columns. In contrast, <code>x &lt;- 0</code>
completely replaces the matrix with the value 0.</p></li>
<li><p>A named character vector can act as a simple lookup table:
<code>c(x = 1, y = 2, z = 3)[c(&quot;y&quot;, &quot;z&quot;, &quot;x&quot;)]</code></p></li>
</ol>
<!--chapter:end:Subsetting.Rmd-->
</div>
</div>
<div id="control-flow" class="section level1">
<h1><span class="header-section-number">5</span> Control flow</h1>
<div id="introduction-4" class="section level2">
<h2><span class="header-section-number">5.1</span> Introduction</h2>
<p>There are two primary tools of control flow: choices and loops. Choices, like <code>if</code> statements and <code>switch()</code> calls, allow you to run different code depending on the input. Loops, like <code>for</code> and <code>while</code>, allow you to repeatedly run code, typically with changing options. I’d expect that you’re already familiar with the basics of these functions so I’ll briefly cover some technical details and then introduce some useful, but lesser known, features.</p>
<p>The condition system (messages, warnings, and errors), which you’ll learn about them in Chapter <a href="#conditions">8</a>, also provides “non-local” control flow.</p>
<div id="quiz-3" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>Want to skip this chapter? Go for it, if you can answer the questions below. Find the answers at the end of the chapter in Section <a href="#control-flow-answers">5.4</a>.</p>
<ul>
<li><p>What is the different between <code>if</code> and <code>ifelse()</code>?</p></li>
<li><p>In the following code, what will the value of <code>y</code> be if <code>x</code> is <code>TRUE</code>?
What if <code>x</code> is <code>FALSE</code>? What if <code>x</code> is <code>NA</code>?</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="cf">if</span> (x) <span class="dv">3</span></code></pre></li>
<li><p>What does <code>switch(&quot;x&quot;, x = , y = 2, z = 3)</code> return?</p></li>
</ul>
</div>
<div id="outline-3" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#choices">5.2</a> dives into the details of <code>if</code>, then discusses
the close relatives <code>ifelse()</code> and <code>switch()</code>.</p></li>
<li><p>Section <a href="#loops">5.3</a> starts off by reminding you of the basic structure
of the for loop in R, discusses some common pitfalls, and then talks
about the related <code>while</code> and <code>repeat</code> statements.</p></li>
</ul>
</div>
</div>
<div id="choices" class="section level2">
<h2><span class="header-section-number">5.2</span> Choices</h2>

<p>The basic form of an if statement in R is as follows:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (condition) true_action
<span class="cf">if</span> (condition) true_action <span class="cf">else</span> false_action</code></pre>
<p>If <code>condition</code> is <code>TRUE</code>, <code>true_action</code> is evaluated; if <code>condition</code> is <code>FALSE</code>, the optional <code>false_action</code> is evaluated.</p>
<p>Typically the actions are compound statements contained within <code>{</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">grade &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (x <span class="op">&gt;</span><span class="st"> </span><span class="dv">90</span>) {
    <span class="st">&quot;A&quot;</span>
  } <span class="cf">else</span> <span class="cf">if</span> (x <span class="op">&gt;</span><span class="st"> </span><span class="dv">80</span>) {
    <span class="st">&quot;B&quot;</span>
  } <span class="cf">else</span> <span class="cf">if</span> (x <span class="op">&gt;</span><span class="st"> </span><span class="dv">50</span>) {
    <span class="st">&quot;C&quot;</span>
  } <span class="cf">else</span> {
    <span class="st">&quot;F&quot;</span>
  }
}</code></pre>
<p><code>if</code> returns a value so that you can assign the results:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="ot">TRUE</span>) <span class="dv">1</span> <span class="cf">else</span> <span class="dv">2</span>
x2 &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="ot">FALSE</span>) <span class="dv">1</span> <span class="cf">else</span> <span class="dv">2</span>

<span class="kw">c</span>(x1, x2)
<span class="co">#&gt; [1] 1 2</span></code></pre>
<p>(I recommend assigning the results of an <code>if</code> statement only when the entire expression fits on one line; otherwise it tends to be hard to read.)</p>
<p>When you use the single argument form without an else statement, <code>if</code> invisibly (Section <a href="#invisible">6.7.2</a>) returns <code>NULL</code> if the condition is <code>FALSE</code>. Since functions like <code>c()</code> and <code>paste()</code> drop <code>NULL</code> inputs, this allows for a compact expression of certain idioms:</p>
<pre class="sourceCode r"><code class="sourceCode r">greet &lt;-<span class="st"> </span><span class="cf">function</span>(name, <span class="dt">birthday =</span> <span class="ot">FALSE</span>) {
  <span class="kw">paste0</span>(
    <span class="st">&quot;Hi &quot;</span>, name,
    <span class="cf">if</span> (birthday) <span class="st">&quot; and HAPPY BIRTHDAY&quot;</span>
  )
}
<span class="kw">greet</span>(<span class="st">&quot;Maria&quot;</span>, <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] &quot;Hi Maria&quot;</span>
<span class="kw">greet</span>(<span class="st">&quot;Jaime&quot;</span>, <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] &quot;Hi Jaime and HAPPY BIRTHDAY&quot;</span></code></pre>
<div id="invalid-inputs" class="section level3">
<h3><span class="header-section-number">5.2.1</span> Invalid inputs</h3>
<p>The <code>condition</code> should evaluate to a single <code>TRUE</code> or <code>FALSE</code>. Most other inputs will generate an error:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (<span class="st">&quot;x&quot;</span>) <span class="dv">1</span>
<span class="co">#&gt; Error in if (&quot;x&quot;) 1:</span>
<span class="co">#&gt;   argument is not interpretable as logical</span>
<span class="cf">if</span> (<span class="kw">logical</span>()) <span class="dv">1</span>
<span class="co">#&gt; Error in if (logical()) 1:</span>
<span class="co">#&gt;   argument is of length zero</span>
<span class="cf">if</span> (<span class="ot">NA</span>) <span class="dv">1</span>
<span class="co">#&gt; Error in if (NA) 1:</span>
<span class="co">#&gt;   missing value where TRUE/FALSE needed</span></code></pre>
<p>The exception is a logical vector of length greater than 1, which generates a warning:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)) <span class="dv">1</span>
<span class="co">#&gt; Warning in if (c(TRUE, FALSE)) 1: the condition has length &gt; 1 and only the</span>
<span class="co">#&gt; first element will be used</span>
<span class="co">#&gt; [1] 1</span></code></pre>
<p>In R 3.5.0 and greater, thanks to Henrik Bengtsson<span id="fn67" class="footnote" data-pagedown-footnote-number="67" style="white-space: pre-line;"><a href="https://github.com/HenrikBengtsson/Wishlist-for-R/issues/38" class="uri">https://github.com/HenrikBengtsson/Wishlist-for-R/issues/38</a></span>, you can turn this into an error by setting an environment variable:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.setenv</span>(<span class="st">&quot;_R_CHECK_LENGTH_1_CONDITION_&quot;</span> =<span class="st"> &quot;true&quot;</span>)
<span class="cf">if</span> (<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)) <span class="dv">1</span>
<span class="co">#&gt; Error in if (c(TRUE, FALSE)) 1:</span>
<span class="co">#&gt;   the condition has length &gt; 1</span></code></pre>
<p>I think this is good practice as it reveals a clear mistake that you might otherwise miss if it were only shown as a warning.</p>
</div>
<div id="vectorised-if" class="section level3">
<h3><span class="header-section-number">5.2.2</span> Vectorised if</h3>

<p>Given that <code>if</code> only works with a single <code>TRUE</code> or <code>FALSE</code>, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of <code>ifelse()</code>: a vectorised function with <code>test</code>, <code>yes</code>, and <code>no</code> vectors (that will be recycled to the same length):</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="kw">ifelse</span>(x <span class="op">%%</span><span class="st"> </span><span class="dv">5</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;XXX&quot;</span>, <span class="kw">as.character</span>(x))
<span class="co">#&gt;  [1] &quot;1&quot;   &quot;2&quot;   &quot;3&quot;   &quot;4&quot;   &quot;XXX&quot; &quot;6&quot;   &quot;7&quot;   &quot;8&quot;   &quot;9&quot;   &quot;XXX&quot;</span>

<span class="kw">ifelse</span>(x <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;even&quot;</span>, <span class="st">&quot;odd&quot;</span>)
<span class="co">#&gt;  [1] &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot;</span></code></pre>
<p>Note that missing values will be propagated into the output.</p>
<p>I recommend using <code>ifelse()</code> only when the <code>yes</code> and <code>no</code> vectors are the same type as it is otherwise hard to predict the output type. See about <a href="https://vctrs.r-lib.org/articles/stability.html#ifelse" class="uri">https://vctrs.r-lib.org/articles/stability.html#ifelse</a> for additional discussion.</p>
<p>Another vectorised equivalent is the more general <code>dplyr::case_when()</code>. It uses a special syntax to allow any number of condition-vector pairs:</p>
<pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">case_when</span>(
  x <span class="op">%%</span><span class="st"> </span><span class="dv">35</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">~</span><span class="st"> &quot;fizz buzz&quot;</span>,
  x <span class="op">%%</span><span class="st"> </span><span class="dv">5</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">~</span><span class="st"> &quot;fizz&quot;</span>,
  x <span class="op">%%</span><span class="st"> </span><span class="dv">7</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">~</span><span class="st"> &quot;buzz&quot;</span>,
  <span class="kw">is.na</span>(x) <span class="op">~</span><span class="st"> &quot;???&quot;</span>,
  <span class="ot">TRUE</span> <span class="op">~</span><span class="st"> </span><span class="kw">as.character</span>(x)
)
<span class="co">#&gt;  [1] &quot;1&quot;    &quot;2&quot;    &quot;3&quot;    &quot;4&quot;    &quot;fizz&quot; &quot;6&quot;    &quot;buzz&quot; &quot;8&quot;    &quot;9&quot;    &quot;fizz&quot;</span></code></pre>
</div>
<div id="switch" class="section level3">
<h3><span class="header-section-number">5.2.3</span> <code>switch()</code> statement</h3>

<p>Closely related to <code>if</code> is the <code>switch()</code>-statement. It’s a compact, special purpose equivalent that lets you replace code like:</p>
<pre class="sourceCode r"><code class="sourceCode r">x_option &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (x <span class="op">==</span><span class="st"> &quot;a&quot;</span>) {
    <span class="st">&quot;option 1&quot;</span>
  } <span class="cf">else</span> <span class="cf">if</span> (x <span class="op">==</span><span class="st"> &quot;b&quot;</span>) {
    <span class="st">&quot;option 2&quot;</span> 
  } <span class="cf">else</span> <span class="cf">if</span> (x <span class="op">==</span><span class="st"> &quot;c&quot;</span>) {
    <span class="st">&quot;option 3&quot;</span>
  } <span class="cf">else</span> {
    <span class="kw">stop</span>(<span class="st">&quot;Invalid `x` value&quot;</span>)
  }
}</code></pre>
<p>with the more succinct:</p>
<pre class="sourceCode r"><code class="sourceCode r">x_option &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">switch</span>(x,
    <span class="dt">a =</span> <span class="st">&quot;option 1&quot;</span>,
    <span class="dt">b =</span> <span class="st">&quot;option 2&quot;</span>,
    <span class="dt">c =</span> <span class="st">&quot;option 3&quot;</span>,
    <span class="kw">stop</span>(<span class="st">&quot;Invalid `x` value&quot;</span>)
  )
}</code></pre>
<p>The last component of a <code>switch()</code> should always throw an error, otherwise unmatched inputs will invisibly return <code>NULL</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">(<span class="cf">switch</span>(<span class="st">&quot;c&quot;</span>, <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>))
<span class="co">#&gt; NULL</span></code></pre>
<p>If multiple inputs have the same output, you can leave the right hand side of <code>=</code> empty and the input will “fall through” to the next value. This mimics the behaviour of C’s <code>switch</code> statement:</p>
<pre class="sourceCode r"><code class="sourceCode r">legs &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">switch</span>(x,
    <span class="dt">cow =</span> ,
    <span class="dt">horse =</span> ,
    <span class="dt">dog =</span> <span class="dv">4</span>,
    <span class="dt">human =</span> ,
    <span class="dt">chicken =</span> <span class="dv">2</span>,
    <span class="dt">plant =</span> <span class="dv">0</span>,
    <span class="kw">stop</span>(<span class="st">&quot;Unknown input&quot;</span>)
  )
}
<span class="kw">legs</span>(<span class="st">&quot;cow&quot;</span>)
<span class="co">#&gt; [1] 4</span>
<span class="kw">legs</span>(<span class="st">&quot;dog&quot;</span>)
<span class="co">#&gt; [1] 4</span></code></pre>
<p>It is also possible to use <code>switch()</code> with a numeric <code>x</code>, but is harder to read, and has undesirable failure modes if <code>x</code> is a not a whole number. I recommend using <code>switch()</code> only with character inputs.</p>
</div>
<div id="exercises-12" class="section level3">
<h3><span class="header-section-number">5.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What type of vector does each of the following calls to <code>ifelse()</code>
return?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ifelse</span>(<span class="ot">TRUE</span>, <span class="dv">1</span>, <span class="st">&quot;no&quot;</span>)
<span class="kw">ifelse</span>(<span class="ot">FALSE</span>, <span class="dv">1</span>, <span class="st">&quot;no&quot;</span>)
<span class="kw">ifelse</span>(<span class="ot">NA</span>, <span class="dv">1</span>, <span class="st">&quot;no&quot;</span>)</code></pre>
<p>Read the documentation and write down the rules in your own words.</p></li>
<li><p>Why does the following code work?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="cf">if</span> (<span class="kw">length</span>(x)) <span class="st">&quot;not empty&quot;</span> <span class="cf">else</span> <span class="st">&quot;empty&quot;</span>
<span class="co">#&gt; [1] &quot;not empty&quot;</span>

x &lt;-<span class="st"> </span><span class="kw">numeric</span>()
<span class="cf">if</span> (<span class="kw">length</span>(x)) <span class="st">&quot;not empty&quot;</span> <span class="cf">else</span> <span class="st">&quot;empty&quot;</span>
<span class="co">#&gt; [1] &quot;empty&quot;</span></code></pre></li>
</ol>
</div>
</div>
<div id="loops" class="section level2">
<h2><span class="header-section-number">5.3</span> Loops</h2>
<p>

</p>
<p>For loops are used to iterate over items in a vector. They have the following basic form:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (item <span class="cf">in</span> vector) perform_action</code></pre>
<p><code>perform_action</code> is called once for each item in <code>vector</code>, rebinding the value of <code>item</code> each time.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>) {
  <span class="kw">print</span>(i)
}
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; [1] 3</span></code></pre>
<p>(When iterating over a vector of indices, it’s conventional to use very short variable names like <code>i</code>, <code>j</code>, or <code>k</code>.)</p>
<p>NB: <code>for</code> assigns the <code>item</code> in the current environment, so that an existing variable with the same name will be overwritten:</p>
<pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="dv">100</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>) {}
i
<span class="co">#&gt; [1] 3</span></code></pre>

<p>There are two ways to terminate a for loop early:</p>
<ul>
<li><code>next</code> terminates the current iteration and advances to the next.</li>
<li><code>break</code> exits the entire for loop.</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) {
  <span class="cf">if</span> (i <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span>) 
    <span class="cf">next</span>

  <span class="kw">print</span>(i)
  
  <span class="cf">if</span> (i <span class="op">&gt;=</span><span class="st"> </span><span class="dv">5</span>)
    <span class="cf">break</span>
}
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; [1] 4</span>
<span class="co">#&gt; [1] 5</span></code></pre>
<div id="common-pitfalls" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Common pitfalls</h3>
<p></p>
<p>There are three common problems that you might encounter when using <code>for</code>. First, if you’re generating data, make sure to preallocate the output. Otherwise the loop will be very slow; see Sections <a href="#memory-profiling">23.2.2</a> and <a href="#avoid-copies">24.6</a> for more details. The <code>vector()</code> function is helpful here.</p>
<pre class="sourceCode r"><code class="sourceCode r">means &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">50</span>, <span class="dv">20</span>)
out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(means))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(means)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>, means[[i]])
}</code></pre>
<p>Next, beware iterating over <code>1:length(x)</code>. This will fail in unhelpful ways if <code>x</code> has length 0:</p>
<pre class="sourceCode r"><code class="sourceCode r">means &lt;-<span class="st"> </span><span class="kw">c</span>()
out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(means))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(means)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>, means[[i]])
}
<span class="co">#&gt; Error in rnorm(10, means[[i]]):</span>
<span class="co">#&gt;   invalid arguments</span></code></pre>
<p>That’s because <code>:</code> works with both positive and increasing sequences:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(means)
<span class="co">#&gt; [1] 1 0</span></code></pre>
<p>Instead switch to <code>seq_along(x)</code> which always returns a value the same length as <code>x</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seq_along</span>(means)
<span class="co">#&gt; integer(0)</span>

out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(means))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(means)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>, means[[i]])
}</code></pre>
<p>Finally, you might encounter problems when iterating over S3 vectors, as loops typically strip the attributes:</p>
<pre class="sourceCode r"><code class="sourceCode r">xs &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="kw">c</span>(<span class="st">&quot;2020-01-01&quot;</span>, <span class="st">&quot;2010-01-01&quot;</span>))
<span class="cf">for</span> (x <span class="cf">in</span> xs) {
  <span class="kw">print</span>(x)
}
<span class="co">#&gt; [1] 18262</span>
<span class="co">#&gt; [1] 14610</span></code></pre>
<p>Work around this by calling <code>[[</code> yourself:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(xs)) {
  <span class="kw">print</span>(xs[[i]])
}
<span class="co">#&gt; [1] &quot;2020-01-01&quot;</span>
<span class="co">#&gt; [1] &quot;2010-01-01&quot;</span></code></pre>
</div>
<div id="for-family" class="section level3">
<h3><span class="header-section-number">5.3.2</span> Related tools</h3>

<p><code>for</code> loops are useful if you know in advance the set of values that you want to iterate over. There are two related tools with more flexible specifications:</p>
<ul>
<li><p><code>while(condition) action</code>: performs <code>action</code> while <code>condition</code> is <code>TRUE</code>.</p></li>
<li><p><code>repeat(action)</code>: repeats action forever (i.e. until it encounters <code>break</code>).</p></li>
</ul>
<p>R does not have an equivalent to the <code>do {action} while (condition)</code> syntax found in other languages.</p>
<p>You can rewrite any <code>for</code> loop to use <code>while</code> instead, and you can rewrite any <code>while</code> loop to use <code>repeat</code>, but the converses are not true. That means <code>while</code> is more flexible than <code>for</code>, and <code>repeat</code> is more flexible than <code>while</code>. It’s good practice to use the least-flexible solution to a problem, which means that you should use <code>for</code> where possible.</p>
<p>Generally speaking you should not need to use for loops for data analysis tasks, as <code>map()</code>/<code>apply()</code> functions provide an even less flexible solution to most problems. You’ll learn more in Chapter <a href="#functionals">9</a>.</p>
</div>
<div id="exercises-13" class="section level3">
<h3><span class="header-section-number">5.3.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why does this code succeed without errors or warnings?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">numeric</span>()
out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(x))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {
  out[i] &lt;-<span class="st"> </span>x[i] <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
}
out</code></pre></li>
<li><p>What does the following code tell you about when the vector being
iterated over is evaluated?</p>
<pre class="sourceCode r"><code class="sourceCode r">xs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="cf">for</span> (x <span class="cf">in</span> xs) {
  xs &lt;-<span class="st"> </span><span class="kw">c</span>(xs, x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)
}
xs
<span class="co">#&gt; [1] 1 2 3 2 4 6</span></code></pre></li>
<li><p>What does the following code tell you about when the index is updated?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>) {
  i &lt;-<span class="st"> </span>i <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
  <span class="kw">print</span>(i) 
}
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; [1] 4</span>
<span class="co">#&gt; [1] 6</span></code></pre></li>
</ol>
</div>
</div>
<div id="control-flow-answers" class="section level2">
<h2><span class="header-section-number">5.4</span> Answers</h2>
<ul>
<li><p><code>if</code> works with scalars; <code>ifelse()</code> works with vectors.</p></li>
<li><p>When <code>x</code> is <code>TRUE</code>, <code>y</code> will be <code>3</code>, when <code>FALSE</code> <code>y</code> will be <code>NULL</code>,
when <code>NA</code> the if statement will throw an error.</p></li>
<li><p>This <code>switch()</code> statement makes use of fall-through so it will return 2.
See details in Section <a href="#switch">5.2.3</a>.</p></li>
</ul>
<!--chapter:end:Control-flow.Rmd-->
</div>
</div>
<div id="functions" class="section level1">
<h1><span class="header-section-number">6</span> Functions</h1>
<div id="introduction-5" class="section level2">
<h2><span class="header-section-number">6.1</span> Introduction</h2>
<p>
</p>
<p>If you’re reading this book, you’ve probably already created many R functions and know how to use them to reduce duplication in your code. In this chapter, you’ll learn how to turn that informal, working knowledge into more rigorous, theoretical understanding. And while you’ll see some interesting tricks and techniques along the way, keep in mind that what you’ll learn here will be important for understanding the more advanced topics discussed later in the book.</p>
<div id="quiz-4" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>Answer the following questions to see if you can safely skip this chapter. You can find the answers in Section <a href="#function-answers">6.9</a>.</p>
<ol style="list-style-type: decimal">
<li><p>What are the three components of a function?</p></li>
<li><p>What does the following code return?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">function</span>() {
    x <span class="op">+</span><span class="st"> </span><span class="dv">10</span>
  }
}
<span class="kw">f1</span>(<span class="dv">1</span>)()</code></pre></li>
<li><p>How would you usually write this code?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">+</span><span class="st">`</span>(<span class="dv">1</span>, <span class="st">`</span><span class="dt">*</span><span class="st">`</span>(<span class="dv">2</span>, <span class="dv">3</span>))</code></pre></li>
<li><p>How could you make this call easier to read?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(, <span class="ot">TRUE</span>, <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="ot">NA</span>))</code></pre></li>
<li><p>Does the following code throw an error when executed? Why/why not?</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="cf">function</span>(a, b) {
  a <span class="op">*</span><span class="st"> </span><span class="dv">10</span>
}
<span class="kw">f2</span>(<span class="dv">10</span>, <span class="kw">stop</span>(<span class="st">&quot;This is an error!&quot;</span>))</code></pre></li>
<li><p>What is an infix function? How do you write it? What’s a replacement
function? How do you write it?</p></li>
<li><p>How do you ensure that cleanup action occurs regardless of how a function
exits?</p></li>
</ol>
</div>
<div id="outline-4" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#function-fundamentals">6.2</a> describes the basics of creating a
function, the three main components of a function, and the exception
to many function rules: primitive functions (which are implemented in C, not
R).</p></li>
<li><p>Section <a href="#function-composition">6.3</a> discusses the strengths and weaknesses
of the three forms of function composition commonly used in R code.</p></li>
<li><p>Section <a href="#lexical-scoping">6.4</a> shows you how R finds the value associated
with a given name, i.e. the rules of lexical scoping.</p></li>
<li><p>Section <a href="#lazy-evaluation">6.5</a> is devoted to an important property of
function arguments: they are only evaluated when used for the first time.</p></li>
<li><p>Section <a href="#fun-dot-dot-dot">6.6</a> discusses the special <code>...</code> argument, which
allows you to pass on extra arguments to another function.</p></li>
<li><p>Section <a href="#exiting-a-function">6.7</a> discusses the two primary ways that a
function can exit, and how to define an exit handler, code that is run on
exit, regardless of what triggers it.</p></li>
<li><p>Section <a href="#function-forms">6.8</a> shows you the various ways in which R
disguises ordinary function calls, and how you can use the standard prefix
form to better understand what’s going on.</p></li>
</ul>
</div>
</div>
<div id="function-fundamentals" class="section level2">
<h2><span class="header-section-number">6.2</span> Function fundamentals</h2>
<p>To understand functions in R you need to internalise two important ideas:</p>
<ul>
<li>Functions can be broken down into three components: arguments, body, and environment.</li>
</ul>
<p>There are exceptions to every rule, and in this case, there is a small selection of “primitive” base functions that are implemented purely in C.</p>
<ul>
<li>Functions are objects, just as vectors are objects.</li>
</ul>
<div id="fun-components" class="section level3">
<h3><span class="header-section-number">6.2.1</span> Function components</h3>
<p>






</p>
<p>A function has three parts:</p>
<ul>
<li><p>The <code>formals()</code>, the list of arguments that control how you call the function.</p></li>
<li><p>The <code>body()</code>, the code inside the function.</p></li>
<li><p>The <code>environment()</code>, the data structure that determines how the function finds
the values associated with the names.</p></li>
</ul>
<p>While the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on <em>where</em> you defined the function. The function environment always exists, but it is only printed when the function isn’t defined in the global environment.</p>
<pre class="sourceCode r"><code class="sourceCode r">f02 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  <span class="co"># A comment</span>
  x <span class="op">+</span><span class="st"> </span>y
}

<span class="kw">formals</span>(f02)
<span class="co">#&gt; $x</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>

<span class="kw">body</span>(f02)
<span class="co">#&gt; {</span>
<span class="co">#&gt;     x + y</span>
<span class="co">#&gt; }</span>

<span class="kw">environment</span>(f02)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span></code></pre>
<p>I’ll draw functions as in the following diagram. The black dot on the left is the environment. The two blocks to the right are the function arguments. I won’t draw the body, because it’s usually large, and doesn’t help you understand the “shape” of the function.</p>
<p><img src="diagrams/functions/components.png" width="118" style="display: block; margin: auto;" /></p>
<p>Like all objects in R, functions can also possess any number of additional <code>attributes()</code>. One attribute used by base R is “srcref”, short for source reference. It points to the source code used to create the function. The srcref is used for printing because, unlike <code>body()</code>, it contains code comments and other formatting.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(f02, <span class="st">&quot;srcref&quot;</span>)
<span class="co">#&gt; function(x, y) {</span>
<span class="co">#&gt;   # A comment</span>
<span class="co">#&gt;   x + y</span>
<span class="co">#&gt; }</span></code></pre>
</div>
<div id="primitive-functions" class="section level3">
<h3><span class="header-section-number">6.2.2</span> Primitive functions</h3>
<p>

</p>
<p>There is one exception to the rule that a function has three components. Primitive functions, like <code>sum()</code> and <code>[</code>, call C code directly.</p>
<pre class="sourceCode r"><code class="sourceCode r">sum
<span class="co">#&gt; function (..., na.rm = FALSE)  .Primitive(&quot;sum&quot;)</span>
<span class="st">`</span><span class="dt">[</span><span class="st">`</span>
<span class="co">#&gt; .Primitive(&quot;[&quot;)</span></code></pre>
<p>They have type “builtin” or “special”:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(sum)
<span class="co">#&gt; [1] &quot;builtin&quot;</span>
<span class="kw">typeof</span>(<span class="st">`</span><span class="dt">[</span><span class="st">`</span>)
<span class="co">#&gt; [1] &quot;special&quot;</span></code></pre>
<p>These functions exist primarily in C, not R, so their <code>formals()</code>, <code>body()</code>, and <code>environment()</code> are all <code>NULL</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">formals</span>(sum)
<span class="co">#&gt; NULL</span>
<span class="kw">body</span>(sum)
<span class="co">#&gt; NULL</span>
<span class="kw">environment</span>(sum)
<span class="co">#&gt; NULL</span></code></pre>
<p>Primitive functions are only found in the base package. While they have certain performance advantages, this benefit comes at a price: they are harder to write. For this reason, R-core generally avoids creating them unless there is no other option.</p>
<!-- HW: mention internal functions here too? Cross-reference to perf example -->
</div>
<div id="first-class-functions" class="section level3">
<h3><span class="header-section-number">6.2.3</span> First-class functions</h3>
<p>
</p>
<p>It’s very important to understand that R functions are objects in their own right, a language property often called “first-class functions”. Unlike in many other languages, there is no special syntax for defining and naming a function: you simply create a function object (with <code>function</code>) and bind it to a name with <code>&lt;-</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">sin</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
}</code></pre>
<p><img src="diagrams/functions/first-class.png" width="156" style="display: block; margin: auto;" /></p>
<p>While you almost always create a function and then bind it to a name, the binding step is not compulsory. If you choose not to give a function a name, you get an <strong>anonymous function</strong>. This is useful when it’s not worth the effort to figure out a name:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lapply</span>(mtcars, <span class="cf">function</span>(x) <span class="kw">length</span>(<span class="kw">unique</span>(x)))
<span class="kw">Filter</span>(<span class="cf">function</span>(x) <span class="op">!</span><span class="kw">is.numeric</span>(x), mtcars)
<span class="kw">integrate</span>(<span class="cf">function</span>(x) <span class="kw">sin</span>(x) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>, <span class="dv">0</span>, pi)</code></pre>
<p>A final option is to put functions in a list:</p>
<pre class="sourceCode r"><code class="sourceCode r">funs &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">half =</span> <span class="cf">function</span>(x) x <span class="op">/</span><span class="st"> </span><span class="dv">2</span>,
  <span class="dt">double =</span> <span class="cf">function</span>(x) x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
)

funs<span class="op">$</span><span class="kw">double</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] 20</span></code></pre>
<p>In R, you’ll often see functions called <strong>closures</strong>. This name reflects the fact that R functions capture, or enclose, their environments, which you’ll learn more about in Section <a href="#function-environments">7.4.2</a>.</p>
</div>
<div id="invoking-a-function" class="section level3">
<h3><span class="header-section-number">6.2.4</span> Invoking a function</h3>

<p>You normally call a function by placing with arguments wrapped in parentheses: <code>mean(1:10, na.rm = TRUE)</code>. But what happens if you have the arguments already in a data structure?</p>
<pre class="sourceCode r"><code class="sourceCode r">args &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre>
<p>You can instead use <code>do.call()</code>: it has two arguments. The function to call, and a list containing the function arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">do.call</span>(mean, args)
<span class="co">#&gt; [1] 5.5</span></code></pre>
<p>We’ll come back to this idea in Section <a href="#tidy-dots">19.6</a>.</p>
</div>
<div id="exercises-14" class="section level3">
<h3><span class="header-section-number">6.2.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Given a name, like <code>&quot;mean&quot;</code>, <code>match.fun()</code> lets you find a function.
Given a function, can you find its name? Why doesn’t that make sense in R?</p></li>
<li><p>It’s possible (although typically not useful) to call an anonymous function.
Which of the two approaches below is correct? Why?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span>(x) <span class="dv">3</span>()
<span class="co">#&gt; function(x) 3()</span>
(<span class="cf">function</span>(x) <span class="dv">3</span>)()
<span class="co">#&gt; [1] 3</span></code></pre></li>
<li><p>A good rule of thumb is that an anonymous function should fit on one line
and shouldn’t need to use <code>{}</code>. Review your code. Where could you have
used an anonymous function instead of a named function? Where should you
have used a named function instead of an anonymous function?</p></li>
<li><p>What function allows you to tell if an object is a function? What function
allows you to tell if a function is a primitive function?</p></li>
<li><p>This code makes a list of all functions in the base package.</p>
<pre class="sourceCode r"><code class="sourceCode r">objs &lt;-<span class="st"> </span><span class="kw">mget</span>(<span class="kw">ls</span>(<span class="st">&quot;package:base&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>), <span class="dt">inherits =</span> <span class="ot">TRUE</span>)
funs &lt;-<span class="st"> </span><span class="kw">Filter</span>(is.function, objs)</code></pre>
<p>Use it to answer the following questions:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Which base function has the most arguments?</p></li>
<li><p>How many base functions have no arguments? What’s special about those
functions?</p></li>
<li><p>How could you adapt the code to find all primitive functions?</p></li>
</ol></li>
<li><p>What are the three important components of a function?</p></li>
<li><p>When does printing a function not show the environment it was created in?</p></li>
</ol>
</div>
</div>
<div id="function-composition" class="section level2">
<h2><span class="header-section-number">6.3</span> Function composition</h2>
<p>


</p>
<p>Base R provides two ways to compose multiple function calls. For example, imagine you want to compute the population standard deviation using <code>sqrt()</code> and <code>mean()</code> as building blocks:</p>
<pre class="sourceCode r"><code class="sourceCode r">square &lt;-<span class="st"> </span><span class="cf">function</span>(x) x<span class="op">^</span><span class="dv">2</span>
deviation &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)</code></pre>
<p>You either nest the function calls:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)

<span class="kw">sqrt</span>(<span class="kw">mean</span>(<span class="kw">square</span>(<span class="kw">deviation</span>(x))))
<span class="co">#&gt; [1] 0.274</span></code></pre>
<p>Or you save the intermediate results as variables:</p>
<pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> </span><span class="kw">deviation</span>(x)
out &lt;-<span class="st"> </span><span class="kw">square</span>(out)
out &lt;-<span class="st"> </span><span class="kw">mean</span>(out)
out &lt;-<span class="st"> </span><span class="kw">sqrt</span>(out)
out
<span class="co">#&gt; [1] 0.274</span></code></pre>
<p>The magrittr package <span class="citation">(Bache and Wickham <a href="#ref-magrittr">2014</a>)</span> provides a third option: the binary operator <code>%&gt;%</code>, which is called the pipe and is pronounced as “and then”.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)

x <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">deviation</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">square</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mean</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">sqrt</span>()
<span class="co">#&gt; [1] 0.274</span></code></pre>
<p><code>x %&gt;% f()</code> is equivalent to <code>f(x)</code>; <code>x %&gt;% f(y)</code> is equivalent to <code>f(x, y)</code>. The pipe allows you to focus on the high-level composition of functions rather than the low-level flow of data; the focus is on what’s being done (the verbs), rather than on what’s being modified (the nouns). This style is common in Haskell and F#, the main inspiration for magrittr, and is the default style in stack based programming languages like Forth and Factor.</p>
<p>Each of the three options has its own strengths and weaknesses:</p>
<ul>
<li><p>Nesting, <code>f(g(x))</code>, is concise, and well suited for short sequences. But
longer sequences are hard to read because they are read inside out and
right to left. As a result, arguments can get spread out over long distances
creating the “Dagwood
sandwich<span id="fn68" class="footnote" data-pagedown-footnote-number="68" style="white-space: pre-line;"><a href="https://en.wikipedia.org/wiki/Dagwood_sandwich" class="uri">https://en.wikipedia.org/wiki/Dagwood_sandwich</a></span>” problem.</p></li>
<li><p>Intermediate objects, <code>y &lt;- f(x); g(y)</code>, requires you to name intermediate
objects. This is a strength when objects are important, but a weakness when
values are truly intermediate.</p></li>
<li><p>Piping, <code>x %&gt;% f() %&gt;% g()</code>, allows you to read code in straightforward
left-to-right fashion and doesn’t require you to name intermediate objects.
But you can only use it with linear sequences of transformations of a single
object. It also requires an additional third party package and assumes that
the reader understands piping.</p></li>
</ul>
<p>Most code will use a combination of all three styles. Piping is more common in data analysis code, as much of an analysis consists of a sequence of transformations of an object (like a data frame or plot). I tend to use piping infrequently in packages; not because it is a bad idea, but because it’s often a less natural fit.</p>
</div>
<div id="lexical-scoping" class="section level2">
<h2><span class="header-section-number">6.4</span> Lexical scoping</h2>
<p></p>
<p>In Chapter <a href="#names-values">2</a>, we discussed assignment, the act of binding a name to a value. Here we’ll discuss <strong>scoping</strong>, the act of finding the value associated with a name.</p>
<p>The basic rules of scoping are quite intuitive, and you’ve probably already internalised them, even if you never explicitly studied them. For example, what will the following code return, 10 or 20?<span id="fn69" class="footnote" data-pagedown-footnote-number="69" style="white-space: pre-line;">I’ll “hide” the answers to these challenges in the footnotes. Try solving them before looking at the answer; this will help you to better remember the correct answer. In this case, <code>g01()</code> will return <code>20</code>.</span></p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
g01 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  x &lt;-<span class="st"> </span><span class="dv">20</span>
  x
}

<span class="kw">g01</span>()</code></pre>
<p>In this section, you’ll learn the formal rules of scoping as well as some of its more subtle details. A deeper understanding of scoping will help you to use more advanced functional programming tools, and eventually, even to write tools that translate R code into other languages.</p>
<p>R uses <strong>lexical scoping</strong><span id="fn70" class="footnote" data-pagedown-footnote-number="70" style="white-space: pre-line;">Functions that automatically quote one or more arguments can override the default scoping rules to implement other varieties of scoping. You’ll learn more about that in Chapter <a href="#evaluation">20</a>.</span>: it looks up the values of names based on how a function is defined, not how it is called. “Lexical” here is not the English adjective “relating to words or a vocabulary”. It’s a technical CS term that tells us that the scoping rules use a parse-time, rather than a run-time structure.</p>
<p>R’s lexical scoping follows four primary rules:</p>
<ul>
<li>Name masking</li>
<li>Functions vs. variables</li>
<li>A fresh start</li>
<li>Dynamic lookup</li>
</ul>
<div id="name-masking" class="section level3">
<h3><span class="header-section-number">6.4.1</span> Name masking</h3>
<p></p>
<p>The basic principle of lexical scoping is that names defined inside a function mask names defined outside a function. This is illustrated in the following example.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
y &lt;-<span class="st"> </span><span class="dv">20</span>
g02 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  x &lt;-<span class="st"> </span><span class="dv">1</span>
  y &lt;-<span class="st"> </span><span class="dv">2</span>
  <span class="kw">c</span>(x, y)
}
<span class="kw">g02</span>()
<span class="co">#&gt; [1] 1 2</span></code></pre>
<p>If a name isn’t defined inside a function, R looks one level up.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">2</span>
g03 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  y &lt;-<span class="st"> </span><span class="dv">1</span>
  <span class="kw">c</span>(x, y)
}
<span class="kw">g03</span>()
<span class="co">#&gt; [1] 2 1</span>

<span class="co"># And this doesn&#39;t change the previous value of y</span>
y
<span class="co">#&gt; [1] 20</span></code></pre>
<p>The same rules apply if a function is defined inside another function. First, R looks inside the current function. Then, it looks where that function was defined (and so on, all the way up to the global environment). Finally, it looks in other loaded packages.</p>
<p>Run the following code in your head, then confirm the result by running the code.<span id="fn71" class="footnote" data-pagedown-footnote-number="71" style="white-space: pre-line;"><code>g04()</code> returns <code>c(1, 2, 3)</code>.</span></p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>
g04 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  y &lt;-<span class="st"> </span><span class="dv">2</span>
  i &lt;-<span class="st"> </span><span class="cf">function</span>() {
    z &lt;-<span class="st"> </span><span class="dv">3</span>
    <span class="kw">c</span>(x, y, z)
  }
  <span class="kw">i</span>()
}
<span class="kw">g04</span>()</code></pre>
<p>The same rules also apply to functions created by other functions, which I call manufactured functions, the topic of Chapter <a href="#function-factories">10</a>.</p>
</div>
<div id="functions-vs.variables" class="section level3">
<h3><span class="header-section-number">6.4.2</span> Functions vs. variables</h3>
<p>In R, functions are ordinary objects. This means the scoping rules described above also apply to functions:</p>
<pre class="sourceCode r"><code class="sourceCode r">g07 &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
g08 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  g07 &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">+</span><span class="st"> </span><span class="dv">100</span>
  <span class="kw">g07</span>(<span class="dv">10</span>)
}
<span class="kw">g08</span>()
<span class="co">#&gt; [1] 110</span></code></pre>
<p>However, when a function and a non-function share the same name (they must, of course, reside in different environments), applying these rules gets a little more complicated. When you use a name in a function call, R ignores non-function objects when looking for that value. For example, in the code below, <code>g09</code> takes on two different values:</p>
<pre class="sourceCode r"><code class="sourceCode r">g09 &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">+</span><span class="st"> </span><span class="dv">100</span>
g10 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  g09 &lt;-<span class="st"> </span><span class="dv">10</span>
  <span class="kw">g09</span>(g09)
}
<span class="kw">g10</span>()
<span class="co">#&gt; [1] 110</span></code></pre>
<p>For the record, using the same name for different things is confusing and best avoided!</p>
</div>
<div id="fresh-start" class="section level3">
<h3><span class="header-section-number">6.4.3</span> A fresh start</h3>
<p>What happens to values between invocations of a function? Consider the example below. What will happen the first time you run this function? What will happen the second time?<span id="fn72" class="footnote" data-pagedown-footnote-number="72" style="white-space: pre-line;"><code>g11()</code> returns <code>1</code> every time it’s called.</span> (If you haven’t seen <code>exists()</code> before, it returns <code>TRUE</code> if there’s a variable with that name and returns <code>FALSE</code> if not.)</p>
<pre class="sourceCode r"><code class="sourceCode r">g11 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">exists</span>(<span class="st">&quot;a&quot;</span>)) {
    a &lt;-<span class="st"> </span><span class="dv">1</span>
  } <span class="cf">else</span> {
    a &lt;-<span class="st"> </span>a <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  a
}

<span class="kw">g11</span>()
<span class="kw">g11</span>()</code></pre>
<p>You might be surprised that <code>g11()</code> always returns the same value. This happens because every time a function is called a new environment is created to host its execution. This means that a function has no way to tell what happened the last time it was run; each invocation is completely independent. (We’ll see some ways to get around this in Section <a href="#stateful-funs">10.2.4</a>)</p>
</div>
<div id="dynamic-lookup" class="section level3">
<h3><span class="header-section-number">6.4.4</span> Dynamic lookup</h3>

<p>Lexical scoping determines where, but not when to look for values. R looks for values when the function is run, not when the function is created. Together, these two properties tell us that the output of a function can differ depending on the objects outside the function’s environment:</p>
<pre class="sourceCode r"><code class="sourceCode r">g12 &lt;-<span class="st"> </span><span class="cf">function</span>() x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
x &lt;-<span class="st"> </span><span class="dv">15</span>
<span class="kw">g12</span>()
<span class="co">#&gt; [1] 16</span>

x &lt;-<span class="st"> </span><span class="dv">20</span>
<span class="kw">g12</span>()
<span class="co">#&gt; [1] 21</span></code></pre>
<p>This behaviour can be quite annoying. If you make a spelling mistake in your code, you won’t get an error message when you create the function. And depending on the variables defined in the global environment, you might not even get an error message when you run the function.</p>
<p>To detect this problem, use <code>codetools::findGlobals()</code>. This function lists all the external dependencies (unbound symbols) within a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">codetools<span class="op">::</span><span class="kw">findGlobals</span>(g12)
<span class="co">#&gt; [1] &quot;+&quot; &quot;x&quot;</span></code></pre>
<p>To solve this problem, you can manually change the function’s environment to the <code>emptyenv()</code>, an environment which contains nothing:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">environment</span>(g12) &lt;-<span class="st"> </span><span class="kw">emptyenv</span>()
<span class="kw">g12</span>()
<span class="co">#&gt; Error in x + 1:</span>
<span class="co">#&gt;   could not find function &quot;+&quot;</span></code></pre>
<p>The problem and its solution reveal why this seemingly undesirable behaviour exists: R relies on lexical scoping to find <em>everything</em>, from the obvious, like <code>mean()</code>, to the less obvious, like <code>+</code> or even <code>{</code>. This gives R’s scoping rules a rather beautiful simplicity.</p>
</div>
<div id="exercises-15" class="section level3">
<h3><span class="header-section-number">6.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What does the following code return? Why? Describe how each of the three
<code>c</code>’s is interpreted.</p>
<pre class="sourceCode r"><code class="sourceCode r">c &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">c</span>(<span class="dt">c =</span> c)</code></pre></li>
<li><p>What are the four principles that govern how R looks for values?</p></li>
<li><p>What does the following function return? Make a prediction before
running the code yourself.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  f &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
    f &lt;-<span class="st"> </span><span class="cf">function</span>() {
      x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
    }
    <span class="kw">f</span>() <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  <span class="kw">f</span>(x) <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
}
<span class="kw">f</span>(<span class="dv">10</span>)</code></pre></li>
</ol>
</div>
</div>
<div id="lazy-evaluation" class="section level2">
<h2><span class="header-section-number">6.5</span> Lazy evaluation</h2>
<p>

</p>
<p>In R, function arguments are <strong>lazily evaluated</strong>: they’re only evaluated if accessed. For example, this code doesn’t generate an error because <code>x</code> is never used:</p>
<pre class="sourceCode r"><code class="sourceCode r">h01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="dv">10</span>
}
<span class="kw">h01</span>(<span class="kw">stop</span>(<span class="st">&quot;This is an error!&quot;</span>))
<span class="co">#&gt; [1] 10</span></code></pre>
<p>This is an important feature because it allows you to do things like include potentially expensive computations in function arguments that will only be evaluated if needed.</p>
<div id="promises" class="section level3">
<h3><span class="header-section-number">6.5.1</span> Promises</h3>
<p>
</p>
<p>Lazy evaluation is powered by a data structure called a <strong>promise</strong>, or (less commonly) a thunk. It’s one of the features that makes R such an interesting programming language (we’ll return to promises again in Section <a href="#quosures">20.3</a>).</p>
<p>A promise has three components:</p>
<ul>
<li><p>An expression, like <code>x + y</code>, which gives rise to the delayed computation.</p></li>
<li><p>An environment where the expression should be evaluated, i.e. the
environment where the function is called. This makes sure that the
following function returns 11, not 101:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">10</span>
h02 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  y &lt;-<span class="st"> </span><span class="dv">100</span>
  x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
}

<span class="kw">h02</span>(y)
<span class="co">#&gt; [1] 11</span></code></pre>
<p>This also means that when you do assignment inside a call to a function,
the variable is bound outside of the function, not inside of it.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">h02</span>(y &lt;-<span class="st"> </span><span class="dv">1000</span>)
<span class="co">#&gt; [1] 1001</span>
y
<span class="co">#&gt; [1] 1000</span></code></pre></li>
<li><p>A value, which is computed and cached the first time a promise is
accessed when the expression is evaluated in the specified environment.
This ensures that the promise is evaluated at most once, and is why you
only see “Calculating…” printed once in the following example.</p>
<pre class="sourceCode r"><code class="sourceCode r">double &lt;-<span class="st"> </span><span class="cf">function</span>(x) { 
  <span class="kw">message</span>(<span class="st">&quot;Calculating...&quot;</span>)
  x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
}

h03 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">c</span>(x, x)
}

<span class="kw">h03</span>(<span class="kw">double</span>(x))
<span class="co">#&gt; Calculating...</span>
<span class="co">#&gt; [1] 40 40</span></code></pre></li>
</ul>
<p>You cannot manipulate promises with R code. Promises are like a quantum state: any attempt to inspect them with R code will force an immediate evaluation, making the promise disappear. Later, in Section <a href="#quosures">20.3</a>, you’ll learn about quosures, which reify promises into an R object where you can easily inspect the expression and the environment.</p>
</div>
<div id="default-arguments" class="section level3">
<h3><span class="header-section-number">6.5.2</span> Default arguments</h3>
<p></p>
<p>Thanks to lazy evaluation, default values can be defined in terms of other arguments, or even in terms of variables defined later in the function:</p>
<pre class="sourceCode r"><code class="sourceCode r">h04 &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>, <span class="dt">z =</span> a <span class="op">+</span><span class="st"> </span>b) {
  a &lt;-<span class="st"> </span><span class="dv">10</span>
  b &lt;-<span class="st"> </span><span class="dv">100</span>
  
  <span class="kw">c</span>(x, y, z)
}

<span class="kw">h04</span>()
<span class="co">#&gt; [1]   1   2 110</span></code></pre>
<p>Many base R functions use this technique, but I don’t recommend it. It makes the code harder to understand: to predict <em>what</em> will be returned, you need to know the exact order in which default arguments are evaluated.</p>
<p>The evaluation environment is slightly different for default and user supplied arguments, as default arguments are evaluated inside the function. This means that seemingly identical calls can yield different results. It’s easiest to see this with an extreme example:</p>
<pre class="sourceCode r"><code class="sourceCode r">h05 &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">ls</span>()) {
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  x
}

<span class="co"># ls() evaluated inside h05:</span>
<span class="kw">h05</span>()
<span class="co">#&gt; [1] &quot;a&quot; &quot;x&quot;</span>

<span class="co"># ls() evaluated in global environment:</span>
<span class="kw">h05</span>(<span class="kw">ls</span>())
<span class="co">#&gt; [1] &quot;h05&quot;</span></code></pre>
</div>
<div id="missing-arguments" class="section level3">
<h3><span class="header-section-number">6.5.3</span> Missing arguments</h3>
<p>
</p>
<p>To determine if an argument’s value comes from the user or from a default, you can use <code>missing()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">h06 &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">10</span>) {
  <span class="kw">list</span>(<span class="kw">missing</span>(x), x)
}
<span class="kw">str</span>(<span class="kw">h06</span>())
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ : logi TRUE</span>
<span class="co">#&gt;  $ : num 10</span>
<span class="kw">str</span>(<span class="kw">h06</span>(<span class="dv">10</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ : logi FALSE</span>
<span class="co">#&gt;  $ : num 10</span></code></pre>
<p><code>missing()</code> is best used sparingly, however. Take <code>sample()</code>, for example. How many arguments are required?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">args</span>(sample)
<span class="co">#&gt; function (x, size, replace = FALSE, prob = NULL) </span>
<span class="co">#&gt; NULL</span></code></pre>
<p>It looks like both <code>x</code> and <code>size</code> are required, but in fact if it’s not supplied, <code>sample()</code> uses <code>missing()</code> to provide a default for <code>size</code>. If I were to rewrite sample, I’d use an explicit <code>NULL</code> to indicate that <code>size</code> is not required but can be supplied:</p>
<pre class="sourceCode r"><code class="sourceCode r">sample &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">size =</span> <span class="ot">NULL</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>, <span class="dt">prob =</span> <span class="ot">NULL</span>) {
  <span class="cf">if</span> (<span class="kw">is.null</span>(size)) {
    size &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  }
  
  x[<span class="kw">sample.int</span>(<span class="kw">length</span>(x), size, <span class="dt">replace =</span> replace, <span class="dt">prob =</span> prob)]
}</code></pre>
<p>With the binary pattern created by the <code>%||%</code> infix function, which uses the left side if it’s not <code>NULL</code> and the right side otherwise, we can further simplify <code>sample()</code>:
</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">%||%</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(lhs, rhs) {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(lhs)) {
    lhs
  } <span class="cf">else</span> {
    rhs
  }
}

sample &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">size =</span> <span class="ot">NULL</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>, <span class="dt">prob =</span> <span class="ot">NULL</span>) {
  size &lt;-<span class="st"> </span>size <span class="op">%||%</span><span class="st"> </span><span class="kw">length</span>(x)
  x[<span class="kw">sample.int</span>(<span class="kw">length</span>(x), size, <span class="dt">replace =</span> replace, <span class="dt">prob =</span> prob)]
}</code></pre>
<p>Because of lazy evaluation, you don’t need to worry about unnecessary computation: the right side of <code>%||%</code> will only be evaluated if the left side is <code>NULL</code>.</p>
</div>
<div id="exercises-16" class="section level3">
<h3><span class="header-section-number">6.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What important property of <code>&amp;&amp;</code> makes <code>x_ok()</code> work?</p>
<pre class="sourceCode r"><code class="sourceCode r">x_ok &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="op">!</span><span class="kw">is.null</span>(x) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">1</span> <span class="op">&amp;&amp;</span><span class="st"> </span>x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>
}

<span class="kw">x_ok</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">x_ok</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">x_ok</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>What is different with this code? Why is this behaviour undesirable here?</p>
<pre class="sourceCode r"><code class="sourceCode r">x_ok &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="op">!</span><span class="kw">is.null</span>(x) <span class="op">&amp;</span><span class="st"> </span><span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">1</span> <span class="op">&amp;</span><span class="st"> </span>x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>
}

<span class="kw">x_ok</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; logical(0)</span>
<span class="kw">x_ok</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">x_ok</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; [1] FALSE FALSE FALSE</span></code></pre></li>
<li><p>What does this function return? Why? Which principle does it illustrate?</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> z) {
  z &lt;-<span class="st"> </span><span class="dv">100</span>
  x
}
<span class="kw">f2</span>()</code></pre></li>
<li><p>What does this function return? Why? Which principle does it illustrate?</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">10</span>
f1 &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> {y &lt;-<span class="st"> </span><span class="dv">1</span>; <span class="dv">2</span>}, <span class="dt">y =</span> <span class="dv">0</span>) {
  <span class="kw">c</span>(x, y)
}
<span class="kw">f1</span>()
y</code></pre></li>
<li><p>In <code>hist()</code>, the default value of <code>xlim</code> is <code>range(breaks)</code>, the default
value for <code>breaks</code> is <code>&quot;Sturges&quot;</code>, and</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range</span>(<span class="st">&quot;Sturges&quot;</span>)
<span class="co">#&gt; [1] &quot;Sturges&quot; &quot;Sturges&quot;</span></code></pre>
<p>Explain how <code>hist()</code> works to get a correct <code>xlim</code> value.</p></li>
<li><p>Explain why this function works. Why is it confusing?</p>
<pre class="sourceCode r"><code class="sourceCode r">show_time &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">stop</span>(<span class="st">&quot;Error!&quot;</span>)) {
  stop &lt;-<span class="st"> </span><span class="cf">function</span>(...) <span class="kw">Sys.time</span>()
  <span class="kw">print</span>(x)
}
<span class="kw">show_time</span>()
<span class="co">#&gt; [1] &quot;2019-01-24 04:32:59 UTC&quot;</span></code></pre></li>
<li><p>How many arguments are required when calling <code>library()</code>?</p></li>
</ol>
</div>
</div>
<div id="fun-dot-dot-dot" class="section level2">
<h2><span class="header-section-number">6.6</span> <code>...</code> (dot-dot-dot)</h2>

<p>

</p>
<p>Functions can have a special argument <code>...</code> (pronounced dot-dot-dot). With it, a function can take any number of additional arguments. In other programming languages, this type of argument is often called a varargs, and a function that uses it is said to be variadic.</p>
<p>You can also use <code>...</code> to pass those additional arguments on to another function.</p>
<pre class="sourceCode r"><code class="sourceCode r">i01 &lt;-<span class="st"> </span><span class="cf">function</span>(y, z) {
  <span class="kw">list</span>(<span class="dt">y =</span> y, <span class="dt">z =</span> z)
}

i02 &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  <span class="kw">i01</span>(...)
}

<span class="kw">str</span>(<span class="kw">i02</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>, <span class="dt">z =</span> <span class="dv">3</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ y: num 2</span>
<span class="co">#&gt;  $ z: num 3</span></code></pre>
<p>Using a special form, <code>..N</code>, it’s possible (but rarely useful) to refer to elements of <code>...</code> by position:</p>
<pre class="sourceCode r"><code class="sourceCode r">i03 &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  <span class="kw">list</span>(<span class="dt">first =</span> ..<span class="dv">1</span>, <span class="dt">third =</span> ..<span class="dv">3</span>)
}
<span class="kw">str</span>(<span class="kw">i03</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ first: num 1</span>
<span class="co">#&gt;  $ third: num 3</span></code></pre>
<p>More useful is <code>list(...)</code>, which evaluates the arguments and stores them in a list:</p>
<pre class="sourceCode r"><code class="sourceCode r">i04 &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  <span class="kw">list</span>(...)
}
<span class="kw">str</span>(<span class="kw">i04</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ a: num 1</span>
<span class="co">#&gt;  $ b: num 2</span></code></pre>
<p>(See also <code>rlang::list2()</code> to support splicing and to silently ignore trailing commas, and <code>rlang::enquos()</code> to capture unevaluated arguments, the topic of <a href="#quasiquotation">quasiquotation</a>.)</p>
<p>There are two primary uses of <code>...</code>, both of which we’ll come back to later in the book:</p>
<ul>
<li><p>If your function takes a function as an argument, you want some way to
pass additional arguments to that function. In this example, <code>lapply()</code>
uses <code>...</code> to pass <code>na.rm</code> on to <code>mean()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="ot">NA</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="ot">NA</span>, <span class="dv">6</span>))
<span class="kw">str</span>(<span class="kw">lapply</span>(x, mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ : num 2</span>
<span class="co">#&gt;  $ : num 5</span></code></pre>
<p>We’ll come back to this technique in Section <a href="#passing-arguments">9.2.3</a>.</p></li>
<li><p>If your function is an S3 generic, you need some way to allow methods to
take arbitrary extra arguments. For example, take the <code>print()</code> function.
Because there are different options for printing depending on the type of
object, there’s no way to pre-specify every possible argument. <code>...</code> is
what allow individual methods to have different arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">factor</span>(letters), <span class="dt">max.levels =</span> <span class="dv">4</span>)

<span class="kw">print</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">showEnv =</span> <span class="ot">TRUE</span>)</code></pre>
<p>We’ll come back to this use of <code>...</code> in Section <a href="#s3-arguments">13.4.3</a>.</p></li>
</ul>
<p>Using <code>...</code> comes with two downsides:</p>
<ul>
<li><p>When you use it to pass arguments to another function, you have to
carefully explain to the user where those arguments go. This makes it
hard to understand what you can do with functions like <code>lapply()</code> and
<code>plot()</code>.</p></li>
<li><p>A misspelled argument will not raise an error. This makes it easy for
typos to go unnoticed:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="dt">na_rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] NA</span></code></pre></li>
</ul>
<div id="exercises-17" class="section level3">
<h3><span class="header-section-number">6.6.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Explain the following results:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="co">#&gt; [1] 6</span>
<span class="kw">mean</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="co">#&gt; [1] 1</span>

<span class="kw">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dt">na.omit =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 7</span>
<span class="kw">mean</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dt">na.omit =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 1</span></code></pre></li>
<li><p>In the following call, explain how to find the documentation for the
named arguments in the following function call:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">xlab =</span> <span class="st">&quot;x&quot;</span>, <span class="dt">col.lab =</span> <span class="st">&quot;blue&quot;</span>)</code></pre>
<p><img src="Functions_files/figure-html/unnamed-chunk-58-1.png" width="70%" style="display: block; margin: auto;" /></p></li>
<li><p>Why does <code>plot(1:10, col = &quot;red&quot;)</code> only colour the points, not the axes
or labels? Read the source code of <code>plot.default()</code> to find out.</p></li>
</ol>
</div>
</div>
<div id="exiting-a-function" class="section level2">
<h2><span class="header-section-number">6.7</span> Exiting a function</h2>
<p>Most functions exit in one of two ways<span id="fn73" class="footnote" data-pagedown-footnote-number="73" style="white-space: pre-line;">Functions can exit in other more esoteric ways like signalling a condition that is caught by an exit handler, invoking a restart, or pressing “Q” in an interactive browser.</span>: they either return a value, indicating success, or they throw an error, indicating failure. This section describes return values (implicit vs. explicit; visible vs. invisible), briefly discusses errors, and introduces exit handlers, which allow you to run code when a function exits.</p>
<div id="implicit-vs.explicit-returns" class="section level3">
<h3><span class="header-section-number">6.7.1</span> Implicit vs. explicit returns</h3>
<p>
</p>
<p>There are two ways that a function can return a value:</p>
<ul>
<li><p>Implicitly, where the last evaluated expression is the return value:</p>
<pre class="sourceCode r"><code class="sourceCode r">j01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (x <span class="op">&lt;</span><span class="st"> </span><span class="dv">10</span>) {
    <span class="dv">0</span>
  } <span class="cf">else</span> {
    <span class="dv">10</span>
  }
}
<span class="kw">j01</span>(<span class="dv">5</span>)
<span class="co">#&gt; [1] 0</span>
<span class="kw">j01</span>(<span class="dv">15</span>)
<span class="co">#&gt; [1] 10</span></code></pre></li>
<li><p>Explicitly, by calling <code>return()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">j02 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (x <span class="op">&lt;</span><span class="st"> </span><span class="dv">10</span>) {
    <span class="kw">return</span>(<span class="dv">0</span>)
  } <span class="cf">else</span> {
    <span class="kw">return</span>(<span class="dv">10</span>)
  }
}</code></pre></li>
</ul>
</div>
<div id="invisible" class="section level3">
<h3><span class="header-section-number">6.7.2</span> Invisible values</h3>

<p>
</p>
<p>Most functions return visibly: calling the function in an interactive context prints the result.</p>
<pre class="sourceCode r"><code class="sourceCode r">j03 &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="dv">1</span>
<span class="kw">j03</span>()
<span class="co">#&gt; [1] 1</span></code></pre>
<p>However, you can prevent automatic printing by applying <code>invisible()</code> to the last value:</p>
<pre class="sourceCode r"><code class="sourceCode r">j04 &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">invisible</span>(<span class="dv">1</span>)
<span class="kw">j04</span>()</code></pre>
<p>To verify that this value does indeed exist, you can explicitly print it or wrap it in parentheses:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">j04</span>())
<span class="co">#&gt; [1] 1</span>

(<span class="kw">j04</span>())
<span class="co">#&gt; [1] 1</span></code></pre>
<p>Alternatively, you can use <code>withVisible()</code> to return the value and a visibility flag:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">withVisible</span>(<span class="kw">j04</span>()))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ value  : num 1</span>
<span class="co">#&gt;  $ visible: logi FALSE</span></code></pre>
<p>The most common function that returns invisibly is <code>&lt;-</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="dv">2</span>
(a &lt;-<span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; [1] 2</span></code></pre>
<p>This is what makes it possible to chain assignments:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span>b &lt;-<span class="st"> </span>c &lt;-<span class="st"> </span>d &lt;-<span class="st"> </span><span class="dv">2</span></code></pre>
<p>In general, any function called primarily for a side effect (like <code>&lt;-</code>, <code>print()</code>, or <code>plot()</code>) should return an invisible value (typically the value of the first argument).</p>
</div>
<div id="errors" class="section level3">
<h3><span class="header-section-number">6.7.3</span> Errors</h3>

<p></p>
<p>If a function cannot complete its assigned task, it should throw an error with <code>stop()</code>, which immediately terminates the execution of the function.</p>
<pre class="sourceCode r"><code class="sourceCode r">j05 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">stop</span>(<span class="st">&quot;I&#39;m an error&quot;</span>)
  <span class="kw">return</span>(<span class="dv">10</span>)
}
<span class="kw">j05</span>()
<span class="co">#&gt; Error in j05():</span>
<span class="co">#&gt;   I&#39;m an error</span></code></pre>
<p>An error indicates that something has gone wrong, and forces the user to deal with the problem. Some languages (like C, Go, and Rust) rely on special return values to indicate problems, but in R you should always throw an error. You’ll learn more about errors, and how to handle them, in <a href="#conditions">Conditions</a>.</p>
</div>
<div id="on-exit" class="section level3">
<h3><span class="header-section-number">6.7.4</span> Exit handlers</h3>

<p></p>
<p>Sometimes a function needs to make temporary changes to the global state. But having to cleanup those changes can be painful (what happens if there’s an error?). To ensure that these changes are undone and that the global state is restored no matter how a function exits, use <code>on.exit()</code> to set up an <strong>exit handler</strong>. The following simple example shows that the exit handler is run regardless of whether the function exits normally or with an error.</p>
<pre class="sourceCode r"><code class="sourceCode r">j06 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">cat</span>(<span class="st">&quot;Hello</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">on.exit</span>(<span class="kw">cat</span>(<span class="st">&quot;Goodbye!</span><span class="ch">\n</span><span class="st">&quot;</span>), <span class="dt">add =</span> <span class="ot">TRUE</span>)
  
  <span class="cf">if</span> (x) {
    <span class="kw">return</span>(<span class="dv">10</span>)
  } <span class="cf">else</span> {
    <span class="kw">stop</span>(<span class="st">&quot;Error&quot;</span>)
  }
}

<span class="kw">j06</span>(<span class="ot">TRUE</span>)
<span class="co">#&gt; Hello</span>
<span class="co">#&gt; Goodbye!</span>
<span class="co">#&gt; [1] 10</span>

<span class="kw">j06</span>(<span class="ot">FALSE</span>)
<span class="co">#&gt; Hello</span>
<span class="co">#&gt; Error in j06(FALSE):</span>
<span class="co">#&gt;   Error</span>
<span class="co">#&gt; Goodbye!</span></code></pre>
<div class="sidebar">
<p>Always set <code>add = TRUE</code> when using <code>on.exit()</code>. If you don’t, each call to <code>on.exit()</code> will overwrite the previous exit handler. Even when only registering a single handler, it’s good practice to set <code>add = TRUE</code> so that you won’t get any unpleasant surprises if you later add more exit handlers.</p>
</div>
<p><code>on.exit()</code> is useful because it allows you to place clean-up code directly next to the code that requires clean-up:</p>
<pre class="sourceCode r"><code class="sourceCode r">cleanup &lt;-<span class="st"> </span><span class="cf">function</span>(dir, code) {
  old_dir &lt;-<span class="st"> </span><span class="kw">setwd</span>(dir)
  <span class="kw">on.exit</span>(<span class="kw">setwd</span>(old_dir), <span class="dt">add =</span> <span class="ot">TRUE</span>)
  
  old_opt &lt;-<span class="st"> </span><span class="kw">options</span>(<span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
  <span class="kw">on.exit</span>(<span class="kw">options</span>(old_opt), <span class="dt">add =</span> <span class="ot">TRUE</span>)
}</code></pre>
<p>Coupled with lazy evaluation, this creates a very useful pattern for running a block of code in an altered environment:</p>
<pre class="sourceCode r"><code class="sourceCode r">with_dir &lt;-<span class="st"> </span><span class="cf">function</span>(dir, code) {
  old &lt;-<span class="st"> </span><span class="kw">setwd</span>(dir)
  <span class="kw">on.exit</span>(<span class="kw">setwd</span>(old), <span class="dt">add =</span> <span class="ot">TRUE</span>)

  <span class="kw">force</span>(code)
}

<span class="kw">getwd</span>()
<span class="co">#&gt; [1] &quot;/home/travis/build/liao961120/adv-r&quot;</span>
<span class="kw">with_dir</span>(<span class="st">&quot;~&quot;</span>, <span class="kw">getwd</span>())
<span class="co">#&gt; [1] &quot;/home/travis&quot;</span></code></pre>
<p>The use of <code>force()</code> isn’t strictly necessary here as simply referring to <code>code</code> will force its evaluation. However, using <code>force()</code> makes it very clear that we are deliberately forcing the execution. You’ll learn other uses of <code>force()</code> in Chapter <a href="#function-factories">10</a>.</p>
<p>The withr package <span class="citation">(Hester et al. <a href="#ref-withr">2018</a>)</span> provides a collection of other functions for setting up a temporary state.</p>
<p>In R 3.4 and earlier, <code>on.exit()</code> expressions are always run in order of creation:</p>
<pre class="sourceCode r"><code class="sourceCode r">j08 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">on.exit</span>(<span class="kw">message</span>(<span class="st">&quot;a&quot;</span>), <span class="dt">add =</span> <span class="ot">TRUE</span>)
  <span class="kw">on.exit</span>(<span class="kw">message</span>(<span class="st">&quot;b&quot;</span>), <span class="dt">add =</span> <span class="ot">TRUE</span>)
}
<span class="kw">j08</span>()
<span class="co">#&gt; a</span>
<span class="co">#&gt; b</span></code></pre>
<p>This can make cleanup a little tricky if some actions need to happen in a specific order; typically you want the most recent added expression to be run first. In R 3.5 and later, you can control this by setting <code>after = FALSE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">j09 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">on.exit</span>(<span class="kw">message</span>(<span class="st">&quot;a&quot;</span>), <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">after =</span> <span class="ot">FALSE</span>)
  <span class="kw">on.exit</span>(<span class="kw">message</span>(<span class="st">&quot;b&quot;</span>), <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">after =</span> <span class="ot">FALSE</span>)
}
<span class="kw">j09</span>()
<span class="co">#&gt; b</span>
<span class="co">#&gt; a</span></code></pre>
</div>
<div id="exercises-18" class="section level3">
<h3><span class="header-section-number">6.7.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What does <code>load()</code> return? Why don’t you normally see these values?</p></li>
<li><p>What does <code>write.table()</code> return? What would be more useful?</p></li>
<li><p>How does the <code>chdir</code> parameter of <code>source()</code> compare to <code>in_dir()</code>? Why
might you prefer one to the other?</p></li>
<li><p>Write a function that opens a graphics device, runs the supplied code, and
closes the graphics device (always, regardless of whether or not the
plotting code works).</p></li>
<li><p>We can use <code>on.exit()</code> to implement a simple version of <code>capture.output()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">capture.output2 &lt;-<span class="st"> </span><span class="cf">function</span>(code) {
  temp &lt;-<span class="st"> </span><span class="kw">tempfile</span>()
  <span class="kw">on.exit</span>(<span class="kw">file.remove</span>(temp), <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">after =</span> <span class="ot">TRUE</span>)

  <span class="kw">sink</span>(temp)
  <span class="kw">on.exit</span>(<span class="kw">sink</span>(), <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">after =</span> <span class="ot">TRUE</span>)

  <span class="kw">force</span>(code)
  <span class="kw">readLines</span>(temp)
}
<span class="kw">capture.output2</span>(<span class="kw">cat</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>Compare <code>capture.output()</code> to <code>capture.output2()</code>. How do the functions
differ? What features have I removed to make the key ideas easier to see?
How have I rewritten the key ideas so they’re easier to understand?</p></li>
</ol>
</div>
</div>
<div id="function-forms" class="section level2">
<h2><span class="header-section-number">6.8</span> Function forms</h2>
<blockquote>
<p>&quot;To understand computations in R, two slogans are helpful:</p>
<ul>
<li>Everything that exists is an object.</li>
<li>Everything that happens is a function call.&quot;</li>
</ul>
<p>— John Chambers</p>
</blockquote>
<p>While everything that happens in R is a result of a function call, not all calls look the same. Function calls come in four varieties:</p>
<ul>
<li><p><strong>prefix</strong>: the function name comes before its arguments, like
<code>foofy(a, b, c)</code>. These constitute of the majority of function calls in R.</p></li>
<li><p><strong>infix</strong>: the function name comes in between its arguments, like
<code>x + y</code>. Infix forms are used for many mathematical operators, and for
user-defined functions that begin and end with <code>%</code>.</p></li>
<li><p><strong>replacement</strong>: functions that replace values by assignment, like
<code>names(df) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code>. They actually look like prefix functions.</p></li>
<li><p><strong>special</strong>: functions like <code>[[</code>, <code>if</code>, and <code>for</code>. While they don’t have a
consistent structure, they play important roles in R’s syntax.</p></li>
</ul>
<p>While there are four forms, you actually only need one because any call can be written in prefix form. I’ll demonstrate this property, and then you’ll learn about each of the forms in turn.</p>
<div id="prefix-transform" class="section level3">
<h3><span class="header-section-number">6.8.1</span> Rewriting to prefix form</h3>
<p>

</p>
<p>An interesting property of R is that every infix, replacement, or special form can be rewritten in prefix form. Doing so is useful because it helps you better understand the structure of the language, it gives you the real name of every function, and it allows you to modify those functions for fun and profit.</p>
<p>The following example shows three pairs of equivalent calls, rewriting an infix form, replacement form, and a special form into prefix form.</p>
<pre class="sourceCode r"><code class="sourceCode r">x <span class="op">+</span><span class="st"> </span>y
<span class="st">`</span><span class="dt">+</span><span class="st">`</span>(x, y)

<span class="kw">names</span>(df) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)
<span class="st">`</span><span class="dt">names&lt;-</span><span class="st">`</span>(df, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>))

<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) <span class="kw">print</span>(i)
<span class="st">`</span><span class="dt">for</span><span class="st">`</span>(i, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="kw">print</span>(i))</code></pre>
<p>Suprisingly, in R, <code>for</code> can be called like a regular function! The same is true for basically every operation in R, which means that knowing the function name of a non-prefix function allows you to override its behaviour. For example, if you’re ever feeling particularly evil, run the following code while a friend is away from their computer. It will introduce a fun bug: 10% of the time, it will add 1 to any numeric calculation inside the parentheses.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">(</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(e1) {
  <span class="cf">if</span> (<span class="kw">is.numeric</span>(e1) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>) <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.1</span>) {
    e1 <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  } <span class="cf">else</span> {
    e1
  }
}
<span class="kw">replicate</span>(<span class="dv">50</span>, (<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>))
<span class="co">#&gt;  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</span>
<span class="co">#&gt; [36] 3 3 3 4 3 4 3 3 3 3 4 3 3 3 3</span>
<span class="kw">rm</span>(<span class="st">&quot;(&quot;</span>)</code></pre>
<p>Of course, overriding built-in functions like this is a bad idea, but, as you’ll learn in Section <a href="#html-env">21.2.5</a>, it’s possible to apply it only to selected code blocks. This provides a clean and elegant approach to writing domain specific languages and translators to other languages.</p>
<p>A more useful application comes up when using functional programming tools. For example, you could use <code>sapply()</code> to add 3 to every element of a list by first defining a function <code>add()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">add &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) x <span class="op">+</span><span class="st"> </span>y
<span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, add, <span class="dv">3</span>)
<span class="co">#&gt;  [1]  4  5  6  7  8  9 10 11 12 13</span></code></pre>
<p>But we can also get the same result simply by relying on the existing <code>+</code> function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>, <span class="dv">3</span>)
<span class="co">#&gt; [1] 4 5 6 7 8</span></code></pre>
<p>We’ll explore this idea in detail in Section <a href="#functionals">9</a>.</p>
</div>
<div id="prefix-form" class="section level3">
<h3><span class="header-section-number">6.8.2</span> Prefix form</h3>
<p>
</p>
<p>The prefix form is the most common form in R code, and indeed in the majority of programming languages. Prefix calls in R are a little special because you can specify arguments in three ways:</p>
<ul>
<li>By position, like <code>help(mean)</code>.</li>
<li>Using partial matching, like <code>help(top = mean)</code>.</li>
<li>By name, like <code>help(topic = mean)</code>.</li>
</ul>
<p>As illustrated by the following chunk, arguments are matched by exact name, then with unique prefixes, and finally by position.</p>
<pre class="sourceCode r"><code class="sourceCode r">k01 &lt;-<span class="st"> </span><span class="cf">function</span>(abcdef, bcde1, bcde2) {
  <span class="kw">list</span>(<span class="dt">a =</span> abcdef, <span class="dt">b1 =</span> bcde1, <span class="dt">b2 =</span> bcde2)
}
<span class="kw">str</span>(<span class="kw">k01</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ a : num 1</span>
<span class="co">#&gt;  $ b1: num 2</span>
<span class="co">#&gt;  $ b2: num 3</span>
<span class="kw">str</span>(<span class="kw">k01</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dt">abcdef =</span> <span class="dv">1</span>))
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ a : num 1</span>
<span class="co">#&gt;  $ b1: num 2</span>
<span class="co">#&gt;  $ b2: num 3</span>

<span class="co"># Can abbreviate long argument names:</span>
<span class="kw">str</span>(<span class="kw">k01</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dt">a =</span> <span class="dv">1</span>))
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ a : num 1</span>
<span class="co">#&gt;  $ b1: num 2</span>
<span class="co">#&gt;  $ b2: num 3</span>

<span class="co"># But this doesn&#39;t work because abbreviation is ambiguous</span>
<span class="kw">str</span>(<span class="kw">k01</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dt">b =</span> <span class="dv">1</span>))
<span class="co">#&gt; Error in k01(1, 3, b = 1):</span>
<span class="co">#&gt;   argument 3 matches multiple formal arguments</span></code></pre>
<p>In general, use positional matching only for the first one or two arguments; they will be the most commonly used, and most readers will know what they are. Avoid using positional matching for less commonly used arguments, and never use partial matching. Unfortunately you can’t disable partial matching, but you can turn it into a warning with the <code>warnPartialMatchArgs</code> option:
</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">warnPartialMatchArgs =</span> <span class="ot">TRUE</span>)
x &lt;-<span class="st"> </span><span class="kw">k01</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="co">#&gt; Warning in k01(a = 1, 2, 3): partial argument match of &#39;a&#39; to &#39;abcdef&#39;</span></code></pre>
</div>
<div id="infix-functions" class="section level3">
<h3><span class="header-section-number">6.8.3</span> Infix functions</h3>
<p>

</p>
<p>Infix functions get their name from the fact the function name comes <strong>in</strong>between its arguments, and hence have two arguments. R comes with a number of built-in infix operators: <code>:</code>, <code>::</code>, <code>:::</code>, <code>$</code>, <code>@</code>, <code>^</code>, <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>!</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>|</code>, <code>||</code>, <code>~</code>, <code>&lt;-</code>, and <code>&lt;&lt;-</code>. You can also create your own infix functions that start and end with <code>%</code>. Base R uses this pattern to define <code>%%</code>, <code>%*%</code>, <code>%/%</code>, <code>%in%</code>, <code>%o%</code>, and <code>%x%</code>.</p>
<p>Defining your own infix function is simple. You create a two argument function and bind it to a name that starts and ends with <code>%</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">%+%</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(a, b) <span class="kw">paste0</span>(a, b)
<span class="st">&quot;new &quot;</span> <span class="op">%+%</span><span class="st"> &quot;string&quot;</span>
<span class="co">#&gt; [1] &quot;new string&quot;</span></code></pre>
<p>The names of infix functions are more flexible than regular R functions: they can contain any sequence of characters except “%”. You will need to escape any special characters in the string used to define the function, but not when you call it:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">% %</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(a, b) <span class="kw">paste</span>(a, b)
<span class="st">`</span><span class="dt">%/</span><span class="ch">\\</span><span class="dt">%</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(a, b) <span class="kw">paste</span>(a, b)

<span class="st">&quot;a&quot;</span> <span class="op">% %</span><span class="st"> &quot;b&quot;</span>
<span class="co">#&gt; [1] &quot;a b&quot;</span>
<span class="st">&quot;a&quot;</span> <span class="op">%/\%</span><span class="st"> &quot;b&quot;</span>
<span class="co">#&gt; [1] &quot;a b&quot;</span></code></pre>
<p>R’s default precedence rules mean that infix operators are composed left to right:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">%-%</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(a, b) <span class="kw">paste0</span>(<span class="st">&quot;(&quot;</span>, a, <span class="st">&quot; %-% &quot;</span>, b, <span class="st">&quot;)&quot;</span>)
<span class="st">&quot;a&quot;</span> <span class="op">%-%</span><span class="st"> &quot;b&quot;</span> <span class="op">%-%</span><span class="st"> &quot;c&quot;</span>
<span class="co">#&gt; [1] &quot;((a %-% b) %-% c)&quot;</span></code></pre>
<p>There are two special infix functions that can be called with a single argument: <code>+</code> and <code>-</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">-1</span>
<span class="co">#&gt; [1] -1</span>
<span class="op">+</span><span class="dv">10</span>
<span class="co">#&gt; [1] 10</span></code></pre>
</div>
<div id="replacement-functions" class="section level3">
<h3><span class="header-section-number">6.8.4</span> Replacement functions</h3>
<p>

</p>
<p>Replacement functions act like they modify their arguments in place, and have the special name <code>xxx&lt;-</code>. They must have arguments named <code>x</code> and <code>value</code>, and must return the modified object. For example, the following function modifies the second element of a vector:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">second&lt;-</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, value) {
  x[<span class="dv">2</span>] &lt;-<span class="st"> </span>value
  x
}</code></pre>
<p>Replacement functions are used by placing the function call on the left side of <code>&lt;-</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="kw">second</span>(x) &lt;-<span class="st"> </span>5L
x
<span class="co">#&gt;  [1]  1  5  3  4  5  6  7  8  9 10</span></code></pre>
<p>I say they “act” like they modify their arguments in place, because, as discussed in <a href="#modify-in-place">Modify-in-place</a>, they actually create a modified copy. We can see that by using <code>tracemem()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="kw">tracemem</span>(x)
<span class="co">#&gt; &lt;0x7ffae71bd880&gt;</span>

<span class="kw">second</span>(x) &lt;-<span class="st"> </span>6L
<span class="co">#&gt; tracemem[0x7ffae71bd880 -&gt; 0x7ffae61b5480]: </span>
<span class="co">#&gt; tracemem[0x7ffae61b5480 -&gt; 0x7ffae73f0408]: second&lt;- </span></code></pre>
<p>If your replacement function needs additional arguments, place them between <code>x</code> and <code>value</code>, and call the replacement function with additional arguments on the left:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">modify&lt;-</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, position, value) {
  x[position] &lt;-<span class="st"> </span>value
  x
}
<span class="kw">modify</span>(x, <span class="dv">1</span>) &lt;-<span class="st"> </span><span class="dv">10</span>
x
<span class="co">#&gt;  [1] 10  5  3  4  5  6  7  8  9 10</span></code></pre>
<p>When you write <code>modify(x, 1) &lt;- 10</code>, behind the scenes R turns it into:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> `</span><span class="dt">modify&lt;-</span><span class="st">`</span>(x, <span class="dv">1</span>, <span class="dv">10</span>)</code></pre>
<p>Combining replacement with other functions requires more complex translation. For example:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)
<span class="kw">names</span>(x)
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span>

<span class="kw">names</span>(x)[<span class="dv">2</span>] &lt;-<span class="st"> &quot;two&quot;</span>
<span class="kw">names</span>(x)
<span class="co">#&gt; [1] &quot;a&quot;   &quot;two&quot; &quot;c&quot;</span></code></pre>
<p>Is translated into:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">*tmp*</span><span class="st">`</span> &lt;-<span class="st"> </span>x
x &lt;-<span class="st"> `</span><span class="dt">names&lt;-</span><span class="st">`</span>(<span class="st">`</span><span class="dt">*tmp*</span><span class="st">`</span>, <span class="st">`</span><span class="dt">[&lt;-</span><span class="st">`</span>(<span class="kw">names</span>(<span class="st">`</span><span class="dt">*tmp*</span><span class="st">`</span>), <span class="dv">2</span>, <span class="st">&quot;two&quot;</span>))
<span class="kw">rm</span>(<span class="st">`</span><span class="dt">*tmp*</span><span class="st">`</span>)</code></pre>
<p>(Yes, it really does create a local variable named <em>tmp</em>, which is removed afterwards.)</p>
</div>
<div id="special-forms" class="section level3">
<h3><span class="header-section-number">6.8.5</span> Special forms</h3>
<p>
</p>
<p>Finally, there are a bunch of language features that are usually written in special ways, but also have prefix forms. These include parentheses:</p>
<ul>
<li><code>(x)</code> (<code>`(`(x)</code>)</li>
<li><code>{x}</code> (<code>`{`(x)</code>).</li>
</ul>
<p>The subsetting operators:</p>
<ul>
<li><code>x[i]</code> (<code>`[`(x, i)</code>)</li>
<li><code>x[[i]]</code> (<code>`[[`(x, i)</code>)</li>
</ul>
<p>And the tools of control flow:</p>
<ul>
<li><code>if (cond) true</code> (<code>`if`(cond, true)</code>)</li>
<li><code>if (cond) true else false</code> (<code>`if`(cond, true, false)</code>)</li>
<li><code>for(var in seq) action</code> (<code>`for`(var, seq, action)</code>)</li>
<li><code>while(cond) action</code> (<code>`while`(cond, action)</code>)</li>
<li><code>repeat expr</code> (<code>`repeat`(expr)</code>)</li>
<li><code>next</code> (<code>`next`()</code>)</li>
<li><code>break</code> (<code>`break`()</code>)</li>
</ul>
<p>Finally, the most complex is the “function” function:</p>
<ul>
<li><code>function(arg1, arg2) {body}</code> (<code>`function`(alist(arg1, arg2), body, env)</code>)</li>
</ul>
<p>Knowing the name of the function that underlies a special form is useful for getting documentation: <code>?(</code> is a syntax error; <code>?`(`</code> will give you the documentation for parentheses.</p>
<p>All special forms are implemented as primitive functions (i.e. in C); this means printing these functions is not informative:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">for</span><span class="st">`</span>
<span class="co">#&gt; .Primitive(&quot;for&quot;)</span></code></pre>
</div>
<div id="exercises-19" class="section level3">
<h3><span class="header-section-number">6.8.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Rewrite the following code snippets into prefix form:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span>

<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span>)

<span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">5</span>) x[[<span class="dv">5</span>]] <span class="cf">else</span> x[[n]]</code></pre></li>
<li><p>Clarify the following list of odd function calls:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dv">20</span>, <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="ot">NA</span>))
y &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">1</span>, <span class="dv">20</span>)
<span class="kw">cor</span>(<span class="dt">m =</span> <span class="st">&quot;k&quot;</span>, <span class="dt">y =</span> y, <span class="dt">u =</span> <span class="st">&quot;p&quot;</span>, <span class="dt">x =</span> x)</code></pre></li>
<li><p>Explain why the following code fails:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">modify</span>(<span class="kw">get</span>(<span class="st">&quot;x&quot;</span>), <span class="dv">1</span>) &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="co">#&gt; Error: target of assignment expands to non-language object</span></code></pre></li>
<li><p>Create a replacement function that modifies a random location in a vector.</p></li>
<li><p>Write your own version of <code>+</code> that pastes its inputs together if they are
character vectors but behaves as usual otherwise. In other words, make this
code work:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] 3</span>

<span class="st">&quot;a&quot;</span> <span class="op">+</span><span class="st"> &quot;b&quot;</span>
<span class="co">#&gt; [1] &quot;ab&quot;</span></code></pre></li>
<li><p>Create a list of all the replacement functions found in the base package.
Which ones are primitive functions? (Hint: use <code>apropos()</code>)</p></li>
<li><p>What are valid names for user-created infix functions?</p></li>
<li><p>Create an infix <code>xor()</code> operator.</p></li>
<li><p>Create infix versions of the set functions <code>intersect()</code>, <code>union()</code>, and
<code>setdiff()</code>. You might call them <code>%n%</code>, <code>%u%</code>, and <code>%/%</code> to match
conventions from mathematics.</p></li>
</ol>
</div>
</div>
<div id="function-answers" class="section level2">
<h2><span class="header-section-number">6.9</span> Quiz answers</h2>
<ol style="list-style-type: decimal">
<li><p>The three components of a function are its body, arguments, and environment.</p></li>
<li><p><code>f1(1)()</code> returns 11.</p></li>
<li><p>You’d normally write it in infix style: <code>1 + (2 * 3)</code>.</p></li>
<li><p>Rewriting the call to <code>mean(c(1:10, NA), na.rm = TRUE)</code> is easier to
understand.</p></li>
<li><p>No, it does not throw an error because the second argument is never used
so it’s never evaluated.</p></li>
<li><p>See Sections <a href="#infix-functions">6.8.3</a> and <a href="#replacement-functions">6.8.4</a>.</p></li>
<li><p>You use <code>on.exit()</code>; see Section <a href="#on-exit">6.7.4</a> for details.</p></li>
</ol>
<!--chapter:end:Functions.Rmd-->
</div>
</div>
<div id="environments" class="section level1">
<h1><span class="header-section-number">7</span> Environments</h1>
<p></p>
<div id="introduction-6" class="section level2">
<h2><span class="header-section-number">7.1</span> Introduction</h2>
<p>The environment is the data structure that powers scoping. This chapter dives deep into environments, describing their structure in depth, and using them to improve your understanding of the four scoping rules described in Section <a href="#lexical-scoping">6.4</a>.
Understanding environments is not necessary for day-to-day use of R. But they are important to understand because they power many important R features like lexical scoping, namespaces, and R6 classes, and interact with evaluation to give you powerful tools for making domain specific languages, like dplyr and ggplot2.</p>
<div id="quiz-5" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>If you can answer the following questions correctly, you already know the most important topics in this chapter. You can find the answers at the end of the chapter in Section <a href="#env-answers">7.7</a>.</p>
<ol style="list-style-type: decimal">
<li><p>List at least three ways that an environment is different to a list.</p></li>
<li><p>What is the parent of the global environment? What is the only
environment that doesn’t have a parent?</p></li>
<li><p>What is the enclosing environment of a function? Why is it
important?</p></li>
<li><p>How do you determine the environment from which a function was called?</p></li>
<li><p>How are <code>&lt;-</code> and <code>&lt;&lt;-</code> different?</p></li>
</ol>
</div>
<div id="outline-5" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#env-basics">7.2</a> introduces you to the basic properties
of an environment and shows you how to create your own.</p></li>
<li><p>Section <a href="#env-recursion">7.3</a> provides a function template
for computing with environments, illustrating the idea with a useful
function.</p></li>
<li><p>Section <a href="#special-environments">7.4</a> describes environments used for special
purposes: for packages, within functions, for namespaces, and for
function execution.</p></li>
<li><p>Section <a href="#call-stack">7.5</a> explains the last important environment: the
caller environment. This requires you to learn about the “call stack”,
that describes how a function was called. You’ll have seen the call stack
before if you’ve ever called <code>traceback()</code> to aid debugging.</p></li>
<li><p>Section <a href="#explicit-envs">7.6</a> briefly discusses three places where
environments are useful data structures for solving other problems.</p></li>
</ul>
</div>
<div id="prerequisites-1" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>This chapter will use rlang<span id="fn74" class="footnote" data-pagedown-footnote-number="74" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span> functions for working with environments, because it allows us to focus on the essence of environments, rather than the incidental details.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)</code></pre>
<p>The <code>env_</code> functions in rlang are designed to work with the pipe: all take an environment as the first argument, and many also return an environment. I won’t use the pipe in this chapter in the interest of keeping the code as simple as possible, but you should consider it for your own code.</p>
</div>
</div>
<div id="env-basics" class="section level2">
<h2><span class="header-section-number">7.2</span> Environment basics</h2>
<p>Generally, an environment is similar to a named list, with four important exceptions:</p>
<ul>
<li><p>Every name must be unique.</p></li>
<li><p>The names in an environment are not ordered.</p></li>
<li><p>An environment has a parent.</p></li>
<li><p>Environments are not copied when modified.</p></li>
</ul>
<p>Let’s explore these ideas with code and pictures.</p>
<div id="basics" class="section level3">
<h3><span class="header-section-number">7.2.1</span> Basics</h3>
<p>


</p>
<p>To create an environment, use <code>rlang::env()</code>. It works like <code>list()</code>, taking a set of name-value pairs:</p>
<pre class="sourceCode r"><code class="sourceCode r">e1 &lt;-<span class="st"> </span><span class="kw">env</span>(
  <span class="dt">a =</span> <span class="ot">FALSE</span>,
  <span class="dt">b =</span> <span class="st">&quot;a&quot;</span>,
  <span class="dt">c =</span> <span class="fl">2.3</span>,
  <span class="dt">d =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
)</code></pre>
<div class="base">
<p>Use <code>new.env()</code> to create a new environment. Ignore the <code>hash</code> and <code>size</code> parameters; they are not needed. You cannot simultaneously create and define values; use <code>$&lt;-</code>, as shown below.</p>
</div>
<p>The job of an environment is to associate, or <strong>bind</strong>, a set of names to a set of values. You can think of an environment as a bag of names, with no implied order (i.e. it doesn’t make sense to ask which is the first element in an environment). For that reason, we’ll draw the environment as so:</p>
<p><img src="diagrams/environments/bindings.png" width="293" style="display: block; margin: auto;" /></p>
<p>As discussed in Section <a href="#env-modify">2.5.2</a>, environments have reference semantics: unlike most R objects, when you modify them, you modify them in place, and don’t create a copy. One important implication is that environments can “contain” themselves.</p>
<pre class="sourceCode r"><code class="sourceCode r">e1<span class="op">$</span>d &lt;-<span class="st"> </span>e1</code></pre>
<p><img src="diagrams/environments/loop.png" width="293" style="display: block; margin: auto;" /></p>
<p>Printing an environment just displays its memory address, which is not terribly useful:</p>
<pre class="sourceCode r"><code class="sourceCode r">e1
<span class="co">#&gt; &lt;environment: 0x2c51c88&gt;</span></code></pre>
<p>Instead, we’ll use <code>env_print()</code> which gives us a little more information:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_print</span>(e1)
<span class="co">#&gt; &lt;environment: 0x2c51c88&gt;</span>
<span class="co">#&gt; parent: &lt;environment: global&gt;</span>
<span class="co">#&gt; bindings:</span>
<span class="co">#&gt;  * a: &lt;lgl&gt;</span>
<span class="co">#&gt;  * b: &lt;chr&gt;</span>
<span class="co">#&gt;  * c: &lt;dbl&gt;</span>
<span class="co">#&gt;  * d: &lt;env&gt;</span></code></pre>
<p>You can use <code>env_names()</code> to get a character vector giving the current bindings</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_names</span>(e1)
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;</span></code></pre>
<div class="base">
<p>In R 3.2.0 and greater, use <code>names()</code> to list the bindings in an environment. If your code needs to work with R 3.1.0 or earlier, use <code>ls()</code>, but note that you’ll need to set <code>all.names = TRUE</code> to show all bindings.</p>
</div>
</div>
<div id="important-environments" class="section level3">
<h3><span class="header-section-number">7.2.2</span> Important environments</h3>
<p>
</p>
<p>We’ll talk in detail about special environments in <a href="#special-environments">7.4</a>, but for now we need to mention two. The current environment, or <code>current_env()</code> is the environment in which code is currently executing. When you’re experimenting interactively, that’s usually the global environment, or <code>global_env()</code>. The global environment is sometimes called your “workspace”, as it’s where all interactive (i.e. outside of a function) computation takes place.</p>
<p>To compare environments, you need to use <code>identical()</code> and not <code>==</code>. This is because <code>==</code> is a vectorised operator, and environments are not vectors.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(<span class="kw">global_env</span>(), <span class="kw">current_env</span>())
<span class="co">#&gt; [1] TRUE</span>

<span class="kw">global_env</span>() <span class="op">==</span><span class="st"> </span><span class="kw">current_env</span>()
<span class="co">#&gt; Error in global_env() == current_env():</span>
<span class="co">#&gt;   comparison (1) is possible only for atomic and list types</span></code></pre>
<div class="base">
<p>Access the global environment with <code>globalenv()</code> and the current environment with <code>environment()</code>. The global environment is printed as <code>Rf_GlobalEnv</code> and <code>.GlobalEnv</code>.</p>
</div>
</div>
<div id="parents" class="section level3">
<h3><span class="header-section-number">7.2.3</span> Parents</h3>
<p>
</p>
<p>Every environment has a <strong>parent</strong>, another environment. In diagrams, the parent is shown as a small pale blue circle and arrow that points to another environment. The parent is what’s used to implement lexical scoping: if a name is not found in an environment, then R will look in its parent (and so on). You can set the parent environment by supplying an unnamed argument to <code>env()</code>. If you don’t supply it, it defaults to the current environment. In the code below, <code>e2a</code> is the parent of <code>e2b</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">e2a &lt;-<span class="st"> </span><span class="kw">env</span>(<span class="dt">d =</span> <span class="dv">4</span>, <span class="dt">e =</span> <span class="dv">5</span>)
e2b &lt;-<span class="st"> </span><span class="kw">env</span>(e2a, <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)</code></pre>
<p><img src="diagrams/environments/parents.png" width="359" style="display: block; margin: auto;" /></p>
<p>To save space, I typically won’t draw all the ancestors; just remember whenever you see a pale blue circle, there’s a parent environment somewhere.</p>
<p>You can find the parent of an environment with <code>env_parent()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_parent</span>(e2b)
<span class="co">#&gt; &lt;environment: 0x57acf78&gt;</span>
<span class="kw">env_parent</span>(e2a)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span></code></pre>
<p>Only one environment doesn’t have a parent: the <strong>empty</strong> environment. I draw the empty environment with a hollow parent environment, and where space allows I’ll label it with <code>R_EmptyEnv</code>, the name R uses.</p>
<pre class="sourceCode r"><code class="sourceCode r">e2c &lt;-<span class="st"> </span><span class="kw">env</span>(<span class="kw">empty_env</span>(), <span class="dt">d =</span> <span class="dv">4</span>, <span class="dt">e =</span> <span class="dv">5</span>)
e2d &lt;-<span class="st"> </span><span class="kw">env</span>(e2c, <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)</code></pre>
<p><img src="diagrams/environments/parents-empty.png" width="359" style="display: block; margin: auto;" /></p>
<p>The ancestors of every environment eventually terminate with the empty environment. You can list see all ancestors with <code>env_parents()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_parents</span>(e2b)
<span class="co">#&gt; [[1]]   &lt;env: 0x57acf78&gt;</span>
<span class="co">#&gt; [[2]] $ &lt;env: global&gt;</span>
<span class="kw">env_parents</span>(e2d)
<span class="co">#&gt; [[1]]   &lt;env: 0x6967c10&gt;</span>
<span class="co">#&gt; [[2]] $ &lt;env: empty&gt;</span></code></pre>
<p>By default, <code>env_parents()</code> stops when it gets to the global environment. This is useful because the ancestors of the global environment include every attached package, which you can see if you override the default behaviour as below. We’ll come back to these environments in Section <a href="#search-path">7.4.1</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_parents</span>(e2b, <span class="dt">last =</span> <span class="kw">empty_env</span>())
<span class="co">#&gt;  [[1]]   &lt;env: 0x57acf78&gt;</span>
<span class="co">#&gt;  [[2]] $ &lt;env: global&gt;</span>
<span class="co">#&gt;  [[3]] $ &lt;env: package:rlang&gt;</span>
<span class="co">#&gt;  [[4]] $ &lt;env: package:stats&gt;</span>
<span class="co">#&gt;  [[5]] $ &lt;env: package:graphics&gt;</span>
<span class="co">#&gt;  [[6]] $ &lt;env: package:grDevices&gt;</span>
<span class="co">#&gt;  [[7]] $ &lt;env: package:utils&gt;</span>
<span class="co">#&gt;  [[8]] $ &lt;env: package:datasets&gt;</span>
<span class="co">#&gt;  [[9]] $ &lt;env: package:methods&gt;</span>
<span class="co">#&gt; [[10]] $ &lt;env: Autoloads&gt;</span>
<span class="co">#&gt; [[11]] $ &lt;env: package:base&gt;</span>
<span class="co">#&gt; [[12]] $ &lt;env: empty&gt;</span></code></pre>
<div class="base">
<p>Use <code>parent.env()</code> to find the parent of an environment. No base function returns all ancestors.</p>
</div>
</div>
<div id="super-assignment--" class="section level3">
<h3><span class="header-section-number">7.2.4</span> Super assignment, <code>&lt;&lt;-</code></h3>

<p>
</p>
<p>The ancestors of an environment have an important relationship to <code>&lt;&lt;-</code>. Regular assignment, <code>&lt;-</code>, always creates a variable in the current environment. Super assignment, <code>&lt;&lt;-</code>, never creates a variable in the current environment, but instead modifies an existing variable found in a parent environment.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">0</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>() {
  x &lt;&lt;-<span class="st"> </span><span class="dv">1</span>
}
<span class="kw">f</span>()
x
<span class="co">#&gt; [1] 1</span></code></pre>
<p>If <code>&lt;&lt;-</code> doesn’t find an existing variable, it will create one in the global environment. This is usually undesirable, because global variables introduce non-obvious dependencies between functions. <code>&lt;&lt;-</code> is most often used in conjunction with a function factory, as described in Section <a href="#stateful-funs">10.2.4</a>.</p>
</div>
<div id="getting-and-setting-1" class="section level3">
<h3><span class="header-section-number">7.2.5</span> Getting and setting</h3>
<p>
</p>
<p>You can get and set elements of an environment with <code>$</code> and <code>[[</code> in the same way as a list:</p>
<pre class="sourceCode r"><code class="sourceCode r">e3 &lt;-<span class="st"> </span><span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>)
e3<span class="op">$</span>x
<span class="co">#&gt; [1] 1</span>
e3<span class="op">$</span>z &lt;-<span class="st"> </span><span class="dv">3</span>
e3[[<span class="st">&quot;z&quot;</span>]]
<span class="co">#&gt; [1] 3</span></code></pre>
<p>But you can’t use <code>[[</code> with numeric indices, and you can’t use <code>[</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">e3[[<span class="dv">1</span>]]
<span class="co">#&gt; Error in e3[[1]]:</span>
<span class="co">#&gt;   wrong arguments for subsetting an environment</span>

e3[<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)]
<span class="co">#&gt; Error in e3[c(&quot;x&quot;, &quot;y&quot;)]:</span>
<span class="co">#&gt;   object of type &#39;environment&#39; is not subsettable</span></code></pre>
<p><code>$</code> and <code>[[</code> will return <code>NULL</code> if the binding doesn’t exist. Use <code>env_get()</code> if you want an error:</p>
<pre class="sourceCode r"><code class="sourceCode r">e3<span class="op">$</span>xyz
<span class="co">#&gt; NULL</span>

<span class="kw">env_get</span>(e3, <span class="st">&quot;xyz&quot;</span>)
<span class="co">#&gt; Error in env_get(e3, &quot;xyz&quot;):</span>
<span class="co">#&gt;   object &#39;xyz&#39; not found</span></code></pre>
<p>If you want to use a default value if the binding doesn’t exist, you can use the <code>default</code> argument.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_get</span>(e3, <span class="st">&quot;xyz&quot;</span>, <span class="dt">default =</span> <span class="ot">NA</span>)
<span class="co">#&gt; [1] NA</span></code></pre>
<p>There are two other ways to add bindings to an environment:</p>
<ul>
<li><p><code>env_poke()</code><span id="fn75" class="footnote" data-pagedown-footnote-number="75" style="white-space: pre-line;">You might wonder why rlang has <code>env_poke()</code> instead of <code>env_set()</code>.
This is for consistency: <code>_set()</code> functions return a modified copy;
<code>_poke()</code> functions modify in place.</span> takes a name (as string) and a value:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_poke</span>(e3, <span class="st">&quot;a&quot;</span>, <span class="dv">100</span>)
e3<span class="op">$</span>a
<span class="co">#&gt; [1] 100</span></code></pre></li>
<li><p><code>env_bind()</code> allows you to bind multiple values:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_bind</span>(e3, <span class="dt">a =</span> <span class="dv">10</span>, <span class="dt">b =</span> <span class="dv">20</span>)
<span class="kw">env_names</span>(e3)
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;a&quot; &quot;b&quot;</span></code></pre></li>
</ul>
<p>You can determine if an environment has a binding with <code>env_has()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_has</span>(e3, <span class="st">&quot;a&quot;</span>)
<span class="co">#&gt;    a </span>
<span class="co">#&gt; TRUE</span></code></pre>
<p>Unlike lists, setting an element to <code>NULL</code> does not remove it, because sometimes you want an name that refers to <code>NULL</code>. Instead, use <code>env_unbind()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">e3<span class="op">$</span>a &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">env_has</span>(e3, <span class="st">&quot;a&quot;</span>)
<span class="co">#&gt;    a </span>
<span class="co">#&gt; TRUE</span>

<span class="kw">env_unbind</span>(e3, <span class="st">&quot;a&quot;</span>)
<span class="kw">env_has</span>(e3, <span class="st">&quot;a&quot;</span>)
<span class="co">#&gt;     a </span>
<span class="co">#&gt; FALSE</span></code></pre>
<p>Unbinding a name doesn’t delete the object. That’s the job of the garbage collector, which automatically removes objects with no names binding to them. This process is described in more detail in Section <a href="#gc">2.6</a>.</p>
<div class="base">
<p>
See <code>get()</code>, <code>assign()</code>, <code>exists()</code>, and <code>rm()</code>. These are designed interactively for use with the current environment, so working with other environments is a little clunky. Also beware the <code>inherits</code> argument: it defaults to <code>TRUE</code> meaning that the base equivalents will inspect the supplied environment and all its ancestors.</p>
</div>
</div>
<div id="advanced-bindings" class="section level3">
<h3><span class="header-section-number">7.2.6</span> Advanced bindings</h3>
<p>



</p>
<p>There are two more exotic variants of <code>env_bind()</code>:</p>
<ul>
<li><p><code>env_bind_lazy()</code> creates <strong>delayed bindings</strong>, which are evaluated the
first time they are accessed. Behind the scenes, delayed bindings create
promises, so behave in the same way as function arguments.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_bind_lazy</span>(<span class="kw">current_env</span>(), <span class="dt">b =</span> {<span class="kw">Sys.sleep</span>(<span class="dv">1</span>); <span class="dv">1</span>})

<span class="kw">system.time</span>(<span class="kw">print</span>(b))
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;       0       0       1</span>
<span class="kw">system.time</span>(<span class="kw">print</span>(b))
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;       0       0       0</span></code></pre>
<p>The primary use of delayed bindings is in <code>autoload()</code>, which makes
allows R packages to provide datasets that behave like they are loaded in
memory, even though they’re only loaded from disk when needed.</p></li>
<li><p><code>env_bind_active()</code> creates <strong>active bindings</strong> which are re-computed every
time they’re accessed:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_bind_active</span>(<span class="kw">current_env</span>(), <span class="dt">z1 =</span> <span class="cf">function</span>(val) <span class="kw">runif</span>(<span class="dv">1</span>))

z1
<span class="co">#&gt; [1] 0.0808</span>
z1
<span class="co">#&gt; [1] 0.834</span></code></pre>
<p>Active bindings are used to implement R6’s active fields, which you’ll learn
about in Section <a href="#active-fields">14.3.2</a>.</p></li>
</ul>
<div class="base">
<p>See <code>?delayedAssign()</code> and <code>?makeActiveBinding()</code>.</p>
</div>
</div>
<div id="exercises-20" class="section level3">
<h3><span class="header-section-number">7.2.7</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>List three ways in which an environment differs from a list.</p></li>
<li><p>Create an environment as illustrated by this picture.</p>
<p><img src="diagrams/environments/recursive-1.png" width="142" style="display: block; margin: auto;" /></p></li>
<li><p>Create a pair of environments as illustrated by this picture.</p>
<p><img src="diagrams/environments/recursive-2.png" width="246" style="display: block; margin: auto;" /></p></li>
<li><p>Explain why <code>e[[1]]</code> and <code>e[c(&quot;a&quot;, &quot;b&quot;)]</code> don’t make sense when <code>e</code> is
an environment.</p></li>
<li><p>Create a version of <code>env_poke()</code> that will only bind new names, never
re-bind old names. Some programming languages only do this, and are known
as single assignment languages<span id="fn76" class="footnote" data-pagedown-footnote-number="76" style="white-space: pre-line;"><a href="http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment" class="uri">http://en.wikipedia.org/wiki/Assignment_(computer_science)#Single_assignment</a></span>.</p></li>
<li><p>What does this function do? How does it differ from <code>&lt;&lt;-</code> and why
might you prefer it?</p>
<pre class="sourceCode r"><code class="sourceCode r">rebind &lt;-<span class="st"> </span><span class="cf">function</span>(name, value, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  <span class="cf">if</span> (<span class="kw">identical</span>(env, <span class="kw">empty_env</span>())) {
    <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find `&quot;</span>, name, <span class="st">&quot;`&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  } <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">env_has</span>(env, name)) {
    <span class="kw">env_poke</span>(env, name, value)
  } <span class="cf">else</span> {
    <span class="kw">rebind</span>(name, value, <span class="kw">env_parent</span>(env))
  }
}
<span class="kw">rebind</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">10</span>)
<span class="co">#&gt; Error: Can&#39;t find `a`</span>
a &lt;-<span class="st"> </span><span class="dv">5</span>
<span class="kw">rebind</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">10</span>)
a
<span class="co">#&gt; [1] 10</span></code></pre></li>
</ol>
</div>
</div>
<div id="env-recursion" class="section level2">
<h2><span class="header-section-number">7.3</span> Recursing over environments</h2>
<p></p>
<p>If you want to operate on every ancestor of an environment, it’s often convenient to write a recursive function. This section shows you how, applying your new knowledge of environments to write a function that given a name, finds the environment <code>where()</code> that name is defined, using R’s regular scoping rules.</p>
<p>The definition of <code>where()</code> is straightforward. It has two arguments: the name to look for (as a string), and the environment in which to start the search. (We’ll learn why <code>caller_env()</code> is a good default in Section <a href="#call-stack">7.5</a>.)</p>
<pre class="sourceCode r"><code class="sourceCode r">where &lt;-<span class="st"> </span><span class="cf">function</span>(name, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  <span class="cf">if</span> (<span class="kw">identical</span>(env, <span class="kw">empty_env</span>())) {
    <span class="co"># Base case</span>
    <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t find &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  } <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">env_has</span>(env, name)) {
    <span class="co"># Success case</span>
    env
  } <span class="cf">else</span> {
    <span class="co"># Recursive case</span>
    <span class="kw">where</span>(name, <span class="kw">env_parent</span>(env))
  }
}</code></pre>
<p>There are three cases:</p>
<ul>
<li><p>The base case: we’ve reached the empty environment and haven’t found the
binding. We can’t go any further, so we throw an error.</p></li>
<li><p>The successful case: the name exists in this environment, so we return the
environment.</p></li>
<li><p>The recursive case: the name was not found in this environment, so try the
parent.</p></li>
</ul>
<p>These three cases are illustrated with these three examples:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">where</span>(<span class="st">&quot;yyy&quot;</span>)
<span class="co">#&gt; Error: Can&#39;t find yyy</span>

x &lt;-<span class="st"> </span><span class="dv">5</span>
<span class="kw">where</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span>

<span class="kw">where</span>(<span class="st">&quot;mean&quot;</span>)
<span class="co">#&gt; &lt;environment: base&gt;</span></code></pre>
<p>It might help to see a picture. Imagine you have two environments, as in the following code and diagram:</p>
<pre class="sourceCode r"><code class="sourceCode r">e4a &lt;-<span class="st"> </span><span class="kw">env</span>(<span class="kw">empty_env</span>(), <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>)
e4b &lt;-<span class="st"> </span><span class="kw">env</span>(e4a, <span class="dt">x =</span> <span class="dv">10</span>, <span class="dt">a =</span> <span class="dv">11</span>)</code></pre>
<p><img src="diagrams/environments/where-ex.png" width="354" style="display: block; margin: auto;" /></p>
<ul>
<li><p><code>where(&quot;a&quot;, e4b)</code> will find <code>a</code> in <code>e4b</code>.</p></li>
<li><p><code>where(&quot;b&quot;, e4b)</code> doesn’t find <code>b</code> in <code>e4b</code>, so it looks in its parent, <code>e4a</code>,
and finds it there.</p></li>
<li><p><code>where(&quot;c&quot;, e4b)</code> looks in <code>e4b</code>, then <code>e4a</code>, then hits the empty environment
and throws an error.</p></li>
</ul>
<p>It’s natural to work with environments recursively, so <code>where()</code> provides a useful template. Removing the specifics of <code>where()</code> shows the structure more clearly:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(..., <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  <span class="cf">if</span> (<span class="kw">identical</span>(env, <span class="kw">empty_env</span>())) {
    <span class="co"># base case</span>
  } <span class="cf">else</span> <span class="cf">if</span> (success) {
    <span class="co"># success case</span>
  } <span class="cf">else</span> {
    <span class="co"># recursive case</span>
    <span class="kw">f</span>(..., <span class="dt">env =</span> <span class="kw">env_parent</span>(env))
  }
}</code></pre>
<div class="sidebar">
<h3 id="iteration-vs-recursion" class="unnumbered">Iteration vs recursion</h3>
<p>It’s possible to use a loop instead of recursion. I think it’s harder to understand than the recursive version, but I include it because you might find it easier to see what’s happening if you haven’t written many recursive functions.</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="cf">function</span>(..., <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  <span class="cf">while</span> (<span class="op">!</span><span class="kw">identical</span>(env, <span class="kw">empty_env</span>())) {
    <span class="cf">if</span> (success) {
      <span class="co"># success case</span>
      <span class="kw">return</span>()
    }
    <span class="co"># inspect parent</span>
    env &lt;-<span class="st"> </span><span class="kw">env_parent</span>(env)
  }

  <span class="co"># base case</span>
}</code></pre>
</div>
<div id="exercises-21" class="section level3">
<h3><span class="header-section-number">7.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Modify <code>where()</code> to return <em>all</em> environments that contain a binding for
<code>name</code>. Carefully think through what type of object the function will
need to return.</p></li>
<li><p>Write a function called <code>fget()</code> that finds only function objects. It
should have two arguments, <code>name</code> and <code>env</code>, and should obey the regular
scoping rules for functions: if there’s an object with a matching name
that’s not a function, look in the parent. For an added challenge, also
add an <code>inherits</code> argument which controls whether the function recurses up
the parents or only looks in one environment.</p></li>
</ol>
</div>
</div>
<div id="special-environments" class="section level2">
<h2><span class="header-section-number">7.4</span> Special environments</h2>
<p>Most environments are not created by you (e.g. with <code>env()</code>) but are instead created by R. In this section, you’ll learn about the most important environments, starting with the package environments. You’ll then learn about the function environment bound to the function when it is created, and the (usually) ephemeral execution environment created every time the function is called. Finally, you’ll see how the package and function environments interact to support namespaces, which ensure that a package always behaves the same way, regardless of what other packages the user has loaded.</p>
<div id="search-path" class="section level3">
<h3><span class="header-section-number">7.4.1</span> Package environments and the search path</h3>

<p>

</p>
<p>Each package attached by <code>library()</code> or <code>require()</code> becomes one of the parents of the global environment. The immediate parent of the global environment is the last package you attached<span id="fn77" class="footnote" data-pagedown-footnote-number="77" style="white-space: pre-line;">Note the difference between attached and loaded. A package is loaded automatically if you access one of its functions using <code>::</code>; it is only <strong>attached</strong> to the search path by <code>library()</code> or <code>require()</code>.</span>, the parent of that package is the second to last package you attached, …</p>
<p><img src="diagrams/environments/search-path.png" width="416" style="display: block; margin: auto;" /></p>
<p>If you follow all the parents back, you see the order in which every package has been attached. This is known as the <strong>search path</strong> because all objects in these environments can be found from the top-level interactive workspace. You can see the names of these environments with <code>base::search()</code>, or the environments themselves with <code>rlang::search_envs()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">search</span>()
<span class="co">#&gt;  [1] &quot;.GlobalEnv&quot;        &quot;package:rlang&quot;     &quot;package:stats&quot;    </span>
<span class="co">#&gt;  [4] &quot;package:graphics&quot;  &quot;package:grDevices&quot; &quot;package:utils&quot;    </span>
<span class="co">#&gt;  [7] &quot;package:datasets&quot;  &quot;package:methods&quot;   &quot;Autoloads&quot;        </span>
<span class="co">#&gt; [10] &quot;package:base&quot;</span>

<span class="kw">search_envs</span>()
<span class="co">#&gt;  [[1]] $ &lt;env: global&gt;</span>
<span class="co">#&gt;  [[2]] $ &lt;env: package:rlang&gt;</span>
<span class="co">#&gt;  [[3]] $ &lt;env: package:stats&gt;</span>
<span class="co">#&gt;  [[4]] $ &lt;env: package:graphics&gt;</span>
<span class="co">#&gt;  [[5]] $ &lt;env: package:grDevices&gt;</span>
<span class="co">#&gt;  [[6]] $ &lt;env: package:utils&gt;</span>
<span class="co">#&gt;  [[7]] $ &lt;env: package:datasets&gt;</span>
<span class="co">#&gt;  [[8]] $ &lt;env: package:methods&gt;</span>
<span class="co">#&gt;  [[9]] $ &lt;env: Autoloads&gt;</span>
<span class="co">#&gt; [[10]] $ &lt;env: package:base&gt;</span></code></pre>
<p>The last two environments on the search path are always the same:</p>
<ul>
<li><p>The <code>Autoloads</code> environment uses delayed bindings to save memory by only
loading package objects (like big datasets) when needed.</p></li>
<li><p>The base environment, <code>package:base</code> or sometimes just <code>base</code>, is the
environment of the base package. It is special because it has to be able
to bootstrap the loading of all other packages. You can access it directly
with <code>base_env()</code>.</p></li>
</ul>
<p>Note that when you attach another package with <code>library()</code>, the parent environment of the global environment changes:</p>
<p><img src="diagrams/environments/search-path-2.png" width="416" style="display: block; margin: auto;" /></p>
</div>
<div id="function-environments" class="section level3">
<h3><span class="header-section-number">7.4.2</span> The function environment</h3>
<p>
</p>
<p>A function binds the current environment when it is created. This is called the <strong>function environment</strong>, and is used for lexical scoping. Across computer languages, functions that capture their environments are called <strong>closures</strong>, which is why this term is often used interchangeably with function in R’s documentation.</p>
<p>You can get the function environment with <code>fn_env()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">1</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">+</span><span class="st"> </span>y
<span class="kw">fn_env</span>(f)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span></code></pre>
<div class="base">
<p>Use <code>environment(f)</code> to access the environment of function <code>f</code>.</p>
</div>
<p>In diagrams, I’ll draw a function as a rectangle with a rounded end that binds an environment.</p>
<p><img src="diagrams/environments/binding.png" width="178" style="display: block; margin: auto;" /></p>
<p>In this case, <code>f()</code> binds the environment that binds the name <code>f</code> to the function. But that’s not always the case: in the following example <code>g</code> is bound in a new environment <code>e</code>, but <code>g()</code> binds the global environment. The distinction between binding and being bound by is subtle but important; the difference is how we find <code>g</code> vs. how <code>g</code> finds its variables.</p>
<pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">env</span>()
e<span class="op">$</span>g &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="dv">1</span></code></pre>
<p><img src="diagrams/environments/binding-2.png" width="166" style="display: block; margin: auto;" /></p>
</div>
<div id="namespaces" class="section level3">
<h3><span class="header-section-number">7.4.3</span> Namespaces</h3>
<p></p>
<p>In the diagram above, you saw that the parent environment of a package varies based on what other packages have been loaded. This seems worrying: doesn’t that mean that the package will find different functions if packages are loaded in a different order? The goal of <strong>namespaces</strong> is to make sure that this does not happen, and that every package works the same way regardless of what packages are attached by the user.</p>
<p>For example, take <code>sd()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">sd
<span class="co">#&gt; function (x, na.rm = FALSE) </span>
<span class="co">#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), </span>
<span class="co">#&gt;     na.rm = na.rm))</span>
<span class="co">#&gt; &lt;bytecode: 0x2e247b8&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:stats&gt;</span></code></pre>
<p><code>sd()</code> is defined in terms of <code>var()</code>, so you might worry that the result of <code>sd()</code> would be affected by any function called <code>var()</code> either in the global environment, or in one of the other attached packages. R avoids this problem by taking advantage of the function vs. binding environment described above. Every function in a package is associated with a pair of environments: the package environment, which you learned about earlier, and the <strong>namespace</strong> environment.</p>
<ul>
<li><p>The package environment is the external interface to the package. It’s how
you, the R user, find a function in an attached package or with <code>::</code>. Its
parent is determined by search path, i.e. the order in which packages have
been attached.</p></li>
<li><p>The namespace environment is the internal interface to the package. The
package environment controls how we find the function; the namespace
controls how the function finds its variables.</p></li>
</ul>
<p>Every binding in the package environment is also found in the namespace environment; this ensures every function can use every other function in the package. But some bindings only occur in the namespace environment. These are known as internal or non-exported objects, which make it possible to hide internal implementation details from the user.</p>
<p><img src="diagrams/environments/namespace-bind.png" width="200" style="display: block; margin: auto;" /></p>
<p>Every namespace environment has the same set of ancestors:</p>
<ul>
<li><p>Each namespace has an <strong>imports</strong> environment that contains bindings to all
the functions used by the package. The imports environment is controlled by
the package developer with the <code>NAMESPACE</code> file.</p></li>
<li><p>Explicitly importing every base function would be tiresome, so the parent
of the imports environment is the base <strong>namespace</strong>. The base namespace
contains the same bindings as the base environment, but it has a different
parent.</p></li>
<li><p>The parent of the base namespace is the global environment. This means that
if a binding isn’t defined in the imports environment the package will look
for it in the usual way. This is usually a bad idea (because it makes code
depend on other loaded packages), so <code>R CMD check</code> automatically warns about
such code. It is needed primarily for historical reasons, particularly due
to how S3 method dispatch works.</p></li>
</ul>
<p><img src="diagrams/environments/namespace-env.png" width="397" style="display: block; margin: auto;" /></p>
<p>Putting all these diagrams together we get:</p>
<p><img src="diagrams/environments/namespace.png" width="397" style="display: block; margin: auto;" /></p>
<p>So when <code>sd()</code> looks for the value of <code>var</code> it always finds it in a sequence of environments determined by the package developer, but not by the package user. This ensures that package code always works the same way regardless of what packages have been attached by the user.</p>
<p>There’s no direct link between the package and namespace environments; the link is defined by the function environments.</p>
</div>
<div id="execution-environments" class="section level3">
<h3><span class="header-section-number">7.4.4</span> Execution environments</h3>
<p>
</p>
<p>The last important topic we need to cover is the <strong>execution</strong> environment. What will the following function return the first time it’s run? What about the second?</p>
<pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">env_has</span>(<span class="kw">current_env</span>(), <span class="st">&quot;a&quot;</span>)) {
    <span class="kw">message</span>(<span class="st">&quot;Defining a&quot;</span>)
    a &lt;-<span class="st"> </span><span class="dv">1</span>
  } <span class="cf">else</span> {
    a &lt;-<span class="st"> </span>a <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  a
}</code></pre>
<p>Think about it for a moment before you read on.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">g</span>(<span class="dv">10</span>)
<span class="co">#&gt; Defining a</span>
<span class="co">#&gt; [1] 1</span>
<span class="kw">g</span>(<span class="dv">10</span>)
<span class="co">#&gt; Defining a</span>
<span class="co">#&gt; [1] 1</span></code></pre>
<p>This function returns the same value every time because of the fresh start principle, described in Section <a href="#fresh-start">6.4.3</a>. Each time a function is called, a new environment is created to host execution. This is called the execution environment, and its parent is the function environment. Let’s illustrate that process with a simpler function. I’ll draw execution environments with an indirect parent; the parent environment is found via the function environment.</p>
<pre class="sourceCode r"><code class="sourceCode r">h &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="co"># 1.</span>
  a &lt;-<span class="st"> </span><span class="dv">2</span> <span class="co"># 2.</span>
  x <span class="op">+</span><span class="st"> </span>a
}
y &lt;-<span class="st"> </span><span class="kw">h</span>(<span class="dv">1</span>) <span class="co"># 3.</span></code></pre>
<p><img src="diagrams/environments/execution.png" width="253" style="display: block; margin: auto;" /></p>
<p>An execution environment is usually ephemeral; once the function has completed, the environment will be garbage collected. There are several ways to make it stay around for longer. The first is to explicitly return it:</p>
<pre class="sourceCode r"><code class="sourceCode r">h2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  a &lt;-<span class="st"> </span>x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
  <span class="kw">current_env</span>()
}

e &lt;-<span class="st"> </span><span class="kw">h2</span>(<span class="dt">x =</span> <span class="dv">10</span>)
<span class="kw">env_print</span>(e)
<span class="co">#&gt; &lt;environment: 0x7aa8bd8&gt;</span>
<span class="co">#&gt; parent: &lt;environment: global&gt;</span>
<span class="co">#&gt; bindings:</span>
<span class="co">#&gt;  * a: &lt;dbl&gt;</span>
<span class="co">#&gt;  * x: &lt;dbl&gt;</span>
<span class="kw">fn_env</span>(h2)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span></code></pre>
<p>Another way to capture it is to return an object with a binding to that environment, like a function. The following example illustrates that idea with a function factory, <code>plus()</code>. We use that factory to create a function called <code>plus_one()</code>.</p>
<p>There’s a lot going on in the diagram because the enclosing environment of <code>plus_one()</code> is the execution environment of <code>plus()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">plus &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">function</span>(y) x <span class="op">+</span><span class="st"> </span>y
}

plus_one &lt;-<span class="st"> </span><span class="kw">plus</span>(<span class="dv">1</span>)
plus_one
<span class="co">#&gt; function(y) x + y</span>
<span class="co">#&gt; &lt;environment: 0x6cc3230&gt;</span></code></pre>
<p><img src="diagrams/environments/closure.png" width="162" style="display: block; margin: auto;" /></p>
<p>What happens when we call <code>plus_one()</code>? Its execution environment will have the captured execution environment of <code>plus()</code> as its parent:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plus_one</span>(<span class="dv">2</span>)
<span class="co">#&gt; [1] 3</span></code></pre>
<p><img src="diagrams/environments/closure-call.png" width="162" style="display: block; margin: auto;" /></p>
<p>You’ll learn more about function factories in Section <a href="#factory-fundamentals">10.2</a>.</p>
</div>
<div id="exercises-22" class="section level3">
<h3><span class="header-section-number">7.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How is <code>search_envs()</code> different to <code>env_parents(global_env())</code>?</p></li>
<li><p>Draw a diagram that shows the enclosing environments of this function:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x1) {
  f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x2) {
    f3 &lt;-<span class="st"> </span><span class="cf">function</span>(x3) {
      x1 <span class="op">+</span><span class="st"> </span>x2 <span class="op">+</span><span class="st"> </span>x3
    }
    <span class="kw">f3</span>(<span class="dv">3</span>)
  }
  <span class="kw">f2</span>(<span class="dv">2</span>)
}
<span class="kw">f1</span>(<span class="dv">1</span>)</code></pre></li>
<li><p>Write an enhanced version of <code>str()</code> that provides more information
about functions. Show where the function was found and what environment
it was defined in.</p></li>
</ol>
</div>
</div>
<div id="call-stack" class="section level2">
<h2><span class="header-section-number">7.5</span> The call stack</h2>
<p>

</p>
<p>There is one last environment we need to explain, the <strong>caller</strong> environment, accessed with <code>rlang::caller_env()</code>. This provides the environment from which the function was called, and hence varies based on how the function is called, not how the function was created. As we saw above this is a useful default whenever you write a function that takes an environment as an argument.</p>
<div class="base">
<p><code>parent.frame()</code> is equivalent to <code>caller_env()</code>; just note that it returns an environment, not a frame.</p>
</div>
<p>To fully understand the caller environment we need to discuss two related concepts: the <strong>call stack</strong>, which is made up of <strong>frames</strong>. Executing a function creates two types of context. You’ve learned about one already: the execution environment is a child of the function environment, which is determined by where the function was created. There’s another type of context created by where the function was called: this is called the call stack.</p>
<!-- HW: mention that this is actually a tree! -->
<div id="simple-call-stacks" class="section level3">
<h3><span class="header-section-number">7.5.1</span> Simple call stacks</h3>

<p>Let’s illustrate this with a simple sequence of calls: <code>f()</code> calls <code>g()</code> calls <code>h()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">g</span>(<span class="dt">x =</span> <span class="dv">2</span>)
}
g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">h</span>(<span class="dt">x =</span> <span class="dv">3</span>)
}
h &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">stop</span>()
}</code></pre>
<p>The way you most commonly see a call stack in R is by looking at the <code>traceback()</code> after an error has occurred:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">f</span>(<span class="dt">x =</span> <span class="dv">1</span>)
<span class="co">#&gt; Error:</span>
<span class="kw">traceback</span>()
<span class="co">#&gt; 4: stop()</span>
<span class="co">#&gt; 3: h(x = 3) </span>
<span class="co">#&gt; 2: g(x = 2)</span>
<span class="co">#&gt; 1: f(x = 1)</span></code></pre>
<p>Instead of <code>stop()</code> + <code>traceback()</code> to understand the call stack, we’re going to use <code>lobstr::cst()</code> to print out the <strong>c</strong>all <strong>s</strong>tack <strong>t</strong>ree:</p>
<pre class="sourceCode r"><code class="sourceCode r">h &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  lobstr<span class="op">::</span><span class="kw">cst</span>()
}
<span class="kw">f</span>(<span class="dt">x =</span> <span class="dv">1</span>)
<span class="co">#&gt; █</span>
<span class="co">#&gt; └─f(x = 1)</span>
<span class="co">#&gt;   └─g(x = 2)</span>
<span class="co">#&gt;     └─h(x = 3)</span>
<span class="co">#&gt;       └─lobstr::cst()</span></code></pre>
<p>This shows us that <code>cst()</code> was called from <code>h()</code>, which was called from <code>g()</code>, which was called from <code>f()</code>. Note that the order is the opposite from <code>traceback()</code>. As the call stacks get more complicated, I think it’s easier to understand the sequence of calls if you start from the beginning, rather than the end (i.e. <code>f()</code> calls <code>g()</code>; rather than <code>g()</code> was called by <code>f()</code>).</p>
</div>
<div id="lazy-call-stack" class="section level3">
<h3><span class="header-section-number">7.5.2</span> Lazy evaluation</h3>
<p></p>
<p>The call stack above is simple - while you get a hint that there’s some tree-like structure involved, everything happens on a single branch. This is typical of a call stack when all arguments are eagerly evaluated.</p>
<p>Let’s create a more complicated example that involves some lazy evaluation. We’ll create a sequence of functions, <code>a()</code>, <code>b()</code>, <code>c()</code>, that pass along an argument <code>x</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">b</span>(x)
b &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">c</span>(x)
c &lt;-<span class="st"> </span><span class="cf">function</span>(x) x

<span class="kw">a</span>(<span class="kw">f</span>())
<span class="co">#&gt; █</span>
<span class="co">#&gt; ├─a(f())</span>
<span class="co">#&gt; │ └─b(x)</span>
<span class="co">#&gt; │   └─c(x)</span>
<span class="co">#&gt; └─f()</span>
<span class="co">#&gt;   └─g(x = 2)</span>
<span class="co">#&gt;     └─h(x = 3)</span>
<span class="co">#&gt;       └─lobstr::cst()</span></code></pre>
<p><code>x</code> is lazily evaluated so this tree gets two branches. In the first branch <code>a()</code> calls <code>b()</code>, then <code>b()</code> calls <code>c()</code>. The second branch starts when <code>c()</code> evaluates its argument <code>x</code>. This argument is evaluated in a new branch because the environment in which it is evaluated is the global environment, not the environment of <code>c()</code>.</p>
</div>
<div id="frames" class="section level3">
<h3><span class="header-section-number">7.5.3</span> Frames</h3>
<p>
</p>
<p>Each element of the call stack is a <strong>frame</strong><span id="fn78" class="footnote" data-pagedown-footnote-number="78" style="white-space: pre-line;">NB: <code>?environment</code> uses frame in a different sense: “Environments consist of a <em>frame</em>, or collection of named objects, and a pointer to an enclosing environment.”. We avoid this sense of frame, which comes from S, because it’s very specific and not widely used in base R. For example, the “frame” in <code>parent.frame()</code> is an execution context, not a collection of named objects.</span>, also known as an evaluation context.
The frame is an extremely important internal data structure, and R code can only access a small part of the data structure because it’s so critical. A frame has three main components that are accessible from R:</p>
<ul>
<li><p>An expression (labelled with <code>expr</code>) giving the function call. This is
what <code>traceback()</code> prints out.</p></li>
<li><p>An environment (labelled with <code>env</code>), which is typically the execution
environment of a function. There are two main exceptions: the environment of
the global frame is the global environment, and calling <code>eval()</code> also
generates frames, where the environment can be anything.</p></li>
<li><p>A parent, the previous call in the call stack (shown by a grey arrow).</p></li>
</ul>
<p><img src="diagrams/environments/calling.png" width="344" style="display: block; margin: auto;" /></p>
<p>(To focus on the calling environments, I have omitted the bindings in the global environment from <code>f</code>, <code>g</code>, and <code>h</code> to the respective function objects.)</p>
<p>The frame also holds exit handlers created with <code>on.exit()</code>, restarts and handlers for the condition system, and which context to <code>return()</code> to when a function completes. These are important for the internal operation of R, but are not directly accessible.</p>
</div>
<div id="dynamic-scope" class="section level3">
<h3><span class="header-section-number">7.5.4</span> Dynamic scope</h3>
<p></p>
<p>Looking up variables in the calling stack rather than in the enclosing environment is called <strong>dynamic scoping</strong>. Few languages implement dynamic scoping (Emacs Lisp is a notable exception<span id="fn79" class="footnote" data-pagedown-footnote-number="79" style="white-space: pre-line;"><a href="http://www.gnu.org/software/emacs/emacs-paper.html#SEC15" class="uri">http://www.gnu.org/software/emacs/emacs-paper.html#SEC15</a></span>.) This is because dynamic scoping makes it much harder to reason about how a function operates: not only do you need to know how it was defined, you also need to know the context in which it was called. Dynamic scoping is primarily useful for developing functions that aid interactive data analysis. It is one of the topics discussed in Chapter <a href="#evaluation">20</a>.</p>
</div>
<div id="exercises-23" class="section level3">
<h3><span class="header-section-number">7.5.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>Write a function that lists all the variables defined in the environment
in which it was called. It should return the same results as <code>ls()</code>.</li>
</ol>
</div>
</div>
<div id="explicit-envs" class="section level2">
<h2><span class="header-section-number">7.6</span> As data structures</h2>
<p>
</p>
<p>As well as powering scoping, environments are also useful data structures in their own right because they have reference semantics. There are three common problems that they can help solve:</p>
<ul>
<li><p><strong>Avoiding copies of large data</strong>. Since environments have reference
semantics, you’ll never accidentally create a copy. But bare environments
are painful to work with, so instead I recommend using R6 objects, which
are built on top of environments. Learn more in Chapter <a href="#r6">14</a>.</p></li>
<li><p><strong>Managing state within a package</strong>. Explicit environments are useful in
packages because they allow you to maintain state across function calls.
Normally, objects in a package are locked, so you can’t modify them
directly. Instead, you can do something like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">my_env &lt;-<span class="st"> </span><span class="kw">new.env</span>(<span class="dt">parent =</span> <span class="kw">emptyenv</span>())
my_env<span class="op">$</span>a &lt;-<span class="st"> </span><span class="dv">1</span>

get_a &lt;-<span class="st"> </span><span class="cf">function</span>() {
  my_env<span class="op">$</span>a
}
set_a &lt;-<span class="st"> </span><span class="cf">function</span>(value) {
  old &lt;-<span class="st"> </span>my_env<span class="op">$</span>a
  my_env<span class="op">$</span>a &lt;-<span class="st"> </span>value
  <span class="kw">invisible</span>(old)
}</code></pre>
<p>Returning the old value from setter functions is a good pattern because
it makes it easier to reset the previous value in conjunction with
<code>on.exit()</code> (Section <a href="#on-exit">6.7.4</a>).</p></li>
<li><p><strong>As a hashmap</strong>. A hashmap is a data structure that takes constant, O(1),
time to find an object based on its name. Environments provide this
behaviour by default, so can be used to simulate a hashmap. See the
hash package <span class="citation">(Brown <a href="#ref-hash">2013</a>)</span> for a complete development of this idea.</p></li>
</ul>
</div>
<div id="env-answers" class="section level2">
<h2><span class="header-section-number">7.7</span> Quiz answers</h2>
<ol style="list-style-type: decimal">
<li><p>There are four ways: every object in an environment must have a name;
order doesn’t matter; environments have parents; environments have
reference semantics.</p></li>
<li><p>The parent of the global environment is the last package that you
loaded. The only environment that doesn’t have a parent is the empty
environment.</p></li>
<li><p>The enclosing environment of a function is the environment where it
was created. It determines where a function looks for variables.</p></li>
<li><p>Use <code>caller_env()</code> or <code>parent.frame()</code>.</p></li>
<li><p><code>&lt;-</code> always creates a binding in the current environment; <code>&lt;&lt;-</code>
rebinds an existing name in a parent of the current environment.</p></li>
</ol>
<!--chapter:end:Environments.Rmd-->
</div>
</div>
<div id="conditions" class="section level1">
<h1><span class="header-section-number">8</span> Conditions</h1>
<div id="introduction-7" class="section level2">
<h2><span class="header-section-number">8.1</span> Introduction</h2>
<p>The <strong>condition</strong> system provides a paired set of tools that allow the author of a function to indicate that something unusual is happening, and the user of that function to deal with it. The function author <strong>signals</strong> conditions with functions like <code>stop()</code> (for errors), <code>warning()</code> (for warnings), and <code>message()</code> (for messages), then the function user can handle them with functions like <code>tryCatch()</code> and <code>withCallingHandlers()</code>. Understanding the condition system is important because you’ll often need to play both roles: signalling conditions from the functions you create, and handle conditions signalled by the functions you call.</p>
<p>R offers a very powerful condition system based on ideas from Common Lisp. Like R’s approach to object oriented programming, it is rather different to currently popular programming languages so it is easy to misunderstand, and there has been relatively little written about how to use it effectively. Historically, this has meant that few people (myself included) have taken full advantage of its power. The goal of this chapter is to remedy that situation. Here you will learn about the big ideas of R’s condition system, as well as learning a bunch of practical tools that will make your code stronger.</p>
<p>I found two resources particularly useful when writing this chapter. You may also want to read them if you want to learn more about the inspirations and motivations for the system:</p>
<ul>
<li><p><em>A prototype of a condition system for R</em><span id="fn80" class="footnote" data-pagedown-footnote-number="80" style="white-space: pre-line;"><a href="http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html" class="uri">http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html</a></span> by Robert Gentleman
and Luke Tierney. This describes an early version of R’s condition system.
While the implementation has changed somewhat since this document was
written, it provides a good overview of how the pieces fit together, and
some motivation for its design.</p></li>
<li><p><em>Beyond exception handling: conditions and restarts</em><span id="fn81" class="footnote" data-pagedown-footnote-number="81" style="white-space: pre-line;"><a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html" class="uri">http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html</a></span>
by Peter Seibel. This describes exception handling in Lisp, which happens
to be very similar to R’s approach. It provides useful motivation and
more sophisticated examples. I have provided an R translation of the
chapter at <a href="http://adv-r.had.co.nz/beyond-exception-handling.html" class="uri">http://adv-r.had.co.nz/beyond-exception-handling.html</a>.</p></li>
</ul>
<p>I also found it helpful to work through the underlying C code that implements these ideas. If you’re interested in understanding how it all works, you might find my notes<span id="fn82" class="footnote" data-pagedown-footnote-number="82" style="white-space: pre-line;"><a href="https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac" class="uri">https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac</a></span> to be useful.</p>
<div id="quiz-6" class="section level3 unnumbered">
<h3>Quiz</h3>
<p>Want to skip this chapter? Go for it, if you can answer the questions below. Find the answers at the end of the chapter in Section <a href="#conditions-answers">8.7</a>.</p>
<ol style="list-style-type: decimal">
<li><p>What are the three most important types of condition?</p></li>
<li><p>What function do you use to ignore errors in block of code?</p></li>
<li><p>What’s the main difference between <code>tryCatch()</code> and <code>withCallingHandlers()</code>?</p></li>
<li><p>Why might you want to create a custom error object?</p></li>
</ol>
</div>
<div id="outline-6" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#signalling-conditions">8.2</a> introduces the basic tools for
signalling conditions, and discusses when it is appropriate to use each type.</p></li>
<li><p>Section <a href="#ignoring-conditions">8.3</a> teaches you about the simplest tools for
handling conditions: functions like <code>try()</code> and <code>supressMessages()</code> that
swallow conditions and prevent them from getting to the top level.</p></li>
<li><p>Section <a href="#handling-conditions">8.4</a> introduces the condition <strong>object</strong>, and
the two fundamental tools of condition handling: <code>tryCatch()</code> for error
conditions, and <code>withCallingHandlers()</code> for everything else.</p></li>
<li><p>Section <a href="#custom-conditions">8.5</a> shows you how to extend the built-in
condition objects to store useful data that condition handlers can use to
make more informed decisions.</p></li>
<li><p>Section <a href="#condition-applications">8.6</a> closes out the chapter with a grab bag
of practical applications based on the low-level tools found in earlier
sections.</p></li>
</ul>
</div>
<div id="prerequisites-2" class="section level3">
<h3><span class="header-section-number">8.1.1</span> Prerequisites</h3>
<p>As well as base R functions, this chapter uses condition signalling and handling functions from rlang<span id="fn83" class="footnote" data-pagedown-footnote-number="83" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)</code></pre>
</div>
</div>
<div id="signalling-conditions" class="section level2">
<h2><span class="header-section-number">8.2</span> Signalling conditions</h2>
<p>
</p>
<p>There are three conditions that you can signal in code: errors, warnings, and messages.</p>
<ul>
<li><p>Errors are the most severe; they indicate that there is no way for a function
to continue and execution must stop.</p></li>
<li><p>Warnings fall somewhat in between errors and warnings, and typically indicate
that something has gone wrong but the function has been able to at least
partially recover.</p></li>
<li><p>Messages are the mildest; they are way of informing the user that some action
has been performed on their behalf.</p></li>
</ul>
<p>There is a final condition that can only be generated interactively: an interrupt, which indicates that the user has “interrupted” execution by pressing Escape, Ctrl + Break, or Ctrl + C (depending on the platform).</p>
<p>Conditions are usually displayed prominently, in a bold font or coloured red, depending on the R interface. You can tell them apart because errors always start with “Error”, warnings with “Warning message”, and messages with nothing.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stop</span>(<span class="st">&quot;This is what an error looks like&quot;</span>)
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   This is what an error looks like</span>

<span class="kw">warning</span>(<span class="st">&quot;This is what a warning looks like&quot;</span>)
<span class="co">#&gt; Warning: This is what a warning looks like</span>

<span class="kw">message</span>(<span class="st">&quot;This is what a message looks like&quot;</span>)
<span class="co">#&gt; This is what a message looks like</span></code></pre>
<p>The following three sections describe errors, warnings, and message in more detail.</p>
<div id="errors-1" class="section level3">
<h3><span class="header-section-number">8.2.1</span> Errors</h3>
<p>

</p>
<p>In base R, errors are signalled, or <strong>thrown</strong>, by <code>stop()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">g</span>()
g &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">h</span>()
h &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">stop</span>(<span class="st">&quot;This is an error!&quot;</span>)

<span class="kw">f</span>()
<span class="co">#&gt; Error in h():</span>
<span class="co">#&gt;   This is an error!</span></code></pre>
<p>By default, the error message includes the call, but this is typically not useful (and recapitulates information that you can easily get from <code>traceback()</code>), so I think it’s good practice to use <code>call. = FALSE</code><span id="fn84" class="footnote" data-pagedown-footnote-number="84" style="white-space: pre-line;">The trailing <code>.</code> in <code>call.</code> is a peculiarity of <code>stop()</code>; don’t read anything into it.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r">h &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">stop</span>(<span class="st">&quot;This is an error!&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
<span class="kw">f</span>()
<span class="co">#&gt; Error: This is an error!</span></code></pre>
<p>The rlang equivalent to <code>stop()</code>, <code>rlang::abort()</code>, does this automatically. We’ll use <code>abort()</code> throughout this chapter, but we won’t get to its most compelling feature, the ability to add additional metadata to the condition object, until we’re near the end of the chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r">h &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">abort</span>(<span class="st">&quot;This is an error!&quot;</span>)
<span class="kw">f</span>()
<span class="co">#&gt; Error: This is an error!</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─global::f()</span>
<span class="co">#&gt;  2.   └─global::g()</span>
<span class="co">#&gt;  3.     └─global::h()</span></code></pre>
<p>(NB: <code>stop()</code> pastes together multiple inputs, while <code>abort()</code> does not. To create complex error messages with abort, I recommend using <code>glue::glue()</code>. This allows us to use other arguments to <code>abort()</code> for useful features that you’ll learn about in Section <a href="#custom-conditions">8.5</a>.)</p>
<p>The best error messages tell you what is wrong and point you in the right direction to fix the problem. Writing good error messages is hard because errors usually occur when the user has a flawed mental model of the function. As a developer, it’s hard to imagine how the user might be thinking incorrectly about your function, and thus it’s hard to write a message that will steer the user in the correct direction. That said, the tidyverse style guide discusses a few general principles that we have found useful: <a href="http://style.tidyverse.org/error-messages.html" class="uri">http://style.tidyverse.org/error-messages.html</a>.</p>
</div>
<div id="warnings" class="section level3">
<h3><span class="header-section-number">8.2.2</span> Warnings</h3>
<p></p>
<p>Warnings, signalled by <code>warning()</code>, are weaker than errors: they signal that something has gone wrong, but the code has been able to recover and continue. Unlike errors, you can have multiple warnings from a single function call:</p>
<pre class="sourceCode r"><code class="sourceCode r">fw &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">cat</span>(<span class="st">&quot;1</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">warning</span>(<span class="st">&quot;W1&quot;</span>)
  <span class="kw">cat</span>(<span class="st">&quot;2</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">warning</span>(<span class="st">&quot;W2&quot;</span>)
  <span class="kw">cat</span>(<span class="st">&quot;3</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">warning</span>(<span class="st">&quot;W3&quot;</span>)
}</code></pre>
<p>By default, warnings are cached and printed only when control returns to the top level:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fw</span>()
<span class="co">#&gt; 1</span>
<span class="co">#&gt; 2</span>
<span class="co">#&gt; 3</span>
<span class="co">#&gt; Warning messages:</span>
<span class="co">#&gt; 1: In f() : W1</span>
<span class="co">#&gt; 2: In f() : W2</span>
<span class="co">#&gt; 3: In f() : W3</span></code></pre>
<p>
You can control this behaviour with the <code>warn</code> option:</p>
<ul>
<li><p>To make warnings appear immediately, set <code>options(warn = 1)</code>.</p></li>
<li><p>To turn warnings into errors, set <code>options(warn = 2)</code>. This is usually
the easiest way to debug a warning, as once it’s an error you can
use tools like <code>traceback()</code> to find the source.</p></li>
<li><p>Restore the default behaviour with <code>options(warn = 0)</code>.</p></li>
</ul>
<p>Like <code>stop()</code>, <code>warning()</code> also has a call argument. It is slightly more useful (since warnings are often more distant from their source), but I still generally suppress it with <code>call. = FALSE</code>. Like <code>rlang::abort()</code>, the rlang equivalent of <code>warning()</code>, <code>rlang::warn()</code>, also suppresses the <code>call.</code> by default.</p>
<p>Warnings occupy a somewhat challenging place between messages (“you should know about this”) and errors (“you must fix this!”), and it’s hard to give precise advice on when to use them. Generally, be restrained, as warnings are easy to miss if there’s a lot of other output, and you don’t want your function to recover too easily from clearly invalid input. In my opinion, base R tends to overuse warnings, and many warnings in base R would be better off as errors. For example, I think these warnings would be more helpful as errors:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">formals</span>(<span class="dv">1</span>)
<span class="co">#&gt; Warning in formals(fun): argument is not a function</span>
<span class="co">#&gt; NULL</span>

<span class="kw">file.remove</span>(<span class="st">&quot;this-file-doesn&#39;t-exist&quot;</span>)
<span class="co">#&gt; Warning in file.remove(&quot;this-file-doesn&#39;t-exist&quot;): cannot remove file</span>
<span class="co">#&gt; &#39;this-file-doesn&#39;t-exist&#39;, reason &#39;No such file or directory&#39;</span>
<span class="co">#&gt; [1] FALSE</span>

<span class="kw">lag</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">k =</span> <span class="fl">1.5</span>)
<span class="co">#&gt; Warning in lag.default(1:3, k = 1.5): &#39;k&#39; is not an integer</span>
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; attr(,&quot;tsp&quot;)</span>
<span class="co">#&gt; [1] -1  1  1</span></code></pre>
<p>There only a couple of cases where using a warning is clearly appropriate:</p>
<ul>
<li><p>When you <strong>deprecate</strong> a function you want to allow older code to continue
to work (so ignoring the warning is OK) but you want to encourage the user
to switch to a new function.</p></li>
<li><p>When you are reasonably certain you can recover from a problem:
If you were 100% certain that you could fix the problem, you wouldn’t need
any message; if you were more uncertain that you could correctly fix the
issue, you’d throw an error.</p></li>
</ul>
<p>Otherwise use warnings with restraint, and carefully consider if an error would be more appropriate.</p>
</div>
<div id="messages" class="section level3">
<h3><span class="header-section-number">8.2.3</span> Messages</h3>
<p>

</p>
<p>Messages, signalled by <code>message()</code>, are informational; use them to tell the user that you’ve done something on their behalf. Good messages are a balancing act: you want to provide just enough information so the user knows what’s going on, but not so much that they’re overwhelmed.</p>
<p><code>message()</code>s are displayed immediately and do not have a <code>call.</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">fm &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">cat</span>(<span class="st">&quot;1</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">message</span>(<span class="st">&quot;M1&quot;</span>)
  <span class="kw">cat</span>(<span class="st">&quot;2</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">message</span>(<span class="st">&quot;M2&quot;</span>)
  <span class="kw">cat</span>(<span class="st">&quot;3</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">message</span>(<span class="st">&quot;M3&quot;</span>)
}

<span class="kw">fm</span>()
<span class="co">#&gt; 1</span>
<span class="co">#&gt; M1</span>
<span class="co">#&gt; 2</span>
<span class="co">#&gt; M2</span>
<span class="co">#&gt; 3</span>
<span class="co">#&gt; M3</span></code></pre>
<p>Good places to use a message are:</p>
<ul>
<li><p>When a default argument requires some non-trivial amount of computation
and you want to tell the user what value was used. For example, ggplot2
reports the number of bins used if you don’t supply a <code>binwidth</code>.</p></li>
<li><p>In functions that are called primarily for their side-effects which would
otherwise be silent. For example, when writing files to disk, calling a web
API, or writing to a database, it’s useful provide regular status messages
telling the user what’s happening.</p></li>
<li><p>When you’re about to start a long running process with no
intermediate output. A progress bar (e.g. with
progress<span id="fn85" class="footnote" data-pagedown-footnote-number="85" style="white-space: pre-line;"><a href="https://github.com/r-lib/progress" class="uri">https://github.com/r-lib/progress</a></span>) is better, but a message
is a good place to start.</p></li>
<li><p>When writing a package, you sometimes want to display a message when
your package is loaded (i.e. in <code>.onAttach()</code>); here you must use
<code>packageStartupMessage()</code>.</p></li>
</ul>
<p>Generally any function that produces a message should have some way to suppress it, like a <code>quiet = TRUE</code> argument. It is possible to suppress all messages with <code>suppressMessages()</code>, as you’ll learn shortly, but it is nice to also give finer grained control.</p>
<p>It’s important to compare <code>message()</code> to the closely related <code>cat()</code>. In terms of usage and result, they appear quite similar<span id="fn86" class="footnote" data-pagedown-footnote-number="86" style="white-space: pre-line;">But note that <code>cat()</code> requires an explicit trailing <code>&quot;\n&quot;</code> to print a new line.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Hi!</span><span class="ch">\n</span><span class="st">&quot;</span>)
<span class="co">#&gt; Hi!</span>

<span class="kw">message</span>(<span class="st">&quot;Hi!&quot;</span>)
<span class="co">#&gt; Hi!</span></code></pre>
<p>However, the <em>purposes</em> of <code>cat()</code> and <code>message()</code> are different. Use <code>cat()</code> when the primary role of the function is to print to the console, like <code>print()</code> or <code>str()</code> methods. Use <code>message()</code> as a side-channel to print to the console when the primary purpose of the function is something else. In other words, <code>cat()</code> is for when the user <em>asks</em> for something to be printed and <code>message()</code> is for when the developer <em>elects</em> to print something.</p>
</div>
<div id="exercises-24" class="section level3">
<h3><span class="header-section-number">8.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Write a wrapper around <code>file.remove()</code> that throws an error if the file
to be deleted does not exist.</p></li>
<li><p>What does the <code>appendLF</code> argument to <code>message()</code> do? How is it related to
<code>cat()</code>?</p></li>
</ol>
</div>
</div>
<div id="ignoring-conditions" class="section level2">
<h2><span class="header-section-number">8.3</span> Ignoring conditions</h2>
<p>


</p>
<p>The simplest way of handling conditions in R is to simply ignore them:</p>
<ul>
<li>Ignore errors with <code>try()</code>.</li>
<li>Ignore warnings with <code>suppressWarnings()</code>.</li>
<li>Ignore messages with <code>suppressMessages()</code>.</li>
</ul>
<p>These functions are heavy handed as you can’t use them to suppress a single type of condition that you know about, while allowing everything else to pass through. We’ll come back to that challenge later in the chapter.</p>
<p><code>try()</code> allows execution to continue even after an error has occurred. Normally if you run a function that throws an error, it terminates immediately and doesn’t return a value:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">log</span>(x)
  <span class="dv">10</span>
}
<span class="kw">f1</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; Error in log(x):</span>
<span class="co">#&gt;   non-numeric argument to mathematical function</span></code></pre>
<p>However, if you wrap the statement that creates the error in <code>try()</code>, the error message will be displayed<span id="fn87" class="footnote" data-pagedown-footnote-number="87" style="white-space: pre-line;">You can suppress the message with <code>try(..., silent = TRUE)</code>.</span> but execution will continue:</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">try</span>(<span class="kw">log</span>(x))
  <span class="dv">10</span>
}
<span class="kw">f2</span>(<span class="st">&quot;a&quot;</span>)
<span class="co">#&gt; Error in log(x) : non-numeric argument to mathematical function</span>
<span class="co">#&gt; [1] 10</span></code></pre>
<p>It is possible, but not recommended, to save the result of <code>try()</code> and perform different actions based on whether or not the code succeeded or failed<span id="fn88" class="footnote" data-pagedown-footnote-number="88" style="white-space: pre-line;">You can tell if the expression failed because the result will have class <code>try-error</code>.</span>. Instead, it is better to use <code>tryCatch()</code> or a higher-level helper; you’ll learn about those shortly.</p>
<p>A simple, but useful, pattern is to do assignment inside the call: this lets you define a default value to be used if the code does not succeed. This works because the argument is evaluated in the calling environment, not inside the function (See Section <a href="#promises">6.5.1</a> for more details.)</p>
<pre class="sourceCode r"><code class="sourceCode r">default &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">try</span>(default &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;possibly-bad-input.csv&quot;</span>), <span class="dt">silent =</span> <span class="ot">TRUE</span>)</code></pre>
<p><code>suppressWarnings()</code> and <code>suppressMessages()</code> suppress all warnings and messages. Unlike errors, messages and warnings don’t terminate execution, so there may be multiple signalled in a single block.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">suppressWarnings</span>({
  <span class="kw">warning</span>(<span class="st">&quot;Uhoh!&quot;</span>)
  <span class="kw">warning</span>(<span class="st">&quot;Another warning&quot;</span>)
  <span class="dv">1</span>
})
<span class="co">#&gt; [1] 1</span>

<span class="kw">suppressMessages</span>({
  <span class="kw">message</span>(<span class="st">&quot;Hello there&quot;</span>)
  <span class="dv">2</span>
})
<span class="co">#&gt; [1] 2</span>

<span class="kw">suppressWarnings</span>({
  <span class="kw">message</span>(<span class="st">&quot;You can still see me&quot;</span>)
  <span class="dv">3</span>
})
<span class="co">#&gt; You can still see me</span>
<span class="co">#&gt; [1] 3</span></code></pre>
</div>
<div id="handling-conditions" class="section level2">
<h2><span class="header-section-number">8.4</span> Handling conditions</h2>
<p>


</p>
<p>Every condition has default behaviour: errors stop execution and return to the top level, warnings are captured and displayed in aggregate, and messages are immediately displayed. Condition <strong>handlers</strong> allow us to temporarily override or supplement the default behaviour.</p>
<p>Two functions, <code>tryCatch()</code> and <code>withCallingHandlers()</code>, allow us to register handlers, functions that take the signalled condition as their single argument. The registration functions have the same basic form:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">error =</span> <span class="cf">function</span>(cnd) {
    <span class="co"># code to run when error is thrown</span>
  },
  code_to_run_while_handlers_are_active
)

<span class="kw">withCallingHandlers</span>(
  <span class="dt">warning =</span> <span class="cf">function</span>(cnd) {
    <span class="co"># code to run when warning is signalled</span>
  },
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) {
    <span class="co"># code to run when message is signalled</span>
  },
  code_to_run_while_handlers_are_active
)</code></pre>
<p>They differ in the type of handlers that they create:</p>
<ul>
<li><p><code>tryCatch()</code> defines <strong>exiting</strong> handlers; after the condition is handled,
control returns to the context where <code>tryCatch()</code> was called. This makes
<code>tryCatch()</code> most suitable for working with errors and interrupts, as these
have to exit anyway.</p></li>
<li><p><code>withCallingHandlers()</code> defines <strong>calling</strong> handlers; after the condition
is captured control returns to the context where the condition was signalled.
This makes it most suitable for working with non-error conditions.</p></li>
</ul>
<p>But before we can learn about and use these handlers, we need to talk a little bit about condition <strong>objects</strong>. These are created implicitly whenever you signal a condition, but become explicit inside the handler.</p>
<div id="condition-objects" class="section level3">
<h3><span class="header-section-number">8.4.1</span> Condition objects</h3>
<p>
</p>
<p>So far we’ve just signalled conditions, and not looked at the objects that are created behind the scenes. The easiest way to see a condition object is to catch one from a signalled condition. That’s the job of <code>rlang::catch_cnd()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">cnd &lt;-<span class="st"> </span><span class="kw">catch_cnd</span>(<span class="kw">stop</span>(<span class="st">&quot;An error&quot;</span>))
<span class="kw">str</span>(cnd)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ message: chr &quot;An error&quot;</span>
<span class="co">#&gt;  $ call   : language force(expr)</span>
<span class="co">#&gt;  - attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>Built-in conditions are lists with two elements:</p>
<ul>
<li><p><code>message</code>, a length-1 character vector containing the text to display to a user.
To extract the message, use <code>conditionMessage(cnd)</code>.</p></li>
<li><p><code>call</code>, the call which triggered the condition. As described above, we don’t
use the call, so it will often be <code>NULL</code>. To extract it, use
<code>conditionCall(cnd)</code>.</p></li>
</ul>
<p>Custom conditions may contain other components, which we’ll discuss in Section <a href="#custom-conditions">8.5</a>.</p>
<p>Conditions also have a <code>class</code> attribute, which makes them S3 objects. We won’t discuss S3 until <a href="#s3">S3</a>, but fortunately, even if you don’t know about S3, condition objects are quite simple. The most important thing to know is that the <code>class</code> attribute is a character vector, and it determines which handlers will match the condition.</p>
</div>
<div id="exiting-handlers" class="section level3">
<h3><span class="header-section-number">8.4.2</span> Exiting handlers</h3>

<p></p>
<p><code>tryCatch()</code> registers exiting handlers, and is typically used to handle error conditions. It allows you to override the default error behaviour. For example, the following code will return <code>NA</code> instead of throwing an error:</p>
<pre class="sourceCode r"><code class="sourceCode r">f3 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="ot">NA</span>,
    <span class="kw">log</span>(x)
  )
}

<span class="kw">f3</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; [1] NA</span></code></pre>
<p>If no conditions are signalled, or the class of the signalled condition does not match the handler name, the code executes normally:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="dv">10</span>,
  <span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
)
<span class="co">#&gt; [1] 2</span>

<span class="kw">tryCatch</span>(
  <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="dv">10</span>,
  {
    <span class="kw">message</span>(<span class="st">&quot;Hi!&quot;</span>)
    <span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
)
<span class="co">#&gt; Hi!</span>
<span class="co">#&gt; [1] 2</span></code></pre>
<p>The handlers set up by <code>tryCatch()</code> are called <strong>exiting</strong> handlers because after the condition is signalled, control passes to the handler and never returns to the original code, effectively meaning that the code “exits”:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;There&quot;</span>,
  {
    <span class="kw">message</span>(<span class="st">&quot;Here&quot;</span>)
    <span class="kw">stop</span>(<span class="st">&quot;This code is never run!&quot;</span>)
  }
)
<span class="co">#&gt; [1] &quot;There&quot;</span></code></pre>
<p>The protected code is evaluated in the environment of <code>tryCatch()</code>, but the handler code is not, because the handlers are functions. This is important to remember if you’re trying to modify objects in the parent environment.</p>
<p>The handler functions are called with a single argument, the condition object. I call this argument <code>cnd</code>, by convention. This value is only moderately useful for the base conditions because they contain relatively little data. It’s more useful when you make your own custom conditions, as you’ll see shortly.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">error =</span> <span class="cf">function</span>(cnd) {
    <span class="kw">paste0</span>(<span class="st">&quot;--&quot;</span>, <span class="kw">conditionMessage</span>(cnd), <span class="st">&quot;--&quot;</span>)
  },
  <span class="kw">stop</span>(<span class="st">&quot;This is an error&quot;</span>)
)
<span class="co">#&gt; [1] &quot;--This is an error--&quot;</span></code></pre>
<p><code>tryCatch()</code> has one other argument: <code>finally</code>. It specifies a block of code (not a function) to run regardless of whether the initial expression succeeds or fails. This can be useful for clean up, like deleting files, or closing connections. This is functionally equivalent to using <code>on.exit()</code> (and indeed that’s how it’s implemented) but it can wrap smaller chunks of code than an entire function.
</p>
<pre class="sourceCode r"><code class="sourceCode r">path &lt;-<span class="st"> </span><span class="kw">tempfile</span>()
<span class="kw">tryCatch</span>(
  {
    <span class="kw">writeLines</span>(<span class="st">&quot;Hi!&quot;</span>, path)
    <span class="co"># ...</span>
  },
  <span class="dt">finally =</span> {
    <span class="co"># always run</span>
    <span class="kw">unlink</span>(path)
  }
)</code></pre>
</div>
<div id="calling-handlers" class="section level3">
<h3><span class="header-section-number">8.4.3</span> Calling handlers</h3>
<p>
</p>
<p>The handlers set up by <code>tryCatch()</code> are called exiting handlers, because they cause code to exit once the condition has been caught. By contrast, <code>withCallingHandlers()</code> sets up <strong>calling</strong> handlers: code execution continues normally once the handler returns. This tends to make <code>withCallingHandlers()</code> a more natural pairing with the non-error conditions. Exiting and calling handlers use “handler” in slighty different senses:</p>
<ul>
<li><p>An exiting handler handles a signal like you handle a problem; it makes the
problem go away.</p></li>
<li><p>A calling handler handles a signal like you handle a car; the car still
exists.</p></li>
</ul>
<p>Compare the results of <code>tryCatch()</code> and <code>withCallingHandlers()</code> in the example below. The messages are not printed in the first case, because the code is terminated once the exiting handler completes. They are printed in the second case, because a calling handler does not exit.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Caught a message!</span><span class="ch">\n</span><span class="st">&quot;</span>), 
  {
    <span class="kw">message</span>(<span class="st">&quot;Someone there?&quot;</span>)
    <span class="kw">message</span>(<span class="st">&quot;Why, yes!&quot;</span>)
  }
)
<span class="co">#&gt; Caught a message!</span>

<span class="kw">withCallingHandlers</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(c) <span class="kw">cat</span>(<span class="st">&quot;Caught a message!</span><span class="ch">\n</span><span class="st">&quot;</span>), 
  {
    <span class="kw">message</span>(<span class="st">&quot;Someone there?&quot;</span>)
    <span class="kw">message</span>(<span class="st">&quot;Why, yes!&quot;</span>)
  }
)
<span class="co">#&gt; Caught a message!</span>
<span class="co">#&gt; Someone there?</span>
<span class="co">#&gt; Caught a message!</span>
<span class="co">#&gt; Why, yes!</span></code></pre>
<p>Handlers are applied in order, so you don’t need to worry getting caught in an infinite loop. In the following example, the <code>message()</code> signalled by the handler doesn’t also get caught:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">withCallingHandlers</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">message</span>(<span class="st">&quot;Second message&quot;</span>),
  <span class="kw">message</span>(<span class="st">&quot;First message&quot;</span>)
)
<span class="co">#&gt; Second message</span>
<span class="co">#&gt; First message</span></code></pre>
<p>(But beware if you have multiple handlers, and some handlers signal conditions that could be captured by another handler: you’ll need to think through the order carefully.)</p>
<p>The return value of a calling handler is ignored because the code continues to execute after the handler completes; where would the return value go? That means that calling handlers are only useful for their side-effects.</p>
<p>
</p>
<p>One important side-effect unique to calling handlers is the ability to <strong>muffle</strong> the signal. By default, a condition will continue to propagate to parent handlers, all the way up to the default handler (or an exiting handler, if provided):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Bubbles all the way up to default handler which generates the message</span>
<span class="kw">withCallingHandlers</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Level 2</span><span class="ch">\n</span><span class="st">&quot;</span>),
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Level 1</span><span class="ch">\n</span><span class="st">&quot;</span>),
    <span class="kw">message</span>(<span class="st">&quot;Hello&quot;</span>)
  )
)
<span class="co">#&gt; Level 1</span>
<span class="co">#&gt; Level 2</span>
<span class="co">#&gt; Hello</span>

<span class="co"># Bubbles up to tryCatch</span>
<span class="kw">tryCatch</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Level 2</span><span class="ch">\n</span><span class="st">&quot;</span>),
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Level 1</span><span class="ch">\n</span><span class="st">&quot;</span>),
    <span class="kw">message</span>(<span class="st">&quot;Hello&quot;</span>)
  )
)
<span class="co">#&gt; Level 1</span>
<span class="co">#&gt; Level 2</span></code></pre>
<p>If you want to prevent the condition “bubbling up” but still run the rest of the code in the block, you need to explicitly muffle it with <code>rlang::cnd_muffle()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Muffles the default handler which prints the messages</span>
<span class="kw">withCallingHandlers</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) {
    <span class="kw">cat</span>(<span class="st">&quot;Level 2</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cnd_muffle</span>(cnd)
  },
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Level 1</span><span class="ch">\n</span><span class="st">&quot;</span>),
    <span class="kw">message</span>(<span class="st">&quot;Hello&quot;</span>)
  )
)
<span class="co">#&gt; Level 1</span>
<span class="co">#&gt; Level 2</span>

<span class="co"># Muffles level 2 handler and the default handler</span>
<span class="kw">withCallingHandlers</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">cat</span>(<span class="st">&quot;Level 2</span><span class="ch">\n</span><span class="st">&quot;</span>),
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">message =</span> <span class="cf">function</span>(cnd) {
      <span class="kw">cat</span>(<span class="st">&quot;Level 1</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">cnd_muffle</span>(cnd)
    },
    <span class="kw">message</span>(<span class="st">&quot;Hello&quot;</span>)
  )
)
<span class="co">#&gt; Level 1</span></code></pre>
</div>
<div id="call-stacks" class="section level3">
<h3><span class="header-section-number">8.4.4</span> Call stacks</h3>
<p>
</p>
<p>To complete the section, there are some important differences between the call stacks of exiting and calling handlers. These differences are generally not important but I’m including it here because I’ve occasionally found it useful, and don’t want to forget about it!</p>
<p>It’s easiest to see the difference by setting up a small example that uses <code>lobstr::cst()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">g</span>()
g &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">h</span>()
h &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">message</span>(<span class="st">&quot;!&quot;</span>)</code></pre>
<p>Calling handlers are called in the context of the call that signalled the condition:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">withCallingHandlers</span>(<span class="kw">f</span>(), <span class="dt">message =</span> <span class="cf">function</span>(cnd) {
  lobstr<span class="op">::</span><span class="kw">cst</span>()
  <span class="kw">cnd_muffle</span>(cnd)
})
<span class="co">#&gt;      █</span>
<span class="co">#&gt;   1. ├─base::withCallingHandlers(...)</span>
<span class="co">#&gt;   2. ├─global::f()</span>
<span class="co">#&gt;   3. │ └─global::g()</span>
<span class="co">#&gt;   4. │   └─global::h()</span>
<span class="co">#&gt;   5. │     └─base::message(&quot;!&quot;)</span>
<span class="co">#&gt;   6. │       ├─base::withRestarts(...)</span>
<span class="co">#&gt;   7. │       │ └─base:::withOneRestart(expr, restarts[[1L]])</span>
<span class="co">#&gt;   8. │       │   └─base:::doWithOneRestart(return(expr), restart)</span>
<span class="co">#&gt;   9. │       └─base::signalCondition(cond)</span>
<span class="co">#&gt;  10. └─(function (cnd) ...</span>
<span class="co">#&gt;  11.   └─lobstr::cst()</span></code></pre>
<p>Whereas exiting handlers are called in the context of the call to <code>tryCatch()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(<span class="kw">f</span>(), <span class="dt">message =</span> <span class="cf">function</span>(cnd) lobstr<span class="op">::</span><span class="kw">cst</span>())
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─base::tryCatch(f(), message = function(cnd) lobstr::cst())</span>
<span class="co">#&gt;  2.   └─base:::tryCatchList(expr, classes, parentenv, handlers)</span>
<span class="co">#&gt;  3.     └─base:::tryCatchOne(expr, names, parentenv, handlers[[1L]])</span>
<span class="co">#&gt;  4.       └─value[[3L]](cond)</span>
<span class="co">#&gt;  5.         └─lobstr::cst()</span></code></pre>
</div>
<div id="exercises-25" class="section level3">
<h3><span class="header-section-number">8.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What extra information does the condition generated by <code>abort()</code> contain
compared to the condition generated by <code>stop()</code>? i.e. what’s the difference
between these two objects? Read the help for <code>?abort</code> to learn more.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">catch_cnd</span>(<span class="kw">stop</span>(<span class="st">&quot;An error&quot;</span>))
<span class="kw">catch_cnd</span>(<span class="kw">abort</span>(<span class="st">&quot;An error&quot;</span>))</code></pre></li>
<li><p>Predict the results of evaluating the following code</p>
<pre class="sourceCode r"><code class="sourceCode r">show_condition &lt;-<span class="st"> </span><span class="cf">function</span>(code) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;error&quot;</span>,
    <span class="dt">warning =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;warning&quot;</span>,
    <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;message&quot;</span>,
    {
      code
      <span class="ot">NULL</span>
    }
  )
}

<span class="kw">show_condition</span>(<span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>))
<span class="kw">show_condition</span>(<span class="dv">10</span>)
<span class="kw">show_condition</span>(<span class="kw">warning</span>(<span class="st">&quot;?!&quot;</span>))
<span class="kw">show_condition</span>({
  <span class="dv">10</span>
  <span class="kw">message</span>(<span class="st">&quot;?&quot;</span>)
  <span class="kw">warning</span>(<span class="st">&quot;?!&quot;</span>)
})</code></pre></li>
<li><p>Explain the results of running this code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">withCallingHandlers</span>(
  <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">message</span>(<span class="st">&quot;b&quot;</span>),
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">message =</span> <span class="cf">function</span>(cnd) <span class="kw">message</span>(<span class="st">&quot;a&quot;</span>),
    <span class="kw">message</span>(<span class="st">&quot;c&quot;</span>)
  )
)
<span class="co">#&gt; b</span>
<span class="co">#&gt; a</span>
<span class="co">#&gt; b</span>
<span class="co">#&gt; c</span></code></pre></li>
<li><p>Read the source code for <code>catch_cnd()</code> and explain how it works.</p></li>
<li><p>How could you rewrite <code>show_condition()</code> to use a single handler?</p></li>
</ol>
</div>
</div>
<div id="custom-conditions" class="section level2">
<h2><span class="header-section-number">8.5</span> Custom conditions</h2>
<p>
</p>
<p>One of the challenges of error handling in R is that most functions generate one of the built-in conditions, which contain only a <code>message</code> and a <code>call</code>. That means that if you want to detect a specific type of error, you can only work with the text of the error message. This is error prone, not only because the message might change over time, but also because messages can be translated into other languages.</p>
<p>Fortunately R has a powerful, but little used feature: the ability to create custom conditions that can contain additional metadata. Creating custom conditions is a little fiddly in base R, but <code>rlang::abort()</code> makes it very easy as you can supply a custom <code>.subclass</code> and additional metadata.</p>
<p>The following example shows the basic pattern. I recommend using the following call structure for custom conditions. This takes advantage of R’s flexible argument matching so that the name of the “type” of error comes first, followed by the user facing text, followed by custom metadata.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">abort</span>(
  <span class="st">&quot;error_not_found&quot;</span>,
  <span class="dt">message =</span> <span class="st">&quot;Path `blah.csv` not found&quot;</span>, 
  <span class="dt">path =</span> <span class="st">&quot;blah.csv&quot;</span>
)
<span class="co">#&gt; Error: Path `blah.csv` not found</span></code></pre>
<p>Custom conditions work just like regular conditions when used interactively, but allow handlers to do much more.</p>
<div id="motivation" class="section level3">
<h3><span class="header-section-number">8.5.1</span> Motivation</h3>
<p>To explore these ideas in more depth, let’s take <code>base::log()</code>. It does the minimum when throwing errors caused by invalid arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">log</span>(letters)
<span class="co">#&gt; Error in log(letters):</span>
<span class="co">#&gt;   non-numeric argument to mathematical function</span>
<span class="kw">log</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">base =</span> letters)
<span class="co">#&gt; Error in log(1:10, base = letters):</span>
<span class="co">#&gt;   non-numeric argument to mathematical function</span></code></pre>
<p>I think we can do better by being explicit about which argument is the problem (i.e. <code>x</code> or <code>base</code>), and saying what the problematic input is (not just what it isn’t).</p>
<pre class="sourceCode r"><code class="sourceCode r">my_log &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">base =</span> <span class="kw">exp</span>(<span class="dv">1</span>)) {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.numeric</span>(x)) {
    <span class="kw">abort</span>(<span class="kw">paste0</span>(<span class="st">&quot;`x` must be a numeric vector; not &quot;</span>, <span class="kw">typeof</span>(x), <span class="st">&quot;.&quot;</span>))
  }
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.numeric</span>(base)) {
    <span class="kw">abort</span>(<span class="kw">paste0</span>(<span class="st">&quot;`base` must be a numeric vector; not &quot;</span>, <span class="kw">typeof</span>(base), <span class="st">&quot;.&quot;</span>))
  }

  base<span class="op">::</span><span class="kw">log</span>(x, <span class="dt">base =</span> base)
}</code></pre>
<p>This gives us:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_log</span>(letters)
<span class="co">#&gt; Error: `x` must be a numeric vector; not character.</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─global::my_log(letters)</span>
<span class="kw">my_log</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">base =</span> letters)
<span class="co">#&gt; Error: `base` must be a numeric vector; not character.</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─global::my_log(1:10, base = letters)</span></code></pre>
<p>This is an improvement for interactive usage as the error messages are more likely to guide the user towards a correct fix. However, they’re no better if you want to programmatically handle the errors: all the useful metadata about the error is jammed into a single string.</p>
</div>
<div id="signalling" class="section level3">
<h3><span class="header-section-number">8.5.2</span> Signalling</h3>
<p></p>
<p>Let’s build some infrastructure to improve this situation, We’ll start by providing a custom <code>abort()</code> function for bad arguments. This is a little over-generalised for the example at hand, but it reflects common patterns that I’ve seen across other functions. The pattern is fairly simple. We create a nice error message for the user, using <code>glue::glue()</code>, and store metadata in the condition call for the developer.</p>
<pre class="sourceCode r"><code class="sourceCode r">abort_bad_argument &lt;-<span class="st"> </span><span class="cf">function</span>(arg, must, <span class="dt">not =</span> <span class="ot">NULL</span>) {
  msg &lt;-<span class="st"> </span>glue<span class="op">::</span><span class="kw">glue</span>(<span class="st">&quot;`{arg}` must {must}&quot;</span>)
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(not)) {
    not &lt;-<span class="st"> </span><span class="kw">typeof</span>(not)
    msg &lt;-<span class="st"> </span>glue<span class="op">::</span><span class="kw">glue</span>(<span class="st">&quot;{msg}; not {not}.&quot;</span>)
  }
  
  <span class="kw">abort</span>(<span class="st">&quot;error_bad_argument&quot;</span>, 
    <span class="dt">message =</span> msg, 
    <span class="dt">arg =</span> arg, 
    <span class="dt">must =</span> must, 
    <span class="dt">not =</span> not
  )
}</code></pre>
<div class="base">
<p>If you want to throw a custom error without adding a dependency on rlang, you can create a condition object “by hand” and then pass it to <code>stop()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">stop_custom &lt;-<span class="st"> </span><span class="cf">function</span>(.subclass, message, <span class="dt">call =</span> <span class="ot">NULL</span>, ...) {
  err &lt;-<span class="st"> </span><span class="kw">structure</span>(
    <span class="kw">list</span>(
      <span class="dt">message =</span> message,
      <span class="dt">call =</span> call,
      ...
    ),
    <span class="dt">class =</span> <span class="kw">c</span>(.subclass, <span class="st">&quot;error&quot;</span>, <span class="st">&quot;condition&quot;</span>)
  )
  <span class="kw">stop</span>(err)
}

err &lt;-<span class="st"> </span><span class="kw">catch_cnd</span>(<span class="kw">stop_custom</span>(<span class="st">&quot;error_new&quot;</span>, <span class="st">&quot;This is a custom error&quot;</span>, <span class="dt">x =</span> <span class="dv">10</span>))
<span class="kw">class</span>(err)
err<span class="op">$</span>x</code></pre>
</div>
<p>We can now rewrite <code>my_log()</code> to use this new helper:</p>
<pre class="sourceCode r"><code class="sourceCode r">my_log &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">base =</span> <span class="kw">exp</span>(<span class="dv">1</span>)) {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.numeric</span>(x)) {
    <span class="kw">abort_bad_argument</span>(<span class="st">&quot;x&quot;</span>, <span class="dt">must =</span> <span class="st">&quot;be numeric&quot;</span>, <span class="dt">not =</span> x)
  }
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.numeric</span>(base)) {
    <span class="kw">abort_bad_argument</span>(<span class="st">&quot;base&quot;</span>, <span class="dt">must =</span> <span class="st">&quot;be numeric&quot;</span>, <span class="dt">not =</span> base)
  }

  base<span class="op">::</span><span class="kw">log</span>(x, <span class="dt">base =</span> base)
}</code></pre>
<p><code>my_log()</code> itself is not much shorter, but is a little more meangingful, and it ensures that error messages for bad arguments are consistent across functions. It yields the same interactive error messages as before:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">my_log</span>(letters)
<span class="co">#&gt; Error: `x` must be numeric; not character.</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─global::my_log(letters)</span>
<span class="co">#&gt;  2.   └─global::abort_bad_argument(&quot;x&quot;, must = &quot;be numeric&quot;, not = x)</span>
<span class="kw">my_log</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">base =</span> letters)
<span class="co">#&gt; Error: `base` must be numeric; not character.</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. └─global::my_log(1:10, base = letters)</span>
<span class="co">#&gt;  2.   └─global::abort_bad_argument(&quot;base&quot;, must = &quot;be numeric&quot;, not = base)</span></code></pre>
</div>
<div id="handling" class="section level3">
<h3><span class="header-section-number">8.5.3</span> Handling</h3>
<p></p>
<p>These structured condition objects are much easier to program with. The first place you might want to use this capability is when testing your function. Unit testing is not a subject of this book (see R packages<span id="fn89" class="footnote" data-pagedown-footnote-number="89" style="white-space: pre-line;"><a href="http://r-pkgs.had.co.nz/" class="uri">http://r-pkgs.had.co.nz/</a></span> for details), but the basics are easy to understand. The following code captures the error, and then asserts it has the structure that we expect.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(testthat)
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: &#39;testthat&#39;</span>
<span class="co">#&gt; The following objects are masked from &#39;package:rlang&#39;:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     is_false, is_null, is_true</span>

err &lt;-<span class="st"> </span><span class="kw">catch_cnd</span>(<span class="kw">my_log</span>(<span class="st">&quot;a&quot;</span>))
<span class="kw">expect_s3_class</span>(err, <span class="st">&quot;error_bad_argument&quot;</span>)
<span class="kw">expect_equal</span>(err<span class="op">$</span>arg, <span class="st">&quot;x&quot;</span>)
<span class="kw">expect_equal</span>(err<span class="op">$</span>not, <span class="st">&quot;character&quot;</span>)</code></pre>
<p>We can also use the class (<code>error_bad_argument</code>) in <code>tryCatch()</code> to only handle that specific error:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">error_bad_argument =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;bad_argument&quot;</span>,
  <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;other error&quot;</span>,
  <span class="kw">my_log</span>(<span class="st">&quot;a&quot;</span>)
)
<span class="co">#&gt; [1] &quot;bad_argument&quot;</span></code></pre>
<p>When using <code>tryCatch()</code> with multiple handlers and custom classes, the first handler to match any class in the signal’s class vector is called, not the best match. For this reason, you need to make sure to put the most specific handlers first. The following code does not do what you might hope:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(
  <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;other error&quot;</span>,
  <span class="dt">error_bad_argument =</span> <span class="cf">function</span>(cnd) <span class="st">&quot;bad_argument&quot;</span>,
  <span class="kw">my_log</span>(<span class="st">&quot;a&quot;</span>)
)
<span class="co">#&gt; [1] &quot;other error&quot;</span></code></pre>
</div>
<div id="exercises-26" class="section level3">
<h3><span class="header-section-number">8.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Inside a package, it’s occasionally useful to check that a package is
installed before using it. Write a function that checks if a package is
installed (with <code>requireNamespace(&quot;pkg&quot;, quietly = FALSE))</code> and if not,
throws a custom condition that includes the package name in the metadata.</p></li>
<li><p>Inside a package you often need to stop with an error when something
is not right. Other packages that depend on your package might be
tempted to check these errors in their unit tests. How could you help
these packages to avoid relying on the error message which is part of
the user interface rather than the API and might change without notice?</p></li>
</ol>
</div>
</div>
<div id="condition-applications" class="section level2">
<h2><span class="header-section-number">8.6</span> Applications</h2>
<p>Now that you’ve learned the basic tools of R’s condition system, it’s time to dive into some applications. The goal of this section is not to show every possible usage of <code>tryCatch()</code> and <code>withCallingHandlers()</code> but to illustrate some common patterns that frequently crop up. Hopefully these will get your creative juices flowing, so when you encounter a new problem you can come up with a useful solution.</p>
<div id="failure-value" class="section level3">
<h3><span class="header-section-number">8.6.1</span> Failure value</h3>

<p>There are a few simple, but useful, <code>tryCatch()</code> patterns based on returning a value from the error handler. The simplest case is a wrapper to return a “default” value if an error occurs:</p>
<pre class="sourceCode r"><code class="sourceCode r">fail_with &lt;-<span class="st"> </span><span class="cf">function</span>(expr, <span class="dt">value =</span> <span class="ot">NULL</span>) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) value,
    expr
  )
}

<span class="kw">fail_with</span>(<span class="kw">log</span>(<span class="dv">10</span>), <span class="ot">NA_real_</span>)
<span class="co">#&gt; [1] 2.3</span>
<span class="kw">fail_with</span>(<span class="kw">log</span>(<span class="st">&quot;x&quot;</span>), <span class="ot">NA_real_</span>)
<span class="co">#&gt; [1] NA</span></code></pre>
<p>A more sophisticated application is <code>base::try()</code>. Below, <code>try2()</code> extracts the essence of <code>base::try()</code>; the real function is more complicated in order to make the error message look more like what you’d see if <code>tryCatch()</code> wasn’t used.</p>
<pre class="sourceCode r"><code class="sourceCode r">try2 &lt;-<span class="st"> </span><span class="cf">function</span>(expr, <span class="dt">silent =</span> <span class="ot">FALSE</span>) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) {
      msg &lt;-<span class="st"> </span><span class="kw">conditionMessage</span>(cnd)
      <span class="cf">if</span> (<span class="op">!</span>silent) {
        <span class="kw">message</span>(<span class="st">&quot;Error: &quot;</span>, msg)
      }
      <span class="kw">structure</span>(msg, <span class="dt">class =</span> <span class="st">&quot;try-error&quot;</span>)
    },
    expr
  )
}

<span class="kw">try2</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] 1</span>
<span class="kw">try2</span>(<span class="kw">stop</span>(<span class="st">&quot;Hi&quot;</span>))
<span class="co">#&gt; Error: Hi</span>
<span class="co">#&gt; [1] &quot;Hi&quot;</span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;try-error&quot;</span>
<span class="kw">try2</span>(<span class="kw">stop</span>(<span class="st">&quot;Hi&quot;</span>), <span class="dt">silent =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] &quot;Hi&quot;</span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;try-error&quot;</span></code></pre>
</div>
<div id="try-success-failure" class="section level3">
<h3><span class="header-section-number">8.6.2</span> Success and failure values</h3>
<p>We can extend this pattern to returns one value if the code evaluates successfully (<code>success_val</code>), and another if it fails (<code>error_val</code>). This pattern just requires one small trick: evaluating the user supplied code, then <code>success_val</code>. If the code throws an error, we’ll never get to <code>success_val</code> and will instead return <code>error_val</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">foo &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) error_val,
    {
      expr
      success_val
    }
  )
}</code></pre>
<p>We can use this to determine if an expression fails:</p>
<pre class="sourceCode r"><code class="sourceCode r">does_error &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) <span class="ot">TRUE</span>,
    {
      expr
      <span class="ot">FALSE</span>
    }
  )
}</code></pre>
<p>Or to capture any condition, like just <code>rlang::catch_cnd()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">catch_cnd &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="kw">tryCatch</span>(
    <span class="dt">condition =</span> <span class="cf">function</span>(cnd) cnd, 
    {
      expr
      <span class="ot">NULL</span>
    }
  )
}</code></pre>
<p>We can also use this pattern to create a <code>try()</code> variant. One challenge with <code>try()</code> is that it’s slightly challenging to determine if the code succeeded or failed. Rather than returning an object with a special class, I think it’s slightly nicer to return a list with two components <code>result</code> and <code>error</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">safety &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) {
      <span class="kw">list</span>(<span class="dt">result =</span> <span class="ot">NULL</span>, <span class="dt">error =</span> cnd)
    },
    <span class="kw">list</span>(<span class="dt">result =</span> expr, <span class="dt">error =</span> <span class="ot">NULL</span>)
  )
}

<span class="kw">str</span>(<span class="kw">safety</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">10</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result: num 11</span>
<span class="co">#&gt;  $ error : NULL</span>
<span class="kw">str</span>(<span class="kw">safety</span>(<span class="kw">stop</span>(<span class="st">&quot;Error!&quot;</span>)))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result: NULL</span>
<span class="co">#&gt;  $ error :List of 2</span>
<span class="co">#&gt;   ..$ message: chr &quot;Error!&quot;</span>
<span class="co">#&gt;   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)</span>
<span class="co">#&gt;   ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>(This is closely related to <code>purrr::safely()</code>, a function operator, which we’ll come back to in Section <a href="#safely">11.2.1</a>.)</p>
</div>
<div id="resignal" class="section level3">
<h3><span class="header-section-number">8.6.3</span> Resignal</h3>
<p></p>
<p>As well as returning default values when a condition is signalled, handlers can be used to make more informative error messages. One simple application is to make a function that works like <code>options(warn = 2)</code> for a single block of code. The idea is simple: we handle warnings by throwing an error:</p>
<pre class="sourceCode r"><code class="sourceCode r">warning2error &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">warning =</span> <span class="cf">function</span>(cnd) <span class="kw">abort</span>(<span class="kw">conditionMessage</span>(cnd)),
    expr
  )
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">warning2error</span>({
  x &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">^</span><span class="st"> </span><span class="dv">4</span>
  <span class="kw">warn</span>(<span class="st">&quot;Hello&quot;</span>)
})
<span class="co">#&gt; Error: Hello</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─global::warning2error(...)</span>
<span class="co">#&gt;  2. │ └─base::withCallingHandlers(...)</span>
<span class="co">#&gt;  3. ├─rlang::warn(&quot;Hello&quot;)</span>
<span class="co">#&gt;  4. │ └─base::warning(cnd)</span>
<span class="co">#&gt;  5. │   └─base::withRestarts(...)</span>
<span class="co">#&gt;  6. │     └─base:::withOneRestart(expr, restarts[[1L]])</span>
<span class="co">#&gt;  7. │       └─base:::doWithOneRestart(return(expr), restart)</span>
<span class="co">#&gt;  8. └─(function (cnd) ...</span></code></pre>
<p>You could write a similar function if you were trying to find the source of an annoying message. More on this in Section <a href="#non-error-failures">22.6</a>.</p>
<!-- 
Another common place where it's useful to add additional context dependent information. For example, you might have a function to download data from a remote website:


```r
download_data <- function(name) {
  src <- paste0("http://awesomedata.com/", name, ".csv")
  dst <- paste0("data/", name, ".csv")
  
  tryCatch(
    curl::curl_download(src, dst),
    error = function(cnd) {
      abort(
        glue::glue("Failed to download remote data `{name}`"), 
        parent = c
      )
    }
  )
}
```

There are two important ideas here:

* We rewrap `curl_download()`, which downloads the file, to provide context
  specific to our function.
  
* We include the original error as the `parent` so that the original context is
  still available.

-->
</div>
<div id="record" class="section level3">
<h3><span class="header-section-number">8.6.4</span> Record</h3>
<p>Another common pattern is to record conditions for later investigation. The new challenge here is that calling handlers are called only for their side-effects so we can’t return values, but instead need to modify some object in place.</p>
<pre class="sourceCode r"><code class="sourceCode r">catch_cnds &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  conds &lt;-<span class="st"> </span><span class="kw">list</span>()
  add_cond &lt;-<span class="st"> </span><span class="cf">function</span>(cnd) {
    conds &lt;&lt;-<span class="st"> </span><span class="kw">append</span>(conds, <span class="kw">list</span>(cnd))
    <span class="kw">cnd_muffle</span>(cnd)
  }
  
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">message =</span> add_cond,
    <span class="dt">warning =</span> add_cond,
    expr
  )
  
  conds
}

<span class="kw">catch_cnds</span>({
  <span class="kw">inform</span>(<span class="st">&quot;a&quot;</span>)
  <span class="kw">warn</span>(<span class="st">&quot;b&quot;</span>)
  <span class="kw">inform</span>(<span class="st">&quot;c&quot;</span>)
})
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; &lt;message: a</span>
<span class="co">#&gt; &gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; &lt;warning: b&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; &lt;message: c</span>
<span class="co">#&gt; &gt;</span></code></pre>
<p>What if you also want to capture errors? You’ll need to wrap the <code>withCallingHandlers()</code> in a <code>tryCatch()</code>. If an error occurs, it will be the last condition.</p>
<pre class="sourceCode r"><code class="sourceCode r">catch_cnds &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  conds &lt;-<span class="st"> </span><span class="kw">list</span>()
  add_cond &lt;-<span class="st"> </span><span class="cf">function</span>(cnd) {
    conds &lt;&lt;-<span class="st"> </span><span class="kw">append</span>(conds, <span class="kw">list</span>(cnd))
    <span class="kw">cnd_muffle</span>(cnd)
  }
  
  <span class="kw">tryCatch</span>(
    <span class="dt">error =</span> <span class="cf">function</span>(cnd) {
      conds &lt;&lt;-<span class="st"> </span><span class="kw">append</span>(conds, <span class="kw">list</span>(cnd))
    },
    <span class="kw">withCallingHandlers</span>(
      <span class="dt">message =</span> add_cond,
      <span class="dt">warning =</span> add_cond,
      expr
    )
  )
  
  conds
}

<span class="kw">catch_cnds</span>({
  <span class="kw">inform</span>(<span class="st">&quot;a&quot;</span>)
  <span class="kw">warn</span>(<span class="st">&quot;b&quot;</span>)
  <span class="kw">abort</span>(<span class="st">&quot;C&quot;</span>)
})
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; &lt;message: a</span>
<span class="co">#&gt; &gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; &lt;warning: b&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; &lt;error&gt;</span>
<span class="co">#&gt; message: C</span>
<span class="co">#&gt; class:   `rlang_error`</span>
<span class="co">#&gt; backtrace:</span>
<span class="co">#&gt;  1. global::catch_cnds(...)</span>
<span class="co">#&gt;  6. base::withCallingHandlers(...)</span>
<span class="co">#&gt; Call `rlang::last_trace()` to see the full backtrace</span></code></pre>
<p>This is the key idea underlying the evaluate package <span class="citation">(Wickham and Xie <a href="#ref-evaluate">2018</a>)</span> which powers knitr: it captures every output into a special data structure so that it can be later replayed. As a whole, the evaluate package is quite a lot more complicated than the code here because it also needs to handle plots and text output.</p>
</div>
<div id="no-default-behaviour" class="section level3">
<h3><span class="header-section-number">8.6.5</span> No default behaviour</h3>

<p>A final useful pattern is to signal a condition that doesn’t inherit from <code>message</code>, <code>warning</code> or <code>error</code>. Because there is no default behaviour, this means the condition has no effect unless the user specifically requests it. For example, you could imagine a logging system based on conditions:</p>
<pre class="sourceCode r"><code class="sourceCode r">log &lt;-<span class="st"> </span><span class="cf">function</span>(message, <span class="dt">level =</span> <span class="kw">c</span>(<span class="st">&quot;info&quot;</span>, <span class="st">&quot;error&quot;</span>, <span class="st">&quot;fatal&quot;</span>)) {
  level &lt;-<span class="st"> </span><span class="kw">match.arg</span>(level)
  <span class="kw">signal</span>(message, <span class="st">&quot;log&quot;</span>, <span class="dt">level =</span> level)
}</code></pre>
<p>When you call <code>log()</code> a condition is signalled, but nothing happens because it has no default handler:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">log</span>(<span class="st">&quot;This code was run&quot;</span>)</code></pre>
<p>To “activate” logging you need a handler that does something with the <code>log</code> condition. Below I define a <code>record_log()</code> function that will record all logging messages to a file:</p>
<pre class="sourceCode r"><code class="sourceCode r">record_log &lt;-<span class="st"> </span><span class="cf">function</span>(expr, <span class="dt">path =</span> <span class="kw">stdout</span>()) {
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">log =</span> <span class="cf">function</span>(cnd) {
      <span class="kw">cat</span>(
        <span class="st">&quot;[&quot;</span>, cnd<span class="op">$</span>level, <span class="st">&quot;] &quot;</span>, cnd<span class="op">$</span>message, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>,
        <span class="dt">file =</span> path, <span class="dt">append =</span> <span class="ot">TRUE</span>
      )
    },
    expr
  )
}

<span class="kw">record_log</span>(<span class="kw">log</span>(<span class="st">&quot;Hello&quot;</span>))
<span class="co">#&gt; [info] Hello</span></code></pre>
<p>You could even imagine layering with another function that allows you to selectively suppress some logging levels.</p>
<pre class="sourceCode r"><code class="sourceCode r">ignore_log_levels &lt;-<span class="st"> </span><span class="cf">function</span>(expr, levels) {
  <span class="kw">withCallingHandlers</span>(
    <span class="dt">log =</span> <span class="cf">function</span>(cnd) {
      <span class="cf">if</span> (cnd<span class="op">$</span>level <span class="op">%in%</span><span class="st"> </span>levels) {
        <span class="kw">cnd_muffle</span>(cnd)
      }
    },
    expr
  )
}

<span class="kw">record_log</span>(<span class="kw">ignore_log_levels</span>(<span class="kw">log</span>(<span class="st">&quot;Hello&quot;</span>), <span class="st">&quot;info&quot;</span>))</code></pre>
<div class="base">
<p>If you create a condition object by hand, and signal it with <code>signalCondition()</code>, <code>cnd_muffle()</code> will not work. Instead you need to call it with a muffle restart defined, like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">withRestarts</span>(<span class="kw">signalCondition</span>(cond), <span class="dt">muffle =</span> <span class="cf">function</span>() <span class="ot">NULL</span>)</code></pre>
<p>Restarts are currently beyond the scope of the book, but I suspect will be included in the 3rd edition.</p>
</div>
</div>
<div id="exercises-27" class="section level3">
<h3><span class="header-section-number">8.6.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Create <code>suppressConditions()</code> that works like <code>suppressMessages()</code> and
<code>suppressWarnings()</code> but suppresses everything. Think carefully about how you
should handle errors.</p></li>
<li><p>Compare the following two implementations of <code>message2error()</code>. What is the
main advantage of <code>withCallingHandlers()</code> in this scenario? (Hint: look
carefully at the traceback.)</p>
<pre class="sourceCode r"><code class="sourceCode r">message2error &lt;-<span class="st"> </span><span class="cf">function</span>(code) {
  <span class="kw">withCallingHandlers</span>(code, <span class="dt">message =</span> <span class="cf">function</span>(e) <span class="kw">stop</span>(e))
}
message2error &lt;-<span class="st"> </span><span class="cf">function</span>(code) {
  <span class="kw">tryCatch</span>(code, <span class="dt">message =</span> <span class="cf">function</span>(e) <span class="kw">stop</span>(e))
}</code></pre></li>
<li><p>How would you modify the <code>catch_cnds()</code> definition if you wanted to recreate
the original intermingling of warnings and messages?</p></li>
<li><p>Why is catching interrupts dangerous? Run this code to find out.</p>
<pre class="sourceCode r"><code class="sourceCode r">bottles_of_beer &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">i =</span> <span class="dv">99</span>) {
  <span class="kw">message</span>(
    <span class="st">&quot;There are &quot;</span>, i, <span class="st">&quot; bottles of beer on the wall, &quot;</span>, 
    i, <span class="st">&quot; bottles of beer.&quot;</span>
  )
  <span class="cf">while</span>(i <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="kw">tryCatch</span>(
      <span class="kw">Sys.sleep</span>(<span class="dv">1</span>),
      <span class="dt">interrupt =</span> <span class="cf">function</span>(err) {
        i &lt;&lt;-<span class="st"> </span>i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>
        <span class="cf">if</span> (i <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
          <span class="kw">message</span>(
            <span class="st">&quot;Take one down, pass it around, &quot;</span>, i, 
            <span class="st">&quot; bottle&quot;</span>, <span class="cf">if</span> (i <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>) <span class="st">&quot;s&quot;</span>, <span class="st">&quot; of beer on the wall.&quot;</span>
          )
        }
      }
    )
  }
  <span class="kw">message</span>(
    <span class="st">&quot;No more bottles of beer on the wall, &quot;</span>, 
    <span class="st">&quot;no more bottles of beer.&quot;</span>
  )
}</code></pre></li>
</ol>
</div>
</div>
<div id="conditions-answers" class="section level2">
<h2><span class="header-section-number">8.7</span> Quiz answers</h2>
<ol style="list-style-type: decimal">
<li><p><code>error</code>, <code>warning</code>, and <code>message</code>.</p></li>
<li><p>You could use <code>try()</code> or <code>tryCatch()</code>.</p></li>
<li><p><code>tryCatch()</code> creates exiting handlers which will terminate the execution
of wrapped code; <code>withCallingHandlers()</code> creates calling handlers which
don’t affect the execution of wrapped code.</p></li>
<li><p>Because you can then capture specific types of error with <code>tryCatch()</code>,
rather than relying on the comparison of error strings, which is risky,
especially when messages are translated.</p></li>
</ol>
<!--chapter:end:Conditions.Rmd-->
</div>
</div>
<div id="part-functional-programming" class="section level1 unnumbered">
<h1><span class="header-section-number">II</span> Functional programming</h1>
</div>
<div id="fp" class="section level1 unnumbered">
<h1>Introduction</h1>
<p></p>
<p>R, at its heart, is a <strong>functional</strong> language. This means that it has certain technical properties, but more importantly that it lends itself to a style of problem solving centred on functions. Below I’ll give a brief overview of the technical definition of a functional <em>language</em>, but in this book I will primarily focus on the functional <em>style</em> of programming, because I think it is an extremely good fit to the types of problem you commonly encounter when doing data analysis.</p>
<p>Recently, functional techniques have experienced a surge in interest because they can produce efficient and elegant solutions to many modern problems. A functional style tends to create functions that can easily be analysed in isolation (i.e. using only local information), and hence is often much easier to automatically optimise or parallelise. The traditional weaknesses of functional languages, poorer performance and sometimes unpredictable memory usage, have been much reduced in recent years. Functional programming is complementary to object oriented programming, which has been the dominant programming paradigm for the last several decades.</p>
<div id="functional-programming-languages" class="section level2 unnumbered">
<h2>Functional programming languages</h2>
<p>Every programming language has functions, so what makes a programming language functional? There are many definitions for precisely what makes a language “functional”, but there are two common threads.</p>
<p>Firstly, functional languages have <strong>first-class functions</strong>, functions that behave like any other data structure. In R, this means that you can do many of the things with a function that you can do with a vector: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function.</p>
<p>Secondly, many functional languages require functions to be <strong>pure</strong>. A function is pure if it satisfies two properties:</p>
<ul>
<li><p>The output only depends on the inputs, i.e. if you call it again with the
same inputs, you get the same outputs. This excludes functions like <code>runif()</code>,
<code>read.csv()</code>, or <code>Sys.time()</code> that can return different values.</p></li>
<li><p>The function has no side-effects, like changing the value of a global
variable, writing to disk, or displaying to the screen. This excludes
functions like <code>print()</code>, <code>write.csv()</code> and <code>&lt;-</code>.</p></li>
</ul>
<p>Pure functions are much easier to reason about, but obviously have significant downsides: imagine doing a data analysis where you couldn’t generate random numbers or read files from disk.</p>
<p>Strictly speaking, R isn’t a functional programming <em>language</em> because it doesn’t require that you write pure functions. However, you can certainly adopt a functional style in parts of your code: you don’t <em>have</em> to write pure functions, but you often <em>should</em>. In my experience, partitioning code into functions that are either extremely pure or extremely impure tends to lead to code that is easier to understand and extends to new situations.</p>
</div>
<div id="functional-style" class="section level2 unnumbered">
<h2>Functional style</h2>
<p>It’s hard to describe exactly what a functional <em>style</em> is, but generally I think it means decomposing a big problem into smaller pieces, then solving each piece with a function or combination of functions. When using a functional style, you strive to decompose components of the problem into isolated functions that operate independently. Each function taken by itself is simple and straightforward to understand; complexity is handled by composing functions in various ways.</p>
<p>The following three chapters discuss the three key functional techniques that help you to decompose problems into smaller pieces:</p>
<ul>
<li><p>Chapter <a href="#functionals">9</a> shows you how to replace many for loops with
<strong>functionals</strong> which are functions (like <code>lapply()</code>) that take another
function as an argument. Functionals allow you to take a function that solves
the problem for a single input and generalise it to handle any number of
inputs. Functionals are by far and away the most important technique and
you’ll use them all the time in data analysis.</p></li>
<li><p>Chapter <a href="#function-factories">10</a> introduces <strong>function factories</strong>:
functions that create functions. Function factories are less commonly
used than functionals, but can allow you to elegantly partition work
between different parts of your code.</p></li>
<li><p>Chapter <a href="#function-operators">11</a> shows you how to create <strong>function
operators</strong>: functions that take functions as input and produce functions
as output. They are like adverbs, because they typically modify the operation
of a function.</p></li>
</ul>
<p>Collectively, these types of function are called <strong>higher-order functions</strong> and they fill out a two-by-two table:</p>
<p><img src="diagrams/fp.png" width="283" style="display: block; margin: auto;" /></p>
<!--chapter:end:FP.Rmd-->
</div>
</div>
<div id="functionals" class="section level1">
<h1><span class="header-section-number">9</span> Functionals</h1>
<div id="introduction-8" class="section level2">
<h2><span class="header-section-number">9.1</span> Introduction</h2>
<p></p>
<blockquote>
<p>“To become significantly more reliable, code must become more transparent.
In particular, nested conditions and loops must be viewed with great
suspicion. Complicated control flows confuse programmers. Messy code often
hides bugs.”</p>
<p>— Bjarne Stroustrup</p>
</blockquote>
<p>A <strong>functional</strong> is a function that takes a function as an input and returns a vector as output. Here’s a simple functional: it calls the function provided as input with 1000 random uniform numbers.</p>
<pre class="sourceCode r"><code class="sourceCode r">randomise &lt;-<span class="st"> </span><span class="cf">function</span>(f) <span class="kw">f</span>(<span class="kw">runif</span>(<span class="fl">1e3</span>))
<span class="kw">randomise</span>(mean)
<span class="co">#&gt; [1] 0.506</span>
<span class="kw">randomise</span>(mean)
<span class="co">#&gt; [1] 0.501</span>
<span class="kw">randomise</span>(sum)
<span class="co">#&gt; [1] 489</span></code></pre>
<p>The chances are that you’ve already used a functional. You might have used for-loop replacements like base R’s <code>lapply()</code>, <code>apply()</code>, and <code>tapply()</code>; or purrr’s <code>map()</code>; or maybe you’ve used a mathematical functional like <code>integrate()</code> or <code>optim()</code>.</p>
<p>
A common use of functionals is as an alternative to for loops. For loops have a bad rap in R because many people believe they are slow<span id="fn90" class="footnote" data-pagedown-footnote-number="90" style="white-space: pre-line;">Typically it’s not the for loop itself that’s slow, but what you’re doing inside of it. A common culprit of slow loops is modifying a data structure, where each modification generates a copy. See Sections <a href="#single-binding">2.5.1</a> and <a href="#avoid-copies">24.6</a> for more details.</span>, but the real downside of for loops is that they’re very flexible: a loop conveys that you’re iterating, but not what should be done with the results. Just as it’s better to use <code>while</code> than <code>repeat</code>, and it’s better to use <code>for</code> than <code>while</code> (Section <a href="#for-family">5.3.2</a>), it’s better to use a functional than <code>for</code>. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it’s being used.</p>
<p>If you’re an experienced for loop user, switching to functionals is typically a pattern matching exercise. You look at the for loop and find a functional that matches the basic form. If one doesn’t exist, don’t try and torture an existing functional to fit the form you need. Instead, just leave it as a for loop! (Or once you’ve repeated the same loop two or more times, maybe think about writing your own functional).</p>
<div id="outline-7" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#map">9.2</a> introduces your first functional: <code>purrr::map()</code>.</p></li>
<li><p>Section <a href="#purrr-style">9.3</a> demonstrates how you can combine multiple simple
functionals to solve a more complex problem and discusses how purrr style
differs from other approaches.</p></li>
<li><p>Section <a href="#map-variants">9.4</a> teaches you about 18 (!!) important variants of
<code>purrr::map()</code>. Fortunately, their orthogonal design makes them easy to
learn, remember, and master.</p></li>
<li><p>Section <a href="#reduce">9.5</a> introduces a new style of functional: <code>purrr:reduce()</code>.
<code>reduce()</code> systematically reduces a vector to a single result by applying
a function that takes two inputs.</p></li>
<li><p>Section <a href="#predicate-functionals">9.6</a> teaches you about predicates: functions
that return a single <code>TRUE</code> or <code>FALSE</code>, and the family of functionals
that use them to solve common problems.</p></li>
<li><p>Section <a href="#base-functionals">9.7</a> reviews some functionals in base R that
are not members of the map, reduce, or predicate families.</p></li>
</ul>
</div>
<div id="prerequisites-3" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>This chapter will focus on functionals provided by the purrr package<span id="fn91" class="footnote" data-pagedown-footnote-number="91" style="white-space: pre-line;"><a href="https://purrr.tidyverse.org" class="uri">https://purrr.tidyverse.org</a></span> <span class="citation">(Henry and Wickham <a href="#ref-purrr">2018</a><a href="#ref-purrr">a</a>)</span>. These functions have a consistent interface that makes it easier to understand the key ideas than their base equivalents, which have grown organically over many years. I’ll compare and contrast base R functions as we go, and then wrap up the chapter with a discussion of base functionals that don’t have purrr equivalents.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(purrr)</code></pre>
</div>
</div>
<div id="map" class="section level2">
<h2><span class="header-section-number">9.2</span> My first functional: <code>map()</code></h2>

<p>The most fundamental functional is <code>purrr::map()</code><span id="fn92" class="footnote" data-pagedown-footnote-number="92" style="white-space: pre-line;">Not to be confused with <code>base::Map()</code>, which is considerably more complex. I’ll discuss <code>Map()</code> in Section <a href="#pmap">9.4.5</a>.</span>. It takes a vector and a function, calls the function once for each element of the vector, and returns the results in a list. In other words, <code>map(1:3, f)</code> is equivalent to <code>list(f(1), f(2), f(3))</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">triple &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">*</span><span class="st"> </span><span class="dv">3</span>
<span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, triple)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 9</span></code></pre>
<p>Or, graphically:</p>
<p><img src="diagrams/functionals/map.png" width="260" style="display: block; margin: auto;" /></p>
<div class="sidebar">
<p>You might wonder why this function is called <code>map()</code>. What does it have to do with depicting physical features of land or sea 🗺? In fact, the meaning comes from mathematics where map refers to “an operation that associates each element of a given set with one or more elements of a second set”. This makes sense here because <code>map()</code> defines a mapping from one vector to another. (“Map” also has the nice property of being short, which is useful for such a fundamental building block.)</p>
</div>
<p>The implementation of <code>map()</code> is quite simple. We allocate a list the same length as the input, and then fill in the list with a for loop. The heart of the implementation is only a handful of lines of code:</p>
<pre class="sourceCode r"><code class="sourceCode r">simple_map &lt;-<span class="st"> </span><span class="cf">function</span>(x, f, ...) {
  out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(x))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
    out[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]], ...)
  }
  out
}</code></pre>
<p>The real <code>purrr::map()</code> function has a few differences: it is written in C to eke out every last iota of performance, preserves names, and supports a few shortcuts that you’ll learn about in Section <a href="#purrr-shortcuts">9.2.2</a>.</p>
<div class="base">
<p>The base equivalent to <code>map()</code> is <code>lapply()</code>. The only difference is that <code>lapply()</code> does not support the helpers that you’ll learn about below, so if you’re only using <code>map()</code> from purrr, you can skip the additional dependency and use <code>lapply()</code> directly.</p>
</div>
<div id="map-atomic" class="section level3">
<h3><span class="header-section-number">9.2.1</span> Producing atomic vectors</h3>
<p><code>map()</code> returns a list, which makes it the most general of the “map” family because you can put anything in a list. But it is inconvenient to return a list when a simpler data structure would do, so there are four more specific variants: <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code>, and <code>map_chr()</code>. Each returns an atomic vector of the specified type:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># map_chr() always returns a character vector</span>
<span class="kw">map_chr</span>(mtcars, typeof)
<span class="co">#&gt;      mpg      cyl     disp       hp     drat       wt     qsec       vs </span>
<span class="co">#&gt; &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;double&quot; &quot;double&quot; </span>
<span class="co">#&gt;       am     gear     carb </span>
<span class="co">#&gt; &quot;double&quot; &quot;double&quot; &quot;double&quot;</span>

<span class="co"># map_lgl() always returns a logical vector</span>
<span class="kw">map_lgl</span>(mtcars, is.double)
<span class="co">#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb </span>
<span class="co">#&gt; TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE</span>

<span class="co"># map_int() always returns a integer vector</span>
n_unique &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">length</span>(<span class="kw">unique</span>(x))
<span class="kw">map_int</span>(mtcars, n_unique)
<span class="co">#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb </span>
<span class="co">#&gt;   25    3   27   22   22   29   30    2    2    3    6</span>

<span class="co"># map_dbl() always returns a double vector</span>
<span class="kw">map_dbl</span>(mtcars, mean)
<span class="co">#&gt;     mpg     cyl    disp      hp    drat      wt    qsec      vs      am </span>
<span class="co">#&gt;  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406 </span>
<span class="co">#&gt;    gear    carb </span>
<span class="co">#&gt;   3.688   2.812</span></code></pre>
<p>purrr uses the convention that suffixes, like <code>_dbl()</code>, refer to the output. All <code>map_*()</code> functions can take any type of vector as input. These examples rely two facts: <code>mtcars</code> is a data frame, and data frames are lists containing vectors of the same length. This is more obvious if we draw a data frame with the same orientation as vector:</p>
<p><img src="diagrams/functionals/map-list.png" width="335" style="display: block; margin: auto;" /></p>
<p>All map functions always return an output vector the same length as the input, which implies that each call to <code>.f</code> must return a single value. If it does not, you’ll get an error:</p>
<pre class="sourceCode r"><code class="sourceCode r">pair &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">c</span>(x, x)
<span class="kw">map_dbl</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, pair)
<span class="co">#&gt; Error: Result 1 is not a length 1 atomic vector</span></code></pre>
<p>This is similar to the error you’ll get if <code>.f</code> returns the wrong type of result:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, as.character)
<span class="co">#&gt; Error: Can&#39;t coerce element 1 from a character to a double</span></code></pre>
<p>In either case, it’s often useful to switch back to <code>map()</code>, because <code>map()</code> can accept any type of output. That allows you to see the problematic output, and figure out what to do with it.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, pair)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 2 2</span>
<span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, as.character)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;1&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] &quot;2&quot;</span></code></pre>
<div class="base">
<p>Base R has two apply functions that can return atomic vectors: <code>sapply()</code> and <code>vapply()</code>. I recommend that you avoid <code>sapply()</code> because it tries simplify the result, so it can return a list, a vector, or a matrix. This makes it difficult to program with, and it should be avoided in non-interactive settings. <code>vapply()</code> is safer because it allows you to provide a template, <code>FUN.VALUE</code>, that describes the output shape. If you don’t want to use purrr, I recommend using always use <code>vapply()</code> in your functions, not <code>sapply()</code>. The primary downside of <code>vapply()</code> is its verbosity: for example, the equivalent to <code>map_dbl(x, mean, na.rm = TRUE)</code> is <code>vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))</code>.</p>
</div>
</div>
<div id="purrr-shortcuts" class="section level3">
<h3><span class="header-section-number">9.2.2</span> Anonymous functions and shortcuts</h3>
<p>
</p>
<p>Instead of using <code>map()</code> with an existing function, you can create an inline anonymous function (as mentioned in Section <a href="#first-class-functions">6.2.3</a>):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(mtcars, <span class="cf">function</span>(x) <span class="kw">length</span>(<span class="kw">unique</span>(x)))
<span class="co">#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb </span>
<span class="co">#&gt;   25    3   27   22   22   29   30    2    2    3    6</span></code></pre>
<p>Anonymous functions are very useful, but the syntax is verbose. So purrr supports a special shortcut:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(mtcars, <span class="op">~</span><span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(.x)))
<span class="co">#&gt;  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb </span>
<span class="co">#&gt;   25    3   27   22   22   29   30    2    2    3    6</span></code></pre>
<p>This works because all purrr functions translate formulas, created by <code>~</code> (pronounced “twiddle”), into functions. You can see what’s happening behind the scenes by calling <code>as_mapper()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_mapper</span>(<span class="op">~</span><span class="st"> </span><span class="kw">length</span>(<span class="kw">unique</span>(.x)))
<span class="co">#&gt; &lt;lambda&gt;</span>
<span class="co">#&gt; function (..., .x = ..1, .y = ..2, . = ..1) </span>
<span class="co">#&gt; length(unique(.x))</span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;rlang_lambda_function&quot;</span></code></pre>
<p>The function arguments look a little quirky but allow you to refer to <code>.</code> for one argument functions, <code>.x</code> and <code>.y.</code> for two argument functions, and <code>..1</code>, <code>..2</code>, <code>..3</code>, etc, for functions with an arbitrary number of arguments. <code>.</code> remains for backward compatibility but I don’t recommend using it because it’s easily confused with the <code>.</code> use by magrittr’s pipe.</p>
<p>This shortcut is particularly useful for generating random data:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="op">~</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">2</span>))
<span class="kw">str</span>(x)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:2] 0.281 0.53</span>
<span class="co">#&gt;  $ : num [1:2] 0.433 0.917</span>
<span class="co">#&gt;  $ : num [1:2] 0.0275 0.8249</span></code></pre>
<p>Reserve this syntax for short and simple functions. A good rule of thumb is that if your function spans lines or uses <code>{}</code>, it’s time to give it a name.</p>

<p>The map functions also have shortcuts for extracting elements from a vector, powered by <code>purrr::pluck()</code>. You can use a character vector to select elements by name, an integer vector to select by position, or a list to select by both name and position. These are very useful for working with deeply nested lists, which often arise when working with JSON.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">list</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">2</span>), <span class="dt">z =</span> <span class="st">&quot;a&quot;</span>),
  <span class="kw">list</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dt">x =</span> <span class="dv">4</span>, <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">6</span>), <span class="dt">z =</span> <span class="st">&quot;b&quot;</span>),
  <span class="kw">list</span>(<span class="op">-</span><span class="dv">3</span>, <span class="dt">x =</span> <span class="dv">8</span>, <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>))
)

<span class="co"># Select by name</span>
<span class="kw">map_dbl</span>(x, <span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; [1] 1 4 8</span>

<span class="co"># Or by position</span>
<span class="kw">map_dbl</span>(x, <span class="dv">1</span>)
<span class="co">#&gt; [1] -1 -2 -3</span>

<span class="co"># Or by both</span>
<span class="kw">map_dbl</span>(x, <span class="kw">list</span>(<span class="st">&quot;y&quot;</span>, <span class="dv">1</span>))
<span class="co">#&gt; [1] 2 5 9</span>

<span class="co"># You&#39;ll get an error if a component doesn&#39;t exist:</span>
<span class="kw">map_chr</span>(x, <span class="st">&quot;z&quot;</span>)
<span class="co">#&gt; Error: Result 3 is not a length 1 atomic vector</span>

<span class="co"># Unless you supply a .default value</span>
<span class="kw">map_chr</span>(x, <span class="st">&quot;z&quot;</span>, <span class="dt">.default =</span> <span class="ot">NA</span>)
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; NA</span></code></pre>
<div class="base">
<p>In base R functions, like <code>lapply()</code>, you can provide the name of the function as a string. This isn’t tremendously useful as <code>lapply(x, &quot;f&quot;)</code> is almost always equivalent to <code>lapply(x, f)</code> and is more typing.</p>
</div>
</div>
<div id="passing-arguments" class="section level3">
<h3><span class="header-section-number">9.2.3</span> Passing arguments with <code>...</code></h3>

<p></p>
<p>It’s often convenient to pass along additional arguments to the function that you’re calling. For example, you might want to pass <code>na.rm = TRUE</code> along to <code>mean()</code>. One way to do that is with an anonymous function:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="ot">NA</span>))
<span class="kw">map_dbl</span>(x, <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(.x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; [1] 3.0 5.5</span></code></pre>
<p>But because the map functions pass <code>...</code> along, there’s a simpler form available:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(x, mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 3.0 5.5</span></code></pre>
<p>This is easiest to understand with a picture: any arguments that come after <code>f</code> in the call to <code>map()</code> are inserted <em>after</em> the data in individual calls to <code>f()</code>:</p>
<p><img src="diagrams/functionals/map-arg.png" width="359" style="display: block; margin: auto;" /></p>
<p>It’s important to note that these arguments are not decomposed; or said another way, <code>map()</code> is only vectorised over its first argument. If an argument after <code>f</code> is a vector, it will be passed along as is:</p>
<p><img src="diagrams/functionals/map-arg-recycle.png" width="345" style="display: block; margin: auto;" /></p>
<p>(You’ll learn about map variants that <em>are</em> vectorised over multiple arguments in Sections <a href="#map2">9.4.2</a> and <a href="#pmap">9.4.5</a>.)</p>
<p>Note there’s a subtle difference between placing extra arguments inside an anonymous function compared with passing them to <code>map()</code>. Putting them in an anonymous function means that they will be evaluated every time <code>f()</code> is executed, not just once when you call <code>map()</code>. This is easiest to see if we make the additional argument random:</p>
<pre class="sourceCode r"><code class="sourceCode r">plus &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) x <span class="op">+</span><span class="st"> </span>y

x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)
<span class="kw">map_dbl</span>(x, plus, <span class="kw">runif</span>(<span class="dv">1</span>))
<span class="co">#&gt; [1] 0.0625 0.0625 0.0625 0.0625</span>
<span class="kw">map_dbl</span>(x, <span class="op">~</span><span class="st"> </span><span class="kw">plus</span>(.x, <span class="kw">runif</span>(<span class="dv">1</span>)))
<span class="co">#&gt; [1] 0.903 0.132 0.629 0.945</span></code></pre>
</div>
<div id="argument-names" class="section level3">
<h3><span class="header-section-number">9.2.4</span> Argument names</h3>
<p>In the diagrams, I’ve omitted argument names to focus on the overall structure. But I recommend writing out the full names in your code, as it makes it easier to read. <code>map(x, mean, 0.1)</code> is perfectly valid code, but will call <code>mean(x[[1]], 0.1)</code> so it relies on the reader remembering that the second argument to <code>mean()</code> is <code>trim</code>. To avoid unnecessary burden on the brain of the reader<span id="fn93" class="footnote" data-pagedown-footnote-number="93" style="white-space: pre-line;">Who is highly likely to be future you!</span>, be kind and write <code>map(x, mean, trim = 0.1)</code>.</p>
<p>This is the reason why the arguments to <code>map()</code> are a little odd: instead of being <code>x</code> and <code>f</code>, they are <code>.x</code> and <code>.f</code>. It’s easiest to see the problem that leads to these names using <code>simple_map()</code> defined above. <code>simple_map()</code> has arguments <code>x</code> and <code>f</code> so you’ll have problems whenever the function you are calling has arguments <code>x</code> or <code>f</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">boostrap_summary &lt;-<span class="st"> </span><span class="cf">function</span>(x, f) {
  <span class="kw">f</span>(<span class="kw">sample</span>(x, <span class="dt">replace =</span> <span class="ot">TRUE</span>))
}

<span class="kw">simple_map</span>(mtcars, boostrap_summary, <span class="dt">f =</span> mean)
<span class="co">#&gt; Error in mean.default(x[[i]], ...):</span>
<span class="co">#&gt;   &#39;trim&#39; must be numeric of length one</span></code></pre>
<!-- GVW: a diagram here showing how the various f's and x's are matched to one another in the example above would be very helpful -->
<p>The error is a little bewildering until you remember that the call to <code>simple_map()</code> is equivalent to <code>simple_map(x = mtcars, f = mean, bootstrap_summary)</code> because named matching beats positional matching.</p>
<p>purrr functions reduce the likelihood of such a clash by using <code>.f</code> and <code>.x</code> instead of the more common <code>f</code> and <code>x</code>. Of course this technique isn’t perfect (because the function you are calling might still use <code>.f</code> and <code>.x</code>), but it avoids 99% of issues. The remaining 1% of the time, use an anonymous function.</p>
<div class="base">
<p>Base functions that pass along <code>...</code> use a variety of naming conventions to prevent undesired argument matching:</p>
<ul>
<li><p>The apply family mostly uses capital letters (e.g. <code>X</code> and <code>FUN</code>).</p></li>
<li><p><code>transform()</code> uses the more exotic prefix <code>_</code>: this makes the name non-syntactic
so it must always be surrounded in <code>`</code>, as described in
Section <a href="#non-syntactic">2.2.1</a>. This makes undesired matches extremely
unlikely.</p></li>
<li>Other functionals like <code>uniroot()</code> and <code>optim()</code> make no effort to avoid
clashes but they tend to be used with specially created functions so
clashes are less likely.</li>
</ul>
</div>
</div>
<div id="change-argument" class="section level3">
<h3><span class="header-section-number">9.2.5</span> Varying another argument</h3>
<p>So far the first argument to <code>map()</code> has always become the first argument to the function. But what happens if the first argument should be constant, and you want to vary a different argument? How do you get the result in this picture?</p>
<p><img src="diagrams/functionals/map-arg-flipped.png" width="359" style="display: block; margin: auto;" /></p>
<p>It turns out that there’s no way to do it directly, but there are two tricks you can use instead. To illustrate them, imagine I have a vector that contains a few unusual values, and I want to explore the effect of different amounts of trimming when computing the mean. In this case, the first argument to <code>mean()</code> will be constant, and I want to vary the second argument, <code>trim</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">trims &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>)
x &lt;-<span class="st"> </span><span class="kw">rcauchy</span>(<span class="dv">1000</span>)</code></pre>
<ul>
<li><p>The simplest technique is to use an anonymous function to rearrange the
argument order:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(trims, <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(x, <span class="dt">trim =</span> .x))
<span class="co">#&gt; [1] -0.3500  0.0434  0.0354  0.0502</span></code></pre>
<p>This is still a little confusing because I’m using both <code>x</code> and <code>.x</code>.
You can make it a little clearer by abandoning the <code>~</code> helper:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(trims, <span class="cf">function</span>(trim) <span class="kw">mean</span>(x, <span class="dt">trim =</span> trim))
<span class="co">#&gt; [1] -0.3500  0.0434  0.0354  0.0502</span></code></pre></li>
<li><p>Sometimes, if you want to be (too) clever, you can take advantage of R’s
flexible argument matching rules (as described in Section
<a href="#prefix-form">6.8.2</a>). For example, in this example you can rewrite
<code>mean(x, trim = 0.1)</code> as <code>mean(0.1, x = x)</code>, so you could write the
call to <code>map_dbl()</code> as:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(trims, mean, <span class="dt">x =</span> x)
<span class="co">#&gt; [1] -0.3500  0.0434  0.0354  0.0502</span></code></pre>
<p>I don’t recommend this technique as it relies on the reader
being very familiar with both the argument order to <code>.f</code>, and R’s
argument matching rules.</p></li>
</ul>
<p>You’ll see one more alternative in Section <a href="#pmap">9.4.5</a>.</p>
</div>
<div id="exercises-28" class="section level3">
<h3><span class="header-section-number">9.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Use <code>as_mapper()</code> to explore how purrr generates anonymous functions for
the integer, character, and list helpers. What helper allows you to
extract attributes? Read the documentation to find out.</p></li>
<li><p><code>map(1:3, ~ runif(2))</code> is a useful pattern for generating random
numbers, but <code>map(1:3, runif(2))</code> is not. Why not? Can you explain why
it returns the result that it does?</p></li>
<li><p>Use the appropriate <code>map()</code> function to:</p>
<ol style="list-style-type: lower-alpha">
<li><p>Compute the standard deviation of every column in a numeric data frame.</p></li>
<li><p>Compute the standard deviation of every numeric column in a mixed data
frame. (Hint: you’ll need to do it in two steps.)</p></li>
<li><p>Compute the number of levels for every factor in a data frame.</p></li>
</ol></li>
<li><p>The following code simulates the performance of a t-test for non-normal
data. Extract the p-value from each test, then visualise.</p>
<pre class="sourceCode r"><code class="sourceCode r">trials &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="op">~</span><span class="st"> </span><span class="kw">t.test</span>(<span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">10</span>), <span class="kw">rpois</span>(<span class="dv">7</span>, <span class="dv">10</span>)))</code></pre></li>
<li><p>The following code uses a map nested inside another map to apply a
function to every element of a nested list. Why does it fail, and
what do you need to do to make it work?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">list</span>(<span class="dv">1</span>, <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">9</span>)),
  <span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">6</span>), <span class="dv">7</span>, <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">6</span>))
)

triple &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">*</span><span class="st"> </span><span class="dv">3</span>
<span class="kw">map</span>(x, map, <span class="dt">.f =</span> triple)
<span class="co">#&gt; Error in .f(.x[[i]], ...):</span>
<span class="co">#&gt;   unused argument (map)</span></code></pre></li>
<li><p>Use <code>map()</code> to fit linear models to the <code>mtcars</code> dataset using the formulas
stored in this list:</p>
<pre class="sourceCode r"><code class="sourceCode r">formulas &lt;-<span class="st"> </span><span class="kw">list</span>(
  mpg <span class="op">~</span><span class="st"> </span>disp,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp),
  mpg <span class="op">~</span><span class="st"> </span>disp <span class="op">+</span><span class="st"> </span>wt,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp) <span class="op">+</span><span class="st"> </span>wt
)</code></pre></li>
<li><p>Fit the model <code>mpg ~ disp</code> to each of the bootstrap replicates of <code>mtcars</code>
in the list below, then extract the <span class="math inline">\(R^2\)</span> of the model fit (Hint: you can
compute the <span class="math inline">\(R^2\)</span> with <code>summary()</code>)</p>
<pre class="sourceCode r"><code class="sourceCode r">bootstrap &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  df[<span class="kw">sample</span>(<span class="kw">nrow</span>(df), <span class="dt">replace =</span> <span class="ot">TRUE</span>), , drop =<span class="st"> </span><span class="ot">FALSE</span>]
}

bootstraps &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="op">~</span><span class="st"> </span><span class="kw">bootstrap</span>(mtcars))</code></pre></li>
</ol>
</div>
</div>
<div id="purrr-style" class="section level2">
<h2><span class="header-section-number">9.3</span> Purrr style</h2>

<p>Before we go on to explore more map variants, let’s take a quick look at how you tend to use multiple purrr functions to solve a moderately realistic problem: fitting a model to each subgroup and extracting a coefficient of the model. For this toy example, I’m going to break the <code>mtcars</code> data set down into groups defined by the number of cylinders, using the base <code>split</code> function:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_cyl &lt;-<span class="st"> </span><span class="kw">split</span>(mtcars, mtcars<span class="op">$</span>cyl)</code></pre>
<p>This creates a list of three data frames: the cars with 4, 6, and 8 cylinders respectively.</p>
<p>Now imagine we want to fit a linear model, then extract the second coefficient (i.e. the slope). The following code shows how you might do that with purrr:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_cyl <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="op">~</span><span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> .x)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(coef) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map_dbl</span>(<span class="dv">2</span>)
<span class="co">#&gt;     4     6     8 </span>
<span class="co">#&gt; -5.65 -2.78 -2.19</span></code></pre>
<p>(If you haven’t seen <code>%&gt;%</code>, the pipe, before, it’s described in Section <a href="#function-composition">6.3</a>.)</p>
<p>I think this code is easy to read because each line encapsulates a single step, you can easily distinguish the functional from what it does, and the purrr helpers allow us to very concisely describe what to do in each step.</p>
<p>How would you attack this problem with base R? You certainly <em>could</em> replace each purrr function with the equivalent base function:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_cyl <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">lapply</span>(<span class="cf">function</span>(data) <span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> data)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">lapply</span>(coef) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">vapply</span>(<span class="cf">function</span>(x) x[[<span class="dv">2</span>]], <span class="kw">double</span>(<span class="dv">1</span>))
<span class="co">#&gt;     4     6     8 </span>
<span class="co">#&gt; -5.65 -2.78 -2.19</span></code></pre>
<p>But this isn’t really base R since we’re using the pipe. To tackle purely in base I think you’d use an intermediate variable, and do more in each step:</p>
<pre class="sourceCode r"><code class="sourceCode r">models &lt;-<span class="st"> </span><span class="kw">lapply</span>(by_cyl, <span class="cf">function</span>(data) <span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> data))
<span class="kw">vapply</span>(models, <span class="cf">function</span>(x) <span class="kw">coef</span>(x)[[<span class="dv">2</span>]], <span class="kw">double</span>(<span class="dv">1</span>))
<span class="co">#&gt;     4     6     8 </span>
<span class="co">#&gt; -5.65 -2.78 -2.19</span></code></pre>
<p>Or, of course, you could use a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">intercepts &lt;-<span class="st"> </span><span class="kw">double</span>(<span class="kw">length</span>(by_cyl))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(by_cyl)) {
  model &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> by_cyl[[i]])
  intercepts[[i]] &lt;-<span class="st"> </span><span class="kw">coef</span>(model)[[<span class="dv">2</span>]]
}
intercepts
<span class="co">#&gt; [1] -5.65 -2.78 -2.19</span></code></pre>
<p>It’s interesting to note that as you move from purrr to base apply functions to for loops you tend to do more and more in each iteration. In purrr we iterate 3 times (<code>map()</code>, <code>map()</code>, <code>map_dbl()</code>), with apply functions we iterate twice (<code>lapply()</code>, <code>vapply()</code>), and with a for loop we iterate once. I prefer more, but simpler, steps because I think it makes the code easier to understand and later modify.</p>
</div>
<div id="map-variants" class="section level2">
<h2><span class="header-section-number">9.4</span> Map variants</h2>
<p>There are 23 primary variants of <code>map()</code>. So far, you’ve learned about five (<code>map()</code>, <code>map_lgl()</code>, <code>map_int()</code>, <code>map_dbl()</code> and <code>map_chr()</code>). That means that you’ve got 18 (!!) more to learn. That sounds like a lot, but fortunately the design of purrr means that you only need to learn five new ideas:</p>
<ul>
<li>Output same type as input with <code>modify()</code></li>
<li>Iterate over two inputs with <code>map2()</code>.</li>
<li>Iterate with an index using <code>imap()</code></li>
<li>Return nothing with <code>walk()</code>.</li>
<li>Iterate over any number of inputs with <code>pmap()</code>.</li>
</ul>
<p>The map family of functions has orthogonal input and outputs, meaning that we can organise all the family into a matrix, with inputs in the rows and outputs in the columns. Once you’ve mastered the idea in a row, you can combine it with any column; once you’ve mastered the idea in a column, you can combine it with any row.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>List</th>
<th>Atomic</th>
<th>Same type</th>
<th>Nothing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>One argument</td>
<td><code>map()</code></td>
<td><code>map_lgl()</code>, …</td>
<td><code>modify()</code></td>
<td><code>walk()</code></td>
</tr>
<tr class="even">
<td>Two arguments</td>
<td><code>map2()</code></td>
<td><code>map2_lgl()</code>, …</td>
<td><code>modify2()</code></td>
<td><code>walk2()</code></td>
</tr>
<tr class="odd">
<td>One argument + index</td>
<td><code>imap()</code></td>
<td><code>imap_lgl()</code>, …</td>
<td><code>imodify()</code></td>
<td><code>iwalk()</code></td>
</tr>
<tr class="even">
<td>N arguments</td>
<td><code>pmap()</code></td>
<td><code>pmap_lgl()</code>, …</td>
<td>—</td>
<td><code>pwalk()</code></td>
</tr>
</tbody>
</table>
<div id="modify" class="section level3">
<h3><span class="header-section-number">9.4.1</span> Same type of output as input: <code>modify()</code></h3>

<p>Imagine you wanted to double every column in a data frame. You might first try using <code>map()</code>, but <code>map()</code> always returns a list:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
  <span class="dt">y =</span> <span class="dv">6</span><span class="op">:</span><span class="dv">4</span>
)

<span class="kw">map</span>(df, <span class="op">~</span><span class="st"> </span>.x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; $x</span>
<span class="co">#&gt; [1] 2 4 6</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>
<span class="co">#&gt; [1] 12 10  8</span></code></pre>
<p>If you want to keep the output as a data frame, you can use <code>modify()</code>, which always returns the same type of output as the input:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">modify</span>(df, <span class="op">~</span><span class="st"> </span>.x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt;   x  y</span>
<span class="co">#&gt; 1 2 12</span>
<span class="co">#&gt; 2 4 10</span>
<span class="co">#&gt; 3 6  8</span></code></pre>
<p>Despite the name, <code>modify()</code> doesn’t modify in place, it returns a modified copy, so if you wanted to permanently modify <code>df</code>, you’d need to assign it:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">modify</span>(df, <span class="op">~</span><span class="st"> </span>.x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)</code></pre>
<p>As usual, the basic implementation of <code>modify()</code> is simple, and in fact it’s even simpler than <code>map()</code> because we don’t need to create a new output vector; we can just progressively replace the input. (The real code is a little complex to handle edge cases more gracefully.)</p>
<pre class="sourceCode r"><code class="sourceCode r">simple_modify &lt;-<span class="st"> </span><span class="cf">function</span>(x, f, ...) {
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
    x[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]], ...)
  }
  x
}</code></pre>
<p>In Section <a href="#predicate-map">9.6.2</a> you’ll learn about a very useful variant of <code>modify()</code>, called <code>modify_if()</code>. This allows you to (e.g.) only double <em>numeric</em> columns of a data frame with <code>modify_if(df, is.numeric, ~ .x * 2)</code>.</p>
</div>
<div id="map2" class="section level3">
<h3><span class="header-section-number">9.4.2</span> Two inputs: <code>map2()</code> and friends</h3>

<p><code>map()</code> is vectorised over a single argument, <code>.x</code>. This means it only varies <code>.x</code> when calling <code>.f</code>, and all other arguments are passed along unchanged, thus making it poorly suited for some problems. For example, how would you find a weighted mean when you have a list of observations and a list of weights? Imagine we have the following data:</p>
<pre class="sourceCode r"><code class="sourceCode r">xs &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">8</span>, <span class="op">~</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">10</span>))
xs[[<span class="dv">1</span>]][[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="ot">NA</span>
ws &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">8</span>, <span class="op">~</span><span class="st"> </span><span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">5</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<p>You can use <code>map_dbl()</code> to compute the unweighted means:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(xs, mean)
<span class="co">#&gt; [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443</span></code></pre>
<p>But passing <code>ws</code> as an additional argument doesn’t work because arguments after <code>.f</code> are not transformed:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(xs, weighted.mean, <span class="dt">w =</span> ws)
<span class="co">#&gt; Error in weighted.mean.default(.x[[i]], ...):</span>
<span class="co">#&gt;   &#39;x&#39; and &#39;w&#39; must have the same length</span></code></pre>
<p><img src="diagrams/functionals/map-arg-recycle.png" width="345" style="display: block; margin: auto;" /></p>
<p>We need a new tool: a <code>map2()</code>, which is vectorised over two arguments. This means both <code>.x</code> and <code>.y</code> are varied in each call to <code>.f</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map2_dbl</span>(xs, ws, weighted.mean)
<span class="co">#&gt; [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464</span></code></pre>
<p><img src="diagrams/functionals/map2.png" width="368" style="display: block; margin: auto;" /></p>
<p>The arguments to <code>map2()</code> are slightly different to the arguments to <code>map()</code> as two vectors come before the function, rather than one. Additional arguments still go afterwards:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map2_dbl</span>(xs, ws, weighted.mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464</span></code></pre>
<p><img src="diagrams/functionals/map2-arg.png" width="453" style="display: block; margin: auto;" /></p>
<p>The basic implementation of <code>map2()</code> is simple, and quite similar to that of <code>map()</code>. Instead of iterating over one vector, we iterate over two in parallel:</p>
<pre class="sourceCode r"><code class="sourceCode r">simple_map2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, f, ...) {
  out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(xs))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
    out[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]], y[[i]], ...)
  }
  out
}</code></pre>
<p>One of the big differences between <code>map2()</code> and the simple function above is that <code>map2()</code> recycles its inputs to make sure that they’re the same length:</p>
<p><img src="diagrams/functionals/map2-recycle.png" width="368" style="display: block; margin: auto;" /></p>
<p>In other words, <code>map2(x, y, f)</code> will automatically behave like <code>map(x, f, y)</code> when needed. This is helpful when writing functions; in scripts you’d generally just use the simpler form directly.</p>
<div class="base">
<p>The closest base equivalent to <code>map2()</code> is <code>Map()</code>, which is discussed in Section <a href="#pmap">9.4.5</a>.</p>
</div>
</div>
<div id="no-outputs-walk-and-friends" class="section level3">
<h3><span class="header-section-number">9.4.3</span> No outputs: <code>walk()</code> and friends</h3>

<p>Most functions are called for the value that they return, so it makes sense to capture and store it with a <code>map()</code> function. But some functions are called primarily for their side-effects (e.g. <code>cat()</code>, <code>write.csv()</code>, or <code>ggsave()</code>) and it doesn’t make sense to capture their results. Take this simple example that displays a welcome message using <code>cat()</code>. <code>cat()</code> returns <code>NULL</code>, so while map works (in the sense that it generates the desired welcomes), it also returns <code>list(NULL, NULL)</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">welcome &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">cat</span>(<span class="st">&quot;Welcome &quot;</span>, x, <span class="st">&quot;!</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
}
names &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Hadley&quot;</span>, <span class="st">&quot;Jenny&quot;</span>)

<span class="co"># As well as generate the welcomes, it also shows </span>
<span class="co"># the return value of cat()</span>
<span class="kw">map</span>(names, welcome)
<span class="co">#&gt; Welcome Hadley!</span>
<span class="co">#&gt; Welcome Jenny!</span>
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; NULL</span></code></pre>
<p>You could avoid this problem by assigning the results of <code>map()</code> to a variable that you never use, but that would muddy the intent of the code. Instead, purrr provides the walk family of functions that ignore the return values of the <code>.f</code> and instead return <code>.x</code> invisibly<span id="fn94" class="footnote" data-pagedown-footnote-number="94" style="white-space: pre-line;">In brief, invisible values are only printed if you explicitly request it. This makes them well suited for functions called primarily for their side-effects, as it allows their output to be ignored by default, while still giving an option to capture it. See Section <a href="#invisible">6.7.2</a> for more details.</span>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">walk</span>(names, welcome)
<span class="co">#&gt; Welcome Hadley!</span>
<span class="co">#&gt; Welcome Jenny!</span></code></pre>
<p>My visual depiction of walk attempts to capture the important difference from <code>map()</code>: the outputs are ephemeral, and the input is returned invisibly.</p>
<p><img src="diagrams/functionals/walk.png" width="236" style="display: block; margin: auto;" /></p>
<p>One of the most useful <code>walk()</code> variants is <code>walk2()</code> because a very common side-effect is saving something to disk, and when saving something to disk you always have a pair of values: the object and the path that you want to save it to.</p>
<p><img src="diagrams/functionals/walk2.png" width="316" style="display: block; margin: auto;" /></p>
<p>For example, imagine you have a list of data frames (which I’ve created here using split), and you’d like to save each one to a separate CSV file. That’s easy with <code>walk2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">temp &lt;-<span class="st"> </span><span class="kw">tempfile</span>()
<span class="kw">dir.create</span>(temp)

cyls &lt;-<span class="st"> </span><span class="kw">split</span>(mtcars, mtcars<span class="op">$</span>cyl)
paths &lt;-<span class="st"> </span><span class="kw">file.path</span>(temp, <span class="kw">paste0</span>(<span class="st">&quot;cyl-&quot;</span>, <span class="kw">names</span>(cyls), <span class="st">&quot;.csv&quot;</span>))
<span class="kw">walk2</span>(cyls, paths, write.csv)

<span class="kw">dir</span>(temp)
<span class="co">#&gt; [1] &quot;cyl-4.csv&quot; &quot;cyl-6.csv&quot; &quot;cyl-8.csv&quot;</span></code></pre>
<p>Here the <code>walk2()</code> is equivalent to <code>write.csv(cyls[[1]], paths[[1]])</code>, <code>write.csv(cyls[[2]], paths[[2]])</code>, <code>write.csv(cyls[[3]], paths[[3]])</code>.</p>
<div class="base">
<p>There is no base equivalent to <code>walk()</code>; either wrap the result of <code>lapply()</code> in <code>invisible()</code> or save it to a variable that is never used.</p>
</div>
</div>
<div id="iterating-over-values-and-indices" class="section level3">
<h3><span class="header-section-number">9.4.4</span> Iterating over values and indices</h3>

<p></p>
<p>There are three basic ways to loop over a vector with a for loop:</p>
<ul>
<li>Loop over the elements: <code>for (x in xs)</code></li>
<li>Loop over the numeric indices: <code>for (i in seq_along(xs))</code></li>
<li>Loop over the names: <code>for (nm in names(xs))</code></li>
</ul>
<p>The first form is analogous to the <code>map()</code> family. The second and third forms are equivalent to the <code>imap()</code> family which allows you to iterate over the values and the indices of a vector in parallel.</p>
<p><code>imap()</code> is like <code>map2()</code> in the sense that your <code>.f</code> gets called with two arguments, but here both are derived from the vector. <code>imap(x, f)</code> is equivalent to <code>map2(x, names(x), f)</code> if x has names, and <code>map2(x, seq_along(x), f)</code> if it does not.</p>
<p><code>imap()</code> is often useful for constructing labels:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">imap_chr</span>(iris, <span class="op">~</span><span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;The first value of &quot;</span>, .y, <span class="st">&quot; is &quot;</span>, .x[[<span class="dv">1</span>]]))
<span class="co">#&gt;                             Sepal.Length </span>
<span class="co">#&gt; &quot;The first value of Sepal.Length is 5.1&quot; </span>
<span class="co">#&gt;                              Sepal.Width </span>
<span class="co">#&gt;  &quot;The first value of Sepal.Width is 3.5&quot; </span>
<span class="co">#&gt;                             Petal.Length </span>
<span class="co">#&gt; &quot;The first value of Petal.Length is 1.4&quot; </span>
<span class="co">#&gt;                              Petal.Width </span>
<span class="co">#&gt;  &quot;The first value of Petal.Width is 0.2&quot; </span>
<span class="co">#&gt;                                  Species </span>
<span class="co">#&gt;   &quot;The first value of Species is setosa&quot;</span></code></pre>
<p>If the vector is unnamed, the second argument will be the index:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="op">~</span><span class="st"> </span><span class="kw">sample</span>(<span class="dv">1000</span>, <span class="dv">10</span>))
<span class="kw">imap_chr</span>(x, <span class="op">~</span><span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;The highest value of &quot;</span>, .y, <span class="st">&quot; is &quot;</span>, <span class="kw">max</span>(.x)))
<span class="co">#&gt; [1] &quot;The highest value of 1 is 885&quot; &quot;The highest value of 2 is 808&quot;</span>
<span class="co">#&gt; [3] &quot;The highest value of 3 is 942&quot; &quot;The highest value of 4 is 966&quot;</span>
<span class="co">#&gt; [5] &quot;The highest value of 5 is 857&quot; &quot;The highest value of 6 is 671&quot;</span></code></pre>
<p><code>imap()</code> is a useful helper if you want to work with the values in a vector along with their positions.</p>
</div>
<div id="pmap" class="section level3">
<h3><span class="header-section-number">9.4.5</span> Any number of inputs: <code>pmap()</code> and friends</h3>

<p>Since we have <code>map()</code> and <code>map2()</code>, you might expect <code>map3()</code>, <code>map4()</code>, <code>map5()</code>, … But where would you stop? Instead of generalising <code>map2()</code> to an arbitrary number of arguments, purrr takes a slightly different tack with <code>pmap()</code>: you supply it a single list, which contains any number of arguments. In most cases, that will be a list of equal-length vectors, i.e. something very similar to a data frame. In diagrams, I’ll emphasise that relationship by drawing the input similar to a data frame.</p>
<p><img src="diagrams/functionals/pmap.png" width="354" style="display: block; margin: auto;" /></p>
<p>There’s a simple equivalence between <code>map2()</code> and <code>pmap()</code>: <code>map2(x, y, f)</code> is the same as <code>pmap(list(x, y), f)</code>. The <code>pmap()</code> equivalent to the <code>map2_dbl(xs, ws, weighted.mean)</code> used above is:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pmap_dbl</span>(<span class="kw">list</span>(xs, ws), weighted.mean)
<span class="co">#&gt; [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464</span></code></pre>
<p>As before, the varying arguments come before <code>.f</code> (although now they must be wrapped in a list), and the constant arguments come afterwards.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pmap_dbl</span>(<span class="kw">list</span>(xs, ws), weighted.mean, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464</span></code></pre>
<p><img src="diagrams/functionals/pmap-arg.png" width="458" style="display: block; margin: auto;" /></p>
<p>A big difference between <code>pmap()</code> and the other map functions is that <code>pmap()</code> gives you much finer control over argument matching because you can name the components of the list. Returning to our example from Section <a href="#change-argument">9.2.5</a>, where we wanted to vary the <code>trim</code> argument to <code>x</code>, we could instead use <code>pmap()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">trims &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>)
x &lt;-<span class="st"> </span><span class="kw">rcauchy</span>(<span class="dv">1000</span>)

<span class="kw">pmap_dbl</span>(<span class="kw">list</span>(<span class="dt">trim =</span> trims), mean, <span class="dt">x =</span> x)
<span class="co">#&gt; [1] -6.6754  0.0192  0.0228  0.0151</span></code></pre>
<p>I think it’s good practice to name the components of the list to make it very clear how the function will be called.</p>
<p>It’s often convenient to call <code>pmap()</code> with a data frame. A handy way to create that data frame is with <code>tibble::tribble()</code>, which allows you to describe a data frame row-by-row (rather than column-by-column, as usual): thinking about the parameters to a function as a data frame is a very powerful pattern. The following example shows how you might draw random uniform numbers with varying parameters:</p>
<pre class="sourceCode r"><code class="sourceCode r">params &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">tribble</span>(
  <span class="op">~</span><span class="st"> </span>n, <span class="op">~</span><span class="st"> </span>min, <span class="op">~</span><span class="st"> </span>max,
   1L,     <span class="dv">0</span>,     <span class="dv">1</span>,
   2L,    <span class="dv">10</span>,   <span class="dv">100</span>,
   3L,   <span class="dv">100</span>,  <span class="dv">1000</span>
)

<span class="kw">pmap</span>(params, runif)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 0.718</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 19.5 39.9</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 535 476 231</span></code></pre>
<p><img src="diagrams/functionals/pmap-3.png" width="449" style="display: block; margin: auto;" />
Here, the column names are critical: I’ve carefully chosen to match them to the arguments to <code>runif()</code>, so the <code>pmap(params, runif)</code> is equivalent to <code>runif(n = 1L, min = 0, max = 1)</code>, <code>runif(n = 2, min = 10, max = 100)</code>, <code>runif(n = 3L, min = 100, max = 1000)</code>. (If you have a data frame in hand, and the names don’t match, use <code>dplyr::rename()</code> or similar.)</p>
<div class="base">
<p>There are two base equivalents to the <code>pmap()</code> family: <code>Map()</code> and <code>mapply()</code>. Both have significant drawbacks:</p>
<ul>
<li><p><code>Map()</code> vectorises over all arguments so you cannot supply arguments that
do not vary.</p></li>
<li><p><code>mapply()</code> is the multidimensional version of <code>sapply()</code>; conceptually it
takes the output of <code>Map()</code> and simplifies it if possible. This gives it
similar issues to <code>sapply()</code>. There is no multi-input equivalent of
<code>vapply()</code>.</p></li>
</ul>
</div>
</div>
<div id="exercises-29" class="section level3">
<h3><span class="header-section-number">9.4.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Explain the results of <code>modify(mtcars, 1)</code>.</p></li>
<li><p>Rewrite the following code to use <code>iwalk()</code> instead of <code>walk2()</code>. What
are the advantages and disadvantages?</p>
<pre class="sourceCode r"><code class="sourceCode r">cyls &lt;-<span class="st"> </span><span class="kw">split</span>(mtcars, mtcars<span class="op">$</span>cyl)
paths &lt;-<span class="st"> </span><span class="kw">file.path</span>(temp, <span class="kw">paste0</span>(<span class="st">&quot;cyl-&quot;</span>, <span class="kw">names</span>(cyls), <span class="st">&quot;.csv&quot;</span>))
<span class="kw">walk2</span>(cyls, paths, write.csv)</code></pre></li>
<li><p>Explain how the following code transforms a data frame using functions
stored in a list.</p>
<pre class="sourceCode r"><code class="sourceCode r">trans &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">disp =</span> <span class="cf">function</span>(x) x <span class="op">*</span><span class="st"> </span><span class="fl">0.0163871</span>,
  <span class="dt">am =</span> <span class="cf">function</span>(x) <span class="kw">factor</span>(x, <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;auto&quot;</span>, <span class="st">&quot;manual&quot;</span>))
)

vars &lt;-<span class="st"> </span><span class="kw">names</span>(trans)
mtcars[vars] &lt;-<span class="st"> </span><span class="kw">map2</span>(trans, mtcars[vars], <span class="cf">function</span>(f, var) <span class="kw">f</span>(var))</code></pre>
<p>Compare and contrast the <code>map2()</code> approach to this <code>map()</code> approach:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[vars] &lt;-<span class="st"> </span><span class="kw">map</span>(vars, <span class="op">~</span><span class="st"> </span>trans[[.x]](mtcars[[.x]]))</code></pre></li>
<li><p>What does <code>write.csv()</code> return? i.e. what happens if you use it with
<code>map2()</code> instead of <code>walk2()</code>?</p></li>
</ol>
</div>
</div>
<div id="reduce" class="section level2">
<h2><span class="header-section-number">9.5</span> Reduce</h2>
<p>After the map family, the next most important family of functions is the reduce family. This family is much smaller, with only two main variants, and is used less commonly, but it’s a powerful idea, gives us the opportunity to discuss some useful algebra, and powers the map-reduce framework frequently used for processing very large datasets.</p>
<div id="basics-1" class="section level3">
<h3><span class="header-section-number">9.5.1</span> Basics</h3>

<p></p>
<p><code>reduce()</code> takes a vector of length n and produces a vector of length one by calling a function with a pair of values at a time: <code>reduce(1:4, f)</code> is equivalent to <code>f(f(f(1, 2), 3), 4)</code>.</p>
<p><img src="diagrams/functionals/reduce.png" width="312" style="display: block; margin: auto;" /></p>
<p><code>reduce()</code> is a useful way to generalise a function that works with two inputs (a <strong>binary</strong> function) to work with any number of inputs. Imagine you have a list of numeric vectors, and you want to find the values that occur in every element. First we generate some sample data:</p>
<pre class="sourceCode r"><code class="sourceCode r">l &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="op">~</span><span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">15</span>, <span class="dt">replace =</span> T))
<span class="kw">str</span>(l)
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ : int [1:15] 7 5 9 7 9 9 5 10 5 5 ...</span>
<span class="co">#&gt;  $ : int [1:15] 6 3 6 10 3 4 4 2 9 9 ...</span>
<span class="co">#&gt;  $ : int [1:15] 5 3 4 6 1 1 9 9 6 8 ...</span>
<span class="co">#&gt;  $ : int [1:15] 4 2 6 6 8 5 10 6 7 1 ...</span></code></pre>
<p>To solve this challenge we need to use <code>intersect()</code> repeatedly:</p>
<pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> </span>l[[<span class="dv">1</span>]]
out &lt;-<span class="st"> </span><span class="kw">intersect</span>(out, l[[<span class="dv">2</span>]])
out &lt;-<span class="st"> </span><span class="kw">intersect</span>(out, l[[<span class="dv">3</span>]])
out &lt;-<span class="st"> </span><span class="kw">intersect</span>(out, l[[<span class="dv">4</span>]])
out
<span class="co">#&gt; [1] 5 1</span></code></pre>
<p><code>reduce()</code> automates this solution for us, so we can write:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(l, intersect)
<span class="co">#&gt; [1] 5 1</span></code></pre>
<p>We could apply the same idea if we wanted to list all the elements that appear in at least one entry. All we have to do is switch from <code>intersect()</code> to <code>union()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(l, union)
<span class="co">#&gt;  [1]  7  5  9 10  1  6  3  4  2  8</span></code></pre>
<p>Like the map family, you can also pass additional arguments. <code>intersect()</code> and <code>union()</code> don’t take extra arguments so I can’t demonstrate them here, but the principle is straightforward and I drew you a picture.</p>
<p><img src="diagrams/functionals/reduce-arg.png" width="387" style="display: block; margin: auto;" /></p>
<p>As usual, the essence of <code>reduce()</code> can be reduced to a simple wrapper around a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">simple_reduce &lt;-<span class="st"> </span><span class="cf">function</span>(x, f) {
  out &lt;-<span class="st"> </span>x[[<span class="dv">1</span>]]
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq</span>(<span class="dv">2</span>, <span class="kw">length</span>(x))) {
    out &lt;-<span class="st"> </span><span class="kw">f</span>(out, x[[i]])
  }
  out
}</code></pre>
<div class="base">
<p>The base equivalent is <code>Reduce()</code>. Note that the argument order is different: the function comes first, followed by the vector, and there is no way to supply additional arguments.</p>
</div>
</div>
<div id="accumulate" class="section level3">
<h3><span class="header-section-number">9.5.2</span> Accumulate</h3>

<p>The first <code>reduce()</code> variant, <code>accumulate()</code>, is useful for understanding how reduce works, because instead of returning just the final result, it returns all the intermediate results as well:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">accumulate</span>(l, intersect)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt;  [1]  7  5  9  7  9  9  5 10  5  5  5 10  9  9  1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1]  5  9 10  1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 5 9 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] 5 1</span></code></pre>
<p>Another useful way to understand reduce is to think about <code>sum()</code>: <code>sum(x)</code> is equivalent to <code>x[[1]] + x[[2]] + x[[3]] + ...</code>, i.e. <code>reduce(x, `+`)</code>. Then <code>accumulate(x, `+`)</code> is the cumulative sum:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">10</span>)
<span class="kw">reduce</span>(x, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)
<span class="co">#&gt; [1] 17</span>

<span class="kw">accumulate</span>(x, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)
<span class="co">#&gt; [1]  4  7 17</span></code></pre>
</div>
<div id="output-types" class="section level3">
<h3><span class="header-section-number">9.5.3</span> Output types</h3>
<p>In the above example using <code>+</code>, what should <code>reduce()</code> return when <code>x</code> is short, i.e. length 1 or 0? Without additional arguments, <code>reduce()</code> just returns the input when <code>x</code> is length 1:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(<span class="dv">1</span>, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)
<span class="co">#&gt; [1] 1</span></code></pre>
<p>This means that <code>reduce()</code> has no way to check that the input is valid:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(<span class="st">&quot;a&quot;</span>, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)
<span class="co">#&gt; [1] &quot;a&quot;</span></code></pre>
<p>What if it’s length 0? We get an error that suggests we need to use the <code>.init</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(<span class="kw">integer</span>(), <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)
<span class="co">#&gt; Error: `.x` is empty, and no `.init` supplied</span></code></pre>
<p>What should <code>.init</code> be here? To figure that out, we need to see what happens when <code>.init</code> is supplied:</p>
<p><img src="diagrams/functionals/reduce-init.png" width="406" style="display: block; margin: auto;" /></p>
<p>So if we call <code>reduce(1, `+`, init)</code> the result will be <code>1 + init</code>. Now we know that the result should be just <code>1</code>, so that suggests that <code>.init</code> should be 0:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(<span class="kw">integer</span>(), <span class="st">`</span><span class="dt">+</span><span class="st">`</span>, <span class="dt">.init =</span> <span class="dv">0</span>)
<span class="co">#&gt; [1] 0</span></code></pre>
<p>This also ensures that <code>reduce()</code> checks that length 1 inputs are valid for the function that you’re calling:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">reduce</span>(<span class="st">&quot;a&quot;</span>, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>, <span class="dt">.init =</span> <span class="dv">0</span>)
<span class="co">#&gt; Error in .x + .y:</span>
<span class="co">#&gt;   non-numeric argument to binary operator</span></code></pre>
<p>If you want to get algebraic about it, 0 is called the <strong>identity</strong> of the real numbers under the operation of addition: if you add a 0 to any number, you get the same number back. R applies the same principle to determine what a summary function with a zero length input should return:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="kw">integer</span>())  <span class="co"># x + 0 = x</span>
<span class="co">#&gt; [1] 0</span>
<span class="kw">prod</span>(<span class="kw">integer</span>()) <span class="co"># x * 1 = x</span>
<span class="co">#&gt; [1] 1</span>
<span class="kw">min</span>(<span class="kw">integer</span>())  <span class="co"># min(x, Inf) = x</span>
<span class="co">#&gt; [1] Inf</span>
<span class="kw">max</span>(<span class="kw">integer</span>())  <span class="co"># max(x, -Inf) = x</span>
<span class="co">#&gt; [1] -Inf</span></code></pre>
<p>If you’re using <code>reduce()</code> in a function, you should always supply <code>.init</code>. Think carefully about what your function should return when passed a vector of length zero or one, and make sure to test your implementation.</p>
</div>
<div id="multiple-inputs" class="section level3">
<h3><span class="header-section-number">9.5.4</span> Multiple inputs</h3>

<p>Very occasionally you need to pass two arguments to the function that you’re reducing. For example, you might have a list of data frames that you want to join together, and the variables that you are joining by vary from element to element. This is a very specialised scenario, so I don’t want to spend much time on it, but I do want you to know that <code>reduce2()</code> exists.</p>
<p>The length of the second argument varies based on whether or not <code>.init</code> is supplied: if you have four elements of <code>x</code>, <code>f</code> will only be called three times. If you supply init, <code>f</code> will be called four times.</p>
<p><img src="diagrams/functionals/reduce2.png" width="520" style="display: block; margin: auto;" />
<img src="diagrams/functionals/reduce2-init.png" width="520" style="display: block; margin: auto;" /></p>
</div>
<div id="map-reduce" class="section level3">
<h3><span class="header-section-number">9.5.5</span> Map-reduce</h3>
<p></p>
<p>You might have heard of map-reduce, the idea that powers technology like Hadoop. Now you can see how simple and powerful the underlying idea is: all map-reduce is a map combined with a reduce. The difference for large data is that the data is spread over multiple computers. Each computer performs the map on the data that it has, then it sends the result to back to a coordinator which <em>reduces</em> the individual results back to a single result.</p>
<p>As a simple example, imagine computing the mean of a very large vector, so large that it has to be split over multiple computers. You could ask each computer to calculate the sum and the length, and then return those to the coordinatorr which computes the overall mean by dividing the total sum by the total length.</p>
</div>
</div>
<div id="predicate-functionals" class="section level2">
<h2><span class="header-section-number">9.6</span> Predicate functionals</h2>
<p>
</p>
<p>A <strong>predicate</strong> is a function that returns a single <code>TRUE</code> or <code>FALSE</code>, like <code>is.character()</code>, <code>is.null()</code>, or <code>all()</code>, and we say a predicate <strong>matches</strong> a vector if it returns <code>TRUE</code>.</p>
<div id="basics-2" class="section level3">
<h3><span class="header-section-number">9.6.1</span> Basics</h3>
<p>A <strong>predicate functional</strong> applies a predicate to each element of a vector. purrr provides six useful functions which come in three pairs:</p>
<ul>
<li><p><code>some(.x, .p)</code> returns <code>TRUE</code> if <em>any</em> element matches;
<code>every(.x, .p)</code> returns <code>TRUE</code> if <em>all</em> elements match.</p>
<p>These are similary to <code>any(map_lgl(.x, .p))</code> and <code>all(map_lgl(.x, .p))</code>
but they terminate early: <code>some()</code> returns <code>TRUE</code> when it sees the first
<code>TRUE</code>, and <code>every()</code> returns <code>FALSE</code> when it sees the first <code>FALSE</code>.</p></li>
<li><p><code>detect(.x, .p)</code> returns the <em>value</em> of the first match;
<code>detect_index(.x, .p)</code> returns the <em>location</em> of the first match.</p></li>
<li><p><code>keep(.x, .p)</code> <em>keeps</em> all matching elements;
<code>discard(.x, .p)</code> <em>drops</em> all matching elements.</p></li>
</ul>
<p>The following example shows how you might use these functionals with a data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
<span class="kw">detect</span>(df, is.factor)
<span class="co">#&gt; [1] a b c</span>
<span class="co">#&gt; Levels: a b c</span>
<span class="kw">detect_index</span>(df, is.factor)
<span class="co">#&gt; [1] 2</span>

<span class="kw">str</span>(<span class="kw">keep</span>(df, is.factor))
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ y: Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 2 3</span>
<span class="kw">str</span>(<span class="kw">discard</span>(df, is.factor))
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  1 variable:</span>
<span class="co">#&gt;  $ x: int  1 2 3</span></code></pre>
</div>
<div id="predicate-map" class="section level3">
<h3><span class="header-section-number">9.6.2</span> Map variants</h3>
<p><code>map()</code> and <code>modify()</code> come in variants that also take predicate functions, transforming only the elements of <code>.x</code> where <code>.p</code> is <code>TRUE</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">num1 =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">20</span>),
  <span class="dt">num2 =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>),
  <span class="dt">chr1 =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>),
  <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>
)

<span class="kw">str</span>(<span class="kw">map_if</span>(df, is.numeric, mean))
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ num1: num 10</span>
<span class="co">#&gt;  $ num2: num 6</span>
<span class="co">#&gt;  $ chr1: chr [1:3] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span>
<span class="kw">str</span>(<span class="kw">modify_if</span>(df, is.numeric, mean))
<span class="co">#&gt; &#39;data.frame&#39;:    3 obs. of  3 variables:</span>
<span class="co">#&gt;  $ num1: num  10 10 10</span>
<span class="co">#&gt;  $ num2: num  6 6 6</span>
<span class="co">#&gt;  $ chr1: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</span>
<span class="kw">str</span>(<span class="kw">map</span>(<span class="kw">keep</span>(df, is.numeric), mean))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ num1: num 10</span>
<span class="co">#&gt;  $ num2: num 6</span></code></pre>
</div>
<div id="exercises-30" class="section level3">
<h3><span class="header-section-number">9.6.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why isn’t <code>is.na()</code> a predicate function? What base R function is closest
to being a predicate version of <code>is.na()</code>?</p></li>
<li><p><code>simple_reduce()</code> has a problem when <code>x</code> is length 0 or length 1. Describe
the source of the problem and how you might go about fixing it.</p>
<pre class="sourceCode r"><code class="sourceCode r">simple_reduce &lt;-<span class="st"> </span><span class="cf">function</span>(x, f) {
  out &lt;-<span class="st"> </span>x[[<span class="dv">1</span>]]
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq</span>(<span class="dv">2</span>, <span class="kw">length</span>(x))) {
    out &lt;-<span class="st"> </span><span class="kw">f</span>(out, x[[i]])
  }
  out
}</code></pre></li>
<li><p>Implement the <code>span()</code> function from Haskell: given a list <code>x</code> and a
predicate function <code>f</code>, <code>span(x, f)</code> returns the location of the longest
sequential run of elements where the predicate is true. (Hint: you
might find <code>rle()</code> helpful.)</p></li>
<li><p>Implement <code>arg_max()</code>. It should take a function and a vector of inputs,
and return the elements of the input where the function returns the highest
value. For example, <code>arg_max(-10:5, function(x) x ^ 2)</code> should return -10.
<code>arg_max(-5:5, function(x) x ^ 2)</code> should return <code>c(-5, 5)</code>.
Also implement the matching <code>arg_min()</code> function.</p></li>
<li><p>The function below scales a vector so it falls in the range [0, 1]. How
would you apply it to every column of a data frame? How would you apply it
to every numeric column in a data frame?</p>
<pre class="sourceCode r"><code class="sourceCode r">scale01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  rng &lt;-<span class="st"> </span><span class="kw">range</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  (x <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>]) <span class="op">/</span><span class="st"> </span>(rng[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>])
}</code></pre></li>
</ol>
</div>
</div>
<div id="base-functionals" class="section level2">
<h2><span class="header-section-number">9.7</span> Base functionals</h2>
<p>To finish up the chapter, here I provide a survey of important base functionals that are not members of the map, reduce, or predicate families, and hence have no equivalent in purrr. This is not to say that they’re not important, but they have more of a mathematical/statistical flavour, and they are generally less useful in data analysis.</p>
<div id="matrices-and-arrays" class="section level3">
<h3><span class="header-section-number">9.7.1</span> Matrices and arrays</h3>

<p><code>map()</code> and friends are specialised to work with 1d vectors. <code>base::apply()</code> is specialised to work with 2d and higher vectors, i.e. matrices and arrays. You can think of <code>apply()</code> as an operation that summarises a matrix or array by collapsing each row or column to a single value. It has four arguments:</p>
<ul>
<li><p><code>X</code>, the matrix or array to summarise.</p></li>
<li><p><code>MARGIN</code>, an integer vector giving the dimensions to summarise over,
1 = rows, 2 = columns, etc. (The argument name comes from thinking about
the “margins” of a joint distribution.)</p></li>
<li><p><code>FUN</code>, a summary function.</p></li>
<li><p><code>...</code> other arguments passed on to <code>FUN</code>.</p></li>
</ul>
<p>A typical example of <code>apply()</code> looks like this</p>
<pre class="sourceCode r"><code class="sourceCode r">a2d &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">20</span>, <span class="dt">nrow =</span> <span class="dv">5</span>)
<span class="kw">apply</span>(a2d, <span class="dv">1</span>, mean)
<span class="co">#&gt; [1]  8.5  9.5 10.5 11.5 12.5</span>
<span class="kw">apply</span>(a2d, <span class="dv">2</span>, mean)
<span class="co">#&gt; [1]  3  8 13 18</span></code></pre>
<!-- HW: recreate diagrams from plyr paper -->
<p>You can specify multiple dimensions to <code>MARGIN</code>, which is useful for high-d arrays:</p>
<pre class="sourceCode r"><code class="sourceCode r">a3d &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">24</span>, <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>))
<span class="kw">apply</span>(a3d, <span class="dv">1</span>, mean)
<span class="co">#&gt; [1] 12 13</span>
<span class="kw">apply</span>(a3d, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), mean)
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,]   10   12   14</span>
<span class="co">#&gt; [2,]   11   13   15</span></code></pre>
<p>There are two caveats to using <code>apply()</code>:</p>
<ul>
<li><p>Like <code>base::sapply()</code>, you have no control over the output type; it
will automatically be simplified to a list, matrix, or vector. However,
you usually use <code>apply()</code> with numeric arrays and a numeric summary
function so you are less likely to encounter a problem than with
<code>sapply()</code>.</p></li>
<li><p><code>apply()</code> is also not idempotent in the sense that if the summary
function is the identity operator, the output is not always the same as
the input.</p>
<pre class="sourceCode r"><code class="sourceCode r">a1 &lt;-<span class="st"> </span><span class="kw">apply</span>(a2d, <span class="dv">1</span>, identity)
<span class="kw">identical</span>(a2d, a1)
<span class="co">#&gt; [1] FALSE</span>

a2 &lt;-<span class="st"> </span><span class="kw">apply</span>(a2d, <span class="dv">2</span>, identity)
<span class="kw">identical</span>(a2d, a2)
<span class="co">#&gt; [1] TRUE</span></code></pre></li>
<li><p>Never use <code>apply()</code> with a data frame. It always coerces it to a matrix,
which will lead to undesirable results if your data frame contains anything
other than numbers.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
<span class="kw">apply</span>(df, <span class="dv">2</span>, mean)
<span class="co">#&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or</span>
<span class="co">#&gt; logical: returning NA</span>

<span class="co">#&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or</span>
<span class="co">#&gt; logical: returning NA</span>
<span class="co">#&gt;  x  y </span>
<span class="co">#&gt; NA NA</span></code></pre></li>
</ul>
</div>
<div id="mathematical" class="section level3">
<h3><span class="header-section-number">9.7.2</span> Mathematical</h3>
<p>Functionals are very common in mathematics. The limit, the maximum, the roots (the set of points where <code>f(x) = 0</code>), and the definite integral are all functionals: given a function, they return a single number (or vector of numbers). At first glance, these functions don’t seem to fit in with the theme of eliminating loops, but if you dig deeper you’ll find out that they are all implemented using an algorithm that involves iteration.</p>
<p>Base R provides a useful set:</p>
<ul>
<li><code>integrate()</code> finds the area under the curve defined by <code>f()</code></li>
<li><code>uniroot()</code> finds where <code>f()</code> hits zero</li>
<li><code>optimise()</code> finds the location of the lowest (or highest) value of <code>f()</code></li>
</ul>
<p>The following example shows how they might be used with a simple function, <code>sin()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">integrate</span>(sin, <span class="dv">0</span>, pi)
<span class="co">#&gt; 2 with absolute error &lt; 2.2e-14</span>
<span class="kw">str</span>(<span class="kw">uniroot</span>(sin, pi <span class="op">*</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>, <span class="dv">3</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)))
<span class="co">#&gt; List of 5</span>
<span class="co">#&gt;  $ root      : num 3.14</span>
<span class="co">#&gt;  $ f.root    : num 1.22e-16</span>
<span class="co">#&gt;  $ iter      : int 2</span>
<span class="co">#&gt;  $ init.it   : int NA</span>
<span class="co">#&gt;  $ estim.prec: num 6.1e-05</span>
<span class="kw">str</span>(<span class="kw">optimise</span>(sin, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span> <span class="op">*</span><span class="st"> </span>pi)))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ minimum  : num 4.71</span>
<span class="co">#&gt;  $ objective: num -1</span>
<span class="kw">str</span>(<span class="kw">optimise</span>(sin, <span class="kw">c</span>(<span class="dv">0</span>, pi), <span class="dt">maximum =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ maximum  : num 1.57</span>
<span class="co">#&gt;  $ objective: num 1</span></code></pre>
</div>
<div id="exercises-31" class="section level3">
<h3><span class="header-section-number">9.7.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How does <code>apply()</code> arrange the output? Read the documentation and perform
some experiments.</p></li>
<li><p>What do <code>eapply()</code> and <code>rapply()</code> do? Does purrr have equivalents?</p></li>
<li><p>Challenge: read about the
fixed point algorithm<span id="fn95" class="footnote" data-pagedown-footnote-number="95" style="white-space: pre-line;"><a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%25_idx_1096" class="uri">https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html#%25_idx_1096</a></span>.
Complete the exercises using R.</p></li>
</ol>
<!--chapter:end:Functionals.Rmd-->
</div>
</div>
</div>
<div id="function-factories" class="section level1">
<h1><span class="header-section-number">10</span> Function factories</h1>
<p></p>
<div id="introduction-9" class="section level2">
<h2><span class="header-section-number">10.1</span> Introduction</h2>
<p>A <strong>function factory</strong> is a function that makes functions. Here’s a very simple example: we use a function factory (<code>power1()</code>) to make two child functions (<code>square()</code> and <code>cube()</code>):</p>
<pre class="sourceCode r"><code class="sourceCode r">power1 &lt;-<span class="st"> </span><span class="cf">function</span>(exp) {
  <span class="cf">function</span>(x) {
    x <span class="op">^</span><span class="st"> </span>exp
  }
}

square &lt;-<span class="st"> </span><span class="kw">power1</span>(<span class="dv">2</span>)
cube &lt;-<span class="st"> </span><span class="kw">power1</span>(<span class="dv">3</span>)</code></pre>
<p>Don’t worry if this doesn’t make sense yet, it should by the end of the chapter!</p>
<p>

I’ll call <code>square()</code> and <code>cube()</code> <strong>manufactured functions</strong>, but this is just a term to ease communication with other humans: from R’s perspective they are no different to functions created any other way.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">square</span>(<span class="dv">3</span>)
<span class="co">#&gt; [1] 9</span>
<span class="kw">cube</span>(<span class="dv">3</span>)
<span class="co">#&gt; [1] 27</span></code></pre>
<p>You have already learned about the individual components that make function factories possible:</p>
<ul>
<li><p>In Section <a href="#first-class-functions">6.2.3</a>, you learned about R’s “first-class”
functions. In R, you bind a function to a name in the same way as you bind
any object to a name: with <code>&lt;-</code>.</p></li>
<li><p>In Section <a href="#function-environments">7.4.2</a>, you learned that a function
captures (encloses) the environment in which it is created.</p></li>
<li><p>In Section <a href="#execution-environments">7.4.4</a>, you learned that a function
creates a new execution environment every time it is run. This environment
is usually ephemeral, but here it becomes the enclosing environment of
the manufactured function.</p></li>
</ul>
<p>In this chapter, you’ll learn how the non-obvious combination of these three features lead to the function factory. You’ll also see examples of their usage in visualisation and statistics.</p>
<p>Of the three main functional programming tools (functionals, function factories, and function operators), function factories are the least commonly used. Generally, they don’t tend to reduce overall code complexity but instead partition complexity into more easily digested chunks. Function factories are also an important building block for the very useful function operators, which you’ll learn about in Chapter <a href="#function-operators">11</a>.</p>
<div id="outline-8" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#factory-fundamentals">10.2</a> begins the chapter with an explanation
of how function factories work, pulling together ideas from scoping and
environments. You’ll also see how function factories can be used to implement
a “memory” for functions, allowing data to persist across calls.</p></li>
<li><p>Section <a href="#graph-fact">10.3</a> illustrates the use of function factories with
examples from ggplot2. You’ll see two examples of how ggplot2 works
with user supplied function factories, and one example of where ggplot2
uses a function factory internally.</p></li>
<li><p>Section <a href="#stat-fact">10.4</a> uses function factories to tackle three challenges from
statistics: understanding the Box-Cox transform, solving maximum likelihood
problems, and drawing bootstrap resamples.</p></li>
<li><p>Section <a href="#functional-factories">10.5</a> shows how you can combine function
factories and functionals to rapidly generate a family of functions from data.</p></li>
</ul>
</div>
<div id="prerequisites-4" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>Make sure you’re familiar with the contents of Sections <a href="#first-class-functions">6.2.3</a> (first-class functions), <a href="#function-environments">7.4.2</a> (the function environment), and <a href="#execution-environments">7.4.4</a> (execution environments) mentioned above.</p>
<p>Function factories only need base R. We’ll use a little rlang<span id="fn96" class="footnote" data-pagedown-footnote-number="96" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span> to peek inside of them more easily, and we’ll use ggplot2<span id="fn97" class="footnote" data-pagedown-footnote-number="97" style="white-space: pre-line;"><a href="https://ggplot2.tidyverse.org" class="uri">https://ggplot2.tidyverse.org</a></span> and scales<span id="fn98" class="footnote" data-pagedown-footnote-number="98" style="white-space: pre-line;"><a href="https://scales.r-lib.org" class="uri">https://scales.r-lib.org</a></span> to explore the use of function factories in visualisation.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)
<span class="kw">library</span>(ggplot2)
<span class="kw">library</span>(scales)</code></pre>
</div>
</div>
<div id="factory-fundamentals" class="section level2">
<h2><span class="header-section-number">10.2</span> Factory fundamentals</h2>
<p>The key idea that makes function factories work can be expressed very concisely:</p>
<blockquote>
<p>The enclosing environment of the manufactured function is an execution
environment of the function factory.</p>
</blockquote>
<p>It only takes few words to express these big ideas, but it takes a lot more work to really understand what this means. This section will help you put the pieces together with interactive exploration and some diagrams.</p>
<div id="environments-1" class="section level3">
<h3><span class="header-section-number">10.2.1</span> Environments</h3>
<p>Let’s start by taking a look at <code>square()</code> and <code>cube()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">square
<span class="co">#&gt; function(x) {</span>
<span class="co">#&gt;     x ^ exp</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt; &lt;environment: 0x371de18&gt;</span>

cube
<span class="co">#&gt; function(x) {</span>
<span class="co">#&gt;     x ^ exp</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt; &lt;bytecode: 0x31154f0&gt;</span>
<span class="co">#&gt; &lt;environment: 0x3787528&gt;</span></code></pre>
<p>It’s obvious where <code>x</code> comes from, but how does R find the value associated with <code>exp</code>? Simply printing the manufactured functions is not revealing because the bodies are identical; it’s the contents of the enclosing environment that’s important. We can get a little more insight by using <code>rlang::env_print()</code>. That shows us that we have two different environments (each of which was originally an execution environment of <code>power1()</code>). The environments have the same parent, which is the enclosing environment of <code>power1()</code>, the global environment.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">env_print</span>(square)
<span class="co">#&gt; &lt;environment: 0x371de18&gt;</span>
<span class="co">#&gt; parent: &lt;environment: global&gt;</span>
<span class="co">#&gt; bindings:</span>
<span class="co">#&gt;  * exp: &lt;dbl&gt;</span>

<span class="kw">env_print</span>(cube)
<span class="co">#&gt; &lt;environment: 0x3787528&gt;</span>
<span class="co">#&gt; parent: &lt;environment: global&gt;</span>
<span class="co">#&gt; bindings:</span>
<span class="co">#&gt;  * exp: &lt;dbl&gt;</span></code></pre>
<p><code>env_print()</code> shows us that both environments have a binding to <code>exp</code>, but we want to see its value<span id="fn99" class="footnote" data-pagedown-footnote-number="99" style="white-space: pre-line;">A future version of <code>env_print()</code> is likely to do better at summarising the contents so you don’t need this step.</span>. We can do that by first getting the environment of the function, and then extracting the values:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fn_env</span>(square)<span class="op">$</span>exp
<span class="co">#&gt; [1] 2</span>

<span class="kw">fn_env</span>(cube)<span class="op">$</span>exp
<span class="co">#&gt; [1] 3</span></code></pre>
<p>This is what makes manufactured functions behave differently from one another: names in the enclosing environment are bound to different values.</p>
</div>
<div id="diagram-conventions" class="section level3">
<h3><span class="header-section-number">10.2.2</span> Diagram conventions</h3>
<p>We can also show these relationships in a diagram:</p>
<p><img src="diagrams/function-factories/power-full.png" width="354" style="display: block; margin: auto;" /></p>
<p>There’s a lot going on this diagram and some of the details aren’t that important. We can simplify considerably by using two conventions:</p>
<ul>
<li><p>Any free floating symbol lives in the global environment.</p></li>
<li><p>Any environment without an explicit parent inherits from the global
environment.</p></li>
</ul>
<p><img src="diagrams/function-factories/power-simple.png" width="330" style="display: block; margin: auto;" /></p>
<p>This view, which focuses on the environments, doesn’t show any direct link between <code>cube()</code> and <code>square()</code>. That’s because the link is the through the body of the function, which is identical for both, but is not shown in this diagram.</p>
<p>To finish up, let’s look at the execution environment of <code>square(10)</code>. When <code>square()</code> executes <code>x ^ exp</code> it finds <code>x</code> in the execution environment and <code>exp</code> in its enclosing environment.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">square</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] 100</span></code></pre>
<p><img src="diagrams/function-factories/power-exec.png" width="330" style="display: block; margin: auto;" /></p>
</div>
<div id="forcing-evaluation" class="section level3">
<h3><span class="header-section-number">10.2.3</span> Forcing evaluation</h3>

<p>There’s a subtle bug in <code>power1()</code> caused by lazy evaluation. To see the problem we need to introduce some indirection:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">2</span>
square &lt;-<span class="st"> </span><span class="kw">power1</span>(x)
x &lt;-<span class="st"> </span><span class="dv">3</span></code></pre>
<p>What should <code>square(2)</code> return? You would hope it returns 4:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">square</span>(<span class="dv">2</span>)
<span class="co">#&gt; [1] 8</span></code></pre>
<p>Unfortunately it doesn’t because <code>x</code> is only evaluated lazily when <code>square()</code> is run, not when <code>power1()</code> is run. In general, this problem will arise whenever a binding changes in between calling the factory function and calling the manufactured function. This is likely to only happen rarely, but when it does, it will lead to a real head-scratcher of a bug.</p>
<p>We can fix this problem by <strong>forcing</strong> evaluation with <code>force()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">power2 &lt;-<span class="st"> </span><span class="cf">function</span>(exp) {
  <span class="kw">force</span>(exp)
  <span class="cf">function</span>(x) {
    x <span class="op">^</span><span class="st"> </span>exp
  }
}

x &lt;-<span class="st"> </span><span class="dv">2</span>
square &lt;-<span class="st"> </span><span class="kw">power2</span>(x)
x &lt;-<span class="st"> </span><span class="dv">3</span>
<span class="kw">square</span>(<span class="dv">2</span>)
<span class="co">#&gt; [1] 4</span></code></pre>
<p>Whenever you create a function factory, make sure every argument is evaluated, using <code>force()</code> as necessary if the argument is only used by the manufactured function.</p>
</div>
<div id="stateful-funs" class="section level3">
<h3><span class="header-section-number">10.2.4</span> Stateful functions</h3>

<p></p>
<p>Function factories also allow you to maintain state across function invocations, which is generally hard to do because of the fresh start principle described in Section <a href="#fresh-start">6.4.3</a>.</p>
<p>There are two things that make this possible:</p>
<ul>
<li><p>The enclosing environment of the manufactured function is unique and constant.</p></li>
<li><p>R has a special assignment operator, <code>&lt;&lt;-</code>, which modifies bindings in the
enclosing environment.</p></li>
</ul>
<p>The usual assignment operator, <code>&lt;-</code>, always creates a binding in the current environment. The <strong>super assignment operator</strong>, <code>&lt;&lt;-</code> rebinds an existing name found in a parent environment.</p>
<p>The following example shows how we can combine these ideas to create a function that records how many times it has been called:</p>
<pre class="sourceCode r"><code class="sourceCode r">new_counter &lt;-<span class="st"> </span><span class="cf">function</span>() {
  i &lt;-<span class="st"> </span><span class="dv">0</span>
  
  <span class="cf">function</span>() {
    i &lt;&lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    i
  }
}

counter_one &lt;-<span class="st"> </span><span class="kw">new_counter</span>()
counter_two &lt;-<span class="st"> </span><span class="kw">new_counter</span>()</code></pre>
<p><img src="diagrams/function-factories/counter-1.png" width="354" style="display: block; margin: auto;" /></p>
<p>When the manufactured function is run <code>i &lt;&lt;- i + 1</code> will modify <code>i</code> in its enclosing environment. Because manufactured functions have independent enclosing environments, they have independent counts:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">counter_one</span>()
<span class="co">#&gt; [1] 1</span>
<span class="kw">counter_one</span>()
<span class="co">#&gt; [1] 2</span>
<span class="kw">counter_two</span>()
<span class="co">#&gt; [1] 1</span></code></pre>
<p><img src="diagrams/function-factories/counter-2.png" width="354" style="display: block; margin: auto;" /></p>
<p>Stateful functions are best used in moderation. As soon as your function starts managing the state of multiple variables, it’s better to switch to R6, the topic of Chapter <a href="#r6">14</a>.</p>
</div>
<div id="factory-pitfalls" class="section level3">
<h3><span class="header-section-number">10.2.5</span> Garbage collection</h3>
<p></p>
<p>With most functions, you can rely on the garbage collector to clean up any large temporary objects created inside a function. However, manufactured functions hold on to the execution environment, so you’ll need to explicitly unbind any large temporary objects with <code>rm()</code>. Compare the sizes of <code>g1()</code> and <code>g2()</code> in the example below:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(n) {
  x &lt;-<span class="st"> </span><span class="kw">runif</span>(n)
  m &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">function</span>() m
}

g1 &lt;-<span class="st"> </span><span class="kw">f1</span>(<span class="fl">1e6</span>)
lobstr<span class="op">::</span><span class="kw">obj_size</span>(g1)
<span class="co">#&gt; 8,013,120 B</span>

f2 &lt;-<span class="st"> </span><span class="cf">function</span>(n) {
  x &lt;-<span class="st"> </span><span class="kw">runif</span>(n)
  m &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="kw">rm</span>(x)
  <span class="cf">function</span>() m
}

g2 &lt;-<span class="st"> </span><span class="kw">f2</span>(<span class="fl">1e6</span>)
lobstr<span class="op">::</span><span class="kw">obj_size</span>(g2)
<span class="co">#&gt; 12,960 B</span></code></pre>
</div>
<div id="exercises-32" class="section level3">
<h3><span class="header-section-number">10.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>The definition of <code>force()</code> is simple:</p>
<pre class="sourceCode r"><code class="sourceCode r">force
<span class="co">#&gt; function (x) </span>
<span class="co">#&gt; x</span>
<span class="co">#&gt; &lt;bytecode: 0x19b5d60&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span></code></pre>
<p>Why is it better to <code>force(x)</code> instead of just <code>x</code>?</p></li>
<li><p>Base R contains two function factories, <code>approxfun()</code> and <code>ecdf()</code>.
Read their documentation and experiment to figure out what the functions
do and what they return.</p></li>
<li><p>Create a function <code>pick()</code> that takes an index, <code>i</code>, as an argument and
returns a function with an argument <code>x</code> that subsets <code>x</code> with <code>i</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pick</span>(<span class="dv">1</span>)(x)
<span class="co"># should be equivalent to</span>
x[[<span class="dv">1</span>]]

<span class="kw">lapply</span>(mtcars, <span class="kw">pick</span>(<span class="dv">5</span>))
<span class="co"># should be equivalent to</span>
<span class="kw">lapply</span>(mtcars, <span class="cf">function</span>(x) x[[<span class="dv">5</span>]])</code></pre></li>
<li><p>Create a function that creates functions that compute the i<sup>th</sup>
central moment<span id="fn100" class="footnote" data-pagedown-footnote-number="100" style="white-space: pre-line;"><a href="http://en.wikipedia.org/wiki/Central_moment" class="uri">http://en.wikipedia.org/wiki/Central_moment</a></span> of a numeric
vector. You can test it by running the following code:</p>
<pre class="sourceCode r"><code class="sourceCode r">m1 &lt;-<span class="st"> </span><span class="kw">moment</span>(<span class="dv">1</span>)
m2 &lt;-<span class="st"> </span><span class="kw">moment</span>(<span class="dv">2</span>)

x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)
<span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(<span class="kw">m1</span>(x), <span class="dv">0</span>))
<span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(<span class="kw">m2</span>(x), <span class="kw">var</span>(x) <span class="op">*</span><span class="st"> </span><span class="dv">99</span> <span class="op">/</span><span class="st"> </span><span class="dv">100</span>))</code></pre></li>
<li><p>What happens if you don’t use a closure? Make predictions, then verify with
the code below.</p>
<pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="dv">0</span>
new_counter2 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  i &lt;&lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  i
}</code></pre></li>
<li><p>What happens if you use <code>&lt;-</code> instead of <code>&lt;&lt;-</code>? Make predictions, then verify
with the code below.</p>
<pre class="sourceCode r"><code class="sourceCode r">new_counter3 &lt;-<span class="st"> </span><span class="cf">function</span>() {
  i &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="cf">function</span>() {
    i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    i
  }
}</code></pre></li>
</ol>
</div>
</div>
<div id="graph-fact" class="section level2">
<h2><span class="header-section-number">10.3</span> Graphical factories</h2>
<p>We’ll begin our exploration of useful function factories with a few examples from ggplot2.</p>
<div id="labelling" class="section level3">
<h3><span class="header-section-number">10.3.1</span> Labelling</h3>
<p>One of the goals of the scales<span id="fn101" class="footnote" data-pagedown-footnote-number="101" style="white-space: pre-line;"><a href="http://scales.r-lib.org" class="uri">http://scales.r-lib.org</a></span> package is to make it easy to customise the labels on ggplot2. It provides many functions to control the fine details of axes and legends. One useful class of functions are the formatter functions<span id="fn102" class="footnote" data-pagedown-footnote-number="102" style="white-space: pre-line;">It’s an unfortunate accident of history that scales uses function suffixes instead of function prefixes. That’s because it was written before I understood the autocomplete advantages to using common prefixes instead of common suffixes.</span> which make it easier to control the appearance of axis breaks. The design of these functions might initially seem a little odd: they all return a function, which you have to call in order to format a number.</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">12345</span>, <span class="dv">123456</span>, <span class="dv">1234567</span>)
<span class="kw">comma_format</span>()(y)
<span class="co">#&gt; [1] &quot;12,345&quot;    &quot;123,456&quot;   &quot;1,234,567&quot;</span>

<span class="kw">number_format</span>(<span class="dt">scale =</span> <span class="fl">1e-3</span>, <span class="dt">suffix =</span> <span class="st">&quot; K&quot;</span>)(y)
<span class="co">#&gt; [1] &quot;12 K&quot;    &quot;123 K&quot;   &quot;1 235 K&quot;</span></code></pre>
<p>In other words, the primary interface is a function factory. At first glance, this seems to add extra complexity for little gain. But it enables a nice interaction with ggplot2’s scales, because they accept functions in the <code>label</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> y)
core &lt;-<span class="st"> </span><span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks =</span> <span class="dv">1</span>, <span class="dt">labels =</span> <span class="ot">NULL</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="ot">NULL</span>)
  
core
core <span class="op">+</span><span class="st"> </span><span class="kw">scale_y_continuous</span>(
  <span class="dt">labels =</span> <span class="kw">comma_format</span>()
)
core <span class="op">+</span><span class="st"> </span><span class="kw">scale_y_continuous</span>(
  <span class="dt">labels =</span> <span class="kw">number_format</span>(<span class="dt">scale =</span> <span class="fl">1e-3</span>, <span class="dt">suffix =</span> <span class="st">&quot; K&quot;</span>)
)
core <span class="op">+</span><span class="st"> </span><span class="kw">scale_y_continuous</span>(
  <span class="dt">labels =</span> <span class="kw">scientific_format</span>()
)</code></pre>
<p><img src="Function-factories_files/figure-html/unnamed-chunk-25-1.png" width="24%" /><img src="Function-factories_files/figure-html/unnamed-chunk-25-2.png" width="24%" /><img src="Function-factories_files/figure-html/unnamed-chunk-25-3.png" width="24%" /><img src="Function-factories_files/figure-html/unnamed-chunk-25-4.png" width="24%" /></p>
</div>
<div id="histogram-bins" class="section level3">
<h3><span class="header-section-number">10.3.2</span> Histogram bins</h3>
<p>A little known feature of <code>geom_histogram()</code> is that the <code>binwidth</code> argument can be a function. This is particularly useful because the function is executed once for each group, which means you can have different binwidths in different facets, which is otherwise not possible.</p>
<p>To illustrate this idea, and see where variable binwidth might be useful, I’m going to construct an example where a fixed binwidth isn’t great.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># construct some sample data with very different numbers in each cell</span>
sd &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">15</span>)
n &lt;-<span class="st"> </span><span class="dv">100</span>

df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">rnorm</span>(<span class="dv">3</span> <span class="op">*</span><span class="st"> </span>n, <span class="dt">sd =</span> sd), <span class="dt">sd =</span> <span class="kw">rep</span>(sd, n))

<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">binwidth =</span> <span class="dv">2</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>sd, <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>)</code></pre>
<p><img src="Function-factories_files/figure-html/unnamed-chunk-26-1.png" width="90%" style="display: block; margin: auto;" /></p>
<p>Here each facet has the same number of observations, but the variability is very different. It would be nice if we could request that the binwidths vary so we get approximately the same number of observations in each bin. One way to do that is with a function factory that inputs the desired number of bins (<code>n</code>), and outputs a function that takes a numeric vector and returns a binwidth:</p>
<pre class="sourceCode r"><code class="sourceCode r">binwidth_bins &lt;-<span class="st"> </span><span class="cf">function</span>(n) {
  <span class="kw">force</span>(n)
  
  <span class="cf">function</span>(x) {
    (<span class="kw">max</span>(x) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(x)) <span class="op">/</span><span class="st"> </span>n
  }
}

<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">binwidth =</span> <span class="kw">binwidth_bins</span>(<span class="dv">20</span>)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>sd, <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>)</code></pre>
<p><img src="Function-factories_files/figure-html/unnamed-chunk-27-1.png" width="90%" style="display: block; margin: auto;" /></p>
<p>We could use this same pattern to wrap around the base R functions that automatically find the “optimal”<span id="fn103" class="footnote" data-pagedown-footnote-number="103" style="white-space: pre-line;">ggplot2 doesn’t expose these functions directly because I don’t think the definition of optimality needed to make the problem mathematically tractable is a good match to the actual needs of data exploration.</span> binwidth, <code>nclass.Sturges()</code>, <code>nclass.scott()</code>, and <code>nclass.FD()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">base_bins &lt;-<span class="st"> </span><span class="cf">function</span>(type) {
  fun &lt;-<span class="st"> </span><span class="cf">switch</span>(type,
    <span class="dt">Sturges =</span> nclass.Sturges,
    <span class="dt">scott =</span> nclass.scott,
    <span class="dt">FD =</span> nclass.FD,
    <span class="kw">stop</span>(<span class="st">&quot;Unknown type&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  )
  
  <span class="cf">function</span>(x) {
    (<span class="kw">max</span>(x) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(x)) <span class="op">/</span><span class="st"> </span><span class="kw">fun</span>(x)
  }
}

<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">binwidth =</span> <span class="kw">base_bins</span>(<span class="st">&quot;FD&quot;</span>)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>sd, <span class="dt">scales =</span> <span class="st">&quot;free_x&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>)</code></pre>
<p><img src="Function-factories_files/figure-html/unnamed-chunk-28-1.png" width="90%" style="display: block; margin: auto;" /></p>
</div>
<div id="ggsave" class="section level3">
<h3><span class="header-section-number">10.3.3</span> <code>ggsave()</code></h3>

<p>Finally, I want to show a function factory used internally by ggplot2. <code>ggplot2:::plot_dev()</code> is used by <code>ggsave()</code> to go from a file extension (e.g. <code>png</code>, <code>jpeg</code> etc) to a graphics device function (e.g. <code>png()</code>, <code>jpeg()</code>). The challenge here arises because the base graphics devices have some minor inconsistencies which we need to paper over:</p>
<ul>
<li><p>Most have <code>filename</code> as first argument but some have <code>file</code>.</p></li>
<li><p>The <code>width</code> and <code>height</code> of raster graphic devices use pixels units
by default, but the vector graphics use inches.</p></li>
</ul>
<p>A mildly simplified version of <code>plot_dev()</code> is shown below:</p>
<pre class="sourceCode r"><code class="sourceCode r">plot_dev &lt;-<span class="st"> </span><span class="cf">function</span>(ext, <span class="dt">dpi =</span> <span class="dv">96</span>) {
  <span class="kw">force</span>(dpi)
  
  <span class="cf">switch</span>(ext,
    <span class="dt">eps =</span>  ,
    <span class="dt">ps  =</span>  <span class="cf">function</span>(filename, ...) {
      grDevices<span class="op">::</span><span class="kw">postscript</span>(
        <span class="dt">file =</span> filename, ..., <span class="dt">onefile =</span> <span class="ot">FALSE</span>, 
        <span class="dt">horizontal =</span> <span class="ot">FALSE</span>, <span class="dt">paper =</span> <span class="st">&quot;special&quot;</span>
      )
    },
    <span class="dt">tex =</span>  <span class="cf">function</span>(filename, ...) grDevices<span class="op">::</span><span class="kw">pictex</span>(<span class="dt">file =</span> filename, ...),
    <span class="dt">pdf =</span>  <span class="cf">function</span>(filename, ...) grDevices<span class="op">::</span><span class="kw">pdf</span>(<span class="dt">file =</span> filename, ...),
    <span class="dt">svg  =</span> <span class="cf">function</span>(filename, ...) svglite<span class="op">::</span><span class="kw">svglite</span>(<span class="dt">file =</span> filename, ...),
    <span class="dt">emf  =</span> ,
    <span class="dt">wmf  =</span> <span class="cf">function</span>(...) grDevices<span class="op">::</span><span class="kw">win.metafile</span>(...),
    <span class="dt">png  =</span> <span class="cf">function</span>(...) grDevices<span class="op">::</span><span class="kw">png</span>(..., <span class="dt">res =</span> dpi, <span class="dt">units =</span> <span class="st">&quot;in&quot;</span>),
    <span class="dt">jpg  =</span> ,
    <span class="dt">jpeg =</span> <span class="cf">function</span>(...) grDevices<span class="op">::</span><span class="kw">jpeg</span>(..., <span class="dt">res =</span> dpi, <span class="dt">units =</span> <span class="st">&quot;in&quot;</span>),
    <span class="dt">bmp  =</span> <span class="cf">function</span>(...) grDevices<span class="op">::</span><span class="kw">bmp</span>(..., <span class="dt">res =</span> dpi, <span class="dt">units =</span> <span class="st">&quot;in&quot;</span>),
    <span class="dt">tiff =</span> <span class="cf">function</span>(...) grDevices<span class="op">::</span><span class="kw">tiff</span>(..., <span class="dt">res =</span> dpi, <span class="dt">units =</span> <span class="st">&quot;in&quot;</span>),
    <span class="kw">stop</span>(<span class="st">&quot;Unknown graphics extension: &quot;</span>, ext, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  )
}

<span class="kw">plot_dev</span>(<span class="st">&quot;pdf&quot;</span>)
<span class="co">#&gt; function(filename, ...) grDevices::pdf(file = filename, ...)</span>
<span class="co">#&gt; &lt;bytecode: 0x53ae410&gt;</span>
<span class="co">#&gt; &lt;environment: 0x4454068&gt;</span>
<span class="kw">plot_dev</span>(<span class="st">&quot;png&quot;</span>)
<span class="co">#&gt; function(...) grDevices::png(..., res = dpi, units = &quot;in&quot;)</span>
<span class="co">#&gt; &lt;bytecode: 0x56e18b0&gt;</span>
<span class="co">#&gt; &lt;environment: 0x5cfdea8&gt;</span></code></pre>
</div>
<div id="exercises-33" class="section level3">
<h3><span class="header-section-number">10.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>Compare and contrast <code>ggplot2::label_bquote()</code> with
<code>scales::number_format()</code></li>
</ol>
</div>
</div>
<div id="stat-fact" class="section level2">
<h2><span class="header-section-number">10.4</span> Statistical factories</h2>
<p>More motivating examples for function factories come from statistics:</p>
<ul>
<li>The Box-Cox transformation.</li>
<li>Bootstrap resampling.</li>
<li>Maximum likelihood estimation.</li>
</ul>
<p>All of these examples can be tackled without function factories, but I think function factories are a good fit for these problems and provide elegant solutions. These examples expect some statistical background, so feel free to skip if they don’t make much sense to you.</p>
<div id="box-cox-transformation" class="section level3">
<h3><span class="header-section-number">10.4.1</span> Box-Cox transformation</h3>
<p></p>
<p>The Box-Cox transformation (a type of power transformation<span id="fn104" class="footnote" data-pagedown-footnote-number="104" style="white-space: pre-line;"><a href="https://en.wikipedia.org/wiki/Power_transform" class="uri">https://en.wikipedia.org/wiki/Power_transform</a></span>) is a flexible transformation often used to transform data towards normality. It has a single parameter, <span class="math inline">\(\lambda\)</span>, which controls the strength of the transformation. We could express the transformation as a simple two argument function:</p>
<pre class="sourceCode r"><code class="sourceCode r">boxcox1 &lt;-<span class="st"> </span><span class="cf">function</span>(x, lambda) {
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(lambda) <span class="op">!=</span><span class="st"> </span><span class="dv">1</span>)
  
  <span class="cf">if</span> (lambda <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="kw">log</span>(x)
  } <span class="cf">else</span> {
    (x <span class="op">^</span><span class="st"> </span>lambda <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>lambda
  }
}</code></pre>
<p>But re-formulating as a function factory makes it easy to explore its behaviour with <code>stat_function()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">boxcox2 &lt;-<span class="st"> </span><span class="cf">function</span>(lambda) {
  <span class="cf">if</span> (lambda <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="cf">function</span>(x) <span class="kw">log</span>(x)
  } <span class="cf">else</span> {
    <span class="cf">function</span>(x) (x <span class="op">^</span><span class="st"> </span>lambda <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>lambda
  }
}

stat_boxcox &lt;-<span class="st"> </span><span class="cf">function</span>(lambda) {
  <span class="kw">stat_function</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> lambda), <span class="dt">fun =</span> <span class="kw">boxcox2</span>(lambda), <span class="dt">size =</span> <span class="dv">1</span>)
}

<span class="kw">ggplot</span>(<span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>)), <span class="kw">aes</span>(x)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">lapply</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="dv">1</span>, <span class="fl">1.5</span>), stat_boxcox) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_colour_viridis_c</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">1.5</span>))

<span class="co"># visually, log() does seem to make sense as the transformation</span>
<span class="co"># for lambda = 0; as values get smaller and smaller, the function</span>
<span class="co"># gets close and closer to a log transformation</span>
<span class="kw">ggplot</span>(<span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="fl">0.01</span>, <span class="dv">1</span>)), <span class="kw">aes</span>(x)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">lapply</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="fl">0.25</span>, <span class="fl">0.1</span>, <span class="dv">0</span>), stat_boxcox) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_colour_viridis_c</span>(<span class="dt">limits =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">1.5</span>))</code></pre>
<p><img src="Function-factories_files/figure-html/unnamed-chunk-31-1.png" width="50%" /><img src="Function-factories_files/figure-html/unnamed-chunk-31-2.png" width="50%" /></p>
<p>In general, this allows you to use a Box-Cox transformation with any function that accepts a unary transformation function: you don’t have to worry about that function providing <code>...</code> to pass along additional arguments. I also think that the partitioning of <code>lambda</code> and <code>x</code> into two different function arguments is natural since <code>lambda</code> plays quite a different role than <code>x</code>.</p>
</div>
<div id="bootstrap-generators" class="section level3">
<h3><span class="header-section-number">10.4.2</span> Bootstrap generators</h3>
<p></p>
<p>Function factories are a useful approach for bootstrapping. Instead of thinking about a single bootstrap (you always need more than one!), you can think about a bootstrap <strong>generator</strong>, a function that yields a fresh bootstrap every time it is called:</p>
<pre class="sourceCode r"><code class="sourceCode r">boot_permute &lt;-<span class="st"> </span><span class="cf">function</span>(df, var) {
  n &lt;-<span class="st"> </span><span class="kw">nrow</span>(df)
  <span class="kw">force</span>(var)
  
  <span class="cf">function</span>() {
    col &lt;-<span class="st"> </span>df[[var]]
    col[<span class="kw">sample</span>(n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)]
  }
}

boot_mtcars1 &lt;-<span class="st"> </span><span class="kw">boot_permute</span>(mtcars, <span class="st">&quot;mpg&quot;</span>)
<span class="kw">head</span>(<span class="kw">boot_mtcars1</span>())
<span class="co">#&gt; [1] 18.1 22.8 21.5 14.7 21.4 17.3</span>
<span class="kw">head</span>(<span class="kw">boot_mtcars1</span>())
<span class="co">#&gt; [1] 19.2 19.2 14.3 21.0 13.3 21.4</span></code></pre>
<p>The advantage of a function factory is more clear with a parametric bootstrap where we have to first fit a model. We can do this setup step once, when the factory is called, rather than once every time we generate the bootstrap:</p>
<pre class="sourceCode r"><code class="sourceCode r">boot_model &lt;-<span class="st"> </span><span class="cf">function</span>(df, formula) {
  mod &lt;-<span class="st"> </span><span class="kw">lm</span>(formula, <span class="dt">data =</span> df)
  fitted &lt;-<span class="st"> </span><span class="kw">unname</span>(<span class="kw">fitted</span>(mod))
  resid &lt;-<span class="st"> </span><span class="kw">unname</span>(<span class="kw">resid</span>(mod))
  <span class="kw">rm</span>(mod)

  <span class="cf">function</span>() {
    fitted <span class="op">+</span><span class="st"> </span><span class="kw">sample</span>(resid)
  }
} 

boot_mtcars2 &lt;-<span class="st"> </span><span class="kw">boot_model</span>(mtcars, mpg <span class="op">~</span><span class="st"> </span>wt)
<span class="kw">head</span>(<span class="kw">boot_mtcars2</span>())
<span class="co">#&gt; [1] 23.1 24.3 23.0 19.1 19.1 16.2</span>
<span class="kw">head</span>(<span class="kw">boot_mtcars2</span>())
<span class="co">#&gt; [1] 30.2 17.4 31.3 26.1 17.8 16.7</span></code></pre>
<p>I use <code>rm(mod)</code> because linear model objects are quite large (they include complete copies of the model matrix and input data) and I want to keep the manufactured function as small as possible.</p>
</div>
<div id="MLE" class="section level3">
<h3><span class="header-section-number">10.4.3</span> Maximum likelihood estimation</h3>
<p>

</p>
<p>The goal of maximum likelihood estimation (MLE) is to find the parameter values for a distribution that make the observed data “most likely”. To do MLE, you start with a probability function. For example, take the Poisson distribution. If we know <span class="math inline">\(\lambda\)</span>, we can compute the probability of getting a vector <span class="math inline">\(\mathbf{x}\)</span> of values (<span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span>, …, <span class="math inline">\(x_n\)</span>) by multiplying the Poisson probability function as follows:</p>
<p><span class="math display">\[ P(\lambda, \mathbf{x}) = \prod_{i=1}^{n} \frac{\lambda ^ {x_i} e^{-\lambda}}{x_i!} \]</span></p>
<p>In statistics, we almost always work with the log of this function. The log is a monotonic transformation which preserves important properties (i.e. the extrema occur in the same place), but has specific advantages:</p>
<ul>
<li><p>The log turns a product into a sum, which is easier to work with.</p></li>
<li><p>Multiplying small numbers yields even smaller numbers, which makes the
floating point approximation used by a computer less accurate.</p></li>
</ul>
<p>Let’s apply a log transformation to this probability function and simplify it as much as possible:</p>
<p><span class="math display">\[ \log(P(\lambda, \mathbf{x})) = \sum_{i=1}^{n} \log(\frac{\lambda ^ {x_i} e^{-\lambda}}{x_i!}) \]</span></p>
<p><span class="math display">\[ \log(P(\lambda, \mathbf{x})) = \sum_{i=1}^{n} \left( x_i \log(\lambda) - \lambda - \log(x_i!) \right) \]</span></p>
<p><span class="math display">\[ \log(P(\lambda, \mathbf{x})) = 
     \sum_{i=1}^{n} x_i \log(\lambda)
   - \sum_{i=1}^{n} \lambda 
   - \sum_{i=1}^{n} \log(x_i!) \]</span></p>
<p><span class="math display">\[ \log(P(\lambda, \mathbf{x})) = 
   \log(\lambda) \sum_{i=1}^{n} x_i - n \lambda - \sum_{i=1}^{n} \log(x_i!) \]</span></p>
<p>We can now turn this function into an R function. The R function is quite elegant because R is vectorised and, because it’s a statistical programming language, R comes with built-in functions like the log-factorial (<code>lfactorial()</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r">lprob_poisson &lt;-<span class="st"> </span><span class="cf">function</span>(lambda, x) {
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  (<span class="kw">log</span>(lambda) <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(x)) <span class="op">-</span><span class="st"> </span>(n <span class="op">*</span><span class="st"> </span>lambda) <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">lfactorial</span>(x))
}</code></pre>
<p>Consider this vector of observations:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">41</span>, <span class="dv">30</span>, <span class="dv">31</span>, <span class="dv">38</span>, <span class="dv">29</span>, <span class="dv">24</span>, <span class="dv">30</span>, <span class="dv">29</span>, <span class="dv">31</span>, <span class="dv">38</span>)</code></pre>
<p>We can use <code>lprob_poisson()</code> to compute the (logged) probability of <code>x1</code> for different values of <code>lambda</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lprob_poisson</span>(<span class="dv">10</span>, x1)
<span class="co">#&gt; [1] -184</span>
<span class="kw">lprob_poisson</span>(<span class="dv">20</span>, x1)
<span class="co">#&gt; [1] -61.1</span>
<span class="kw">lprob_poisson</span>(<span class="dv">30</span>, x1)
<span class="co">#&gt; [1] -31</span></code></pre>
<p>So far we’ve been thinking of <code>lambda</code> as fixed and known and the function told us the probability of getting different values of <code>x</code>. But in real-life, we observe <code>x</code> and it is <code>lambda</code> that is unknown. The likelihood is the probability function seen through this lens: we want to find the <code>lambda</code> that makes the observed <code>x</code> the “most likely”. That is, given <code>x</code>, what value of <code>lambda</code> gives us the highest value of <code>lprob_poisson</code>()?</p>
<p>In statistics, we highlight this change in perspective by writing <span class="math inline">\(f_{\mathbf{x}}(\lambda)\)</span> instead of <span class="math inline">\(f(\lambda, \mathbf{x})\)</span>. In R, we can use a function factory. We provide <code>x</code> and generate a function with a single parameter, <code>lambda</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">ll_poisson1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)

  <span class="cf">function</span>(lambda) {
    <span class="kw">log</span>(lambda) <span class="op">*</span><span class="st"> </span><span class="kw">sum</span>(x) <span class="op">-</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>lambda <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">lfactorial</span>(x))
  }
}</code></pre>
<p>(We don’t need <code>force()</code> because <code>length()</code> implicitly forces evaluation of <code>x</code>.)</p>
<p>One nice thing about this approach is that we can do some precomputation: any term that only involves <code>x</code> can be computed once in the factory. This is useful because we’re going to need to call this function many times to find the best <code>lambda</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">ll_poisson2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  sum_x &lt;-<span class="st"> </span><span class="kw">sum</span>(x)
  c &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">lfactorial</span>(x))

  <span class="cf">function</span>(lambda) {
    <span class="kw">log</span>(lambda) <span class="op">*</span><span class="st"> </span>sum_x <span class="op">-</span><span class="st"> </span>n <span class="op">*</span><span class="st"> </span>lambda <span class="op">-</span><span class="st"> </span>c
  }
}</code></pre>
<p>Now we can use this function to find the value of <code>lambda</code> that maximizes the (log) likelihood:</p>
<pre class="sourceCode r"><code class="sourceCode r">ll1 &lt;-<span class="st"> </span><span class="kw">ll_poisson2</span>(x1)

<span class="kw">ll1</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] -184</span>
<span class="kw">ll1</span>(<span class="dv">20</span>)
<span class="co">#&gt; [1] -61.1</span>
<span class="kw">ll1</span>(<span class="dv">30</span>)
<span class="co">#&gt; [1] -31</span></code></pre>
<p>Rather than trial and error, we can automate the process of finding the best value with <code>optimise()</code>. It will evaluate <code>ll1()</code> many times, using mathematical tricks to narrow in on the largest value as quickly as possible. The results tell us that the highest value is <code>-30.27</code> which occurs when <code>lambda = 32.1</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">optimise</span>(ll1, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">100</span>), <span class="dt">maximum =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; $maximum</span>
<span class="co">#&gt; [1] 32.1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $objective</span>
<span class="co">#&gt; [1] -30.3</span></code></pre>
<p>Now, we could have solved this problem without using a function factory because <code>optimise()</code> passes <code>...</code> on to the function being optimised. That means we could use the log-probability function directly:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">optimise</span>(lprob_poisson, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">100</span>), <span class="dt">x =</span> x1, <span class="dt">maximum =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; $maximum</span>
<span class="co">#&gt; [1] 32.1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $objective</span>
<span class="co">#&gt; [1] -30.3</span></code></pre>
<p>The advantage of using a function factory here is fairly small, but there are two niceties:</p>
<ul>
<li><p>We can precompute some values in the factory itself, saving computation time
in each iteration.</p></li>
<li><p>The two-level design better reflects the mathematical structure of
the underlying problem.</p></li>
</ul>
<p>These advantages get bigger in more complex MLE problems, where you have multiple parameters and multiple data vectors.</p>
<!-- GVW: stepping back, what patterns in existing code should people look for that suggest "Hey, maybe use a function factory here"? -->
</div>
<div id="exercises-34" class="section level3">
<h3><span class="header-section-number">10.4.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In <code>boot_model()</code>, why don’t I need to force the evaluation of <code>df</code>
or <code>model</code>?</p></li>
<li><p>Why might you formulate the Box-Cox transformation like this?</p>
<pre class="sourceCode r"><code class="sourceCode r">boxcox3 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">function</span>(lambda) {
    <span class="cf">if</span> (lambda <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
      <span class="kw">log</span>(x)
    } <span class="cf">else</span> {
      (x <span class="op">^</span><span class="st"> </span>lambda <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>lambda
    }
  }  
}</code></pre></li>
<li><p>Why don’t you need to worry that <code>boot_permute()</code> stores a copy of the
data inside the function that it generates?</p></li>
<li><p>How much time does <code>ll_poisson2()</code> save compared to <code>ll_poisson1()</code>?
Use <code>bench::mark()</code> to see how much faster the optimisation occurs.
How does changing the length of <code>x</code> change the results?</p></li>
</ol>
</div>
</div>
<div id="functional-factories" class="section level2">
<h2><span class="header-section-number">10.5</span> Function factories + functionals</h2>
<p>To finish off the chapter, I’ll show how you might combine functionals and function factories to turn data into many functions. The following code creates many specially named power functions by iterating over a list of arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r">names &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">square =</span> <span class="dv">2</span>, 
  <span class="dt">cube =</span> <span class="dv">3</span>, 
  <span class="dt">root =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span>, 
  <span class="dt">cuberoot =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span>, 
  <span class="dt">reciprocal =</span> <span class="dv">-1</span>
)
funs &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">map</span>(names, power1)

funs<span class="op">$</span><span class="kw">root</span>(<span class="dv">64</span>)
<span class="co">#&gt; [1] 8</span>
funs<span class="op">$</span>root
<span class="co">#&gt; function(x) {</span>
<span class="co">#&gt;     x ^ exp</span>
<span class="co">#&gt;   }</span>
<span class="co">#&gt; &lt;bytecode: 0x31154f0&gt;</span>
<span class="co">#&gt; &lt;environment: 0x27c6388&gt;</span></code></pre>
<p>This idea extends in a straightforward way if your function factory takes two (replace <code>map()</code> with <code>map2()</code>) or more (replace with <code>pmap()</code>) arguments.</p>

<p>One downside of the current construction is that you have to prefix every function call with <code>funs$</code>. There are three ways to eliminate this additional syntax:</p>
<ul>
<li><p>For a very temporary effect, you can use <code>with()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">with</span>(funs, <span class="kw">root</span>(<span class="dv">100</span>))
<span class="co">#&gt; [1] 10</span></code></pre>
<p>I recommend this because it makes it very clear when code is being
executed in a special context and what that context is.</p></li>
<li><p>For a longer effect, you can <code>attach()</code> the functions to the search path,
then <code>detach()</code> when you’re done:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(funs)
<span class="co">#&gt; The following objects are masked _by_ .GlobalEnv:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     cube, square</span>
<span class="kw">root</span>(<span class="dv">100</span>)
<span class="co">#&gt; [1] 10</span>
<span class="kw">detach</span>(funs)</code></pre>
<p>You’ve probably been told to avoid using <code>attach()</code>, and that’s generally
good advice. However, the situation is a little different to the usual
because we’re attaching a list of functions, not a data frame. It’s less
likely that you’ll modify a function than a column in a data frame, so the
some of the worst problems with <code>attach()</code> don’t apply.</p></li>
<li><p>Finally, you could copy the functions to the global environment with
<code>env_bind()</code> (you’ll learn about <code>!!!</code> in Section <a href="#tidy-dots">19.6</a>).
This is mostly permanent:</p>
<pre class="sourceCode r"><code class="sourceCode r">rlang<span class="op">::</span><span class="kw">env_bind</span>(<span class="kw">globalenv</span>(), <span class="op">!!!</span>funs)
<span class="kw">root</span>(<span class="dv">100</span>)
<span class="co">#&gt; [1] 10</span></code></pre>
<p>You can later unbind those same names, but there’s no guarantee that
they haven’t been rebound in the meantime, and you might be deleting an
object that someone else created.</p>
<pre class="sourceCode r"><code class="sourceCode r">rlang<span class="op">::</span><span class="kw">env_unbind</span>(<span class="kw">globalenv</span>(), <span class="kw">names</span>(funs))</code></pre></li>
</ul>
<p>You’ll learn an alternative approach to the same problem in Section <a href="#new-function">19.7.4</a>. Instead of using a function factory, you could construct the function with quasiquotation. This requires additional knowledge, but generates functions with readable bodies, and avoids accidentally capturing large objects in the enclosing scope. We use that idea in Section <a href="#tag-functions">21.2.4</a> when we work on tools for generating HTML from R.</p>
<div id="exercises-35" class="section level3">
<h3><span class="header-section-number">10.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Which of the following commands is equivalent to <code>with(x, f(z))</code>?</p>
<ol style="list-style-type: lower-alpha">
<li><code>x$f(x$z)</code>.</li>
<li><code>f(x$z)</code>.</li>
<li><code>x$f(z)</code>.</li>
<li><code>f(z)</code>.</li>
<li>It depends.</li>
</ol></li>
<li><p>Compare and contrast the effects of <code>env_bind()</code> vs. <code>attach()</code> for the
following code.</p>
<pre class="sourceCode r"><code class="sourceCode r">funs &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">mean =</span> <span class="cf">function</span>(x) <span class="kw">mean</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
  <span class="dt">sum =</span> <span class="cf">function</span>(x) <span class="kw">sum</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
)

<span class="kw">attach</span>(funs)
<span class="co">#&gt; The following objects are masked from package:base:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     mean, sum</span>
mean &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">stop</span>(<span class="st">&quot;Hi!&quot;</span>)
<span class="kw">detach</span>(funs)

<span class="kw">env_bind</span>(<span class="kw">globalenv</span>(), <span class="op">!!!</span>funs)
mean &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">stop</span>(<span class="st">&quot;Hi!&quot;</span>) 
<span class="kw">env_unbind</span>(<span class="kw">globalenv</span>(), <span class="kw">names</span>(funs))</code></pre></li>
</ol>
<!--chapter:end:Function-factories.Rmd-->
</div>
</div>
</div>
<div id="function-operators" class="section level1">
<h1><span class="header-section-number">11</span> Function operators</h1>
<div id="introduction-10" class="section level2">
<h2><span class="header-section-number">11.1</span> Introduction</h2>
<p></p>
<p>In this chapter, you’ll learn about function operators. A <strong>function operator</strong> is a function that takes one (or more) functions as input and returns a function as output. The following code shows a simple function operator, <code>chatty()</code>. It wraps a function, making a new function that prints out its first argument. You might create a function like this because it gives you a window to see how functionals, like <code>map_int()</code>, work.</p>
<pre class="sourceCode r"><code class="sourceCode r">chatty &lt;-<span class="st"> </span><span class="cf">function</span>(f) {
  <span class="kw">force</span>(f)
  
  <span class="cf">function</span>(x, ...) {
    res &lt;-<span class="st"> </span><span class="kw">f</span>(x, ...)
    <span class="kw">cat</span>(<span class="st">&quot;Processing &quot;</span>, x, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
    res
  }
}
f &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>)

purrr<span class="op">::</span><span class="kw">map_dbl</span>(s, <span class="kw">chatty</span>(f))
<span class="co">#&gt; Processing 3</span>
<span class="co">#&gt; Processing 2</span>
<span class="co">#&gt; Processing 1</span>
<span class="co">#&gt; [1] 9 4 1</span></code></pre>
<p>Function operators are closely related to function factories; indeed they’re just a function factory that takes a function as input. Like factories, there’s nothing you can’t do without them, but they often allow you to factor out complexity in order to make your code more readable and reusable.</p>
<p>Function operators are typically paired with functionals. If you’re using a for-loop, there’s rarely a reason to use a function operator, as it will make your code more complex for little gain.</p>
<p>If you’re familiar with Python, decorators are just another name for function operators.</p>
<div id="outline-9" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#existing-fos">11.2</a> introduces you to two extremely useful existing
function operators, and shows you how to use them to solve real problems.</p></li>
<li><p>Section <a href="#fo-case-study">11.3</a> works through a problem amenable to solution
with function operators: downloading many web pages.</p></li>
</ul>
</div>
<div id="prerequisites-5" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>Function operators are a type of function factory, so make sure you’re familiar with at least Section <a href="#function-fundamentals">6.2</a> before you go on.</p>
<p>We’ll use purrr<span id="fn105" class="footnote" data-pagedown-footnote-number="105" style="white-space: pre-line;"><a href="https://purrr.tidyverse.org" class="uri">https://purrr.tidyverse.org</a></span> for a couple of functionals that you learned about in Chapter <a href="#functionals">9</a>, and some function operators that you’ll learn about below. We’ll also use the memoise package<span id="fn106" class="footnote" data-pagedown-footnote-number="106" style="white-space: pre-line;"><a href="https://memoise.r-lib.org" class="uri">https://memoise.r-lib.org</a></span> <span class="citation">(Wickham et al. <a href="#ref-memoise">2018</a>)</span> for the <code>memoise()</code> operator.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(purrr)
<span class="kw">library</span>(memoise)</code></pre>
<!--
### In other languages

Function operators are used extensively in FP languages like Haskell, and commonly in Lisp, Scheme and Clojure. They are also an important part of modern JavaScript programming, like in the [underscore.js](http://underscorejs.org/) library. They are particularly common in CoffeeScript because its syntax for anonymous functions is so concise. In stack-based languages like Forth and Factor, function operators are used almost exclusively because it's rare to refer to variables by name. Python's decorators are just function operators by a [different name](http://stackoverflow.com/questions/739654/). In Java, they are very rare because it's difficult to manipulate functions (although possible if you wrap them up in strategy-type objects). They are also rare in C++ because, while it's possible to create objects that work like functions ("functors") by overloading the `()` operator, modifying these objects with other functions is not a common programming technique. That said, C++ 11 includes partial application (`std::bind`) as part of the standard library.
-->
</div>
</div>
<div id="existing-fos" class="section level2">
<h2><span class="header-section-number">11.2</span> Existing function operators</h2>
<p>There are two very useful function operators that will both help you solve common recurring problems, and give you a sense for what function operators can do: <code>purrr::safely()</code> and <code>memoise::memoise()</code>.</p>
<div id="safely" class="section level3">
<h3><span class="header-section-number">11.2.1</span> Capturing errors with <code>purrr::safely()</code></h3>

<p></p>
<p>One advantage of for-loops is that if one of the iterations fails, you can still access all the results up to the failure:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">c</span>(<span class="fl">0.512</span>, <span class="fl">0.165</span>, <span class="fl">0.717</span>),
  <span class="kw">c</span>(<span class="fl">0.064</span>, <span class="fl">0.781</span>, <span class="fl">0.427</span>),
  <span class="kw">c</span>(<span class="fl">0.890</span>, <span class="fl">0.785</span>, <span class="fl">0.495</span>),
  <span class="st">&quot;oops&quot;</span>
)

out &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA_real_</span>, <span class="kw">length</span>(x))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
  out[[i]] &lt;-<span class="st"> </span><span class="kw">sum</span>(x[[i]])
}
<span class="co">#&gt; Error in sum(x[[i]]):</span>
<span class="co">#&gt;   invalid &#39;type&#39; (character) of argument</span>
out
<span class="co">#&gt; [1] 1.39 1.27 2.17   NA</span></code></pre>
<p>If you do the same thing with a functional, you get no output, making it hard to figure out where the problem lies:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(x, sum)
<span class="co">#&gt; Error in .Primitive(&quot;sum&quot;)(..., na.rm = na.rm):</span>
<span class="co">#&gt;   invalid &#39;type&#39; (character) of argument</span></code></pre>
<p><code>purrr::safely()</code> provides a tool to help with this problem. <code>safely()</code> is a function operator that transforms a function to turn errors into data. (You can learn the basic idea that makes it work in Section <a href="#try-success-failure">8.6.2</a>). Let’s start by taking a look at it outside of <code>map_dbl()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">safe_sum &lt;-<span class="st"> </span><span class="kw">safely</span>(sum)
safe_sum
<span class="co">#&gt; function (...) </span>
<span class="co">#&gt; capture_error(.f(...), otherwise, quiet)</span>
<span class="co">#&gt; &lt;bytecode: 0x591a3c0&gt;</span>
<span class="co">#&gt; &lt;environment: 0x5919f28&gt;</span></code></pre>
<p>Like all function operators, <code>safely()</code> takes a function and returns a wrapped function which we can call as usual:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">safe_sum</span>(x[[<span class="dv">1</span>]]))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result: num 1.39</span>
<span class="co">#&gt;  $ error : NULL</span>
<span class="kw">str</span>(<span class="kw">safe_sum</span>(x[[<span class="dv">4</span>]]))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result: NULL</span>
<span class="co">#&gt;  $ error :List of 2</span>
<span class="co">#&gt;   ..$ message: chr &quot;invalid &#39;type&#39; (character) of argument&quot;</span>
<span class="co">#&gt;   ..$ call   : language .Primitive(&quot;sum&quot;)(..., na.rm = na.rm)</span>
<span class="co">#&gt;   ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>You can see that a function transformed by <code>safely()</code> always returns a list with two elements, <code>result</code> and <code>error</code>. If the function runs successfully, <code>error</code> is <code>NULL</code> and <code>result</code> contains the result; if the function fails, <code>result</code> is <code>NULL</code> and <code>error</code> contains the error.</p>
<p>Now lets use <code>safely()</code> with a functional:</p>
<pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> </span><span class="kw">map</span>(x, <span class="kw">safely</span>(sum))
<span class="kw">str</span>(out)
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: num 1.39</span>
<span class="co">#&gt;   ..$ error : NULL</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: num 1.27</span>
<span class="co">#&gt;   ..$ error : NULL</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: num 2.17</span>
<span class="co">#&gt;   ..$ error : NULL</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: NULL</span>
<span class="co">#&gt;   ..$ error :List of 2</span>
<span class="co">#&gt;   .. ..$ message: chr &quot;invalid &#39;type&#39; (character) of argument&quot;</span>
<span class="co">#&gt;   .. ..$ call   : language .Primitive(&quot;sum&quot;)(..., na.rm = na.rm)</span>
<span class="co">#&gt;   .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>The output is in a slightly inconvenient form, since we have four lists, each of which is a list containing the <code>result</code> and the <code>error</code>. We can make the output easier to use with <code>purrr::transpose()</code>. This turns it “inside-out” so that we get a list of <code>result</code>s and a list of <code>error</code>s:</p>
<pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> </span><span class="kw">transpose</span>(<span class="kw">map</span>(x, <span class="kw">safely</span>(sum)))
<span class="kw">str</span>(out)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result:List of 4</span>
<span class="co">#&gt;   ..$ : num 1.39</span>
<span class="co">#&gt;   ..$ : num 1.27</span>
<span class="co">#&gt;   ..$ : num 2.17</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;  $ error :List of 4</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;   ..$ :List of 2</span>
<span class="co">#&gt;   .. ..$ message: chr &quot;invalid &#39;type&#39; (character) of argument&quot;</span>
<span class="co">#&gt;   .. ..$ call   : language .Primitive(&quot;sum&quot;)(..., na.rm = na.rm)</span>
<span class="co">#&gt;   .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>Now we can easily find the results that worked, or the inputs that failed:</p>
<pre class="sourceCode r"><code class="sourceCode r">ok &lt;-<span class="st"> </span><span class="kw">map_lgl</span>(out<span class="op">$</span>error, is.null)
ok
<span class="co">#&gt; [1]  TRUE  TRUE  TRUE FALSE</span>

x[<span class="op">!</span>ok]
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;oops&quot;</span>

out<span class="op">$</span>result[ok]
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1.39</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 1.27</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 2.17</span></code></pre>
<p>You can use this same technique in many different situations. For example, imagine you’re fitting a generalised linear model (GLM) to a list of data frames. GLMs can sometimes fail because of optimisation problems, but you still want to be able to try to fit all the models, and later look back at those that failed:</p>
<pre class="sourceCode r"><code class="sourceCode r">fit_model &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  <span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2 <span class="op">*</span><span class="st"> </span>x3, <span class="dt">data =</span> df)
}

models &lt;-<span class="st"> </span><span class="kw">transpose</span>(<span class="kw">map</span>(datasets, <span class="kw">safely</span>(fit_model)))
ok &lt;-<span class="st"> </span><span class="kw">map_lgl</span>(models<span class="op">$</span>error, is.null)

<span class="co"># which data failed to converge?</span>
datasets[<span class="op">!</span>ok]

<span class="co"># which models were successful?</span>
models[ok]</code></pre>
<p>I think this is a great example of the power of combining functionals and function operators: <code>safely()</code> lets you succinctly express what you need to solve a common data analysis problem.</p>
<p>purrr comes with three other function operators in a similar vein:</p>
<ul>
<li><p><code>possibly()</code>: returns a default value when there’s an error.
It provides no way to tell if an error occured or not, so it’s best
reserved for cases when there’s some obvious sentinel value (like <code>NA</code>).</p></li>
<li><p><code>quietly()</code>: turns output, messages, and warning side-effects into
<code>output</code>, <code>message</code>, and <code>warning</code> components of the output.</p></li>
<li><p><code>auto_browser()</code>: automatically executes <code>browser()</code> inside the
function when there’s an error.</p></li>
</ul>
<p>See their documentation for more details.</p>
</div>
<div id="memoise" class="section level3">
<h3><span class="header-section-number">11.2.2</span> Caching computations with <code>memoise::memoise()</code></h3>
<p>
</p>
<p>Another handy function operator is <code>memoise::memoise()</code>. It <strong>memoises</strong> a function, meaning that the function will remember previous inputs and return cached results. Memoisation is an example of the classic computer science tradeoff of memory versus speed. A memoised function can run much faster because it stores all of the previous inputs and outputs, using more memory.</p>
<p>Let’s explore this idea with a toy function that simulates an expensive operation:</p>
<pre class="sourceCode r"><code class="sourceCode r">slow_function &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">Sys.sleep</span>(<span class="dv">1</span>)
  x <span class="op">*</span><span class="st"> </span><span class="dv">10</span> <span class="op">*</span><span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
}
<span class="kw">system.time</span>(<span class="kw">print</span>(<span class="kw">slow_function</span>(<span class="dv">1</span>)))
<span class="co">#&gt; [1] 0.808</span>
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;       0       0       1</span>

<span class="kw">system.time</span>(<span class="kw">print</span>(<span class="kw">slow_function</span>(<span class="dv">1</span>)))
<span class="co">#&gt; [1] 8.34</span>
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.004   0.000   1.004</span></code></pre>
<p>When we memoise this function, it’s slow when we call it with new arguments. But when we call it with arguments that it’s seen before it’s instantaneous: it retrieves the previous value of the computation.</p>
<pre class="sourceCode r"><code class="sourceCode r">fast_function &lt;-<span class="st"> </span>memoise<span class="op">::</span><span class="kw">memoise</span>(slow_function)
<span class="kw">system.time</span>(<span class="kw">print</span>(<span class="kw">fast_function</span>(<span class="dv">1</span>)))
<span class="co">#&gt; [1] 6.01</span>
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;       0       0       1</span>

<span class="kw">system.time</span>(<span class="kw">print</span>(<span class="kw">fast_function</span>(<span class="dv">1</span>)))
<span class="co">#&gt; [1] 6.01</span>
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.016   0.000   0.016</span></code></pre>
<p>A relatively realistic use of memoisation is computing the Fibonacci series. The Fibonacci series is defined recursively: the first two values are defined by convention, <span class="math inline">\(f(0) = 0\)</span>, <span class="math inline">\(f(n) = 1\)</span>, and then <span class="math inline">\(f(n) = f(n - 1) + f(n - 2)\)</span> (for any positive integer). A naive version is slow because, for example, <code>fib(10)</code> computes <code>fib(9)</code> and <code>fib(8)</code>, and <code>fib(9)</code> computes <code>fib(8)</code> and <code>fib(7)</code>, and so on.</p>
<pre class="sourceCode r"><code class="sourceCode r">fib &lt;-<span class="st"> </span><span class="cf">function</span>(n) {
  <span class="cf">if</span> (n <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>) <span class="kw">return</span>(<span class="dv">1</span>)
  <span class="kw">fib</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">fib</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)
}
<span class="kw">system.time</span>(<span class="kw">fib</span>(<span class="dv">23</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.044   0.000   0.042</span>
<span class="kw">system.time</span>(<span class="kw">fib</span>(<span class="dv">24</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.060   0.000   0.062</span></code></pre>
<p>Memoising <code>fib()</code> makes the implementation much faster because each value is computed only once:</p>
<pre class="sourceCode r"><code class="sourceCode r">fib2 &lt;-<span class="st"> </span>memoise<span class="op">::</span><span class="kw">memoise</span>(<span class="cf">function</span>(n) {
  <span class="cf">if</span> (n <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>) <span class="kw">return</span>(<span class="dv">1</span>)
  <span class="kw">fib2</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">fib2</span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)
})
<span class="kw">system.time</span>(<span class="kw">fib2</span>(<span class="dv">23</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.024   0.000   0.025</span></code></pre>
<p>And future calls can rely on previous computations:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(<span class="kw">fib2</span>(<span class="dv">24</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.004   0.000   0.001</span></code></pre>
<p>This is an example of <strong>dynamic programming</strong>, where a complex problem can be broken down into many overlapping subproblems, and remembering the results of a subproblem considerably improves performance.</p>
<p>Think carefully before memoising a function. If the function is not <strong>pure</strong>, i.e. the output does not depend only on the input, you will get misleading and confusing results. I created a subtle bug in devtools because I memoised the results of <code>available.packages()</code>, which is rather slow because it has to download a large file from CRAN. The available packages don’t change that frequently, but if you have an R process that’s been running for a few days, the changes can become important, and because the problem only arose in long-running R processes, the bug was very painful to find.</p>
</div>
<div id="exercises-36" class="section level3">
<h3><span class="header-section-number">11.2.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Base R provides a function operator in the form of <code>Vectorize()</code>.
What does it do? When might you use it?</p></li>
<li><p>Read the source code for <code>possibly()</code>. How does it work?</p></li>
<li><p>Read the source code for <code>safely()</code>. How does it work?</p></li>
</ol>
</div>
</div>
<div id="fo-case-study" class="section level2">
<h2><span class="header-section-number">11.3</span> Case study: creating your own function operators</h2>
<p></p>
<p><code>meomoise()</code> and <code>safely()</code> are very useful but also quite complex. In this case study you’ll learn how to create your own simpler function operators. Imagine you have a named vector of URLs and you’d like to download each one to disk. That’s pretty simple with <code>walk2()</code> and <code>file.download()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">urls &lt;-<span class="st"> </span><span class="kw">c</span>(
  <span class="st">&quot;adv-r&quot;</span> =<span class="st"> &quot;https://adv-r.hadley.nz&quot;</span>, 
  <span class="st">&quot;r4ds&quot;</span> =<span class="st"> &quot;http://r4ds.had.co.nz/&quot;</span>
  <span class="co"># and many many more</span>
)
path &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">tempdir</span>(), <span class="kw">names</span>(urls), <span class="st">&quot;.html&quot;</span>)

<span class="kw">walk2</span>(urls, path, download.file, <span class="dt">quiet =</span> <span class="ot">TRUE</span>)</code></pre>
<p>This approach is fine for a handful of URLs, but as the vector gets longer, it’d be nice to add a couple more features:</p>
<ul>
<li><p>Add a small delay between each request to avoid hammering the server.</p></li>
<li><p>Display a <code>.</code> every few URLs so that we know that the function is still
working.</p></li>
</ul>
<p>It’s relatively easy to add these extra features if we’re using a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(urls)) {
  <span class="kw">Sys.sleep</span>(<span class="fl">0.1</span>)
  <span class="cf">if</span> (i <span class="op">%%</span><span class="st"> </span><span class="dv">10</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">cat</span>(<span class="st">&quot;.&quot;</span>)
  <span class="kw">download.file</span>(urls[[i]], paths[[i]])
}</code></pre>
<p>I think this for loop is suboptimal because it interleaves different concerns: pausing, showing progress, and downloading. This makes the code harder to read, and it makes it harder to reuse the components in new situations. Instead, let’s see if we can use function operators to extract out pausing and showing progress and make them reusable.</p>
<p>First, let’s write an function operator that adds a small delay. I’m going to call it <code>delay_by()</code> for reasons that will be more clear shortly, and it has two arguments: the function to wrap, and the amount of delay to add. The actual implementation is quite simple. The main trick is forcing evaluation of all arguments as described in Section <a href="#factory-pitfalls">10.2.5</a>, because function operators are a special type of function factory:</p>
<pre class="sourceCode r"><code class="sourceCode r">delay_by &lt;-<span class="st"> </span><span class="cf">function</span>(f, amount) {
  <span class="kw">force</span>(f)
  <span class="kw">force</span>(amount)
  
  <span class="cf">function</span>(...) {
    <span class="kw">Sys.sleep</span>(amount)
    <span class="kw">f</span>(...)
  }
}
<span class="kw">system.time</span>(<span class="kw">runif</span>(<span class="dv">100</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;       0       0       0</span>
<span class="kw">system.time</span>(<span class="kw">delay_by</span>(runif, <span class="fl">0.1</span>)(<span class="dv">100</span>))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;     0.0     0.0     0.1</span></code></pre>
<p>And we can use it with the original <code>walk2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">walk2</span>(urls, path, <span class="kw">delay_by</span>(download.file, <span class="fl">0.1</span>), <span class="dt">quiet =</span> <span class="ot">TRUE</span>)</code></pre>
<p>Creating a function to display the occasional dot is a little harder, because we can no longer rely on the index from the loop. We could pass the index along as another argument, but that breaks encapsulation: a concern of the progress function now becomes a problem that the higher level wrapper needs to handle. Instead, we’ll use another function factory trick (from Section <a href="#stateful-funs">10.2.4</a>), so that the progress wrapper can manage its own internal counter:</p>
<pre class="sourceCode r"><code class="sourceCode r">dot_every &lt;-<span class="st"> </span><span class="cf">function</span>(f, n) {
  <span class="kw">force</span>(f)
  <span class="kw">force</span>(n)
  
  i &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="cf">function</span>(...) {
    i &lt;&lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    <span class="cf">if</span> (i <span class="op">%%</span><span class="st"> </span>n <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">cat</span>(<span class="st">&quot;.&quot;</span>)
    <span class="kw">f</span>(...)
  }
}
<span class="kw">walk</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, runif)
<span class="kw">walk</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="kw">dot_every</span>(runif, <span class="dv">10</span>))
<span class="co">#&gt; ..........</span></code></pre>
<p>Now we can express our original for loop as:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">walk2</span>(
  urls, path, 
  <span class="kw">dot_every</span>(<span class="kw">delay_by</span>(download.file, <span class="fl">0.1</span>), <span class="dv">10</span>), 
  <span class="dt">quiet =</span> <span class="ot">TRUE</span>
)</code></pre>
<p>This is starting to get a little hard to read because we are composing many function calls, and the arguments are getting spread out. One way to resolve that is to use the pipe:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">walk2</span>(
  urls, path, 
  download.file <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">dot_every</span>(<span class="dv">10</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">delay_by</span>(<span class="fl">0.1</span>), 
  <span class="dt">quiet =</span> <span class="ot">TRUE</span>
)</code></pre>
<p>The pipe works well here because I’ve carefully chosen the function names to yield an (almost) readable sentence: take <code>download.file</code> then (add) a dot every 10 iterations, then delay by 0.1s. The more clearly you can express the intent of your code through function names, the more easily others (including future you!) can read and understand the code.</p>
<div id="exercises-37" class="section level3">
<h3><span class="header-section-number">11.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Weigh the pros and cons of
<code>download.file %&gt;% dot_every(10) %&gt;% delay_by(0.1)</code> vs
<code>download.file %&gt;% delay_by(0.1) %&gt;% dot_every(10)</code>.</p></li>
<li><p>Should you memoise <code>file.download()</code>? Why/why not?</p></li>
<li><p>Create a function operator that reports whenever a file is created or
deleted in the working directory, using <code>dir()</code> and <code>setdiff()</code>. What other
global function effects might you want to track?</p></li>
<li><p>Write a function operator that logs a timestamp and message to a file
every time a function is run.</p></li>
<li><p>Modify <code>delay_by()</code> so that instead of delaying by a fixed amount of time,
it ensures that a certain amount of time has elapsed since the function
was last called. That is, if you called
<code>g &lt;- delay_by(1, f); g(); Sys.sleep(2); g()</code> there shouldn’t be an
extra delay.</p></li>
</ol>
<!--chapter:end:Function-operators.Rmd-->
</div>
</div>
</div>
<div id="part-object-oriented-programming" class="section level1 unnumbered">
<h1><span class="header-section-number">III</span> Object oriented programming</h1>
<p></p>
</div>
<div id="oo" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>In the following five chapters you’ll learn about <strong>object oriented programming</strong> (OOP). OOP is a little more challenging in R than in other languages because:</p>
<ul>
<li><p>There are multiple OOP systems to choose from. In this book, I’ll focus
on the three that I believe are most important: <strong>S3</strong>, <strong>R6</strong>, and <strong>S4</strong>.
S3 and S4 are provided by base R. R6 is provided by the R6 package, and is
similar to the “Reference Classes”, or <strong>RC</strong> for short, from base R.</p></li>
<li><p>There is disagreement about the relative importance of the OOP systems.
I think S3 is most important, followed by R6, then S4. Others believe that
S4 is most important, followed by RC, and that S3 should be avoided. This
means that different R communities use different systems.</p></li>
<li><p>S3 and S4 use “generic function OOP” which is rather different from the
“encapsulated OOP” used by most languages popular today<span id="fn107" class="footnote" data-pagedown-footnote-number="107" style="white-space: pre-line;">The exception is Julia, which also uses generic function OOP. Compared to R, Julia’s implementation is fully developed and extremely performant.</span>. We’ll come
back to precisely what those terms mean shortly, but basically, while the
underlying ideas of OOP are the same across languages, their expressions are
rather different. This means that you can’t immediately transfer your
existing OOP skills to R.</p></li>
</ul>
<p>Generally in R, functional programming is much more important than object oriented programming, because you typically solve complex problems by decomposing them into simple functions, not simple objects. Nevertheless, there are important reasons to learn each of the three systems:</p>
<ul>
<li><p>S3 allows your functions to return rich results with user-friendly display
and programmer-friendly internals. S3 is used throughout base R, so it’s
important to master if you want to extend base R functions to work with new
types of input.</p></li>
<li><p>R6 provides a standardised way to escape R’s copy-on-modify semantics.
This is particularly important if you want to model objects that exist
independently of R. Today, a common need for R6 is to model data that comes
from a web API, and where changes come from inside or outside of R.</p></li>
<li><p>S4 is a rigorous system that forces you to think carefully about program
design. It’s particularly well-suited for building large systems that evolve
over time and will receive contributions from many programmers. This is
why it is used by the Bioconductor project, so another reason to learn S4
is in order to contribute to that project.</p></li>
</ul>
<p>The goal of this brief introductory chapter is to give you some important vocabulary and some tools to identify OOP systems in the wild. The following four chapters (Base types, S3, R6, and S4) then dive into the details of R’s OOP systems.</p>
<p>This book focusses on the mechanics of OOP, not its effective use, and it may be challenging to fully understand if you have not done object oriented programming before. You might wonder why I chose not to provide more immediately useful coverage. I have focussed on mechanics here because they need to be well described somewhere (writing these chapters required a considerable amount of reading, exploration, and synthesis on my behalf), and using OOP effectively is sufficiently complex to require book-length treatment; there’s simply not enough room in Advanced R to cover it in the depth required.</p>
<div id="oop-systems" class="section level2 unnumbered">
<h2>OOP systems</h2>
<p>Different people use OOP terms in different ways, so this section provides a quick overview of important vocabulary. The explanations are necessarily compressed, but we will come back to these ideas multiple times.</p>
<p>The main reason to use OOP is <strong>polymorphism</strong> (literally: many shapes). Polymorphism means that a developer can consider a function’s interface separately from its implementation, making it possible to use the same function form for different types of input. This is closely related to the idea of <strong>encapsulation</strong>: the user doesn’t need to worry about details of an object because they are encapsulated behind a standard interface.</p>
<p>To be concrete, polymorphism is what allows <code>summary()</code> to produce different outputs for numeric and factor variables:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds &lt;-<span class="st"> </span>ggplot2<span class="op">::</span>diamonds

<span class="kw">summary</span>(diamonds<span class="op">$</span>carat)
<span class="co">#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </span>
<span class="co">#&gt;    0.20    0.40    0.70    0.80    1.04    5.01</span>

<span class="kw">summary</span>(diamonds<span class="op">$</span>cut)
<span class="co">#&gt;      Fair      Good Very Good   Premium     Ideal </span>
<span class="co">#&gt;      1610      4906     12082     13791     21551</span></code></pre>
<p>You could imagine <code>summary()</code> containing a series of if-else statements, but that would mean only the original author could add new implementations. An OOP system makes it possible for any developer to extend the interface with implementations for new types of input.</p>
<p>To be more precise, OO systems call the “type” of an object its <strong>class</strong>, and an implementation for a specific class is called a <strong>method</strong>. Roughly speaking, a class defines what an object <em>is</em> and methods describe what that object can <em>do</em>.
The class defines the <strong>fields</strong>, the data possessed by every instance of that class. Classes are organised in a hierarchy so that if a method does not exist for one class, its parent’s method is used, and the child is said to <strong>inherit</strong> behaviour. For example, in R, an ordered factor inherits from a regular factor, and a generalised linear model inherits from a linear model. The process of finding the correct method given a class is called <strong>method dispatch</strong>.</p>
<p>There are two main paradigms of object-oriented programming which differ in how methods and classes are related. In this book, we’ll borrow the terminology of <em>Extending R</em> <span class="citation">(Chambers <a href="#ref-extending-R">2016</a>)</span> and call these paradigms encapsulated and functional:</p>
<ul>
<li><p>In <strong>encapsulated</strong> OOP, methods belong to objects or classes, and method
calls typically look like <code>object.method(arg1, arg2)</code>. This is called
encapsulated because the object encapsulates both data (with fields) and
behaviour (with methods), and is the paradigm found in most popular
languages.</p></li>
<li><p>In <strong>functional</strong> OOP, methods belong to <strong>generic</strong> functions, and method
calls look like ordinary function calls: <code>generic(object, arg2, arg3)</code>.
This is called functional because from the outside it looks like a regular
function call, and internally the components are also functions.</p></li>
</ul>
<p>With this terminology in hand, we can now talk precisely about the different OO systems available in R.</p>
</div>
<div id="oop-in-r" class="section level2 unnumbered">
<h2>OOP in R</h2>
<p>Base R provides three OOP systems: S3, S4, and reference classes (RC):</p>
<ul>
<li><p><strong>S3</strong> is R’s first OOP system, and is described in <em>Statistical Models
in S</em> <span class="citation">(Chambers and Hastie <a href="#ref-white-book">1992</a>)</span>. S3 is an informal implementation of functional OOP
and relies on common conventions rather than ironclad guarantees.
This makes it easy to get started with, providing a low cost way of
solving many simple problems.</p></li>
<li><p><strong>S4</strong> is a formal and rigorous rewrite of S3, and was introduced in
<em>Programming with Data</em> <span class="citation">(Chambers <a href="#ref-programming-with-data">1998</a>)</span>. It requires more upfront
work than S3, but in return provides more guarantees and greater
encapsulation. S4 is implemented in the base <strong>methods</strong> package, which is
always installed with R.</p>
<p>(You might wonder if S1 and S2 exist. They don’t: S3 and S4 were named
according to the versions of S that they accompanied. The first two
versions of S didn’t have any OOP framework.)</p></li>
<li><p><strong>RC</strong> implements encapsulated OO. RC objects are a special type of S4
objects that are also <strong>mutable</strong>, i.e., instead of using R’s usual
copy-on-modify semantics, they can be modified in place. This makes them
harder to reason about, but allows them to solve problems that are difficult
to solve in the functional OOP style of S3 and S4.</p></li>
</ul>
<p>A number of other OOP systems are provided by CRAN packages:</p>
<ul>
<li><p><strong>R6</strong> <span class="citation">(Chang <a href="#ref-R6">2017</a>)</span> implements encapsulated OOP like RC, but resolves some
important issues. In this book, you’ll learn about R6 instead of RC, for
reasons described in Section <a href="#why-r6">14.5</a>.</p></li>
<li><p><strong>R.oo</strong> <span class="citation">(Bengtsson <a href="#ref-R.oo">2003</a>)</span> provides some formalism on top of S3, and makes it
possible to have mutable S3 objects.</p></li>
<li><p><strong>proto</strong> <span class="citation">(Grothendieck, Kates, and Petzoldt <a href="#ref-proto">2016</a>)</span> implements another style of OOP based on the idea of
<strong>prototypes</strong>, which blur the distinctions between classes and instances
of classes (objects). I was briefly enamoured with prototype based
programming <span class="citation">(Wickham <a href="#ref-mutatr">2011</a>)</span> and used it in ggplot2, but now think it’s better to
stick with the standard forms.</p></li>
</ul>
<p>Apart from R6, which is widely used, these systems are primarily of theoretical interest. They do have their strengths, but few R users know and understand them, so it is hard for others to read and contribute to your code.</p>
</div>
<div id="sloop" class="section level2 unnumbered">
<h2>sloop</h2>
<p>Before we go on I want to introduce the sloop package:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sloop)</code></pre>
<p>The sloop package (think “sail the seas of OOP”) provides a number of helpers that fill in missing pieces in base R. The first of these is <code>sloop::otype()</code>. It makes it easy to figure out the OOP system used by a wild-caught object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">otype</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;base&quot;</span>

<span class="kw">otype</span>(mtcars)
<span class="co">#&gt; [1] &quot;S3&quot;</span>

mle_obj &lt;-<span class="st"> </span>stats4<span class="op">::</span><span class="kw">mle</span>(<span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>) (x <span class="op">-</span><span class="st"> </span><span class="dv">2</span>) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
<span class="kw">otype</span>(mle_obj)
<span class="co">#&gt; [1] &quot;S4&quot;</span></code></pre>
<p>Use this function to figure out which chapter to read to understand how to work with an existing object.</p>
<!--chapter:end:OO.Rmd-->
</div>
</div>
<div id="base-types" class="section level1">
<h1><span class="header-section-number">12</span> Base types</h1>
<div id="introduction-11" class="section level2">
<h2><span class="header-section-number">12.1</span> Introduction</h2>
<p>
</p>
<p>To talk about objects and OOP in R we first need to clear up a fundamental confusion about two uses of the word “object”. So far in this book, we’ve used the word in the general sense captured by John Chambers’ pithy quote: “Everything that exists in R is an object”. However, while everything <em>is</em> an object, not everything is “object-oriented”. This confusion arises because the base objects come from S, and were developed before anyone thought that S might need an OOP system. The tools and nomenclature evolved organically over many years without a single guiding principle.</p>
<p>Most of the time, the distinction between objects and object-oriented objects is not important. But here we need to get into the nitty gritty details so we’ll use the terms <strong>base objects</strong> and <strong>OO objects</strong> to distinguish them.</p>
<p><img src="diagrams/oo-venn.png" width="212" style="display: block; margin: auto;" /></p>
<div id="outline-10" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#base-vs-oo">12.2</a> shows you how to identify base and OO objects.</p></li>
<li><p>Section <a href="#base-types-2">12.3</a> gives a complete set of the base types that all
objects are built up from.</p></li>
</ul>
</div>
</div>
<div id="base-vs-oo" class="section level2">
<h2><span class="header-section-number">12.2</span> Base vs OO objects</h2>

<p>
</p>
<p>To tell the difference between a base and OO object, use <code>is.object()</code> or <code>sloop::otype()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A base object:</span>
<span class="kw">is.object</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; [1] FALSE</span>
sloop<span class="op">::</span><span class="kw">otype</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;base&quot;</span>

<span class="co"># An OO object</span>
<span class="kw">is.object</span>(mtcars)
<span class="co">#&gt; [1] TRUE</span>
sloop<span class="op">::</span><span class="kw">otype</span>(mtcars)
<span class="co">#&gt; [1] &quot;S3&quot;</span></code></pre>
<p>Technically, the difference between base and OO objects is that OO objects have a “class” attribute:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="st">&quot;class&quot;</span>)
<span class="co">#&gt; NULL</span>

<span class="kw">attr</span>(mtcars, <span class="st">&quot;class&quot;</span>)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre>
<p>You may already be familiar with the <code>class()</code> function. This function is safe to apply to S3 and S4 objects, but it returns misleading results when applied to base objects. It’s safer to use <code>sloop::s3_class()</code>, which returns the implicit class that the S3 and S4 systems will use to pick methods. You’ll learn more about <code>s3_class()</code> in Section <a href="#implicit-class">13.7.1</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)
<span class="kw">class</span>(x)
<span class="co">#&gt; [1] &quot;matrix&quot;</span>
sloop<span class="op">::</span><span class="kw">s3_class</span>(x)
<span class="co">#&gt; [1] &quot;matrix&quot;  &quot;integer&quot; &quot;numeric&quot;</span></code></pre>
</div>
<div id="base-types-2" class="section level2">
<h2><span class="header-section-number">12.3</span> Base types</h2>

<p></p>
<p>While only OO objects have a class attribute, every object has a <strong>base type</strong>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;integer&quot;</span>

<span class="kw">typeof</span>(mtcars)
<span class="co">#&gt; [1] &quot;list&quot;</span></code></pre>
<p>Base types do not form an OOP system because functions that behave differently for different base types are primarily written in C code that uses switch statements. This means that only R-core can create new types, and creating a new type is a lot of work because every switch statement needs to be modified to handle a new case. As a consequence, new base types are rarely added. The most recent change, in 2011, added two exotic types that you never see in R itself, but are needed for diagnosing memory problems. Prior to that, the last type added was a special base type for S4 objects added in 2005.</p>
<!-- 
https://github.com/wch/r-source/blob/f5bb85782509ddadbcec94ab7648886c2d008bda/src/main/util.c#L185-L211-->
<p>In total, there are 25 different base types. They are listed below, loosely grouped according to where they’re discussed in this book. These types are most important in C code, so you’ll often see them called by their C type names. I’ve included those in parentheses.</p>
<ul>
<li><p>Vectors, Chapter <a href="#vectors-chap">3</a>, include types <code>NULL</code> (<code>NULLSXP</code>),
<code>logical</code> (<code>LGLSXP</code>), <code>integer</code> (<code>INTSXP</code>), <code>double</code> (<code>REALSXP</code>), <code>complex</code>
(<code>CPLSXP</code>), <code>character</code> (<code>STRSXP</code>), <code>list</code> (<code>VECSXP</code>), and <code>raw</code> (<code>RAWSXP</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="ot">NULL</span>)
<span class="co">#&gt; [1] &quot;NULL&quot;</span>
<span class="kw">typeof</span>(1L)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">typeof</span>(1i)
<span class="co">#&gt; [1] &quot;complex&quot;</span></code></pre></li>
<li><p>Functions, Chapter <a href="#functions">6</a>, include types <code>closure</code> (regular R
functions, <code>CLOSXP</code>), <code>special</code> (internal functions, <code>SPECIALSXP</code>), and
<code>builtin</code> (primitive functions, <code>BUILTINSXP</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(mean)
<span class="co">#&gt; [1] &quot;closure&quot;</span>
<span class="kw">typeof</span>(<span class="st">`</span><span class="dt">[</span><span class="st">`</span>)
<span class="co">#&gt; [1] &quot;special&quot;</span>
<span class="kw">typeof</span>(sum)    
<span class="co">#&gt; [1] &quot;builtin&quot;</span></code></pre>
<p>Internal and primitive functions are described in Section
<a href="#primitive-functions">6.2.2</a>.</p></li>
<li><p>Environments, Chapter <a href="#environments">7</a>, have type <code>environment</code>
(<code>ENVSXP</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="kw">globalenv</span>())
<span class="co">#&gt; [1] &quot;environment&quot;</span></code></pre></li>
<li><p>The <code>S4</code> type (<code>S4SXP</code>), Chapter <a href="#s4">15</a>, is used for S4 classes that
don’t inherit from an existing base type.</p>
<pre class="sourceCode r"><code class="sourceCode r">mle_obj &lt;-<span class="st"> </span>stats4<span class="op">::</span><span class="kw">mle</span>(<span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>) (x <span class="op">-</span><span class="st"> </span><span class="dv">2</span>) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
<span class="kw">typeof</span>(mle_obj)
<span class="co">#&gt; [1] &quot;S4&quot;</span></code></pre></li>
<li><p>Language components, Chapter <a href="#expressions">18</a>, include <code>symbol</code> (aka
name, <code>SYMSXP</code>), <code>language</code> (usually called calls, <code>LANGSXP</code>), and
<code>pairlist</code> (used for function arguments, <code>LISTSXP</code>) types.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="kw">quote</span>(a))
<span class="co">#&gt; [1] &quot;symbol&quot;</span>
<span class="kw">typeof</span>(<span class="kw">quote</span>(a <span class="op">+</span><span class="st"> </span><span class="dv">1</span>))
<span class="co">#&gt; [1] &quot;language&quot;</span>
<span class="kw">typeof</span>(<span class="kw">formals</span>(mean))
<span class="co">#&gt; [1] &quot;pairlist&quot;</span></code></pre>
<p><code>expression</code> (<code>EXPRSXP</code>) is a special purpose type that’s only returned by
<code>parse()</code> and <code>expression()</code>. Expressions are generally not needed in user
code.</p></li>
<li><p>The remaining types are esoteric and rarely seen in R. They are important
primarily for C code: <code>externalptr</code> (<code>EXTPTRSXP</code>), <code>weakref</code> (<code>WEAKREFSXP</code>),
<code>bytecode</code> (<code>BCODESXP</code>), <code>promise</code> (<code>PROMSXP</code>), <code>...</code> (<code>DOTSXP</code>), and
<code>any</code> (<code>ANYSXP</code>).</p></li>
</ul>

<p>You may have heard of <code>mode()</code> and <code>storage.mode()</code>. Do not use these functions: they exist only to provide type names that are compatible with S.</p>
<div id="numeric-type" class="section level3">
<h3><span class="header-section-number">12.3.1</span> Numeric type</h3>
<p>
</p>
<p>Be careful when talking about the “numeric” type, because R uses “numeric” to mean three slightly different things:</p>
<ol style="list-style-type: decimal">
<li><p>In some places numeric is used as an alias for the “double” type. For
example <code>as.numeric()</code> is identical to <code>as.double()</code>, and <code>numeric()</code> is
identical to <code>double()</code>.</p>
<p>(R also occasionally uses “real” instead of double; <code>NA_real_</code> is the one
place that you’re likely to encounter this in practice.)</p></li>
<li><p>In the S3 and S4 systems, numeric is used as a shorthand for either
integer or double type, and is used when picking methods:</p>
<pre class="sourceCode r"><code class="sourceCode r">sloop<span class="op">::</span><span class="kw">s3_class</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;double&quot;  &quot;numeric&quot;</span>
sloop<span class="op">::</span><span class="kw">s3_class</span>(1L)
<span class="co">#&gt; [1] &quot;integer&quot; &quot;numeric&quot;</span></code></pre></li>
<li><p><code>is.numeric()</code> tests for objects that <em>behave</em> like numbers. For example,
factors have type “integer” but don’t behave like numbers (i.e. it doesn’t
make sense to take the mean of factor).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="kw">factor</span>(<span class="st">&quot;x&quot;</span>))
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">is.numeric</span>(<span class="kw">factor</span>(<span class="st">&quot;x&quot;</span>))
<span class="co">#&gt; [1] FALSE</span></code></pre></li>
</ol>
<p>In this book, I consistently use numeric to mean an object of type integer or double.</p>
<!--chapter:end:base-types.Rmd-->
</div>
</div>
</div>
<div id="s3" class="section level1">
<h1><span class="header-section-number">13</span> S3</h1>
<div id="introduction-12" class="section level2">
<h2><span class="header-section-number">13.1</span> Introduction</h2>
<p></p>
<p>S3 is R’s first and simplest OO system. S3 is informal and ad hoc, but there is a certain elegance in its minimalism: you can’t take away any part of it and still have a useful OO system. For these reasons, you should use it, unless you have a compelling reason to do otherwise. S3 is the only OO system used in the base and stats packages, and it’s the most commonly used system in CRAN packages.</p>
<p>S3 is very flexible, which means it allows you to do things that are quite ill-advised. If you’re coming from a strict environment like Java this will seem pretty frightening, but it gives R programmers a tremendous amount of freedom. It may be very difficult to prevent someone from doing something you don’t want them to do, but your users will never be held back because there is something you haven’t implemented yet. Since S3 has few built-in constraints, the key to its successful use is applying the constraints yourself. This chapter will therefore teach you the conventions you should (almost) always adhere to.</p>
<p>The goal of this chapter is to show you how the S3 system works, not how to use it effectively to create new classes and generics. I’d recommend coupling the theoretical knowledge from this chapter with the practical knowledge encoded in the vctrs package<span id="fn108" class="footnote" data-pagedown-footnote-number="108" style="white-space: pre-line;"><a href="https://vctrs.r-lib.org" class="uri">https://vctrs.r-lib.org</a></span>.</p>
<div id="outline-11" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#s3-basics">13.2</a> gives a rapid overview of all the main components
of S3: classes, generics, and methods. You’ll also learn about
<code>sloop::s3_dispatch()</code>, which we’ll use throughout the chapter to explore
how S3 works.</p></li>
<li><p>Section <a href="#s3-classes">13.3</a> goes into the details of creating a new S3 class,
including the three functions that should accompany most classes:
a constructor, a helper, and a validator.</p></li>
<li><p>Section <a href="#s3-methods">13.4</a> describes how S3 generics and methods work,
including the basics of method dispatch.</p></li>
<li><p>Section <a href="#object-styles">13.5</a> discusses the four main styles of S3 objects:
vector, record, data frame, and scalar.</p></li>
<li><p>Section <a href="#s3-inheritance">13.6</a> demonstrates how inheritance works in S3,
and shows you what you need to make a class “subclassable”.</p></li>
<li><p>Section <a href="#s3-dispatch">13.7</a> concludes the chapter with a discussion of the
finer details of method dispatch including base types, internal generics,
group generics, and double dispatch.</p></li>
</ul>
</div>
<div id="prerequisites-6" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>S3 classes are implemented using attributes, so make sure you’re familiar with the details described in Section <a href="#attributes">3.3</a>. We’ll use existing base S3 vectors for examples and exploration, so make sure that you’re familiar with the factor, Date, difftime, POSIXct, and POSIXlt classes described in Section <a href="#s3-atomic-vectors">3.4</a>.</p>
<p>We’ll use the sloop<span id="fn109" class="footnote" data-pagedown-footnote-number="109" style="white-space: pre-line;"><a href="https://sloop.r-lib.org" class="uri">https://sloop.r-lib.org</a></span> package for its interactive helpers.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sloop)</code></pre>
</div>
</div>
<div id="s3-basics" class="section level2">
<h2><span class="header-section-number">13.2</span> Basics</h2>
<p>

</p>
<p>An S3 object is a base type with at least a “class” attribute (other attributes may be used to store other data). For example, take the factor. Its base type is the integer vector, it has a class attribute of “factor”, and a levels attribute that stores the possible levels:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))

<span class="kw">typeof</span>(f)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">attributes</span>(f)
<span class="co">#&gt; $levels</span>
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;factor&quot;</span></code></pre>
<p>You can get the “underlying” base type by <code>unclass()</code>ing it, which strips the class attribute, causing it to lose its special behaviour:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unclass</span>(f)
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; attr(,&quot;levels&quot;)</span>
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>
</p>
<p>An S3 object behaves differently from its underlying base type whenever it’s passed to a <strong>generic</strong> (short for generic function). The easiest way to tell if a function is a generic is to use <code>sloop::ftype()</code> and look for “generic” in the output:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ftype</span>(print)
<span class="co">#&gt; [1] &quot;S3&quot;      &quot;generic&quot;</span>
<span class="kw">ftype</span>(str)
<span class="co">#&gt; [1] &quot;S3&quot;      &quot;generic&quot;</span>
<span class="kw">ftype</span>(unclass)
<span class="co">#&gt; [1] &quot;primitive&quot;</span></code></pre>
<p>A generic function defines an interface, which uses a different implementation depending on the class of an argument (almost always the first argument). Many base R functions are generic, including the important <code>print()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(f)
<span class="co">#&gt; [1] a b c</span>
<span class="co">#&gt; Levels: a b c</span>

<span class="co"># stripping class reverts to integer behaviour</span>
<span class="kw">print</span>(<span class="kw">unclass</span>(f))
<span class="co">#&gt; [1] 1 2 3</span>
<span class="co">#&gt; attr(,&quot;levels&quot;)</span>
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>Beware that <code>str()</code> is generic, and some S3 classes use that generic to hide the internal details. For example, the <code>POSIXlt</code> class used to represent date-time data is actually built on top of a list, a fact which is hidden by its <code>str()</code> method:</p>
<pre class="sourceCode r"><code class="sourceCode r">time &lt;-<span class="st"> </span><span class="kw">strptime</span>(<span class="kw">c</span>(<span class="st">&quot;2017-01-01&quot;</span>, <span class="st">&quot;2020-05-04 03:21&quot;</span>), <span class="st">&quot;%Y-%m-%d&quot;</span>)
<span class="kw">str</span>(time)
<span class="co">#&gt;  POSIXlt[1:2], format: &quot;2017-01-01&quot; &quot;2020-05-04&quot;</span>

<span class="kw">str</span>(<span class="kw">unclass</span>(time))
<span class="co">#&gt; List of 9</span>
<span class="co">#&gt;  $ sec  : num [1:2] 0 0</span>
<span class="co">#&gt;  $ min  : int [1:2] 0 0</span>
<span class="co">#&gt;  $ hour : int [1:2] 0 0</span>
<span class="co">#&gt;  $ mday : int [1:2] 1 4</span>
<span class="co">#&gt;  $ mon  : int [1:2] 0 4</span>
<span class="co">#&gt;  $ year : int [1:2] 117 120</span>
<span class="co">#&gt;  $ wday : int [1:2] 0 1</span>
<span class="co">#&gt;  $ yday : int [1:2] 0 124</span>
<span class="co">#&gt;  $ isdst: int [1:2] 0 0</span>
<span class="co">#&gt;  - attr(*, &quot;tzone&quot;)= chr &quot;UTC&quot;</span></code></pre>
<p>The generic is a middleman: its job is to define the interface (i.e. the arguments) then find the right implementation for the job. The implementation for a specific class is called a <strong>method</strong>, and the generic finds that method by performing <strong>method dispatch</strong>.</p>
<p>You can use <code>sloop::s3_dispatch()</code> to see the process of method dispatch:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(<span class="kw">print</span>(f))
<span class="co">#&gt; =&gt; print.factor</span>
<span class="co">#&gt;  * print.default</span></code></pre>
<p>
We’ll come back to the details of dispatch in Section <a href="#method-dispatch">13.4.1</a>, for now note that S3 methods are functions with a special naming scheme, <code>generic.class()</code>. For example, the <code>factor</code> method for the <code>print()</code> generic is called <code>print.factor()</code>. You should never call the method directly, but instead rely on the generic to find it for you.</p>
<p>Generally, you can identify a method by the presence of <code>.</code> in the function name, but there are a number of important functions in base R that were written before S3, and hence use <code>.</code> to join words. If you’re unsure, check with <code>sloop::ftype()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ftype</span>(t.test)
<span class="co">#&gt; [1] &quot;S3&quot;      &quot;generic&quot;</span>
<span class="kw">ftype</span>(t.data.frame)
<span class="co">#&gt; [1] &quot;S3&quot;     &quot;method&quot;</span></code></pre>
<p>
Unlike most functions, you can’t see the source code for most S3 methods<span id="fn110" class="footnote" data-pagedown-footnote-number="110" style="white-space: pre-line;">The exceptions are methods found in the base package, like <code>t.data.frame</code>, and methods that you’ve created.</span> just by typing their names. That’s because S3 methods are not usually exported: they live only inside the package, and are not available from the global environment. Instead, you can use <code>sloop::s3_get_method()</code>, which will work regardless of where the method lives:</p>
<pre class="sourceCode r"><code class="sourceCode r">weighted.mean.Date
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;weighted.mean.Date&#39; not found</span>

<span class="kw">s3_get_method</span>(weighted.mean.Date)
<span class="co">#&gt; function (x, w, ...) </span>
<span class="co">#&gt; structure(weighted.mean(unclass(x), w, ...), class = &quot;Date&quot;)</span>
<span class="co">#&gt; &lt;bytecode: 0x604b080&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:stats&gt;</span></code></pre>
<div id="exercises-38" class="section level3">
<h3><span class="header-section-number">13.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Describe the difference between <code>t.test()</code> and <code>t.data.frame()</code>?
When is each function called?</p></li>
<li><p>Make a list of commonly used base R functions that contain <code>.</code> in their
name but are not S3 methods.</p></li>
<li><p>What does the <code>as.data.frame.data.frame()</code> method do? Why is
it confusing? How could you avoid this confusion in your own
code?</p></li>
<li><p>Describe the difference in behaviour in these two calls.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1014</span>)
some_days &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;2017-01-31&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">sample</span>(<span class="dv">10</span>, <span class="dv">5</span>)

<span class="kw">mean</span>(some_days)
<span class="co">#&gt; [1] &quot;2017-02-05&quot;</span>
<span class="kw">mean</span>(<span class="kw">unclass</span>(some_days))
<span class="co">#&gt; [1] 17202</span></code></pre></li>
<li><p>What class of object does the following code return? What base type is it
built on? What attributes does it use?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">ecdf</span>(<span class="kw">rpois</span>(<span class="dv">100</span>, <span class="dv">10</span>))
x
<span class="co">#&gt; Empirical CDF </span>
<span class="co">#&gt; Call: ecdf(rpois(100, 10))</span>
<span class="co">#&gt;  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01</span></code></pre></li>
<li><p>What class of object does the following code return? What base type is it
built on? What attributes does it use?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">table</span>(<span class="kw">rpois</span>(<span class="dv">100</span>, <span class="dv">5</span>))
x
<span class="co">#&gt; </span>
<span class="co">#&gt;  1  2  3  4  5  6  7  8  9 10 </span>
<span class="co">#&gt;  8  5 18 14 12 19 12  3  5  4</span></code></pre></li>
</ol>
</div>
</div>
<div id="s3-classes" class="section level2">
<h2><span class="header-section-number">13.3</span> Classes</h2>
<p>

</p>
<p>If you have done object oriented programming in other languages, you may be surprised to learn that S3 has no formal definition of a class: to make an object an instance of a class, you simply set the <strong>class attribute</strong>. You can do that during creation with <code>structure()</code>, or after the fact with <code>class&lt;-()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create and assign class in one step</span>
x &lt;-<span class="st"> </span><span class="kw">structure</span>(<span class="kw">list</span>(), <span class="dt">class =</span> <span class="st">&quot;my_class&quot;</span>)

<span class="co"># Create, then set class</span>
x &lt;-<span class="st"> </span><span class="kw">list</span>()
<span class="kw">class</span>(x) &lt;-<span class="st"> &quot;my_class&quot;</span></code></pre>
<p>You can determine the class of an S3 object with <code>class(x)</code>, and see if an object is an instance of a class using <code>inherits(x, &quot;classname&quot;)</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(x)
<span class="co">#&gt; [1] &quot;my_class&quot;</span>
<span class="kw">inherits</span>(x, <span class="st">&quot;my_class&quot;</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">inherits</span>(x, <span class="st">&quot;your_class&quot;</span>)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>The class name can be any string, but I recommend using only letters and <code>_</code>. Avoid <code>.</code> because (as mentioned earlier) it can be confused with the <code>.</code> separator between a generic name and a class name. When using a class in a package, I recommend including the package name in the class name. That ensures you won’t accidentally clash with a class defined by another package.</p>
<p>S3 has no checks for correctness which means you can change the class of existing objects:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create a linear model</span>
mod &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(mpg) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(disp), <span class="dt">data =</span> mtcars)
<span class="kw">class</span>(mod)
<span class="co">#&gt; [1] &quot;lm&quot;</span>
<span class="kw">print</span>(mod)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = log(mpg) ~ log(disp), data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)    log(disp)  </span>
<span class="co">#&gt;       5.381       -0.459</span>

<span class="co"># Turn it into a date (?!)</span>
<span class="kw">class</span>(mod) &lt;-<span class="st"> &quot;Date&quot;</span>

<span class="co"># Unsurprisingly this doesn&#39;t work very well</span>
<span class="kw">print</span>(mod)
<span class="co">#&gt; Error in as.POSIXlt.Date(x):</span>
<span class="co">#&gt;   (list) object cannot be coerced to type &#39;double&#39;</span></code></pre>
<p>If you’ve used other OO languages, this might make you feel queasy, but in practice this flexibility causes few problems. R doesn’t stop you from shooting yourself in the foot, but as long as you don’t aim the gun at your toes and pull the trigger, you won’t have a problem.</p>
<p>To avoid foot-bullet intersections when creating your own class, I recommend that you usually provide three functions:</p>
<ul>
<li><p>A low-level <strong>constructor</strong>, <code>new_myclass()</code>, that efficiently creates new
objects with the correct structure.</p></li>
<li><p>A <strong>validator</strong>, <code>validate_myclass()</code>, that performs more expensive checks to
ensure that the object has correct values.</p></li>
<li><p>A user-friendly <strong>helper</strong>, <code>myclass()</code>, that provides a convenient way for
others to create objects of your class.</p></li>
</ul>
<p>You don’t need a validator for very simple classes, and you can skip the helper if the class is for internal use only, but you should always provide a constructor.</p>
<div id="s3-constructor" class="section level3">
<h3><span class="header-section-number">13.3.1</span> Constructors</h3>
<p>
</p>
<p>S3 doesn’t provide a formal definition of a class, so it has no built-in way to ensure that all objects of a given class have the same structure (i.e. the same base type and the same attributes with the same types). Instead, you must enforce a consistent structure yourself by using a <strong>constructor</strong>.</p>
<p>The constructor should follow three principles:</p>
<ul>
<li><p>Be called <code>new_myclass()</code>.</p></li>
<li><p>Have one argument for the base object, and one for each attribute.</p></li>
<li><p>Check the type of the base object and the types of each attribute.</p></li>
</ul>
<p>I’ll illustrate these ideas by creating constructors for base classes<span id="fn111" class="footnote" data-pagedown-footnote-number="111" style="white-space: pre-line;">Recent versions of R have <code>.Date()</code>, <code>.difftime()</code>, <code>.POSIXct()</code>, and <code>.POSIXlt()</code> constructors but they are internal, not well documented, and do not follow the principles that I recommend.</span> that you’re already familiar with. To start, lets make a constructor for the simplest S3 class: <code>Date</code>. A <code>Date</code> is just a double with a “Date” class attribute, and no additional attributes. This makes for a very simple constructor:</p>

<pre class="sourceCode r"><code class="sourceCode r">new_Date &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">double</span>()) {
  <span class="kw">stopifnot</span>(<span class="kw">is.double</span>(x))
  <span class="kw">structure</span>(x, <span class="dt">class =</span> <span class="st">&quot;Date&quot;</span>)
}

<span class="kw">new_Date</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>))
<span class="co">#&gt; [1] &quot;1969-12-31&quot; &quot;1970-01-01&quot; &quot;1970-01-02&quot;</span></code></pre>
<p>The purpose of constructors is to help you, the developer. That means you can keep them simple, and you don’t need to optimise error messages for public consumption. If you expect users to also create objects, you should create a friendly helper function, called <code>class_name()</code>, which I’ll describe shortly.</p>
<p>A slightly more complicated constructor is that for <code>difftime</code>, which is used to represent time differences. It is again built on a double, but has a units attribute that must take one of a small set of values:</p>

<pre class="sourceCode r"><code class="sourceCode r">new_difftime &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">double</span>(), <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>) {
  <span class="kw">stopifnot</span>(<span class="kw">is.double</span>(x))
  units &lt;-<span class="st"> </span><span class="kw">match.arg</span>(units, <span class="kw">c</span>(<span class="st">&quot;secs&quot;</span>, <span class="st">&quot;mins&quot;</span>, <span class="st">&quot;hours&quot;</span>, <span class="st">&quot;days&quot;</span>, <span class="st">&quot;weeks&quot;</span>))

  <span class="kw">structure</span>(x,
    <span class="dt">class =</span> <span class="st">&quot;difftime&quot;</span>,
    <span class="dt">units =</span> units
  )
}

<span class="kw">new_difftime</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">3600</span>), <span class="st">&quot;secs&quot;</span>)
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt; [1]    1   10 3600</span>
<span class="kw">new_difftime</span>(<span class="dv">52</span>, <span class="st">&quot;weeks&quot;</span>)
<span class="co">#&gt; Time difference of 52 weeks</span></code></pre>
<p>The constructor is a developer function: it will be called in many places, by an experienced user. That means it’s ok to trade a little safety in return for performance, and you should avoid potentially time-consuming checks in the constructor.</p>
</div>
<div id="validators" class="section level3">
<h3><span class="header-section-number">13.3.2</span> Validators</h3>
<p>
</p>
<p>More complicated classes require more complicated checks for validity. Take factors, for example. A constructor only checks that types are correct, making it possible to create malformed factors:</p>

<pre class="sourceCode r"><code class="sourceCode r">new_factor &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">integer</span>(), <span class="dt">levels =</span> <span class="kw">character</span>()) {
  <span class="kw">stopifnot</span>(<span class="kw">is.integer</span>(x))
  <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(levels))

  <span class="kw">structure</span>(
    x,
    <span class="dt">levels =</span> levels,
    <span class="dt">class =</span> <span class="st">&quot;factor&quot;</span>
  )
}

<span class="kw">new_factor</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="st">&quot;a&quot;</span>)
<span class="co">#&gt; Error in as.character.factor(x):</span>
<span class="co">#&gt;   malformed factor</span>
<span class="kw">new_factor</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>, <span class="st">&quot;a&quot;</span>)
<span class="co">#&gt; Error in as.character.factor(x):</span>
<span class="co">#&gt;   malformed factor</span></code></pre>
<p>Rather than encumbering the constructor with complicated checks, it’s better to put them in a separate function. Doing so allows you to cheaply create new objects when you know that the values are correct, and easily re-use the checks in other places.</p>
<pre class="sourceCode r"><code class="sourceCode r">validate_factor &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  values &lt;-<span class="st"> </span><span class="kw">unclass</span>(x)
  levels &lt;-<span class="st"> </span><span class="kw">attr</span>(x, <span class="st">&quot;levels&quot;</span>)

  <span class="cf">if</span> (<span class="op">!</span><span class="kw">all</span>(<span class="op">!</span><span class="kw">is.na</span>(values) <span class="op">&amp;</span><span class="st"> </span>values <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)) {
    <span class="kw">stop</span>(
      <span class="st">&quot;All `x` values must be non-missing and greater than zero&quot;</span>,
      <span class="dt">call. =</span> <span class="ot">FALSE</span>
    )
  }

  <span class="cf">if</span> (<span class="kw">length</span>(levels) <span class="op">&lt;</span><span class="st"> </span><span class="kw">max</span>(values)) {
    <span class="kw">stop</span>(
      <span class="st">&quot;There must at least as many `levels` as possible values in `x`&quot;</span>,
      <span class="dt">call. =</span> <span class="ot">FALSE</span>
    )
  }

  x
}

<span class="kw">validate_factor</span>(<span class="kw">new_factor</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="st">&quot;a&quot;</span>))
<span class="co">#&gt; Error: There must at least as many `levels` as possible values in `x`</span>
<span class="kw">validate_factor</span>(<span class="kw">new_factor</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">1</span>, <span class="st">&quot;a&quot;</span>))
<span class="co">#&gt; Error: All `x` values must be non-missing and greater than zero</span></code></pre>
<p>This validator function is called primarily for its side-effects (throwing an error if the object is invalid) so you’d expect it to invisibly return its primary input (as described in Section <a href="#invisible">6.7.2</a>). However, it’s useful for validation methods to return visibly, as we’ll see next.</p>
</div>
<div id="helpers" class="section level3">
<h3><span class="header-section-number">13.3.3</span> Helpers</h3>
<p>
</p>
<p>If you want users to construct objects from your class, you should also provide a helper method that makes their life as easy as possible. A helper should always:</p>
<ul>
<li><p>Have the same name as the class, e.g. <code>myclass()</code>.</p></li>
<li><p>Finish by calling the constructor, and the validator, if it exists.</p></li>
<li><p>Create carefully crafted error messages tailored towards an end-user.</p></li>
<li><p>Have a thoughtfully crafted user interface with carefully chosen default
values and useful conversions.</p></li>
</ul>
<p>The last bullet is the trickiest, and it’s hard to give general advice. However, there are three common patterns:</p>
<ul>
<li><p>Sometimes all the helper needs to do is coerce its inputs to the desired
type. For example, <code>new_difftime()</code> is very strict, and violates the usual
convention that you can use an integer vector wherever you can use a
double vector:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">new_difftime</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; Error in new_difftime(1:10):</span>
<span class="co">#&gt;   is.double(x) is not TRUE</span></code></pre>
<p>It’s not the job of the constructor to be flexible, so here we create
a helper that just coerces the input to a double.</p>
<pre class="sourceCode r"><code class="sourceCode r">difftime &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">double</span>(), <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>) {
  x &lt;-<span class="st"> </span><span class="kw">as.double</span>(x)
  <span class="kw">new_difftime</span>(x, <span class="dt">units =</span> units)
}

<span class="kw">difftime</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</span></code></pre></li>
<li><p>Often, the most natural representation of a complex object is a string.
For example, it’s very convenient to specify factors with a character
vector. The code below shows a simple version of <code>factor()</code>: it takes a
character vector, and guesses that the levels should be the unique values.
This is not always correct (since some levels might not be seen in the
data), but it’s a useful default.</p>
<pre class="sourceCode r"><code class="sourceCode r">factor &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">character</span>(), <span class="dt">levels =</span> <span class="kw">unique</span>(x)) {
  ind &lt;-<span class="st"> </span><span class="kw">match</span>(x, levels)
  <span class="kw">validate_factor</span>(<span class="kw">new_factor</span>(ind, levels))
}

<span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))
<span class="co">#&gt; [1] a a b</span>
<span class="co">#&gt; Levels: a b</span></code></pre></li>
<li><p>Some complex objects are most naturally specified by multiple simple<br />
components. For example, I think it’s natural to construct a date-time
by supplying the individual components (year, month, day etc). That leads
me to this <code>POSIXct()</code> helper that resembles the existing <code>ISODatetime()</code>
function<span id="fn112" class="footnote" data-pagedown-footnote-number="112" style="white-space: pre-line;">This helper is not efficient: behind the scenes <code>ISODatetime()</code> works by pasting the components into a string and then using <code>strptime()</code>. A more efficient equivalent is available in <code>lubridate::make_datetime()</code>.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r">POSIXct &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">year =</span> <span class="kw">integer</span>(), 
                    <span class="dt">month =</span> <span class="kw">integer</span>(), 
                    <span class="dt">day =</span> <span class="kw">integer</span>(), 
                    <span class="dt">hour =</span> 0L, 
                    <span class="dt">minute =</span> 0L, 
                    <span class="dt">sec =</span> <span class="dv">0</span>, 
                    <span class="dt">tzone =</span> <span class="st">&quot;&quot;</span>) {
  <span class="kw">ISOdatetime</span>(year, month, day, hour, minute, sec, <span class="dt">tz =</span> tzone)
}

<span class="kw">POSIXct</span>(<span class="dv">2020</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dt">tzone =</span> <span class="st">&quot;America/New_York&quot;</span>)
<span class="co">#&gt; [1] &quot;2020-01-01 EST&quot;</span></code></pre></li>
</ul>
<p>For more complicated classes, you should feel free to go beyond these patterns to make life as easy as possible for your users.</p>
</div>
<div id="exercises-39" class="section level3">
<h3><span class="header-section-number">13.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Write a constructor for <code>data.frame</code> objects. What base type is a data
frame built on? What attributes does it use? What are the restrictions
placed on the individual elements? What about the names?</p></li>
<li><p>Enhance my <code>factor()</code> helper to have better behaviour when one or
more <code>values</code> is not found in <code>levels</code>. What does <code>base::factor()</code> do
in this situation?</p></li>
<li><p>Carefully read the source code of <code>factor()</code>. What does it do that
my constructor does not?</p></li>
<li><p>Factors have an optional “contrasts” attribute. Read the help for <code>C()</code>,
and briefly describe the purpose of the attribute. What type should it
have? Rewrite the <code>new_factor()</code> constructor to include this attribute.</p></li>
<li><p>Read the documentation for <code>utils::as.roman()</code>. How would you write a
constructor for this class? Does it need a validator? What might a helper
do?</p></li>
</ol>
</div>
</div>
<div id="s3-methods" class="section level2">
<h2><span class="header-section-number">13.4</span> Generics and methods</h2>

<p>
</p>
<p>The job of an S3 generic is to perform method dispatch, i.e. find the specific implementation for a class. Method dispatch is performed by <code>UseMethod()</code>, which every generic calls<span id="fn113" class="footnote" data-pagedown-footnote-number="113" style="white-space: pre-line;">The exception is internal generics, which are implemented in C, and are the topic of Section <a href="#internal-generics">13.7.2</a>.</span>. <code>UseMethod()</code> takes two arguments: the name of the generic function (required), and the argument to use for method dispatch (optional). If you omit the second argument, it will dispatch based on the first argument, which is almost always what is desired.</p>
<p>Most generics are very simple, and consist of only a call to <code>UseMethod()</code>. Take <code>mean()</code> for example:</p>
<pre class="sourceCode r"><code class="sourceCode r">mean
<span class="co">#&gt; function (x, ...) </span>
<span class="co">#&gt; UseMethod(&quot;mean&quot;)</span>
<span class="co">#&gt; &lt;bytecode: 0x267d858&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span></code></pre>
<p>Creating your own generic is similarly simple:</p>
<pre class="sourceCode r"><code class="sourceCode r">my_new_generic &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">UseMethod</span>(<span class="st">&quot;my_new_generic&quot;</span>)
}</code></pre>
<p>(If you wonder why we have to repeat <code>my_new_generic</code> twice, think back to Section <a href="#first-class-functions">6.2.3</a>.)</p>
<p>You don’t pass any of the arguments of the generic to <code>UseMethod()</code>; it uses deep magic to pass to the method automatically. The precise process is complicated and frequently surprising, so you should avoid doing any computation in a generic. To learn the full details, carefully read the “technical details” section in <code>?UseMethod</code>.</p>
<div id="method-dispatch" class="section level3">
<h3><span class="header-section-number">13.4.1</span> Method dispatch</h3>
<p>
</p>
<p>How does <code>UseMethod()</code> work? It basically creates a vector of method names, <code>paste0(&quot;generic&quot;, &quot;.&quot;, c(class(x), &quot;default&quot;))</code>, and then looks for each potential method in turn. We can see this in action with <code>sloop::s3_dispatch()</code>. You give it a call to an S3 generic, and it lists all the possible methods. For example, what method is called when you print a <code>Date</code> object?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">Sys.Date</span>()
<span class="kw">s3_dispatch</span>(<span class="kw">print</span>(x))
<span class="co">#&gt; =&gt; print.Date</span>
<span class="co">#&gt;  * print.default</span></code></pre>
<p>The output here is simple:</p>
<ul>
<li><code>=&gt;</code> indicates the method that is called, here <code>print.Date()</code></li>
<li><code>*</code> indicates a method that is defined, but not called, here <code>print.default()</code>.</li>
</ul>
<p>The “default” class is a special <strong>pseudo-class</strong>. This is not a real class, but is included to make it possible to define a standard fallback that is found whenever a class-specific method is not available.</p>
<p>The essence of method dispatch is quite simple, but as the chapter proceeds you’ll see it get progressively more complicated to encompass inheritance, base types, internal generics, and group generics. The code below shows a couple of more complicated cases which we’ll come back to in Sections <a href="#inheritance">14.2.4</a> and <a href="#s3-dispatch">13.7</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)
<span class="kw">s3_dispatch</span>(<span class="kw">mean</span>(x))
<span class="co">#&gt;    mean.matrix</span>
<span class="co">#&gt;    mean.integer</span>
<span class="co">#&gt;    mean.numeric</span>
<span class="co">#&gt; =&gt; mean.default</span>

<span class="kw">s3_dispatch</span>(<span class="kw">sum</span>(<span class="kw">Sys.time</span>()))
<span class="co">#&gt;    sum.POSIXct</span>
<span class="co">#&gt;    sum.POSIXt</span>
<span class="co">#&gt;    sum.default</span>
<span class="co">#&gt; =&gt; Summary.POSIXct</span>
<span class="co">#&gt;    Summary.POSIXt</span>
<span class="co">#&gt;    Summary.default</span>
<span class="co">#&gt; -&gt; sum (internal)</span></code></pre>
</div>
<div id="finding-methods" class="section level3">
<h3><span class="header-section-number">13.4.2</span> Finding methods</h3>
<p></p>
<p><code>sloop::s3_dispatch()</code> lets you find the specific method used for a single call. What if you want to find all methods defined for a generic or associated with a class? That’s the job of <code>sloop::s3_methods_generic()</code> and <code>sloop::s3_methods_class()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_methods_generic</span>(<span class="st">&quot;mean&quot;</span>)
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   generic class visible source             </span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;lgl&gt;   &lt;chr&gt;              </span>
<span class="co">#&gt; 1 mean    1     TRUE    base               </span>
<span class="co">#&gt; 2 mean    2     TRUE    base               </span>
<span class="co">#&gt; 3 mean    3     TRUE    base               </span>
<span class="co">#&gt; 4 mean    4     TRUE    base               </span>
<span class="co">#&gt; 5 mean    5     TRUE    base               </span>
<span class="co">#&gt; 6 mean    6     FALSE   registered S3method</span>

<span class="kw">s3_methods_class</span>(<span class="st">&quot;ordered&quot;</span>)
<span class="co">#&gt; # A tibble: 4 x 4</span>
<span class="co">#&gt;   generic       class   visible source             </span>
<span class="co">#&gt;   &lt;chr&gt;         &lt;chr&gt;   &lt;lgl&gt;   &lt;chr&gt;              </span>
<span class="co">#&gt; 1 as.data.frame ordered TRUE    base               </span>
<span class="co">#&gt; 2 Ops           ordered TRUE    base               </span>
<span class="co">#&gt; 3 relevel       ordered FALSE   registered S3method</span>
<span class="co">#&gt; 4 Summary       ordered TRUE    base</span></code></pre>
</div>
<div id="s3-arguments" class="section level3">
<h3><span class="header-section-number">13.4.3</span> Creating methods</h3>
<p>
</p>
<p>There are two wrinkles to be aware of when you create a new method:</p>
<ul>
<li><p>First, you should only ever write a method if you own the generic or the
class. R will allow you to define a method even if you don’t, but it is
exceedingly bad manners. Instead, work with the author of either the
generic or the class to add the method in their code.</p></li>
<li><p>A method must have the same arguments as its generic. This is enforced in
packages by <code>R CMD check</code>, but it’s good practice even if you’re not
creating a package.</p>
<p>There is one exception to this rule: if the generic has <code>...</code>, the method
can contain a superset of the arguments. This allows methods to take
arbitrary additional arguments. The downside of using <code>...</code>, however, is
that any misspelled arguments will be silently swallowed<span id="fn114" class="footnote" data-pagedown-footnote-number="114" style="white-space: pre-line;">See <a href="https://github.com/hadley/ellipsis" class="uri">https://github.com/hadley/ellipsis</a> for an experimental way of warning when methods fail to use all the arguments in <code>...</code>, providing a potential resolution of this issue.</span>,
as mentioned in Section <a href="#fun-dot-dot-dot">6.6</a>.</p></li>
</ul>
</div>
<div id="exercises-40" class="section level3">
<h3><span class="header-section-number">13.4.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Read the source code for <code>t()</code> and <code>t.test()</code> and confirm that
<code>t.test()</code> is an S3 generic and not an S3 method. What happens if
you create an object with class <code>test</code> and call <code>t()</code> with it? Why?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">structure</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">class =</span> <span class="st">&quot;test&quot;</span>)
<span class="kw">t</span>(x)</code></pre></li>
<li><p>What generics does the <code>table</code> class have methods for?</p></li>
<li><p>What generics does the <code>ecdf</code> class have methods for?</p></li>
<li><p>Which base generic has the greatest number of defined methods?</p></li>
<li><p>Carefully read the documentation for <code>UseMethod()</code> and explain why the
following code returns the results that it does. What two usual rules
of function evaluation does <code>UseMethod()</code> violate?</p>
<pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  x &lt;-<span class="st"> </span><span class="dv">10</span>
  y &lt;-<span class="st"> </span><span class="dv">10</span>
  <span class="kw">UseMethod</span>(<span class="st">&quot;g&quot;</span>)
}
g.default &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">c</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)

x &lt;-<span class="st"> </span><span class="dv">1</span>
y &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">g</span>(x)
<span class="co">#&gt;  x  y </span>
<span class="co">#&gt;  1 10</span></code></pre></li>
<li><p>What are the arguments to <code>[</code>? Why is this a hard question to answer?</p></li>
</ol>
</div>
</div>
<div id="object-styles" class="section level2">
<h2><span class="header-section-number">13.5</span> Object styles</h2>
<p></p>
<p>So far I’ve focussed on “vector style” classes like <code>Date</code> and <code>factor</code>. These have the key property that <code>length(x)</code> represents the number of observations in the vector. There are three variants that do not have this property:</p>
<ul>
<li><p>“Record style” objects use a list of equal-length vectors to represent
individual components of the object. The best example of this is <code>POSIXlt</code>,
which underneath the hood is a list of 11 date-time components like year,
month, and day. Record style classes override <code>length()</code> and subsetting
methods to conceal this implementation detail.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">as.POSIXlt</span>(<span class="kw">ISOdatetime</span>(<span class="dv">2020</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>))
x
<span class="co">#&gt; [1] &quot;2020-01-01 00:00:01 UTC&quot; &quot;2020-01-01 00:00:02 UTC&quot;</span>
<span class="co">#&gt; [3] &quot;2020-01-01 00:00:03 UTC&quot;</span>

<span class="kw">length</span>(x)
<span class="co">#&gt; [1] 3</span>
<span class="kw">length</span>(<span class="kw">unclass</span>(x))
<span class="co">#&gt; [1] 9</span>

x[[<span class="dv">1</span>]] <span class="co"># the first date time</span>
<span class="co">#&gt; [1] &quot;2020-01-01 00:00:01 UTC&quot;</span>
<span class="kw">unclass</span>(x)[[<span class="dv">1</span>]] <span class="co"># the first component, the number of seconds</span>
<span class="co">#&gt; [1] 1 2 3</span></code></pre></li>
<li><p>Data frames are similar to record style objects in that both use lists of
equal length vectors. However, data frames are conceptually two dimensional,
and the individual components are readily exposed to the user. The number of
observations is the number of rows, not the length:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">100</span>)
<span class="kw">length</span>(x)
<span class="co">#&gt; [1] 2</span>
<span class="kw">nrow</span>(x)
<span class="co">#&gt; [1] 100</span></code></pre></li>
<li><p>Scalar objects typically use a list to represent a single “thing”.
For example, an <code>lm</code> object is a list of length 12 but it represents one
model.</p>
<pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> mtcars)
<span class="kw">length</span>(mod)
<span class="co">#&gt; [1] 12</span></code></pre>
<p>Scalar objects can also be built on top of functions, calls, and
environments<span id="fn115" class="footnote" data-pagedown-footnote-number="115" style="white-space: pre-line;">You can also build an object on top of a pairlist, but I have yet to find a good reason to do so.</span>. This is less generally useful, but you can see
applications in <code>stats::ecdf()</code>, R6 (Chapter <a href="#r6">14</a>), and
<code>rlang::quo()</code> (Chapter <a href="#quasiquotation">19</a>).
</p></li>
</ul>
<p>Unfortunately, describing the appropriate use of each of these object styles is beyond the scope of this book. However, you can learn more from the documentation of the vctrs package (<a href="https://vctrs.r-lib.org" class="uri">https://vctrs.r-lib.org</a>); the package also provides constructors and helper that make implementation of the different styles easier.</p>
<div id="exercises-41" class="section level3">
<h3><span class="header-section-number">13.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Categorise the objects returned by <code>lm()</code>, <code>factor()</code>, <code>table()</code>,
<code>as.Date()</code>, <code>as.POSIXct()</code> <code>ecdf()</code>, <code>ordered()</code>, <code>I()</code> into the
styles described above.</p></li>
<li><p>What would a constructor function for <code>lm</code> objects, <code>new_lm()</code>, look like?
Use <code>?lm</code> and experimentation to figure out the required fields and their
types.</p></li>
</ol>
</div>
</div>
<div id="s3-inheritance" class="section level2">
<h2><span class="header-section-number">13.6</span> Inheritance</h2>
<p>

</p>
<p>S3 classes can share behaviour through a mechanism called <strong>inheritance</strong>. Inheritance is powered by three ideas:</p>
<ul>
<li><p>The class can be a character <em>vector</em>. For example, the <code>ordered</code> and
<code>POSIXct</code> classes have two components in their class:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw">ordered</span>(<span class="st">&quot;x&quot;</span>))
<span class="co">#&gt; [1] &quot;ordered&quot; &quot;factor&quot;</span>
<span class="kw">class</span>(<span class="kw">Sys.time</span>())
<span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</span></code></pre></li>
<li><p>If a method is not found for the class in the first element of the
vector, R looks for a method for the second class (and so on):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(<span class="kw">print</span>(<span class="kw">ordered</span>(<span class="st">&quot;x&quot;</span>)))
<span class="co">#&gt;    print.ordered</span>
<span class="co">#&gt; =&gt; print.factor</span>
<span class="co">#&gt;  * print.default</span>
<span class="kw">s3_dispatch</span>(<span class="kw">print</span>(<span class="kw">Sys.time</span>()))
<span class="co">#&gt; =&gt; print.POSIXct</span>
<span class="co">#&gt;    print.POSIXt</span>
<span class="co">#&gt;  * print.default</span></code></pre></li>
<li><p>A method can delegate work by calling <code>NextMethod()</code>. We’ll come back to
that very shortly; for now, note that <code>s3_dispatch()</code> reports delegation
with <code>-&gt;</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(<span class="kw">ordered</span>(<span class="st">&quot;x&quot;</span>)[<span class="dv">1</span>])
<span class="co">#&gt;    [.ordered</span>
<span class="co">#&gt; =&gt; [.factor</span>
<span class="co">#&gt;    [.default</span>
<span class="co">#&gt; -&gt; [ (internal)</span>
<span class="kw">s3_dispatch</span>(<span class="kw">Sys.time</span>()[<span class="dv">1</span>])
<span class="co">#&gt; =&gt; [.POSIXct</span>
<span class="co">#&gt;    [.POSIXt</span>
<span class="co">#&gt;    [.default</span>
<span class="co">#&gt; -&gt; [ (internal)</span></code></pre></li>
</ul>
<p>Before we continue we need a bit of vocabulary to describe the relationship between the classes that appear together in a class vector. We’ll say that <code>ordered</code> is a <strong>subclass</strong> of <code>factor</code> because it always appears before it in the class vector, and, conversely, we’ll say <code>factor</code> is a <strong>superclass</strong> of <code>ordered</code>.</p>
<p>S3 imposes no restrictions on the relationship between sub- and superclasses but your life will be easier if you impose some yourself. I recommend that you adhere to two simple principles when creating a subclass:</p>
<ul>
<li><p>The base type of the subclass should be that same as the superclass.</p></li>
<li><p>The attributes of the subclass should be a superset of the attributes
of the superclass.</p></li>
</ul>
<p><code>POSIXt</code> does not adhere to these principles because <code>POSIXct</code> has type double, and <code>POSIXlt</code> has type list. This means that <code>POSIXt</code> is not a superclass, and illustrates that it’s quite possible to use the S3 inheritance system to implement other styles of code sharing (here <code>POSIXt</code> plays a role more like an interface), but you’ll need to figure out safe conventions yourself.
</p>
<div id="nextmethod" class="section level3">
<h3><span class="header-section-number">13.6.1</span> <code>NextMethod()</code></h3>

<p><code>NextMethod()</code> is the hardest part of inheritance to understand, so we’ll start with a concrete example for the most common use case: <code>[</code>. We’ll start by creating a simple toy class: a <code>secret</code> class that hides its output when printed:</p>
<pre class="sourceCode r"><code class="sourceCode r">new_secret &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="kw">double</span>()) {
  <span class="kw">stopifnot</span>(<span class="kw">is.double</span>(x))
  <span class="kw">structure</span>(x, <span class="dt">class =</span> <span class="st">&quot;secret&quot;</span>)
}

print.secret &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  <span class="kw">print</span>(<span class="kw">strrep</span>(<span class="st">&quot;x&quot;</span>, <span class="kw">nchar</span>(x)))
  <span class="kw">invisible</span>(x)
}

x &lt;-<span class="st"> </span><span class="kw">new_secret</span>(<span class="kw">c</span>(<span class="dv">15</span>, <span class="dv">1</span>, <span class="dv">456</span>))
x
<span class="co">#&gt; [1] &quot;xx&quot;  &quot;x&quot;   &quot;xxx&quot;</span></code></pre>
<p>This works, but the default <code>[</code> method doesn’t preserve the class:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(x[<span class="dv">1</span>])
<span class="co">#&gt;    [.secret</span>
<span class="co">#&gt;    [.default</span>
<span class="co">#&gt; =&gt; [ (internal)</span>
x[<span class="dv">1</span>]
<span class="co">#&gt; [1] 15</span></code></pre>
<p>To fix this, we need to provide a <code>[.secret</code> method. How could we implement this method? The naive approach won’t work because we’ll get stuck in an infinite loop:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">[.secret</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, i) {
  <span class="kw">new_secret</span>(x[i])
}</code></pre>
<p>Instead, we need some way to call the underlying <code>[</code> code, i.e. the implementation that would get called if we didn’t have a <code>[.secret</code> method. One approach would be to <code>unclass()</code> the object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">[.secret</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, i) {
  x &lt;-<span class="st"> </span><span class="kw">unclass</span>(x)
  <span class="kw">new_secret</span>(x[i])
}
x[<span class="dv">1</span>]
<span class="co">#&gt; [1] &quot;xx&quot;</span></code></pre>
<p>This works, but is inefficient because it creates a copy of <code>x</code>. A better approach is to use <code>NextMethod()</code>, which concisely solves the problem delegating to the method that would’ve have been called if <code>[.secret</code> didn’t exist:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">[.secret</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, i) {
  <span class="kw">new_secret</span>(<span class="kw">NextMethod</span>())
}
x[<span class="dv">1</span>]
<span class="co">#&gt; [1] &quot;xx&quot;</span></code></pre>
<p>We can see what’s going on with <code>sloop::s3_dispatch()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(x[<span class="dv">1</span>])
<span class="co">#&gt; =&gt; [.secret</span>
<span class="co">#&gt;    [.default</span>
<span class="co">#&gt; -&gt; [ (internal)</span></code></pre>
<p>The <code>=&gt;</code> indicates that <code>[.secret</code> is called, but that <code>NextMethod()</code> delegates work to the underlying internal <code>[</code> method, as shown by the <code>-&gt;</code>.</p>
<p>As with <code>UseMethod()</code>, the precise semantics of <code>NextMethod()</code> are complex. In particular, it tracks the list of potential next methods with a special variable, which means that modifying the object that’s being dispatched upon will have no impact on which method gets called next.</p>
</div>
<div id="s3-subclassing" class="section level3">
<h3><span class="header-section-number">13.6.2</span> Allowing subclassing</h3>
<p></p>
<p>When you create a class, you need to decide if you want to allow subclasses, because it requires some changes to the constructor and careful thought in your methods.</p>
<p>To allow subclasses, the parent constructor needs to have <code>...</code> and <code>class</code> arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r">new_secret &lt;-<span class="st"> </span><span class="cf">function</span>(x, ..., <span class="dt">class =</span> <span class="kw">character</span>()) {
  <span class="kw">stopifnot</span>(<span class="kw">is.double</span>(x))

  <span class="kw">structure</span>(
    x,
    ...,
    <span class="dt">class =</span> <span class="kw">c</span>(class, <span class="st">&quot;secret&quot;</span>)
  )
}</code></pre>
<p>Then the subclass constructor can just call to the parent class constructor with additional arguments as needed. For example, imagine we want to create a supersecret class which also hides the number of characters:</p>
<pre class="sourceCode r"><code class="sourceCode r">new_supersecret &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">new_secret</span>(x, <span class="dt">class =</span> <span class="st">&quot;supersecret&quot;</span>)
}

print.supersecret &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  <span class="kw">print</span>(<span class="kw">rep</span>(<span class="st">&quot;xxxxx&quot;</span>, <span class="kw">length</span>(x)))
  <span class="kw">invisible</span>(x)
}

x2 &lt;-<span class="st"> </span><span class="kw">new_supersecret</span>(<span class="kw">c</span>(<span class="dv">15</span>, <span class="dv">1</span>, <span class="dv">456</span>))
x2
<span class="co">#&gt; [1] &quot;xxxxx&quot; &quot;xxxxx&quot; &quot;xxxxx&quot;</span></code></pre>
<p>To allow inheritance, you also need to think carefully about your methods, as you can no longer use the constructor. If you do, the method will always return the same class, regardless of the input. This forces whoever makes a subclass to do a lot of extra work.</p>
<p>Concretely, this means we need to revise the <code>[.secret</code> method. Currently it always returns a <code>secret()</code>, even when given a supersecret:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">[.secret</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  <span class="kw">new_secret</span>(<span class="kw">NextMethod</span>())
}

x2[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]
<span class="co">#&gt; [1] &quot;xx&quot;  &quot;x&quot;   &quot;xxx&quot;</span></code></pre>

<p>We want to make sure that <code>[.secret</code> returns the same class as <code>x</code> even if it’s a subclass. As far as I can tell, there is no way to solve this problem using base R alone. Instead, you’ll need to use the vctrs package, which provides a solution in the form of the <code>vctrs::vec_restore()</code> generic. This generic takes two inputs: an object which has lost subclass information, and a template object to use for restoration.</p>
<p>Typically <code>vec_restore()</code> methods are quite simple: you just call the constructor with appropriate arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r">vec_restore.secret &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) <span class="kw">new_secret</span>(x)
vec_restore.supersecret &lt;-<span class="st"> </span><span class="cf">function</span>(x, to) <span class="kw">new_supersecret</span>(x)</code></pre>
<p>(If your class has attributes, you’ll need to pass them from <code>to</code> into the constructor.)</p>
<p>Now we can use <code>vec_restore()</code> in the <code>[.secret</code> method:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">[.secret</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  vctrs<span class="op">::</span><span class="kw">vec_restore</span>(<span class="kw">NextMethod</span>(), x)
}
x2[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]
<span class="co">#&gt; [1] &quot;xxxxx&quot; &quot;xxxxx&quot; &quot;xxxxx&quot;</span></code></pre>
<p>(I only fully understood this issue quite recently, so at time of writing it is not used in the tidyverse. Hopefully by the time you’re reading this, it will have rolled out, making it much easier to (e.g.) subclass tibbles.)</p>
<p>If you build your class using the tools provided by the vctrs package, <code>[</code> will gain this behaviour automatically. You will only need to provide your own <code>[</code> method if you use attributes that depend on the data or want non-standard subsetting behaviour. See <code>?vctrs::new_vctr</code> for details.</p>
</div>
<div id="exercises-42" class="section level3">
<h3><span class="header-section-number">13.6.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How does <code>[.Date</code> support subclasses? How does it fail to support
subclasses?</p></li>
<li><p>R has two classes for representing date time data, <code>POSIXct</code> and
<code>POSIXlt</code>, which both inherit from <code>POSIXt</code>. Which generics have
different behaviours for the two classes? Which generics share the same
behaviour?</p></li>
<li><p>What do you expect this code to return? What does it actually return?
Why?</p>
<pre class="sourceCode r"><code class="sourceCode r">generic2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">UseMethod</span>(<span class="st">&quot;generic2&quot;</span>)
generic2.a1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="st">&quot;a1&quot;</span>
generic2.a2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="st">&quot;a2&quot;</span>
generic2.b &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">class</span>(x) &lt;-<span class="st"> &quot;a1&quot;</span>
  <span class="kw">NextMethod</span>()
}

<span class="kw">generic2</span>(<span class="kw">structure</span>(<span class="kw">list</span>(), <span class="dt">class =</span> <span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;a2&quot;</span>)))</code></pre></li>
</ol>
</div>
</div>
<div id="s3-dispatch" class="section level2">
<h2><span class="header-section-number">13.7</span> Dispatch details</h2>
<p></p>
<p>This chapter concludes with a few additional details about method dispatch. It is safe to skip these details if you’re new to S3.</p>
<div id="implicit-class" class="section level3">
<h3><span class="header-section-number">13.7.1</span> S3 and base types</h3>
<p>
</p>
<p>What happens when you call an S3 generic with a base object, i.e. an object with no class? You might think it would dispatch on what <code>class()</code> returns:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>))
<span class="co">#&gt; [1] &quot;matrix&quot;</span></code></pre>
<p>But unfortunately dispatch actually occurs on the <strong>implicit class</strong>, which has three components:</p>
<ul>
<li>“array” or “matrix” (if the object has dimensions).</li>
<li><code>typeof()</code> (with a few minor tweaks).</li>
<li>If it’s “integer” or “double”, “numeric”.</li>
</ul>
<p>There is no base function that will compute the implicit class, but you can use <code>sloop::s3_class()</code></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_class</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>))
<span class="co">#&gt; [1] &quot;matrix&quot;  &quot;integer&quot; &quot;numeric&quot;</span></code></pre>
<p>This is used by <code>s3_dispatch()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(<span class="kw">print</span>(<span class="kw">matrix</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)))
<span class="co">#&gt;    print.matrix</span>
<span class="co">#&gt;    print.integer</span>
<span class="co">#&gt;    print.numeric</span>
<span class="co">#&gt; =&gt; print.default</span></code></pre>
<p>This means that the <code>class()</code> of an object does not uniquely determine its dispatch:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
<span class="kw">class</span>(x1)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">s3_dispatch</span>(<span class="kw">mean</span>(x1))
<span class="co">#&gt;    mean.integer</span>
<span class="co">#&gt;    mean.numeric</span>
<span class="co">#&gt; =&gt; mean.default</span>

x2 &lt;-<span class="st"> </span><span class="kw">structure</span>(x1, <span class="dt">class =</span> <span class="st">&quot;integer&quot;</span>)
<span class="kw">class</span>(x2)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">s3_dispatch</span>(<span class="kw">mean</span>(x2))
<span class="co">#&gt;    mean.integer</span>
<span class="co">#&gt; =&gt; mean.default</span></code></pre>
</div>
<div id="internal-generics" class="section level3">
<h3><span class="header-section-number">13.7.2</span> Internal generics</h3>
<p></p>
<p>Some base functions, like <code>[</code>, <code>sum()</code>, and <code>cbind()</code>, are called <strong>internal generics</strong> because they don’t call <code>UseMethod()</code> but instead call the C functions <code>DispatchGroup()</code> or <code>DispatchOrEval()</code>. <code>s3_dispatch()</code> shows internal generics by including the name of the generic followed by <code>(internal)</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(<span class="kw">Sys.time</span>()[<span class="dv">1</span>])
<span class="co">#&gt; =&gt; [.POSIXct</span>
<span class="co">#&gt;    [.POSIXt</span>
<span class="co">#&gt;    [.default</span>
<span class="co">#&gt; -&gt; [ (internal)</span></code></pre>
<p>For performance reasons, internal generics do not dispatch to methods unless the class attribute has been set, which means that internal generics do not use the implicit class. Again, if you’re ever confused about method dispatch, you can rely on <code>s3_dispatch()</code>.</p>
</div>
<div id="group-generics" class="section level3">
<h3><span class="header-section-number">13.7.3</span> Group generics</h3>
<p>
</p>
<p>Group generics are the most complicated part of S3 method dispatch because they involve both <code>NextMethod()</code> and internal generics. Like internal generics, they only exist in base R, and you cannot define your own group generic.</p>
<p>There are four group generics:</p>
<ul>
<li><p><strong>Math</strong>: <code>abs()</code>, <code>sign()</code>, <code>sqrt()</code>, <code>floor()</code>, <code>cos()</code>, <code>sin()</code>, <code>log()</code>,
and more (see <code>?Math</code> for the complete list).</p></li>
<li><p><strong>Ops</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;=</code>, and <code>&gt;</code>.</p></li>
<li><p><strong>Summary</strong>: <code>all()</code>, <code>any()</code>, <code>sum()</code>, <code>prod()</code>, <code>min()</code>, <code>max()</code>, and
<code>range()</code>.</p></li>
<li><p><strong>Complex</strong>: <code>Arg()</code>, <code>Conj()</code>, <code>Im()</code>, <code>Mod()</code>, <code>Re()</code>.</p></li>
</ul>
<p>Defining a single group generic for your class overrides the default behaviour for all of the members of the group. Methods for group generics are looked for only if the methods for the specific generic do not exist:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">s3_dispatch</span>(<span class="kw">sum</span>(<span class="kw">Sys.time</span>()))
<span class="co">#&gt;    sum.POSIXct</span>
<span class="co">#&gt;    sum.POSIXt</span>
<span class="co">#&gt;    sum.default</span>
<span class="co">#&gt; =&gt; Summary.POSIXct</span>
<span class="co">#&gt;    Summary.POSIXt</span>
<span class="co">#&gt;    Summary.default</span>
<span class="co">#&gt; -&gt; sum (internal)</span></code></pre>
<p>Most group generics involve a call to <code>NextMethod()</code>. For example, take <code>difftime()</code> objects. If you look at the method dispatch for <code>abs()</code>, you’ll see there’s a <code>Math</code> group generic defined.</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">as.difftime</span>(<span class="dv">10</span>, <span class="dt">units =</span> <span class="st">&quot;mins&quot;</span>)
<span class="kw">s3_dispatch</span>(<span class="kw">abs</span>(y))
<span class="co">#&gt;    abs.difftime</span>
<span class="co">#&gt;    abs.default</span>
<span class="co">#&gt; =&gt; Math.difftime</span>
<span class="co">#&gt;    Math.default</span>
<span class="co">#&gt; -&gt; abs (internal)</span></code></pre>
<p><code>Math.difftime</code> basically looks like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">Math.difftime &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  <span class="kw">new_difftime</span>(<span class="kw">NextMethod</span>(), <span class="dt">units =</span> <span class="kw">attr</span>(x, <span class="st">&quot;units&quot;</span>))
}</code></pre>
<p>It dispatches to the next method, here the internal default, to perform the actual computation, then restore the class and attributes. (To better support subclasses of <code>difftime</code> this would need to call <code>vec_restore()</code>, as described in Section <a href="#s3-subclassing">13.6.2</a>.)</p>
<p>Inside a group generic function a special variable <code>.Generic</code> provides the actual generic function called. This can be useful when producing error messages, and can sometimes be useful if you need to manually re-call the generic with different arguments.</p>
</div>
<div id="double-dispatch" class="section level3">
<h3><span class="header-section-number">13.7.4</span> Double dispatch</h3>
<p>
</p>
<p>Generics in the “Ops” group, which includes the two-argument arithmetic and boolean operators like <code>-</code> and <code>&amp;</code>, implement a special type of method dispatch. They dispatch on the type of <em>both</em> of the arguments, which is called <strong>double dispatch</strong>. This is necessary to preserve the commutative property of many operators, i.e. <code>a + b</code> should equal <code>b + a</code>. Take the following simple example:</p>
<pre class="sourceCode r"><code class="sourceCode r">date &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;2017-01-01&quot;</span>)
integer &lt;-<span class="st"> </span>1L

date <span class="op">+</span><span class="st"> </span>integer
<span class="co">#&gt; [1] &quot;2017-01-02&quot;</span>
integer <span class="op">+</span><span class="st"> </span>date
<span class="co">#&gt; [1] &quot;2017-01-02&quot;</span></code></pre>
<p>If <code>+</code> dispatched only on the first argument, it would return different values for the two cases. To overcome this problem, generics in the Ops group use a slightly different strategy from usual. Rather than doing a single method dispatch, they do two, one for each input. There are three possible outcomes of this lookup:</p>
<ul>
<li><p>The methods are the same, so it doesn’t matter which method is used.</p></li>
<li><p>The methods are different, and R falls back to the internal method with
a warning.</p></li>
<li><p>One method is internal, in which case R calls the other method.</p></li>
</ul>
<p>This approach is error prone so if you want to implement robust double dispatch for algebraic operators, I recommend using the vctrs package. See <code>?vctrs::vec_arith</code> for details.</p>
</div>
<div id="exercises-43" class="section level3">
<h3><span class="header-section-number">13.7.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Explain the differences in dispatch below:</p>
<pre class="sourceCode r"><code class="sourceCode r">length.integer &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="dv">10</span>

x1 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
<span class="kw">class</span>(x1)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">s3_dispatch</span>(<span class="kw">length</span>(x1))
<span class="co">#&gt;  * length.integer</span>
<span class="co">#&gt;    length.numeric</span>
<span class="co">#&gt;    length.default</span>
<span class="co">#&gt; =&gt; length (internal)</span>

x2 &lt;-<span class="st"> </span><span class="kw">structure</span>(x1, <span class="dt">class =</span> <span class="st">&quot;integer&quot;</span>)
<span class="kw">class</span>(x2)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">s3_dispatch</span>(<span class="kw">length</span>(x2))
<span class="co">#&gt; =&gt; length.integer</span>
<span class="co">#&gt;    length.default</span>
<span class="co">#&gt;  * length (internal)</span></code></pre></li>
<li><p>What classes have a method for the <code>Math</code> group generic in base R? Read
the source code. How do the methods work?</p></li>
<li><p><code>Math.difftime()</code> is more complicated than I described. Why?</p></li>
</ol>
<!--chapter:end:S3.Rmd-->
</div>
</div>
</div>
<div id="r6" class="section level1">
<h1><span class="header-section-number">14</span> R6</h1>
<div id="introduction-13" class="section level2">
<h2><span class="header-section-number">14.1</span> Introduction</h2>
<p></p>
<p>This chapter describes the R6 OOP system. R6 has two special properties:</p>
<ul>
<li><p>It uses the encapsulated OOP paradigm, which means that methods belong to
objects, not generics, and you call them like <code>object$method()</code>.</p></li>
<li><p>R6 objects are <strong>mutable</strong>, which means that they are modified in place, and
hence have reference semantics.</p></li>
</ul>
<p>If you’ve learned OOP in another programming language, it’s likely that R6 will feel very natural, and you’ll be inclined to prefer it over S3. Resist the temptation to follow the path of least resistance: in most cases R6 will lead you to non-idiomatic R code. We’ll come back to this theme in Section <a href="#s3-r6">16.3</a>.</p>
<p>R6 is very similar to a base OOP system called <strong>reference classes</strong>, or RC for short. I describe why I teach R6 and not RC in Section <a href="#why-r6">14.5</a>.</p>
<div id="outline-12" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#r6-classes">14.2</a> introduces <code>R6::R6class()</code>, the one function that
you need to know to create R6 classes. You’ll learn about the constructor
method, <code>$new()</code>, which allows you to create R6 objects, as well as other
important methods like <code>$initialize()</code> and <code>$print()</code>.</p></li>
<li><p>Section <a href="#r6-access">14.3</a> discusses the access mechanisms of R6: private and
active fields. Together, these allow you to hide data from the user, or
expose private data for reading but not writing.</p></li>
<li><p>Section <a href="#r6-semantics">14.4</a> explores the consequences of R6’s reference
semantics. You’ll learn about the use of finalizers to automatically
clean up any operations performed in the initializer, and a common gotcha
if you use an R6 object as a field in another R6 object.</p></li>
<li><p>Section <a href="#why-r6">14.5</a> describes why I cover R6, rather than the base RC
system.</p></li>
</ul>
</div>
<div id="prerequisites-7" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>Because R6<span id="fn116" class="footnote" data-pagedown-footnote-number="116" style="white-space: pre-line;"><a href="https://r6.r-lib.org" class="uri">https://r6.r-lib.org</a></span> is not built into base R, you’ll need to install and load the R6 package to use it:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># install.packages(&quot;R6&quot;)</span>
<span class="kw">library</span>(R6)</code></pre>
<p>R6 objects have reference semantics which means that they are modified in-place, not copied-on-modify. If you’re not familiar with these terms, brush up your vocab by reading Section <a href="#modify-in-place">2.5</a>.</p>
</div>
</div>
<div id="r6-classes" class="section level2">
<h2><span class="header-section-number">14.2</span> Classes and methods</h2>
<p>


</p>
<p>R6 only needs a single function call to create both the class and its methods: <code>R6::R6Class()</code>. This is the only function from the package that you’ll ever use!<span id="fn117" class="footnote" data-pagedown-footnote-number="117" style="white-space: pre-line;">That means if you’re creating R6 in a package, you only need to make sure it’s listed in the <code>Imports</code> field of the <code>DESCRIPTION</code>. There’s no need to import the package into the <code>NAMESPACE</code>.</span></p>
<p>The following example shows the two most important arguments to <code>R6Class()</code>:</p>
<ul>
<li><p>The first argument is the <code>classname</code>. It’s not strictly needed, but it
improves error messages and makes it possible to use R6 objects with S3
generics. By convention, R6 classes have <code>UpperCamelCase</code> names.</p></li>
<li><p>The second argument, <code>public</code>, supplies a list of methods (functions) and
fields (anything else) that make up the public interface of the object.
By convention, methods and fields use <code>snake_case</code>. Methods can access
the methods and fields of the current object via <code>self$</code>.<span id="fn118" class="footnote" data-pagedown-footnote-number="118" style="white-space: pre-line;">Unlike in <code>this</code> in python, the <code>self</code> variable is automatically provided by R6, and does not form part of the method signature.</span>
</p></li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">Accumulator &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Accumulator&quot;</span>, <span class="kw">list</span>(
  <span class="dt">sum =</span> <span class="dv">0</span>,
  <span class="dt">add =</span> <span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>) {
    self<span class="op">$</span>sum &lt;-<span class="st"> </span>self<span class="op">$</span>sum <span class="op">+</span><span class="st"> </span>x 
    <span class="kw">invisible</span>(self)
  })
)</code></pre>
<p>You should always assign the result of <code>R6Class()</code> into a variable with the same name as the class, because <code>R6Class()</code> returns an R6 object that defines the class:</p>
<pre class="sourceCode r"><code class="sourceCode r">Accumulator
<span class="co">#&gt; &lt;Accumulator&gt; object generator</span>
<span class="co">#&gt;   Public:</span>
<span class="co">#&gt;     sum: 0</span>
<span class="co">#&gt;     add: function (x = 1) </span>
<span class="co">#&gt;     clone: function (deep = FALSE) </span>
<span class="co">#&gt;   Parent env: &lt;environment: R_GlobalEnv&gt;</span>
<span class="co">#&gt;   Locked objects: TRUE</span>
<span class="co">#&gt;   Locked class: FALSE</span>
<span class="co">#&gt;   Portable: TRUE</span></code></pre>
<p>
You construct a new object from the class by calling the <code>new()</code> method. In R6, methods belong to objects, so you use <code>$</code> to access <code>new()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>Accumulator<span class="op">$</span><span class="kw">new</span>() </code></pre>
<p>You can then call methods and access fields with <code>$</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x<span class="op">$</span><span class="kw">add</span>(<span class="dv">4</span>) 
x<span class="op">$</span>sum
<span class="co">#&gt; [1] 4</span></code></pre>
<p>In this class, the fields and methods are public, which means that you can get or set the value of any field. Later, we’ll see how to use private fields and methods to prevent casual access to the internals of your class.</p>
<p>To make it clear when we’re talking about fields and methods as opposed to variables and functions, I’ll prefix their names with <code>$</code>. For example, the <code>Accumulate</code> class has field <code>$sum</code> and method <code>$add()</code>.</p>
<div id="method-chaining" class="section level3">
<h3><span class="header-section-number">14.2.1</span> Method chaining</h3>
<p></p>
<p><code>$add()</code> is called primarily for its side-effect of updating <code>$sum</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">Accumulator &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Accumulator&quot;</span>, <span class="kw">list</span>(
  <span class="dt">sum =</span> <span class="dv">0</span>,
  <span class="dt">add =</span> <span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>) {
    self<span class="op">$</span>sum &lt;-<span class="st"> </span>self<span class="op">$</span>sum <span class="op">+</span><span class="st"> </span>x 
    <span class="kw">invisible</span>(self)
  })
)</code></pre>
<p>Side-effect R6 methods should always return <code>self</code> invisibly. This returns the “current” object and makes it possible to chain together multiple method calls:</p>
<pre class="sourceCode r"><code class="sourceCode r">x<span class="op">$</span><span class="kw">add</span>(<span class="dv">10</span>)<span class="op">$</span><span class="kw">add</span>(<span class="dv">10</span>)<span class="op">$</span>sum
<span class="co">#&gt; [1] 24</span></code></pre>
<p>For, readability, you might put one method call on each line:</p>
<pre class="sourceCode r"><code class="sourceCode r">x<span class="op">$</span>
<span class="st">  </span><span class="kw">add</span>(<span class="dv">10</span>)<span class="op">$</span>
<span class="st">  </span><span class="kw">add</span>(<span class="dv">10</span>)<span class="op">$</span>
<span class="st">  </span>sum
<span class="co">#&gt; [1] 44</span></code></pre>
<p>This technique is called <strong>method chaining</strong> and is commonly used in languages like Python and JavaScript. Method chaining is deeply related to the pipe, and we’ll discuss the pros and cons of each approach in Section <a href="#tradeoffs-pipe">16.3.3</a>.</p>
</div>
<div id="r6-important-methods" class="section level3">
<h3><span class="header-section-number">14.2.2</span> Important methods</h3>
<p>
</p>
<p>There are two important methods that should be defined for most classes: <code>$initialize()</code> and <code>$print()</code>. They’re not required, but providing them will make your class easier to use.</p>
<p><code>$initialize()</code> overrides the default behaviour of <code>$new()</code>. For example, the following code defines an Person class with fields <code>$name</code> and <code>$age</code>. To ensure that that <code>$name</code> is always a single string, and <code>$age</code> is always a single number, I placed checks in <code>$initialize()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">Person &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Person&quot;</span>, <span class="kw">list</span>(
  <span class="dt">name =</span> <span class="ot">NULL</span>,
  <span class="dt">age =</span> <span class="ot">NA</span>,
  <span class="dt">initialize =</span> <span class="cf">function</span>(name, <span class="dt">age =</span> <span class="ot">NA</span>) {
    <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(name), <span class="kw">length</span>(name) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
    <span class="kw">stopifnot</span>(<span class="kw">is.numeric</span>(age), <span class="kw">length</span>(age) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
    
    self<span class="op">$</span>name &lt;-<span class="st"> </span>name
    self<span class="op">$</span>age &lt;-<span class="st"> </span>age
  }
))

hadley &lt;-<span class="st"> </span>Person<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;Hadley&quot;</span>, <span class="dt">age =</span> <span class="st">&quot;thirty-eight&quot;</span>)
<span class="co">#&gt; Error in .subset2(public_bind_env, &quot;initialize&quot;)(...):</span>
<span class="co">#&gt;   is.numeric(age) is not TRUE</span>

hadley &lt;-<span class="st"> </span>Person<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;Hadley&quot;</span>, <span class="dt">age =</span> <span class="dv">38</span>)</code></pre>
<p>If you have more expensive validation requirements, implement them in a separate <code>$validate()</code> and only call when needed.</p>
<p>Defining <code>$print()</code> allows you to override the default printing behaviour. As with any R6 method called for its side effects, <code>$print()</code> should return <code>invisible(self)</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">Person &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Person&quot;</span>, <span class="kw">list</span>(
  <span class="dt">name =</span> <span class="ot">NULL</span>,
  <span class="dt">age =</span> <span class="ot">NA</span>,
  <span class="dt">initialize =</span> <span class="cf">function</span>(name, <span class="dt">age =</span> <span class="ot">NA</span>) {
    self<span class="op">$</span>name &lt;-<span class="st"> </span>name
    self<span class="op">$</span>age &lt;-<span class="st"> </span>age
  },
  <span class="dt">print =</span> <span class="cf">function</span>(...) {
    <span class="kw">cat</span>(<span class="st">&quot;Person: </span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;  Name: &quot;</span>, self<span class="op">$</span>name, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;  Age:  &quot;</span>, self<span class="op">$</span>age, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
    <span class="kw">invisible</span>(self)
  }
))

hadley2 &lt;-<span class="st"> </span>Person<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;Hadley&quot;</span>)
hadley2
<span class="co">#&gt; Person: </span>
<span class="co">#&gt;   Name: Hadley</span>
<span class="co">#&gt;   Age:  NA</span></code></pre>
<p>This code illustrates an important aspect of R6. Because methods are bound to individual objects, the previously created <code>hadley</code> object does not get this new method:</p>
<pre class="sourceCode r"><code class="sourceCode r">hadley
<span class="co">#&gt; &lt;Person&gt;</span>
<span class="co">#&gt;   Public:</span>
<span class="co">#&gt;     age: 38</span>
<span class="co">#&gt;     clone: function (deep = FALSE) </span>
<span class="co">#&gt;     initialize: function (name, age = NA) </span>
<span class="co">#&gt;     name: Hadley</span>

hadley<span class="op">$</span>print
<span class="co">#&gt; NULL</span></code></pre>
<p>From the perspective of R6, there is no relationship between <code>hadley</code> and <code>hadley2</code>; they just coincidentally share the same class name. This doesn’t cause problems when using already developed R6 objects but can make interactive experimentation confusing. If you’re changing the code and can’t figure out why the results of method calls aren’t any different, make sure you’ve re-constructed R6 objects with the new class.</p>
</div>
<div id="adding-methods-after-creation" class="section level3">
<h3><span class="header-section-number">14.2.3</span> Adding methods after creation</h3>
<p></p>
<p>Instead of continuously creating new classes, it’s also possible to modify the fields and methods of an existing class. This is useful when exploring interactively, or when you have a class with many functions that you’d like to break up into pieces. Add new elements to an existing class with <code>$set()</code>, supplying the visibility (more on in Section <a href="#r6-access">14.3</a>), the name, and the component.</p>
<pre class="sourceCode r"><code class="sourceCode r">Accumulator &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Accumulator&quot;</span>)
Accumulator<span class="op">$</span><span class="kw">set</span>(<span class="st">&quot;public&quot;</span>, <span class="st">&quot;sum&quot;</span>, <span class="dv">0</span>)
Accumulator<span class="op">$</span><span class="kw">set</span>(<span class="st">&quot;public&quot;</span>, <span class="st">&quot;add&quot;</span>, <span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>) {
  self<span class="op">$</span>sum &lt;-<span class="st"> </span>self<span class="op">$</span>sum <span class="op">+</span><span class="st"> </span>x 
  <span class="kw">invisible</span>(self)
})</code></pre>
<p>As above, new methods and fields are only available to new objects; they are not retrospectively added to existing objects.</p>
</div>
<div id="inheritance" class="section level3">
<h3><span class="header-section-number">14.2.4</span> Inheritance</h3>
<p>
</p>
<p>To inherit behaviour from an existing class, provide the class object to the <code>inherit</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">AccumulatorChatty &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;AccumulatorChatty&quot;</span>, 
  <span class="dt">inherit =</span> Accumulator,
  <span class="dt">public =</span> <span class="kw">list</span>(
    <span class="dt">add =</span> <span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>) {
      <span class="kw">cat</span>(<span class="st">&quot;Adding &quot;</span>, x, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
      super<span class="op">$</span><span class="kw">add</span>(<span class="dt">x =</span> x)
    }
  )
)

x2 &lt;-<span class="st"> </span>AccumulatorChatty<span class="op">$</span><span class="kw">new</span>()
x2<span class="op">$</span><span class="kw">add</span>(<span class="dv">10</span>)<span class="op">$</span><span class="kw">add</span>(<span class="dv">1</span>)<span class="op">$</span>sum
<span class="co">#&gt; Adding 10</span>
<span class="co">#&gt; Adding 1</span>
<span class="co">#&gt; [1] 11</span></code></pre>
<p><code>$add()</code> overrides the superclass implementation, but we can still delegate to the superclass implementation by using <code>super$</code>. (This is analogous to <code>NextMethod()</code> in S3, as discussed in Section <a href="#s3-inheritance">13.6</a>.) Any methods which are not overridden will use the implementation in the parent class.</p>
</div>
<div id="introspection" class="section level3">
<h3><span class="header-section-number">14.2.5</span> Introspection</h3>
<p></p>
<p>Every R6 object has an S3 class that reflects its hierarchy of R6 classes. This means that the easiest way to determine the class (and all classes it inherits from) is to use <code>class()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(hadley2)
<span class="co">#&gt; [1] &quot;Person&quot; &quot;R6&quot;</span></code></pre>
<p>The S3 hierarchy includes the base “R6” class. This provides common behaviour, including a <code>print.R6()</code> method which calls <code>$print()</code>, as described above.</p>
<p>
You can list all methods and fields with <code>names()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(hadley2)
<span class="co">#&gt; [1] &quot;.__enclos_env__&quot; &quot;age&quot;             &quot;name&quot;            &quot;clone&quot;          </span>
<span class="co">#&gt; [5] &quot;print&quot;           &quot;initialize&quot;</span></code></pre>
<p>We defined <code>$name</code>, <code>$age</code>, <code>$print</code>, and <code>$initialize</code>. As suggested by the name, <code>.__enclos_env__</code> is an internal implementation detail that you shouldn’t touch; we’ll come back to <code>$clone()</code> in Section <a href="#r6-semantics">14.4</a>.</p>
</div>
<div id="exercises-44" class="section level3">
<h3><span class="header-section-number">14.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Create a bank account R6 class that stores a balance and allows you to
deposit and withdraw money. Create a subclass that throws an error
if you attempt to go into overdraft. Create another subclass that allows
you to go into overdraft, but charges you a fee.</p></li>
<li><p>Create an R6 class that represents a shuffled deck of cards. You should be
able to draw cards from the deck with <code>$draw(n)</code>, and return all cards to
the deck and reshuffle with <code>$reshuffle()</code>. Use the following code to make
a vector of cards.</p>
<pre class="sourceCode r"><code class="sourceCode r">suit &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;♠&quot;</span>, <span class="st">&quot;♥&quot;</span>, <span class="st">&quot;♦&quot;</span>, <span class="st">&quot;♣&quot;</span>)
value &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A&quot;</span>, <span class="dv">2</span><span class="op">:</span><span class="dv">10</span>, <span class="st">&quot;J&quot;</span>, <span class="st">&quot;Q&quot;</span>, <span class="st">&quot;K&quot;</span>)
cards &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="kw">rep</span>(value, <span class="dv">4</span>), suit)</code></pre></li>
<li><p>Why can’t you model a bank account or a deck of cards with an S3 class?</p></li>
<li><p>Create an R6 class that allows you to get and set the current timezone.
You can access the current timezone with <code>Sys.timezone()</code> and set it
with <code>Sys.setenv(TZ = &quot;newtimezone&quot;)</code>. When setting the time zone, make
sure the new time zone is in the list provided by <code>OlsonNames()</code>.</p></li>
<li><p>Create an R6 class that manages the current working directory.
It should have <code>$get()</code> and <code>$set()</code> methods.</p></li>
<li><p>Why can’t you model the time zone or current working directory with an S3
class?</p></li>
<li><p>What base type are R6 objects built on top of? What attributes do they
have?</p></li>
</ol>
</div>
</div>
<div id="r6-access" class="section level2">
<h2><span class="header-section-number">14.3</span> Controlling access</h2>
<p></p>
<p><code>R6Class()</code> has two other arguments that work similarly to <code>public</code>:</p>
<ul>
<li><p><code>private</code> allows you to create fields and methods that are only available
from within the class, not outside of it.</p></li>
<li><p><code>active</code> allows you to use accessor functions to define dynamic, or
active, fields.</p></li>
</ul>
<p>These are described in the following sections.</p>
<div id="privacy" class="section level3">
<h3><span class="header-section-number">14.3.1</span> Privacy</h3>
<p></p>
<p>With R6 you can define <strong>private</strong> fields and methods, elements that can only be accessed from within the class, not from the outside<span id="fn119" class="footnote" data-pagedown-footnote-number="119" style="white-space: pre-line;">Because R is such a flexible language, it’s technically still possible to access private values, but you’ll have to try much harder, spelunking in to the details of R6’s implementation.</span>. There are two things that you need to know to take advantage of private elements:</p>
<ul>
<li><p>The <code>private</code> argument to <code>R6Class</code> works in the same way as the <code>public</code>
argument: you give it a named list of methods (functions) and fields
(everything else).</p></li>
<li><p>Fields and methods defined in <code>private</code> are available within the methods
using <code>private$</code> instead of <code>self$</code>. You cannot access private fields or
methods outside of the class.</p></li>
</ul>
<p>To make this concrete, we could make <code>$age</code> and <code>$name</code> fields of the Person class private. With this definition of <code>Person</code> we can only set <code>$age</code> and <code>$name</code> during object creation, and we cannot access their values from outside of the class.</p>
<pre class="sourceCode r"><code class="sourceCode r">Person &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Person&quot;</span>, 
  <span class="dt">public =</span> <span class="kw">list</span>(
    <span class="dt">initialize =</span> <span class="cf">function</span>(name, <span class="dt">age =</span> <span class="ot">NA</span>) {
      private<span class="op">$</span>name &lt;-<span class="st"> </span>name
      private<span class="op">$</span>age &lt;-<span class="st"> </span>age
    },
    <span class="dt">print =</span> <span class="cf">function</span>(...) {
      <span class="kw">cat</span>(<span class="st">&quot;Person: </span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">cat</span>(<span class="st">&quot;  Name: &quot;</span>, private<span class="op">$</span>name, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
      <span class="kw">cat</span>(<span class="st">&quot;  Age:  &quot;</span>, private<span class="op">$</span>age, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
    }
  ),
  <span class="dt">private =</span> <span class="kw">list</span>(
    <span class="dt">age =</span> <span class="ot">NA</span>,
    <span class="dt">name =</span> <span class="ot">NULL</span>
  )
)

hadley3 &lt;-<span class="st"> </span>Person<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;Hadley&quot;</span>)
hadley3
<span class="co">#&gt; Person: </span>
<span class="co">#&gt;   Name: Hadley</span>
<span class="co">#&gt;   Age:  NA</span>
hadley3<span class="op">$</span>name
<span class="co">#&gt; NULL</span></code></pre>
<p>The distinction between public and private fields is important when you create complex networks of classes, and you want to make it as clear as possible what it’s ok for others to access. Anything that’s private can be more easily refactored because you know others aren’t relying on it. Private methods tend to be less important in R compared to other programming languages because the object hierarchies in R tend to be simpler.</p>
</div>
<div id="active-fields" class="section level3">
<h3><span class="header-section-number">14.3.2</span> Active fields</h3>
<p>
</p>
<p>Active fields allow you to define components that look like fields from the outside, but are defined with functions, like methods. Active fields are implemented using <strong>active bindings</strong> (Section <a href="#advanced-bindings">7.2.6</a>). Each active binding is a function that takes a single argument: <code>value</code>. If the argument is <code>missing()</code>, the value is being retrieved; otherwise it’s being modified.</p>
<p>For example, you could make an active field <code>random</code> that returns a different value every time you access it:</p>
<pre class="sourceCode r"><code class="sourceCode r">Rando &lt;-<span class="st"> </span>R6<span class="op">::</span><span class="kw">R6Class</span>(<span class="st">&quot;Rando&quot;</span>, <span class="dt">active =</span> <span class="kw">list</span>(
  <span class="dt">random =</span> <span class="cf">function</span>(value) {
    <span class="cf">if</span> (<span class="kw">missing</span>(value)) {
      <span class="kw">runif</span>(<span class="dv">1</span>)  
    } <span class="cf">else</span> {
      <span class="kw">stop</span>(<span class="st">&quot;Can&#39;t set `$random`&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
    }
  }
))
x &lt;-<span class="st"> </span>Rando<span class="op">$</span><span class="kw">new</span>()
x<span class="op">$</span>random
<span class="co">#&gt; [1] 0.0808</span>
x<span class="op">$</span>random
<span class="co">#&gt; [1] 0.834</span>
x<span class="op">$</span>random
<span class="co">#&gt; [1] 0.601</span></code></pre>
<p>
Active fields are particularly useful in conjunction with private fields, because they make it possible to implement components that look like fields from the outside but provide additional checks. For example, we can use then make a read-only <code>age</code> field, and to ensure that <code>name</code> is a length 1 character vector.</p>
<pre class="sourceCode r"><code class="sourceCode r">Person &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;Person&quot;</span>, 
  <span class="dt">private =</span> <span class="kw">list</span>(
    <span class="dt">.age =</span> <span class="ot">NA</span>,
    <span class="dt">.name =</span> <span class="ot">NULL</span>
  ),
  <span class="dt">active =</span> <span class="kw">list</span>(
    <span class="dt">age =</span> <span class="cf">function</span>(value) {
      <span class="cf">if</span> (<span class="kw">missing</span>(value)) {
        private<span class="op">$</span>.age
      } <span class="cf">else</span> {
        <span class="kw">stop</span>(<span class="st">&quot;`$age` is read only&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
      }
    },
    <span class="dt">name =</span> <span class="cf">function</span>(value) {
      <span class="cf">if</span> (<span class="kw">missing</span>(value)) {
        private<span class="op">$</span>.name
      } <span class="cf">else</span> {
        <span class="kw">stopifnot</span>(<span class="kw">is.character</span>(value), <span class="kw">length</span>(value) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
        private<span class="op">$</span>.name &lt;-<span class="st"> </span>value
        self
      }
    }
  ),
  <span class="dt">public =</span> <span class="kw">list</span>(
    <span class="dt">initialize =</span> <span class="cf">function</span>(name, <span class="dt">age =</span> <span class="ot">NA</span>) {
      private<span class="op">$</span>.name &lt;-<span class="st"> </span>name
      private<span class="op">$</span>.age &lt;-<span class="st"> </span>age
    }
  )
)

hadley4 &lt;-<span class="st"> </span>Person<span class="op">$</span><span class="kw">new</span>(<span class="st">&quot;Hadley&quot;</span>, <span class="dt">age =</span> <span class="dv">38</span>)
hadley4<span class="op">$</span>name
<span class="co">#&gt; [1] &quot;Hadley&quot;</span>
hadley4<span class="op">$</span>name &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="co">#&gt; Error in (function (value) :</span>
<span class="co">#&gt;   is.character(value) is not TRUE</span>
hadley4<span class="op">$</span>age &lt;-<span class="st"> </span><span class="dv">20</span>
<span class="co">#&gt; Error: `$age` is read only</span></code></pre>
</div>
<div id="exercises-45" class="section level3">
<h3><span class="header-section-number">14.3.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Create a bank account class that prevents you from directly setting the
account balance, but you can still withdraw from and deposit to. Throw
an error if you attempt to go into overdraft.</p></li>
<li><p>Create a class with a write-only <code>$password</code> field. It should have
<code>$check_password(password)</code> method that returns <code>TRUE</code> or <code>FALSE</code>, but
there should be no way to view the complete password.</p></li>
<li><p>Extend the <code>Rando</code> class with another active binding that allows you to
access the previous random value. Ensure that active binding is the only
way to access the value.</p></li>
<li><p>Can subclasses access private fields/methods from their parent? Perform
an experiment to find out.</p></li>
</ol>
</div>
</div>
<div id="r6-semantics" class="section level2">
<h2><span class="header-section-number">14.4</span> Reference semantics</h2>
<p></p>
<p>One of the big differences between R6 and most other objects is that they have reference semantics. The primary consequence of reference semantics is that objects are not copied when modified:</p>
<pre class="sourceCode r"><code class="sourceCode r">y1 &lt;-<span class="st"> </span>Accumulator<span class="op">$</span><span class="kw">new</span>() 
y2 &lt;-<span class="st"> </span>y1

y1<span class="op">$</span><span class="kw">add</span>(<span class="dv">10</span>)
<span class="kw">c</span>(<span class="dt">y1 =</span> y1<span class="op">$</span>sum, <span class="dt">y2 =</span> y2<span class="op">$</span>sum)
<span class="co">#&gt; y1 y2 </span>
<span class="co">#&gt; 10 10</span></code></pre>
<p>Instead, if you want a copy, you’ll need to explicitly <code>$clone()</code> the object:</p>
<pre class="sourceCode r"><code class="sourceCode r">y1 &lt;-<span class="st"> </span>Accumulator<span class="op">$</span><span class="kw">new</span>() 
y2 &lt;-<span class="st"> </span>y1<span class="op">$</span><span class="kw">clone</span>()

y1<span class="op">$</span><span class="kw">add</span>(<span class="dv">10</span>)
<span class="kw">c</span>(<span class="dt">y1 =</span> y1<span class="op">$</span>sum, <span class="dt">y2 =</span> y2<span class="op">$</span>sum)
<span class="co">#&gt; y1 y2 </span>
<span class="co">#&gt; 10  0</span></code></pre>
<p>(<code>$clone()</code> does not recursively clone nested R6 objects. If you want that, you’ll need to use <code>$clone(deep = TRUE)</code>.)</p>
<p>There are three other less obvious consequences:</p>
<ul>
<li><p>It is harder to reason about code that uses R6 objects because you need to
understand more context.</p></li>
<li><p>It makes sense to think about when an R6 object is deleted, and you
can write a <code>$finalize()</code> to complement the <code>$initialize()</code>.</p></li>
<li><p>If one of the fields is an R6 object, you must create it inside
<code>$initialize()</code>, not <code>R6Class()</code>.</p></li>
</ul>
<p>These consequences are described in more detail below.</p>
<div id="reasoning" class="section level3">
<h3><span class="header-section-number">14.4.1</span> Reasoning</h3>
<p>Generally, reference semantics makes code harder to reason about. Take this very simple example:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>)
y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">b =</span> <span class="dv">2</span>)

z &lt;-<span class="st"> </span><span class="kw">f</span>(x, y)</code></pre>
<p>For the vast majority of functions, you know that the final line only modifies <code>z</code>.</p>
<p>Take a similar example that uses an imaginary <code>List</code> reference class:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>List<span class="op">$</span><span class="kw">new</span>(<span class="dt">a =</span> <span class="dv">1</span>)
y &lt;-<span class="st"> </span>List<span class="op">$</span><span class="kw">new</span>(<span class="dt">b =</span> <span class="dv">2</span>)

z &lt;-<span class="st"> </span><span class="kw">f</span>(x, y)</code></pre>
<p>The final line is much harder to reason about: if <code>f()</code> calls methods of <code>x</code> or <code>y</code>, it might modify them as well as <code>z</code>. This is the biggest potential downside of R6 and you should take care to avoid it by writing functions that either return a value, or modify their R6 inputs, but not both. That said, doing both can lead to substantially simpler code in some cases, and we’ll discuss this further in Section <a href="#threading-state">16.3.2</a>.</p>
</div>
<div id="finalizer" class="section level3">
<h3><span class="header-section-number">14.4.2</span> Finalizer</h3>
<p>
</p>
<p>One useful property of reference semantics is that it makes sense to think about when an R6 object is <strong>finalized</strong>, i.e. when it’s deleted. This doesn’t make sense for most objects because copy-on-modify semantics mean that there may be many transient versions of an object, as alluded to in Section <a href="#gc">2.6</a>. For example, the following creates two factor objects: the second is created when the levels are modified, leaving the first to be destroyed by the garbage collector.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
<span class="kw">levels</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;c&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;a&quot;</span>)</code></pre>
<p>Since R6 objects are not copied-on-modify they are only deleted once, and it makes sense to think about <code>$finalize()</code> as a complement to <code>$initialize()</code>. Finalizers usually play a similar role to <code>on.exit()</code> (as described in Section <a href="#on-exit">6.7.4</a>), cleaning up any resources created by the initializer. For example, the following class wraps up a temporary file, automatically deleting it when the class is finalized.</p>
<pre class="sourceCode r"><code class="sourceCode r">TemporaryFile &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;TemporaryFile&quot;</span>, <span class="kw">list</span>(
  <span class="dt">path =</span> <span class="ot">NULL</span>,
  <span class="dt">initialize =</span> <span class="cf">function</span>() {
    self<span class="op">$</span>path &lt;-<span class="st"> </span><span class="kw">tempfile</span>()
  },
  <span class="dt">finalize =</span> <span class="cf">function</span>() {
    <span class="kw">message</span>(<span class="st">&quot;Cleaning up &quot;</span>, self<span class="op">$</span>path)
    <span class="kw">unlink</span>(self<span class="op">$</span>path)
  }
))</code></pre>
<p>The finalize method will be run when the object is deleted (or more precisely, by the first garbage collection after the object has been unbound from all names) or when R exits. This means that the finalizer can called effectively anywhere in your R code, and therefore it’s almost impossible to reason about finalizer code that touches shared data structures. Avoid these potential problems by only using the finalizer to clean up private resources allocated by initializer.</p>
<pre class="sourceCode r"><code class="sourceCode r">tf &lt;-<span class="st"> </span>TemporaryFile<span class="op">$</span><span class="kw">new</span>()
<span class="kw">rm</span>(tf)
<span class="co">#&gt; Cleaning up /tmp/Rtmpk73JdI/file155f31d8424bd</span></code></pre>
</div>
<div id="r6-fields" class="section level3">
<h3><span class="header-section-number">14.4.3</span> R6 fields</h3>
<p></p>
<p>A final consequence of reference semantics can crop up where you don’t expect it. If you use an R6 class as the default value of a field, it will be shared across all instances of the object! Take the following code: we want to create a temporary database every time we call <code>TemporaryDatabase$new()</code>, but the current code always uses the same path.</p>
<pre class="sourceCode r"><code class="sourceCode r">TemporaryDatabase &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;TemporaryDatabase&quot;</span>, <span class="kw">list</span>(
  <span class="dt">con =</span> <span class="ot">NULL</span>,
  <span class="dt">file =</span> TemporaryFile<span class="op">$</span><span class="kw">new</span>(),
  <span class="dt">initialize =</span> <span class="cf">function</span>() {
    self<span class="op">$</span>con &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw">dbConnect</span>(RSQLite<span class="op">::</span><span class="kw">SQLite</span>(), <span class="dt">path =</span> file<span class="op">$</span>path)
  },
  <span class="dt">finalize =</span> <span class="cf">function</span>() {
    DBI<span class="op">::</span><span class="kw">dbDisconnect</span>(self<span class="op">$</span>con)
  }
))

db_a &lt;-<span class="st"> </span>TemporaryDatabase<span class="op">$</span><span class="kw">new</span>()
db_b &lt;-<span class="st"> </span>TemporaryDatabase<span class="op">$</span><span class="kw">new</span>()

db_a<span class="op">$</span>file<span class="op">$</span>path <span class="op">==</span><span class="st"> </span>db_b<span class="op">$</span>file<span class="op">$</span>path
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>(If you’re familiar with Python, this is very similar to the “mutable default argument” problem.)</p>
<p>The problem arises because <code>TemporaryFile$new()</code> is called only once when the <code>TemporaryDatabase</code> class is defined. To fix the problem, we need to make sure it’s called every time that <code>TemporaryDatabase$new()</code> is called, i.e. we need to put it in <code>$initialize()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">TemporaryDatabase &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;TemporaryDatabase&quot;</span>, <span class="kw">list</span>(
  <span class="dt">con =</span> <span class="ot">NULL</span>,
  <span class="dt">file =</span> <span class="ot">NULL</span>,
  <span class="dt">initialize =</span> <span class="cf">function</span>() {
    self<span class="op">$</span>file &lt;-<span class="st"> </span>TemporaryFile<span class="op">$</span><span class="kw">new</span>()
    self<span class="op">$</span>con &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw">dbConnect</span>(RSQLite<span class="op">::</span><span class="kw">SQLite</span>(), <span class="dt">path =</span> file<span class="op">$</span>path)
  },
  <span class="dt">finalize =</span> <span class="cf">function</span>() {
    DBI<span class="op">::</span><span class="kw">dbDisconnect</span>(self<span class="op">$</span>con)
  }
))

db_a &lt;-<span class="st"> </span>TemporaryDatabase<span class="op">$</span><span class="kw">new</span>()
db_b &lt;-<span class="st"> </span>TemporaryDatabase<span class="op">$</span><span class="kw">new</span>()

db_a<span class="op">$</span>file<span class="op">$</span>path <span class="op">==</span><span class="st"> </span>db_b<span class="op">$</span>file<span class="op">$</span>path
<span class="co">#&gt; [1] FALSE</span></code></pre>
</div>
<div id="exercises-46" class="section level3">
<h3><span class="header-section-number">14.4.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>Create a class that allows you to write a line to a specified file.
You should open a connection to the file in <code>$initialize()</code>, append a
line using <code>cat()</code> in <code>$append_line()</code>, and close the connection in
<code>$finalize()</code>.</li>
</ol>
</div>
</div>
<div id="why-r6" class="section level2">
<h2><span class="header-section-number">14.5</span> Why R6?</h2>
<p>
</p>
<p>R6 is very similar to a built-in OO system called <strong>reference classes</strong>, or RC for short. I prefer R6 to RC because:</p>
<ul>
<li><p>R6 is much simpler. Both R6 and RC are built on top of environments, but
while R6 uses S3, RC uses S4. This means to fully understand RC, you need
to understand how the more complicated S4 works.</p></li>
<li><p>R6 has comprehensive online documentation at <a href="https://r6.r-lib.org" class="uri">https://r6.r-lib.org</a>.</p></li>
<li><p>R6 has a simpler mechanism for cross-package subclassing, which just
works without you having to think about it. For RC, read the details in the
“External Methods; Inter-Package Superclasses” section of <code>?setRefClass</code>.</p></li>
<li><p>RC mingles variables and fields in the same stack of environments so that you
get (<code>field</code>) and set (<code>field &lt;&lt;- value</code>) fields like regular values. R6 puts
fields in a separate environment so you get (<code>self$field</code>) and set
(<code>self$field &lt;- value</code>) with a prefix. The R6 approach is more verbose but
I like it because it is more explicit.</p></li>
<li><p>R6 is much faster than RC. Generally, the speed of method dispatch is not
important outside of microbenchmarks. However, RC is quite slow, and switching
from RC to R6 led to a substantial performance improvement in the shiny package.
For more details, see <code>vignette(&quot;Performance&quot;, &quot;R6&quot;)</code>.</p></li>
<li><p>RC is tied to R. That means if any bugs are fixed, you can only take
advantage of the fixes by requiring a newer version of R. This makes it
difficult for packages (like those in the tidyverse) that need to work across
many R versions.</p></li>
<li><p>Finally, because the ideas that underlie R6 and RC are similar, it will only
require a small amount of additional effort to learn RC if you need to.</p></li>
</ul>
<!--chapter:end:R6.Rmd-->
</div>
</div>
<div id="s4" class="section level1">
<h1><span class="header-section-number">15</span> S4</h1>
<div id="introduction-14" class="section level2">
<h2><span class="header-section-number">15.1</span> Introduction</h2>
<p>S4 provides a formal approach to functional OOP. The underlying ideas are similar to S3 (the topic of Chapter <a href="#s3">13</a>), but implementation is much stricter and makes use of specialised functions for creating classes (<code>setClass()</code>), generics (<code>setGeneric()</code>), and methods (<code>setMethod()</code>). Additionally, S4 provides both multiple inheritance (i.e. a class can have multiple parents) and multiple dispatch (i.e. method dispatch can use the class of multiple arguments).</p>
<p>An important new component of S4 is the <strong>slot</strong>, a named component of the object that is accessed using the specialised subsetting operator <code>@</code> (pronounced at). The set of slots, and their classes, forms an important part of the definition of an S4 class.</p>
<div id="outline-13" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#s4-basics">15.2</a> gives a quick overview of the main components of S4:
classes, generics, and methods.</p></li>
<li><p>Section <a href="#s4-classes">15.3</a> dives into the details of S4 classes, including
prototypes, constructors, helpers, and validators.</p></li>
<li><p>Section <a href="#s4-generics">15.4</a> shows you how to create new S4 generics, and
how to supply those generics with methods. You’ll also learn about
accessor functions which are designed to allow users to safely inspect and
modify object slots.</p></li>
<li><p>Section <a href="#s4-dispatch">15.5</a> dives into the full details of method dispatch
in S4. The basic idea is simple, then it rapidly gets more complex once
multiple inheritance and multiple dispatch are combined.</p></li>
<li><p>Section <a href="#s4-s3">15.6</a> discusses the interaction between S4 and S3, showing
you how to use them together.</p></li>
</ul>
</div>
<div id="learning-more" class="section level3 unnumbered">
<h3>Learning more</h3>
<p>Like the other OO chapters, the focus here will be on how S4 works, not how to deploy it most effectively. If you do want to use it in practice, there are two main challenges:</p>
<ul>
<li><p>There is no one reference that will answer all your questions about S4.</p></li>
<li><p>R’s built-in documentation sometimes clashes with community best practices.</p></li>
</ul>
<p>As you move towards more advanced usage, you will need to piece together needed information by carefully reading the documentation, asking questions on StackOverflow, and performing experiments. Some recommendations:</p>
<ul>
<li><p>The Bioconductor community is a long-term user S4 and have produced much of
best material about its effective use. Start with S4 classes and
methods<span id="fn120" class="footnote" data-pagedown-footnote-number="120" style="white-space: pre-line;"><a href="https://bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html" class="uri">https://bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html</a></span> taught by Martin Morgan and Hervé Pagès, or
check for a newer version at Bioconductor course materials<span id="fn121" class="footnote" data-pagedown-footnote-number="121" style="white-space: pre-line;"><a href="https://bioconductor.org/help/course-materials/" class="uri">https://bioconductor.org/help/course-materials/</a></span>.</p>
<p>Martin Morgan is a member of R-core and the project lead of Bioconductor.
He’s a world expert on the practical use of S4, and I recommend reading
anything he has written about it, starting with the questions he has
answered on stackoverflow<span id="fn122" class="footnote" data-pagedown-footnote-number="122" style="white-space: pre-line;"><a href="http://stackoverflow.com/search?tab=votes&amp;q=user%3a547331%20%5bs4%5d%20is%3aanswe" class="uri">http://stackoverflow.com/search?tab=votes&amp;q=user%3a547331%20%5bs4%5d%20is%3aanswe</a></span>.</p></li>
<li><p>John Chambers is the author of the S4 system, and provides an overview<br />
of its motivation and historical context in “Object-oriented programming,
functional programming and R” <span class="citation">(Chambers <a href="#ref-chambers-2014">2014</a>)</span>. For a fuller exploration
of S4, see his book “Software for Data Analysis” <span class="citation">(Chambers <a href="#ref-s4da">2008</a>)</span>.</p></li>
</ul>
</div>
<div id="prerequisites-8" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>All functions related to S4 live in the methods package. This package is always available when you’re running R interactively, but may not be available when running R in batch mode, i.e. from <code>Rscript</code><span id="fn123" class="footnote" data-pagedown-footnote-number="123" style="white-space: pre-line;">This is a historical quirk introduced because the methods package used to take a long time to load and <code>Rscript</code> is optimised for fast command line invocation.</span>. For this reason, it’s a good idea to call <code>library(methods)</code> whenever you use S4. This also signals to the reader that you’ll be using the S4 object system.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(methods)</code></pre>
</div>
</div>
<div id="s4-basics" class="section level2">
<h2><span class="header-section-number">15.2</span> Basics</h2>
<p>We’ll start with a quick overview of the main components of S4. You define an S4 class by calling <code>setClass()</code> with the class name and a definition of its slots, and the names and classes of the class data:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setClass</span>(<span class="st">&quot;Person&quot;</span>, 
  <span class="dt">slots =</span> <span class="kw">c</span>(
    <span class="dt">name =</span> <span class="st">&quot;character&quot;</span>, 
    <span class="dt">age =</span> <span class="st">&quot;numeric&quot;</span>
  )
)</code></pre>
<p>Once the class is defined, you can construct new objects from it by calling <code>new()</code> with the name of the class and a value for each slot:</p>
<pre class="sourceCode r"><code class="sourceCode r">john &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;Person&quot;</span>, <span class="dt">name =</span> <span class="st">&quot;John Smith&quot;</span>, <span class="dt">age =</span> <span class="ot">NA_real_</span>)</code></pre>

<p>
</p>
<p>Given an S4 object you can see its class with <code>is()</code> and access slots with <code>@</code> (equivalent to <code>$</code>) and <code>slot()</code> (equivalent to <code>[[</code>):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is</span>(john)
<span class="co">#&gt; [1] &quot;Person&quot;</span>
john<span class="op">@</span>name
<span class="co">#&gt; [1] &quot;John Smith&quot;</span>
<span class="kw">slot</span>(john, <span class="st">&quot;age&quot;</span>)
<span class="co">#&gt; [1] NA</span></code></pre>
<p>Generally, you should only use <code>@</code> in your methods. If you’re working with someone else’s class, look for <strong>accessor</strong> functions that allow you to safely set and get slot values. As the developer of a class, you should also provide your own accessor functions. Accessors are typically S4 generics allowing multiple classes to share the same external interface.</p>
<p>Here we’ll create a setter and getter for the <code>age</code> slot by first creating generics with <code>setGeneric()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setGeneric</span>(<span class="st">&quot;age&quot;</span>, <span class="cf">function</span>(x) <span class="kw">standardGeneric</span>(<span class="st">&quot;age&quot;</span>))
<span class="kw">setGeneric</span>(<span class="st">&quot;age&lt;-&quot;</span>, <span class="cf">function</span>(x, value) <span class="kw">standardGeneric</span>(<span class="st">&quot;age&lt;-&quot;</span>))</code></pre>
<p>And then defining methods with <code>setMethod()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setMethod</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(x) x<span class="op">@</span>age)
<span class="kw">setMethod</span>(<span class="st">&quot;age&lt;-&quot;</span>, <span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(x, value) {
  x<span class="op">@</span>age &lt;-<span class="st"> </span>value
  x
})

<span class="kw">age</span>(john) &lt;-<span class="st"> </span><span class="dv">50</span>
<span class="kw">age</span>(john)
<span class="co">#&gt; [1] 50</span></code></pre>
<p>If you’re using an S4 class defined in a package, you can get help on it with <code>class?Person</code>. To get help for a method, put <code>?</code> in front of a call (e.g. <code>?age(john)</code>) and <code>?</code> will use the class of the arguments to figure out which help file you need.</p>
<p>Finally, you can use sloop functions to identify S4 objects and generics found in the wild:</p>
<pre class="sourceCode r"><code class="sourceCode r">sloop<span class="op">::</span><span class="kw">otype</span>(john)
<span class="co">#&gt; [1] &quot;S4&quot;</span>
sloop<span class="op">::</span><span class="kw">ftype</span>(age)
<span class="co">#&gt; [1] &quot;S4&quot;      &quot;generic&quot;</span></code></pre>
<div id="exercises-47" class="section level3">
<h3><span class="header-section-number">15.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p><code>lubridate::period()</code> returns an S4 class. What slots does it have?
What class is each slot? What accessors does it provide?</p></li>
<li><p>What other ways can you find help for a method? Read <code>?&quot;?&quot;</code> and
summarise the details.</p></li>
</ol>
</div>
</div>
<div id="s4-classes" class="section level2">
<h2><span class="header-section-number">15.3</span> Classes</h2>
<p>

</p>
<p>To define an S4 class, call <code>setClass()</code> with three arguments:</p>
<ul>
<li><p>The class <strong>name</strong>. By convention, S4 class names use <code>UpperCamelCase</code>.</p></li>
<li><p>A named character vector that describes the names and classes of the
<strong>slots</strong> (fields). For example, a person might be represented by a character
name and a numeric age: <code>c(name = &quot;character&quot;, age = &quot;numeric&quot;)</code>. The
pseudo-class <code>ANY</code> allows a slot to accept objects of any type.</p></li>
<li><p>A <strong>prototype</strong>, a list of default values for each slot. Technically,
the prototype is optional<span id="fn124" class="footnote" data-pagedown-footnote-number="124" style="white-space: pre-line;"><code>?setClass</code> recommends that you avoid the <code>prototype</code> argument, but this is generally considered to be bad advice.</span>, but you should always provide it.</p></li>
</ul>
<p>The code below illustrates the three arguments by creating a <code>Person</code> class with character <code>name</code> and numeric <code>age</code> slots.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setClass</span>(<span class="st">&quot;Person&quot;</span>, 
  <span class="dt">slots =</span> <span class="kw">c</span>(
    <span class="dt">name =</span> <span class="st">&quot;character&quot;</span>, 
    <span class="dt">age =</span> <span class="st">&quot;numeric&quot;</span>
  ), 
  <span class="dt">prototype =</span> <span class="kw">list</span>(
    <span class="dt">name =</span> <span class="ot">NA_character_</span>,
    <span class="dt">age =</span> <span class="ot">NA_real_</span>
  )
)

me &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;Person&quot;</span>, <span class="dt">name =</span> <span class="st">&quot;Hadley&quot;</span>)
<span class="kw">str</span>(me)
<span class="co">#&gt; Formal class &#39;Person&#39; [package &quot;.GlobalEnv&quot;] with 2 slots</span>
<span class="co">#&gt;   ..@ name: chr &quot;Hadley&quot;</span>
<span class="co">#&gt;   ..@ age : num NA</span></code></pre>
<div id="inheritance-1" class="section level3">
<h3><span class="header-section-number">15.3.1</span> Inheritance</h3>
<p>
</p>
<p>There is one other important argument to <code>setClass()</code>: <code>contains</code>. This specifies a class (or classes) to inherit slots and behaviour from. For example, we can create an <code>Employee</code> class that inherits from the <code>Person</code> class, adding an extra slot that describes their <code>boss</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setClass</span>(<span class="st">&quot;Employee&quot;</span>, 
  <span class="dt">contains =</span> <span class="st">&quot;Person&quot;</span>, 
  <span class="dt">slots =</span> <span class="kw">c</span>(
    <span class="dt">boss =</span> <span class="st">&quot;Person&quot;</span>
  ),
  <span class="dt">prototype =</span> <span class="kw">list</span>(
    <span class="dt">boss =</span> <span class="kw">new</span>(<span class="st">&quot;Person&quot;</span>)
  )
)

<span class="kw">str</span>(<span class="kw">new</span>(<span class="st">&quot;Employee&quot;</span>))
<span class="co">#&gt; Formal class &#39;Employee&#39; [package &quot;.GlobalEnv&quot;] with 3 slots</span>
<span class="co">#&gt;   ..@ boss:Formal class &#39;Person&#39; [package &quot;.GlobalEnv&quot;] with 2 slots</span>
<span class="co">#&gt;   .. .. ..@ name: chr NA</span>
<span class="co">#&gt;   .. .. ..@ age : num NA</span>
<span class="co">#&gt;   ..@ name: chr NA</span>
<span class="co">#&gt;   ..@ age : num NA</span></code></pre>
<p><code>setClass()</code> has 9 other arguments but they are either deprecated or not recommended.</p>
</div>
<div id="introspection-1" class="section level3">
<h3><span class="header-section-number">15.3.2</span> Introspection</h3>
<p>
</p>
<p>To determine what classes an object inherits from, use <code>is()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is</span>(<span class="kw">new</span>(<span class="st">&quot;Person&quot;</span>))
<span class="co">#&gt; [1] &quot;Person&quot;</span>
<span class="kw">is</span>(<span class="kw">new</span>(<span class="st">&quot;Employee&quot;</span>))
<span class="co">#&gt; [1] &quot;Employee&quot; &quot;Person&quot;</span></code></pre>
<p>To test if an object inherits from a specific class, use the second argument of <code>is()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is</span>(john, <span class="st">&quot;person&quot;</span>)
<span class="co">#&gt; [1] FALSE</span></code></pre>
</div>
<div id="redefinition" class="section level3">
<h3><span class="header-section-number">15.3.3</span> Redefinition</h3>
<p>In most programming languages, class definition occurs at compile-time and object construction occurs later, at run-time. In R, however, both definition and construction occur at run time. When you call <code>setClass()</code>, you are registering a class definition in a (hidden) global variable. As with all state-modifying functions you need to use <code>setClass()</code> with care. It’s possible to create invalid objects if you redefine a class after already having instantiated an object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setClass</span>(<span class="st">&quot;A&quot;</span>, <span class="dt">slots =</span> <span class="kw">c</span>(<span class="dt">x =</span> <span class="st">&quot;numeric&quot;</span>))
a &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;A&quot;</span>, <span class="dt">x =</span> <span class="dv">10</span>)

<span class="kw">setClass</span>(<span class="st">&quot;A&quot;</span>, <span class="dt">slots =</span> <span class="kw">c</span>(<span class="dt">a_different_slot =</span> <span class="st">&quot;numeric&quot;</span>))
a
<span class="co">#&gt; An object of class &quot;A&quot;</span>
<span class="co">#&gt; Slot &quot;a_different_slot&quot;:</span>
<span class="co">#&gt; Error in slot(object, what):</span>
<span class="co">#&gt;   no slot of name &quot;a_different_slot&quot; for this object of class &quot;A&quot;</span></code></pre>
<p>This can cause confusion during interactive creation of new classes. (R6 classes have the same problem, as described in Section <a href="#r6-important-methods">14.2.2</a>.)</p>
</div>
<div id="helper" class="section level3">
<h3><span class="header-section-number">15.3.4</span> Helper</h3>
<p>


</p>
<p><code>new()</code> is a low-level constructor suitable for use by you, the developer. User-facing classes should always be paired with a user-friendly helper. A helper should always:</p>
<ul>
<li><p>Have the same name as the class, e.g. <code>myclass()</code>.</p></li>
<li><p>Have a thoughtfully crafted user interface with carefully chosen default
values and useful conversions.</p></li>
<li><p>Create carefully crafted error messages tailored towards an end-user.</p></li>
<li><p>Finish by calling by calling <code>methods::new()</code>.</p></li>
</ul>
<p>The <code>Person</code> class is so simple so a helper is almost superfluous, but we can use it to clearly define the contract: <code>age</code> is optional but <code>name</code> is required. We’ll also coerce age to a double so the helper also works when passed an integer.</p>
<pre class="sourceCode r"><code class="sourceCode r">Person &lt;-<span class="st"> </span><span class="cf">function</span>(name, <span class="dt">age =</span> <span class="ot">NA</span>) {
  age &lt;-<span class="st"> </span><span class="kw">as.double</span>(age)
  
  <span class="kw">new</span>(<span class="st">&quot;Person&quot;</span>, <span class="dt">name =</span> name, <span class="dt">age =</span> age)
}

<span class="kw">Person</span>(<span class="st">&quot;Hadley&quot;</span>)
<span class="co">#&gt; An object of class &quot;Person&quot;</span>
<span class="co">#&gt; Slot &quot;name&quot;:</span>
<span class="co">#&gt; [1] &quot;Hadley&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Slot &quot;age&quot;:</span>
<span class="co">#&gt; [1] NA</span></code></pre>
</div>
<div id="validator" class="section level3">
<h3><span class="header-section-number">15.3.5</span> Validator</h3>
<p>

</p>
<p>The constructor automatically checks that the slots have correct classes:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Person</span>(mtcars)
<span class="co">#&gt; Error in validObject(.Object):</span>
<span class="co">#&gt;   Error in validObject(.Object): invalid class &quot;Person&quot; object: invalid</span>
<span class="co">#&gt;   object for slot &quot;name&quot; in class &quot;Person&quot;: got class &quot;data.frame&quot;, should</span>
<span class="co">#&gt;   be or extend class &quot;character&quot;</span></code></pre>
<p>You will need to implement more complicated checks (i.e. checks that involve lengths, or multiple slots) yourself. For example, we might want to make it clear that the Person class is a vector class, and can store data about multiple people. That’s not currently clear because <code>@name</code> and <code>@age</code> can be different lengths:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Person</span>(<span class="st">&quot;Hadley&quot;</span>, <span class="dt">age =</span> <span class="kw">c</span>(<span class="dv">30</span>, <span class="dv">37</span>))
<span class="co">#&gt; An object of class &quot;Person&quot;</span>
<span class="co">#&gt; Slot &quot;name&quot;:</span>
<span class="co">#&gt; [1] &quot;Hadley&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Slot &quot;age&quot;:</span>
<span class="co">#&gt; [1] 30 37</span></code></pre>
<p>To enforce these additional constraints we write a validator with <code>setValidity()</code>. It takes a class and a function that returns <code>TRUE</code> if the input is valid, and otherwise returns a character vector describing the problem(s):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setValidity</span>(<span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(object) {
  <span class="cf">if</span> (<span class="kw">length</span>(object<span class="op">@</span>name) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(object<span class="op">@</span>age)) {
    <span class="st">&quot;@name and @age must be same length&quot;</span>
  } <span class="cf">else</span> {
    <span class="ot">TRUE</span>
  }
})</code></pre>
<p>Now we can no longer create an invalid object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Person</span>(<span class="st">&quot;Hadley&quot;</span>, <span class="dt">age =</span> <span class="kw">c</span>(<span class="dv">30</span>, <span class="dv">37</span>))
<span class="co">#&gt; Error in validObject(.Object):</span>
<span class="co">#&gt;   invalid class &quot;Person&quot; object: @name and @age must be same length</span></code></pre>
<p>NB: The validity method is only called automatically by <code>new()</code>, so you can still create an invalid object by modifying it:</p>
<pre class="sourceCode r"><code class="sourceCode r">alex &lt;-<span class="st"> </span><span class="kw">Person</span>(<span class="st">&quot;Alex&quot;</span>, <span class="dt">age =</span> <span class="dv">30</span>)
alex<span class="op">@</span>age &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span></code></pre>

<p>You can explicitly check the validity yourself by calling <code>validObject()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">validObject</span>(alex)
<span class="co">#&gt; Error in validObject(alex):</span>
<span class="co">#&gt;   invalid class &quot;Person&quot; object: @name and @age must be same length</span></code></pre>
<p>In Section <a href="#accessors">15.4.4</a>, we’ll use <code>validObject()</code> to create accessors that can not create invalid objects.</p>
</div>
<div id="exercises-48" class="section level3">
<h3><span class="header-section-number">15.3.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Extend the Person class with fields to match <code>utils::person()</code>.
Think about what slots you will need, what class each slot should have,
and what you’ll need to check in your validity method.</p></li>
<li><p>What happens if you define a new S4 class that doesn’t have any slots?
(Hint: read about virtual classes in <code>?setClass</code>.)</p></li>
<li><p>Imagine you were going to reimplement factors, dates, and data frames in
S4. Sketch out the <code>setClass()</code> calls that you would use to define the
classes. Think about appropriate <code>slots</code> and <code>prototype</code>.</p></li>
</ol>
</div>
</div>
<div id="s4-generics" class="section level2">
<h2><span class="header-section-number">15.4</span> Generics and methods</h2>
<p>


</p>
<p>The job of a generic is to perform method dispatch, i.e. find the specific implementation for the combination of classes passed to the generic. Here you’ll learn how to define S4 generics and methods, then in the next section we’ll explore precisely how S4 method dispatch works.</p>
<p>To create a new S4 generic, call <code>setGeneric()</code> with a function that calls <code>standardGeneric()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setGeneric</span>(<span class="st">&quot;myGeneric&quot;</span>, <span class="cf">function</span>(x) <span class="kw">standardGeneric</span>(<span class="st">&quot;myGeneric&quot;</span>))</code></pre>
<p>By convention, new S4 generics should use <code>lowerCamelCase</code>.</p>
<p>It is bad practice to use <code>{}</code> in the generic as it triggers a special case that is more expensive, and generally best avoided.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Don&#39;t do this!</span>
<span class="kw">setGeneric</span>(<span class="st">&quot;myGeneric&quot;</span>, <span class="cf">function</span>(x) {
  <span class="kw">standardGeneric</span>(<span class="st">&quot;myGeneric&quot;</span>)
})</code></pre>
<div id="signature" class="section level3">
<h3><span class="header-section-number">15.4.1</span> Signature</h3>
<p></p>
<p>Like <code>setClass()</code>, <code>setGeneric()</code> has many other arguments. There is only one that you need to know about: <code>signature</code>. This allows you to control the arguments that are used for method dispatch. If <code>signature</code> is not supplied, all arguments (apart from <code>...</code>) are used. It is occasionally useful to remove arguments from dispatch. This allows you to require that methods provide arguments like <code>verbose = TRUE</code> or <code>quiet = FALSE</code>, but they don’t take part in dispatch.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setGeneric</span>(<span class="st">&quot;myGeneric&quot;</span>, 
  <span class="cf">function</span>(x, ..., <span class="dt">verbose =</span> <span class="ot">TRUE</span>) <span class="kw">standardGeneric</span>(<span class="st">&quot;myGeneric&quot;</span>),
  <span class="dt">signature =</span> <span class="st">&quot;x&quot;</span>
)</code></pre>
</div>
<div id="methods" class="section level3">
<h3><span class="header-section-number">15.4.2</span> Methods</h3>

<p>
</p>
<p>A generic isn’t useful without some methods, and in S4 you define methods with <code>setMethod()</code>. There are three important arguments: the name of the generic, the name of the class, and the method itself.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setMethod</span>(<span class="st">&quot;myGeneric&quot;</span>, <span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(x) {
  <span class="co"># method implementation</span>
})</code></pre>
<p>More formally, the second argument to <code>setMethod()</code> is called the <strong>signature</strong>. In S4, unlike S3, the signature can include multiple arguments. This makes method dispatch in S4 substantially more complicated, but avoids having to implement double-dispatch as specially. We’ll talk more about multiple dispatch in the next section. <code>setMethod()</code> has other arguments, but you should never use them.</p>
<p>To list all the methods that belong to a generic, or that are associated with a class, use <code>methods(&quot;generic&quot;)</code> or <code>methods(class = &quot;class&quot;)</code>; to find the implementation of a specific method, use <code>selectMethod(&quot;generic&quot;, &quot;class&quot;)</code>.</p>
</div>
<div id="show-method" class="section level3">
<h3><span class="header-section-number">15.4.3</span> Show method</h3>

<p></p>
<p>The most commonly defined S4 method that controls printing is <code>show()</code>, which controls how the object appears when it is printed. To define a method for an existing generic, you must first determine the arguments. You can get those from the documentation or by looking at the <code>args()</code> of the generic:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">args</span>(<span class="kw">getGeneric</span>(<span class="st">&quot;show&quot;</span>))
<span class="co">#&gt; function (object) </span>
<span class="co">#&gt; NULL</span></code></pre>
<p>Our show method needs to have a single argument <code>object</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setMethod</span>(<span class="st">&quot;show&quot;</span>, <span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(object) {
  <span class="kw">cat</span>(<span class="kw">is</span>(object)[[<span class="dv">1</span>]], <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>,
      <span class="st">&quot;  Name: &quot;</span>, object<span class="op">@</span>name, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>,
      <span class="st">&quot;  Age:  &quot;</span>, object<span class="op">@</span>age, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>,
      <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>
  )
})
john
<span class="co">#&gt; Person</span>
<span class="co">#&gt;   Name: John Smith</span>
<span class="co">#&gt;   Age:  50</span></code></pre>
</div>
<div id="accessors" class="section level3">
<h3><span class="header-section-number">15.4.4</span> Accessors</h3>
<p></p>
<p>Slots should be considered an internal implementation detail: they can change without warning and user code should avoid accessing them directly. Instead, all user-accessible slots should be accompanied by a pair of <strong>accessors</strong>. If the slot is unique to the class, this can just be a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">person_name &lt;-<span class="st"> </span><span class="cf">function</span>(x) x<span class="op">@</span>name</code></pre>
<p>Typically, however, you’ll define a generic so that multiple classes can use the same interface:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setGeneric</span>(<span class="st">&quot;name&quot;</span>, <span class="cf">function</span>(x) <span class="kw">standardGeneric</span>(<span class="st">&quot;name&quot;</span>))
<span class="kw">setMethod</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(x) x<span class="op">@</span>name)

<span class="kw">name</span>(john)
<span class="co">#&gt; [1] &quot;John Smith&quot;</span></code></pre>
<p>If the slot is also writeable, you should provide a setter function. You should always include <code>validObject()</code> in the setter to prevent the user from creating invalid objects.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setGeneric</span>(<span class="st">&quot;name&lt;-&quot;</span>, <span class="cf">function</span>(x, value) <span class="kw">standardGeneric</span>(<span class="st">&quot;name&lt;-&quot;</span>))
<span class="kw">setMethod</span>(<span class="st">&quot;name&lt;-&quot;</span>, <span class="st">&quot;Person&quot;</span>, <span class="cf">function</span>(x, value) {
  x<span class="op">@</span>name &lt;-<span class="st"> </span>value
  <span class="kw">validObject</span>(x)
  x
})

<span class="kw">name</span>(john) &lt;-<span class="st"> &quot;Jon Smythe&quot;</span>
<span class="kw">name</span>(john)
<span class="co">#&gt; [1] &quot;Jon Smythe&quot;</span>

<span class="kw">name</span>(john) &lt;-<span class="st"> </span>letters
<span class="co">#&gt; Error in validObject(x):</span>
<span class="co">#&gt;   invalid class &quot;Person&quot; object: @name and @age must be same length</span></code></pre>
<p>(If the <code>name&lt;-</code> notation is unfamiliar, review Section <a href="#function-forms">6.8</a>.)</p>
</div>
<div id="exercises-49" class="section level3">
<h3><span class="header-section-number">15.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Add <code>age()</code> accessors for the <code>Person</code> class.</p></li>
<li><p>In the definition of the generic, why is it necessary to repeat the
name of the generic twice?</p></li>
<li><p>Why does the <code>show()</code> method defined in Section <a href="#show-method">15.4.3</a> use
<code>is(object)[[1]]</code>? (Hint: try printing the employee subclass.)</p></li>
<li><p>What happens if you define a method with different argument names to
the generic?</p></li>
</ol>
</div>
</div>
<div id="s4-dispatch" class="section level2">
<h2><span class="header-section-number">15.5</span> Method dispatch</h2>
<p>
</p>
<p>S4 dispatch is complicated because S4 has two important features:</p>
<ul>
<li>Multiple inheritance, i.e. a class can have multiple parents,</li>
<li>Multiple dispatch, i.e. a generic can use multiple arguments to pick a method.</li>
</ul>
<p>These features make S4 very powerful, but can also make it hard to understand which method will get selected for a given combination of inputs. In practice, keep method dispatch as simple as possible by avoiding multiple inheritance, and reserving multiple dispatch only for where it is absolutely necessary.</p>
<p>But it’s important to describe the full details, so here we’ll start simple with single inheritance and single dispatch, and work our way up to the more complicated cases. To illustrate the ideas without getting bogged down in the details, we’ll use an imaginary <strong>class graph</strong> based on emoji:</p>
<p><img src="diagrams/s4/emoji.png" width="226" style="display: block; margin: auto;" /></p>
<p>Emoji give us very compact class names that evoke the relationships between the classes. It should be straightforward to remember that 😜 inherits from 😉 which inherits from 😶, and that 😎 inherits from both 🕶 and 🙂.</p>
<div id="single-dispatch" class="section level3">
<h3><span class="header-section-number">15.5.1</span> Single dispatch</h3>
<p></p>
<p>Let’s start with the simplest case: a generic function that dispatches on a single class with a single parent. The method dispatch here is simple so it’s a good place to define the graphical conventions we’ll use for the more complex cases.</p>
<p><img src="diagrams/s4/single.png" width="189" style="display: block; margin: auto;" /></p>
<p>There are two parts to this diagram:</p>
<ul>
<li><p>The top part, <code>f(...)</code>, defines the scope of the diagram. Here we have a
generic with one argument, that has a class hierarchy that is three levels
deep.</p></li>
<li><p>The bottom part is the <strong>method graph</strong> and displays all the possible methods
that could be defined. Methods that exist, i.e. that have been defined with
<code>setMethod()</code>, have a grey background.</p></li>
</ul>
<p>To find the method that gets called, you start with the most specific class of the actual arguments, then follow the arrows until you find a method that exists. For example, if you called the function with an object of class 😉 you would follow the arrow right to find the method defined for the more general 😶 class. If no method is found, method dispatch has failed and an error is thrown. In practice, this means that you should alway define methods defined for the terminal nodes, i.e. those on the far right.</p>
<p>

There are two <strong>pseudo-classes</strong> that you can define methods for. These are called pseudo-classes because they don’t actually exist, but allow you to define useful behaviours. The first pseudo-class is <code>ANY</code> which matches any class<span id="fn125" class="footnote" data-pagedown-footnote-number="125" style="white-space: pre-line;">The S4 <code>ANY</code> pseudo-class plays the same role as the S3 <code>default</code> pseudo-class.</span>. For technical reasons that we’ll get to later, the link to the <code>ANY</code> method is longer than the links between the other classes:</p>
<p><img src="diagrams/s4/single-any.png" width="269" style="display: block; margin: auto;" /></p>

<p>The second pseudo-class is <code>MISSING</code>. If you define a method for this pseudo-class, it will match whenever the argument is missing. It’s not useful for single dispatch, but is important for functions like <code>+</code> and <code>-</code> that use double dispatch and behave differently depending on whether they have one or two arguments.</p>
</div>
<div id="multiple-inheritance" class="section level3">
<h3><span class="header-section-number">15.5.2</span> Multiple inheritance</h3>
<p>
</p>
<p>Things get more complicated when the class has multiple parents.</p>
<p><img src="diagrams/s4/multiple.png" width="179" style="display: block; margin: auto;" /></p>
<p>The basic process remains the same: you start from the actual class supplied to the generic, then follow the arrows until you find a defined method. The wrinkle is that now there are multiple arrows to follow, so you might find multiple methods. If that happens, you pick the method that is closest, i.e. requires travelling the fewest arrows.</p>
<p>NB: while the method graph is a powerful metaphor for understanding method dispatch, implementing it in this way would be rather inefficient, so the actual approach that S4 uses is somewhat different. You can read the details in <code>?Methods_Details</code></p>
<p>What happens if methods are the same distance? For example, imagine we’ve defined methods for 🕶 and 🙂, and we call the generic with 😎. Note that no method can be found for the 😶 class, which I’ll highlight with a red double outline.</p>
<p><img src="diagrams/s4/multiple-ambig.png" width="165" style="display: block; margin: auto;" /></p>
<p>This is called an <strong>ambiguous</strong> method, and in diagrams I’ll illustrate it with a thick dotted border. When this happens in R, you’ll get a warning, and the method for the class that comes earlier in the alphabet will be picked (this is effectively random and should not be relied upon). When you discover ambiguity you should always resolve it by providing a more precise method:</p>
<p><img src="diagrams/s4/multiple-ambig-2.png" width="165" style="display: block; margin: auto;" /></p>
<p>The fallback <code>ANY</code> method still exists but the rules are little more complex. As indicated by the wavy dotted lines, the <code>ANY</code> method is always considered further away than a method for a real class. This means that it will never contribute to ambiguity.</p>
<p><img src="diagrams/s4/multiple-any.png" width="241" style="display: block; margin: auto;" /></p>
<p>With multiple inheritances it is hard to simultaneously prevent ambiguity, ensure that every terminal method has an implementation, and minimise the number of defined methods (in order to benefit from OOP). For example, of the six ways to define only two methods for this call, only one is free from problems. For this reason, I recommend using multiple inheritance with extreme care: you will need to carefully think about the method graph and plan accordingly.</p>
<p><img src="diagrams/s4/multiple-all.png" width="416" style="display: block; margin: auto;" /></p>
</div>
<div id="multiple-dispatch" class="section level3">
<h3><span class="header-section-number">15.5.3</span> Multiple dispatch</h3>
<p>
</p>
<p>Once you understand multiple inheritance, understanding multiple dispatch is straightforward. You follow multiple arrows in the same way as previously, but now each method is specified by two classes (separated by a comma).</p>
<p><img src="diagrams/s4/single-single.png" width="316" style="display: block; margin: auto;" /></p>
<p>I’m not going to show examples of dispatching on more than two arguments, but you can follow the basic principles to generate your own method graphs.</p>
<p>The main difference between multiple inheritance and multiple dispatch is that there are many more arrows to follow. The following diagram shows four defined methods which produce two ambiguous cases:</p>
<p><img src="diagrams/s4/single-single-ambig.png" width="316" style="display: block; margin: auto;" /></p>
<p>Multiple dispatch tends to be less tricky to work with than multiple inheritance because there are usually fewer terminal class combinations. In this example, there’s only one. That means, at a minimum, you can define a single method and have default behaviour for all inputs.</p>
</div>
<div id="multiple-dispatch-and-multiple-inheritance" class="section level3">
<h3><span class="header-section-number">15.5.4</span> Multiple dispatch and multiple inheritance</h3>
<p>Of course you can combine multiple dispatch with multiple inheritance:</p>
<p><img src="diagrams/s4/single-multiple.png" width="307" style="display: block; margin: auto;" /></p>
<p>A still more complicated case dispatches on two classes, both of which have multiple inheritance:</p>
<p><img src="diagrams/s4/multiple-multiple.png" width="236" style="display: block; margin: auto;" /></p>
<p>As the method graph gets more and more complicated it gets harder and harder to predict which method will get called given a combination of inputs, and it gets harder and harder to make sure that you haven’t introduced ambiguity. If you have to draw diagrams to figure out what method is actually going to be called, it’s a strong indication that you should go back and simplify your design.</p>
</div>
<div id="exercises-50" class="section level3">
<h3><span class="header-section-number">15.5.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Draw the method graph for
<code>f(</code>😅, 😽<code>)</code>.</p></li>
<li><p>Draw the method graph for
<code>f(</code>😃, 😉, 😙<code>)</code>.</p></li>
<li><p>Take the last example which shows multiple dispatch over two classes that
use multiple inheritance. What happens if you define a method for all
terminal classes? Why does method dispatch not save us much work here?</p></li>
</ol>
</div>
</div>
<div id="s4-s3" class="section level2">
<h2><span class="header-section-number">15.6</span> S4 and S3</h2>
<p>
</p>
<p>When writing S4 code, you’ll often need to interact with existing S3 classes and generics. This section describes how S4 classes, methods, and generics interact with existing code.</p>
<div id="classes" class="section level3">
<h3><span class="header-section-number">15.6.1</span> Classes</h3>

<p>In <code>slots</code> and <code>contains</code> you can use S4 classes, S3 classes, or the implicit class (Section <a href="#implicit-class">13.7.1</a>) of a base type. To use an S3 class, you must first register it with <code>setOldClass()</code>. You call this function once for each S3 class, giving it the class attribute. For example, the following definitions are already provided by base R:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setOldClass</span>(<span class="st">&quot;data.frame&quot;</span>)
<span class="kw">setOldClass</span>(<span class="kw">c</span>(<span class="st">&quot;ordered&quot;</span>, <span class="st">&quot;factor&quot;</span>))
<span class="kw">setOldClass</span>(<span class="kw">c</span>(<span class="st">&quot;glm&quot;</span>, <span class="st">&quot;lm&quot;</span>))</code></pre>
<p>However, it’s generally better to be more specific and provide a full S4 definition with <code>slots</code> and a <code>prototype</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setClass</span>(<span class="st">&quot;factor&quot;</span>,
  <span class="dt">contains =</span> <span class="st">&quot;integer&quot;</span>,
  <span class="dt">slots =</span> <span class="kw">c</span>(
    <span class="dt">levels =</span> <span class="st">&quot;character&quot;</span>
  ),
  <span class="dt">prototype =</span> <span class="kw">structure</span>(
    <span class="kw">integer</span>(),
    <span class="dt">levels =</span> <span class="kw">character</span>()
  )
)
<span class="kw">setOldClass</span>(<span class="st">&quot;factor&quot;</span>, <span class="dt">S4Class =</span> <span class="st">&quot;factor&quot;</span>)</code></pre>
<p>Generally, these definitions should be provided by the creator of the S3 class. If you’re trying to build an S4 class on top of an S3 class provided by a package, you should request that the package maintainer add this call to their package, rather than adding it to your own code.</p>
<p>If an S4 object inherits from an S3 class or a base type, it will have a special virtual slot called <code>.Data</code>. This contains the underlying base type or S3 object: </p>
<pre class="sourceCode r"><code class="sourceCode r">RangedNumeric &lt;-<span class="st"> </span><span class="kw">setClass</span>(
  <span class="st">&quot;RangedNumeric&quot;</span>,
  <span class="dt">contains =</span> <span class="st">&quot;numeric&quot;</span>,
  <span class="dt">slots =</span> <span class="kw">c</span>(<span class="dt">min =</span> <span class="st">&quot;numeric&quot;</span>, <span class="dt">max =</span> <span class="st">&quot;numeric&quot;</span>),
  <span class="dt">prototype =</span> <span class="kw">structure</span>(<span class="kw">numeric</span>(), <span class="dt">min =</span> <span class="ot">NA_real_</span>, <span class="dt">max =</span> <span class="ot">NA_real_</span>)
)
rn &lt;-<span class="st"> </span><span class="kw">RangedNumeric</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">min =</span> <span class="dv">1</span>, <span class="dt">max =</span> <span class="dv">10</span>)
rn<span class="op">@</span>min
<span class="co">#&gt; [1] 1</span>
rn<span class="op">@</span>.Data
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</span></code></pre>
<p>It is possible to define S3 methods for S4 generics, and S4 methods for S3 generics (provided you’ve called <code>setOldClass()</code>). However, it’s more complicated than it might appear at first glance, so make sure you thoroughly read <code>?Methods_for_S3</code>.</p>
</div>
<div id="generics" class="section level3">
<h3><span class="header-section-number">15.6.2</span> Generics</h3>

<p>As well as creating a new generic from scratch, it’s also possible to convert an existing S3 generic to an S4 generic:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setGeneric</span>(<span class="st">&quot;mean&quot;</span>)</code></pre>
<p>In this case, the existing function becomes the default (<code>ANY</code>) method:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">selectMethod</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;ANY&quot;</span>)
<span class="co">#&gt; Method Definition (Class &quot;derivedDefaultMethod&quot;):</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; function (x, ...) </span>
<span class="co">#&gt; UseMethod(&quot;mean&quot;)</span>
<span class="co">#&gt; &lt;bytecode: 0x2eacd50&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Signatures:</span>
<span class="co">#&gt;         x    </span>
<span class="co">#&gt; target  &quot;ANY&quot;</span>
<span class="co">#&gt; defined &quot;ANY&quot;</span></code></pre>
<p>NB: <code>setMethod()</code> will automatically call <code>setGeneric()</code> if the first argument isn’t already a generic, enabling you to turn any existing function into an S4 generic. It is ok to convert an existing S3 generic to S4, but you should avoid converting regular functions to S4 generics in packages because that requires careful coordination if done by multiple packages.</p>
</div>
<div id="exercises-51" class="section level3">
<h3><span class="header-section-number">15.6.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What would a full <code>setOldClass()</code> definition look like for an ordered
factor? (i.e. add <code>slots</code> and <code>prototype</code> the definition above)</p></li>
<li><p>Define a <code>length</code> method for the <code>Person</code> class.</p></li>
</ol>
<!--chapter:end:S4.Rmd-->
</div>
</div>
</div>
<div id="oo-tradeoffs" class="section level1">
<h1><span class="header-section-number">16</span> Trade-offs</h1>
<div id="introduction-15" class="section level2">
<h2><span class="header-section-number">16.1</span> Introduction</h2>
<p>You now know about the three most important OOP toolkits available in R. Now that you understand their basic operation and the principles that underlie them, we can start to compare and contrast the systems in order to understand their strengths and weaknesses. This will help you pick the system that is most likely to solve new problems.</p>
<p>Overall, when picking an OO system, I recommend that you default to S3. S3 is simple, and widely used throughout base R and CRAN. While it’s far from perfect, its idiosyncrasies are well understood and there are known approaches to overcome most shortcomings. If you have an existing background in programming you are likely to lean towards R6, because it will feel familiar. I think you should resist this tendency for two reasons. Firstly, if you use R6 it’s very easy to create a non-idiomatic API that will feel very odd to native R users, and will have surprising pain points because of the reference semantics. Secondly, if you stick to R6, you’ll lose out on learning a new way of thinking about OOP that gives you a new set of tools for solving problems.</p>
<div id="outline-14" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#s3-s4">16.2</a> compares S3 and S4. In brief, S4 is more formal and
tends to require more upfront planning. That makes it more suitable for big
projects developed by teams, not individuals.</p></li>
<li><p>Section <a href="#s3-r6">16.3</a> compares S3 and R6. This section is quite long because
these two systems are fundamentally different and there are a number of
tradeoffs that you need to consider.</p></li>
</ul>
</div>
<div id="prerequisites-9" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>You need to be familiar with S3, S4, and R6, as discussed in the previous three chapters.</p>
</div>
</div>
<div id="s3-s4" class="section level2">
<h2><span class="header-section-number">16.2</span> S4 vs S3</h2>
<p>
</p>
<p>Once you’ve mastered S3, S4 is not too difficult to pick up: the underlying ideas are the same, S4 is just more formal, more strict, and more verbose. The strictness and formality of S4 make it well suited for large teams. Since more structure is provided by the system itself, there is less need for convention, and new contributors don’t need as much training. S4 tends to require more upfront design than S3, and this investment is more likely to pay off on larger projects where greater resources are available.</p>
<p>One large team effort where S4 is used to good effect is Bioconductor. Bioconductor is similar to CRAN: it’s a way of sharing packages amongst a wider audience. Bioconductor is smaller than CRAN (~1,300 vs ~10,000 packages, July 2017) and the packages tend to be more tightly integrated because of the shared domain and because Bioconductor has a stricter review process. Bioconductor packages are not required to use S4, but most will because the key data structures (e.g. SummarizedExperiment, IRanges, DNAStringSet) are built using S4.</p>
<p>S4 is also a good fit for complex systems of interrelated objects, and it’s possible to minimise code duplication through careful implementation of methods. The best example of such a system is the Matrix package <span class="citation">(Bates and Maechler <a href="#ref-Matrix">2018</a>)</span>. It is designed to efficiently store and compute with many different types of sparse and dense matrices. As of version 1.2.15, it defines 102 classes, 21 generic functions, and 1993 methods, and to give you some idea of the complexity, a small subset of the class graph is shown in Figure <a href="#fig:matrix-classes">16.1</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:matrix-classes"></span>
<img src="diagrams/s4/Matrix.png" alt="A small subset of the Matrix class graph showing the inheritance of sparse matrices. Each concrete class inherits from two virtual parents: one that describes how the data is stored (C = column oriented, R = row oriented, T = tagged) and one that describes any restriction on the matrix (s = symmetric, t = triangle, g = general)" width="80%" />
<p class="caption">
Figure 16.1: A small subset of the Matrix class graph showing the inheritance of sparse matrices. Each concrete class inherits from two virtual parents: one that describes how the data is stored (C = column oriented, R = row oriented, T = tagged) and one that describes any restriction on the matrix (s = symmetric, t = triangle, g = general)
</p>
</div>
<p>This domain is a good fit for S4 because there are often computational shortcuts for specific combinations of sparse matrices. S4 makes it easy to provide a general method that works for all inputs, and then provide more specialised methods where the inputs allow a more efficient implementation. This requires careful planning to avoid method dispatch ambiguity, but the planning pays off with higher performance.</p>
<p>The biggest challenge to using S4 is the combination of increased complexity and absence of a single source of documentation. S4 is a complex system and it can be challenging to use effectively in practice. This wouldn’t be such a problem if S4 documentation wasn’t scattered through R documentation, books, and websites. S4 needs a book length treatment, but that book does not (yet) exist. (The documentation for S3 is no better, but the lack is less painful because S3 is much simpler.)</p>
</div>
<div id="s3-r6" class="section level2">
<h2><span class="header-section-number">16.3</span> R6 vs S3</h2>
<p>
</p>
<p>R6 is a profoundly different OO system from S3 and S4 because it is built on encapsulated objects, rather than generic functions. Additionally R6 objects have reference semantics, which means that they can be modified in place. These two big differences have a number of non-obvious consequences which we’ll explore here:</p>
<ul>
<li><p>A generic is a regular function so it lives in the global namespace. An R6 method
belongs to an object so it lives in a local namespace. This influences how we
think about naming.</p></li>
<li><p>R6’s reference semantics allow methods to simultaneously return a value
and modify an object. This solves a painful problem called “threading state”.</p></li>
<li><p>You invoke an R6 method using <code>$</code>, which is an infix operator. If you set up
your methods correctly you can use chains of method calls as an alternative
to the pipe.</p></li>
</ul>
<p>These are general trade-offs between functional and encapsulated OOP, so they also serve as a discussion of system design in R vs Python.</p>
<div id="namespacing" class="section level3">
<h3><span class="header-section-number">16.3.1</span> Namespacing</h3>
<p>One non-obvious difference between S3 and R6 is the “space” in which methods are found:</p>
<ul>
<li>Generic functions are global: all packages share the same namespace.</li>
<li>Encapsulated methods are local: methods are bound to a single object.</li>
</ul>
<p>The advantage of a global namespace is that multiple packages can use the same verbs for working with different types of objects. Generic functions provide a uniform API that makes it easier to perform typical actions with a new object because there are strong naming conventions. This works well for data analysis because you often want to do the same thing to different types of objects. In particular, this is one reason that R’s modelling system is so useful: regardless of where the model has been implemented you always work with it using the same set of tools (<code>summary()</code>, <code>predict()</code>, …).</p>
<p>The disadvantage of a global namespace is that it forces you to think more deeply about naming. You want to avoid multiple generics with the same name in different packages because it requires the user to type <code>::</code> frequently. This can be hard because function names are usually English verbs, and verbs often have multiple meanings. Take <code>plot()</code> for example:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(data)       <span class="co"># plot some data</span>
<span class="kw">plot</span>(bank_heist) <span class="co"># plot a crime</span>
<span class="kw">plot</span>(land)       <span class="co"># create a new plot of land</span>
<span class="kw">plot</span>(movie)      <span class="co"># extract plot of a movie</span></code></pre>
<p>Generally, you should avoid methods that are homonyms of the original generic, and instead define a new generic.</p>
<p>This problem doesn’t occur with R6 methods because they are scoped to the object. The following code is fine, because there is no implication that the plot method of two different R6 objects has the same meaning:</p>
<pre class="sourceCode r"><code class="sourceCode r">data<span class="op">$</span><span class="kw">plot</span>()
bank_heist<span class="op">$</span><span class="kw">plot</span>()
land<span class="op">$</span><span class="kw">plot</span>()
movie<span class="op">$</span><span class="kw">plot</span>()</code></pre>
<p>These considerations also apply to the arguments to the generic. S3 generics must have the same core arguments, which mean they generally have non-specific names like <code>x</code> or <code>.data</code>. S3 generics generally need <code>...</code> to pass on additional arguments to methods, but this has the downside that misspelled argument names will not create an error. In comparison, R6 methods can vary more widely and use more specific and evocative argument names.</p>
<p>A secondary advantage of local namespacing is that creating an R6 method is very cheap. Most encapsulated OO languages encourage you to create many small methods, each doing one thing well with an evocative name. Creating a new S3 method is more expensive, because you may also have to create a generic, and think about the naming issues described above. That means that the advice to create many small methods does not apply to S3. It’s still a good idea to break your code down into small, easily understood chunks, but they should generally just be regular functions, not methods.</p>
</div>
<div id="threading-state" class="section level3">
<h3><span class="header-section-number">16.3.2</span> Threading state</h3>
<p>
</p>
<p>One challenge of programming with S3 is when you want to both return a value and modify the object. This violates our guideline that a function should either be called for its return value or for its side effects, but is necessary in a handful of cases.</p>
<p>For example, imagine you want to create a <strong>stack</strong> of objects. A stack has two main methods:</p>
<ul>
<li><code>push()</code> adds a new object to the top of the stack.</li>
<li><code>pop()</code> returns the top most value, and removes it from the stack.</li>
</ul>
<p>The implementation of the constructor and the <code>push()</code> method is straightforward. A stack contains a list of items, and pushing an object to the stack simply appends to this list.</p>
<pre class="sourceCode r"><code class="sourceCode r">new_stack &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">items =</span> <span class="kw">list</span>()) {
  <span class="kw">structure</span>(<span class="kw">list</span>(<span class="dt">items =</span> items), <span class="dt">class =</span> <span class="st">&quot;stack&quot;</span>)
}

push &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  x<span class="op">$</span>items &lt;-<span class="st"> </span><span class="kw">c</span>(x<span class="op">$</span>items, <span class="kw">list</span>(y))
  x
}</code></pre>
<p>(I haven’t created a real method for <code>push()</code> because making it generic would just make this example more complicated for no real benefit.)</p>
<p>Implementing <code>pop()</code> is more challenging because it has to both return a value (the object at the top of the stack), and have a side-effect (remove that object from that top). Since we can’t modify the input object in S3 we need to return two things: the value, and the updated object.</p>
<pre class="sourceCode r"><code class="sourceCode r">pop &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x<span class="op">$</span>items)
  
  item &lt;-<span class="st"> </span>x<span class="op">$</span>items[[n]]
  x<span class="op">$</span>items &lt;-<span class="st"> </span>x<span class="op">$</span>items[<span class="op">-</span>n]
  
  <span class="kw">list</span>(<span class="dt">item =</span> item, <span class="dt">x =</span> x)
}</code></pre>
<p>This leads to rather awkward usage:</p>
<pre class="sourceCode r"><code class="sourceCode r">s &lt;-<span class="st"> </span><span class="kw">new_stack</span>()
s &lt;-<span class="st"> </span><span class="kw">push</span>(s, <span class="dv">10</span>)
s &lt;-<span class="st"> </span><span class="kw">push</span>(s, <span class="dv">20</span>)

out &lt;-<span class="st"> </span><span class="kw">pop</span>(s)
out<span class="op">$</span>item
<span class="co">#&gt; [1] 20</span>
s &lt;-<span class="st"> </span>out<span class="op">$</span>x
s
<span class="co">#&gt; $items</span>
<span class="co">#&gt; $items[[1]]</span>
<span class="co">#&gt; [1] 10</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;stack&quot;</span></code></pre>
<p>This problem is known as <strong>threading state</strong> or <strong>accumulator programming</strong>, because no matter how deeply the <code>pop()</code> is called, you have to thread the modified stack object all the way back to where it lives.</p>
<p>

One way that other FP languages deal with this challenge is to provide a <strong>multiple assign</strong> (or destructuring bind) operator that allows you to assign multiple values in a single step. The zeallot package <span class="citation">(Teetor <a href="#ref-zeallot">2018</a>)</span> provides multi-assign for R with <code>%&lt;-%</code>. This makes the code more elegant, but doesn’t solve the key problem:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(zeallot)

<span class="kw">c</span>(value, s) <span class="op">%&lt;-%</span><span class="st"> </span><span class="kw">pop</span>(s)
value
<span class="co">#&gt; [1] 10</span></code></pre>
<p>An R6 implementation of a stack is simpler because <code>$pop()</code> can modify the object in place, and return only the top-most value:</p>
<pre class="sourceCode r"><code class="sourceCode r">Stack &lt;-<span class="st"> </span>R6<span class="op">::</span><span class="kw">R6Class</span>(<span class="st">&quot;Stack&quot;</span>, <span class="kw">list</span>(
  <span class="dt">items =</span> <span class="kw">list</span>(),
  <span class="dt">push =</span> <span class="cf">function</span>(x) {
    self<span class="op">$</span>items &lt;-<span class="st"> </span><span class="kw">c</span>(self<span class="op">$</span>items, x)
    <span class="kw">invisible</span>(self)
  },
  <span class="dt">pop =</span> <span class="cf">function</span>() {
    item &lt;-<span class="st"> </span>self<span class="op">$</span>items[[self<span class="op">$</span><span class="kw">length</span>()]]
    self<span class="op">$</span>items &lt;-<span class="st"> </span>self<span class="op">$</span>items[<span class="op">-</span>self<span class="op">$</span><span class="kw">length</span>()]
    item
  },
  <span class="dt">length =</span> <span class="cf">function</span>() {
    <span class="kw">length</span>(self<span class="op">$</span>items)
  }
))</code></pre>
<p>This leads to more natural code:</p>
<pre class="sourceCode r"><code class="sourceCode r">s &lt;-<span class="st"> </span>Stack<span class="op">$</span><span class="kw">new</span>()
s<span class="op">$</span><span class="kw">push</span>(<span class="dv">10</span>)
s<span class="op">$</span><span class="kw">push</span>(<span class="dv">20</span>)
s<span class="op">$</span><span class="kw">pop</span>()
<span class="co">#&gt; [1] 20</span></code></pre>
<p>I encountered a real-life example of threading state in ggplot2 scales. Scales are complex because they need to combine data across every facet and every layer. I originally used S3 classes, but it required passing scale data to and from many functions. Switching to R6 made the code substantially simpler. However, it also introduced some problems because I forgot to call to <code>$clone()</code> when modifying a plot. This allowed independent plots to share the same scale data, creating a subtle bug that was hard to track down.</p>
</div>
<div id="tradeoffs-pipe" class="section level3">
<h3><span class="header-section-number">16.3.3</span> Method chaining</h3>
<p>
</p>
<p>The pipe, <code>%&gt;%</code>, is useful because it provides an infix operator that makes it easy to compose functions from left-to-right. Interestingly, the pipe is not so important for R6 objects because they already use an infix operator: <code>$</code>. This allows the user to chain together multiple method calls in a single expression, a technique known as <strong>method chaining</strong>:</p>
<pre class="sourceCode r"><code class="sourceCode r">s &lt;-<span class="st"> </span>Stack<span class="op">$</span><span class="kw">new</span>()
s<span class="op">$</span>
<span class="st">  </span><span class="kw">push</span>(<span class="dv">10</span>)<span class="op">$</span>
<span class="st">  </span><span class="kw">push</span>(<span class="dv">20</span>)<span class="op">$</span>
<span class="st">  </span><span class="kw">pop</span>()
<span class="co">#&gt; [1] 20</span></code></pre>
<p>This technique is commonly used in other programming languages, like Python and JavaScript, and is made possible with one convention: any R6 method that is primarily called for its side-effects (usually modifying the object) should return <code>invisible(self)</code>.</p>
<p>The primary advantage of method chaining is that you can get useful autocomplete; the primary disadvantage is that only the creator of the class can add new methods (and there’s no way to use multiple dispatch).</p>
<!--chapter:end:OO-tradeoffs.Rmd-->
</div>
</div>
</div>
<div id="part-metaprogramming" class="section level1 unnumbered">
<h1><span class="header-section-number">IV</span> Metaprogramming</h1>
</div>
<div id="introduction-16" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>
</p>
<p>One of the most intriguing things about R is its capability for <strong>metaprogramming</strong>: the idea that code is itself data, and can be inspected and modified programmatically. This is a powerful idea and deeply influences much R code. At a simple level it allows you to write <code>library(purrr)</code> instead of <code>library(&quot;purrr&quot;)</code> and enables <code>plot(x, sin(x))</code> to label the axes with <code>x</code> and <code>sin(x)</code>. At a deeper level it allows <code>y ~ x1 + x2</code> to represent a model that predicts the value of <code>y</code> from <code>x1</code> and <code>x2</code>, <code>subset(df, x == y)</code> to be translated to <code>df[df$x == df$y, , drop = FALSE]</code>, and <code>dplyr::filter(db, is.na(x))</code> to generate the SQL <code>WHERE x IS NULL</code> when <code>db</code> is a remote database table.</p>
<p>Closely related to metaprogramming is <strong>non-standard evaluation</strong>, or NSE for short. This term is commonly used to describe the behaviour of R functions, but there are two problems with it. Firstly, NSE is actually a property of an argument (or arguments) of a function, so talking about NSE functions is a little sloppy. Secondly, it’s confusing to define something by what it is not (standard), so in this book I’ll teach you more precise vocabulary.</p>
<p>Specifically, this book focuses on tidy evaluation (sometimes called tidy eval for short). Tidy evaluation is implemented in the rlang package <span class="citation">(Henry and Wickham <a href="#ref-rlang">2018</a><a href="#ref-rlang">b</a>)</span>, and I’ll use rlang extensively in these chapters. This will allow you to focus on the big ideas, without being distracted by implementation quirks that arise from R’s history. After I introduce each big idea with rlang, I’ll then circle back to talk about how those ideas are expressed in base R. This approach seems backward to some, but it’s analogous to learning how to drive an automatic transmission before a manual one so you can focus on the big picture before learning the details. This book focusses on the theoretical side of tidy evaluation, so you can fully understand how it works from the ground up. If you are looking for a practical introduction, I recommend the “tidy evaluation book”, <a href="https://tidyeval.tidyverse.org" class="uri">https://tidyeval.tidyverse.org</a><span id="fn126" class="footnote" data-pagedown-footnote-number="126" style="white-space: pre-line;">The tidy evaluation book is a work-in-progress at the time I wrote this chapter, but will hopefully be finished by the time you read it.</span>.</p>
<p>You’ll learn about metaprogramming and tidy evaluation in the following five chapters:</p>
<ul>
<li><p>In <strong>Big picture</strong>, Chapter <a href="#meta-big-picture">17</a>, you’ll get a glimpse of
the whole metaprogramming story, briefly learning about each of the major
components and how they fit together into a cohesive whole.</p></li>
<li><p>In <strong>Expressions</strong>, Chapter <a href="#expressions">18</a>, you’ll learn that all R code
can be described as a tree. You’ll learn how to visualise that tree, how the
rules of R’s grammar convert linear sequences of characters into a tree, and
how to use recursive functions to work with code trees.</p></li>
<li><p>In <strong>Quasiquotation</strong>, Chapter <a href="#quasiquotation">19</a>, you’ll learn to use
tools from rlang to capture (“quote”) unevaluated function arguments. You’ll
also learn about quasiquotation, which provides a set of techniques for
“unquoting” input that makes it possible to easily generate new trees from
code fragments.</p></li>
<li><p>In <strong>Evaluation</strong>, Chapter <a href="#evaluation">20</a>, you’ll learn how to evaluate
captured code. Here you’ll learn about an important data structure, the
<strong>quosure</strong>, which ensures correct evaluation by capturing both the code
to evaluate, and the environment in which to evaluate it. This chapter will
show you how to put all the pieces together to understand how NSE in base
R works, and how to write your own functions that work like <code>subset()</code>.</p></li>
<li><p>Finally, in <strong>Translating R code</strong>, Chapter <a href="#translation">21</a>, you’ll see
how to combine first-class environments, lexical scoping, and metaprogramming
to translate R code into other languages, namely HTML and LaTeX.</p></li>
</ul>
<!--chapter:end:Meta.Rmd-->
</div>
<div id="meta-big-picture" class="section level1">
<h1><span class="header-section-number">17</span> Big picture</h1>
<div id="introduction-17" class="section level2">
<h2><span class="header-section-number">17.1</span> Introduction</h2>
<p>Metaprogramming is the hardest topic in this book because it brings together many formerly unrelated topics and forces you grapple with issues that you probably haven’t thought about before. You’ll also need to learn a lot of new vocabulary, and at first it will seem like every new term is defined by three other terms that you haven’t heard of. Even if you’re an experienced programmer in another language, your existing skills are unlikely to be much help as few modern popular languages expose the level of metaprogramming that R provides. So don’t be surprised if you’re frustrated or confused at first; this is a natural part of the process that happens to everyone!</p>
<p>But I think it’s easier to learn metaprogramming now than ever before. Over the last few years, the theory and practice have matured substantially, providing a strong foundation paired with tools that allow you to solve common problems. In this chapter, you’ll get the big picture of all the main pieces and how they fit together.</p>
<div id="outline-15" class="section level3 unnumbered">
<h3>Outline</h3>
<p>Each section in this chapter introduces one big new idea:</p>
<ul>
<li><p>Section <a href="#code-data">17.2</a>: Code is data and captured code is called an
expression.</p></li>
<li><p>Section <a href="#code-tree">17.3</a>: Code has a tree-like structure called an
abstract syntax tree.</p></li>
<li><p>Section <a href="#coding-code">17.4</a>: Code can create new expressions programmatically.</p></li>
<li><p>Section <a href="#eval-intro">17.5</a>: To “execute” code, you evaluate an expression in
an environment.</p></li>
<li><p>Section <a href="#eval-funs">17.6</a>: You can customise evaluation by supplying custom
functions in a new environment.</p></li>
<li><p>Section <a href="#eval-data">17.7</a>: You can also customise evaluation by supplying a
data mask, which blurs the line between environments and data frames.</p></li>
<li><p>Section <a href="#quosure-intro">17.8</a>: All this is made simpler (and more correct)
with a new data structure called the quosure.</p></li>
</ul>
</div>
<div id="prerequisites-10" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>This chapter introduces the big ideas using rlang; you’ll learn the base equivalents in later chapters. We’ll also use the lobstr package to explore the tree structure of code.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)
<span class="kw">library</span>(lobstr)</code></pre>
<p>Make sure that you’re also familiar with the environment (Section <a href="#env-basics">7.2</a>) and data frame (Section <a href="#tibble">3.6</a>) data structures.</p>
</div>
</div>
<div id="code-data" class="section level2">
<h2><span class="header-section-number">17.2</span> Code is data</h2>
<p>The first big idea is that code is data: you can capture code and compute on it like any other type of data. The first way you can to capture code is with <code>rlang::expr()</code>. You can think of <code>expr()</code> as returning exactly what you pass in:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr</span>(<span class="kw">mean</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; mean(x, na.rm = TRUE)</span>
<span class="kw">expr</span>(<span class="dv">10</span> <span class="op">+</span><span class="st"> </span><span class="dv">100</span> <span class="op">+</span><span class="st"> </span><span class="dv">1000</span>)
<span class="co">#&gt; 10 + 100 + 1000</span></code></pre>
<p>More formally, captured code is called an <strong>expression</strong>. An expression isn’t a single type of object, but is a collective term for any of four types (call, symbol, constant, or pairlist), which you’ll learn more about in Chapter <a href="#expressions">18</a>.</p>
<p><code>expr()</code> lets you capture code that you’ve typed. You need a different tool to capture code passed to a function because <code>expr()</code> doesn’t work:</p>
<pre class="sourceCode r"><code class="sourceCode r">capture_it &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">expr</span>(x)
}
<span class="kw">capture_it</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c)
<span class="co">#&gt; x</span></code></pre>
<p>Here you need to use a function specifically designed to capture user input in a function argument: <code>enexpr()</code>. Think of the “en” like in “enrich”: <code>enexpr()</code> takes a lazily evaluted argument and turns it into an expression:</p>
<pre class="sourceCode r"><code class="sourceCode r">capture_it &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">enexpr</span>(x)
}
<span class="kw">capture_it</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c)
<span class="co">#&gt; a + b + c</span></code></pre>
<p>Because <code>capture_it()</code> uses <code>enexpr()</code> we say that it automatically “quotes” its first argument. You’ll learn more about this term in Section <a href="#vocabulary">19.2.1</a>.</p>
<p>Once you have captured an expression, you can inspect and modify it. Complex expressions behave much like lists. That means you can modify them using <code>[[</code> and <code>$</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">f</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>))

<span class="co"># Add a new argument</span>
f<span class="op">$</span>z &lt;-<span class="st"> </span><span class="dv">3</span>
f
<span class="co">#&gt; f(x = 1, y = 2, z = 3)</span>

<span class="co"># Or remove an argument:</span>
f[[<span class="dv">2</span>]] &lt;-<span class="st"> </span><span class="ot">NULL</span>
f
<span class="co">#&gt; f(y = 2, z = 3)</span></code></pre>
<p>The first element of the call is the function to be called, which means the first argument is in the second position. You’ll learn the full details in Section <a href="#expression-details">18.3</a>.</p>
</div>
<div id="code-tree" class="section level2">
<h2><span class="header-section-number">17.3</span> Code is a tree</h2>
<p>To do more complex manipulation with expressions, you need to fully understand their structure. Behind the scenes, almost every programming language represents code as a tree, often called the <strong>abstract syntax tree</strong>, or AST for short. R is unusual in that you can actually inspect and manipulate this tree.</p>
<p>A very convenient tool for understanding the tree-like structure is <code>lobstr::ast()</code>. Given some code, this function displays the underlying tree structure. Function calls form the branches of the tree, and are shown by rectangles. The leaves of the tree are symbols (like <code>a</code>) and constants (like <code>&quot;b&quot;</code>).</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">f</span>(a, <span class="st">&quot;b&quot;</span>))
<span class="co">#&gt; █─f </span>
<span class="co">#&gt; ├─a </span>
<span class="co">#&gt; └─&quot;b&quot;</span></code></pre>
<p>Nested function calls create more deeply branching trees:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">f1</span>(<span class="kw">f2</span>(a, b), <span class="kw">f3</span>(<span class="dv">1</span>, <span class="kw">f4</span>(<span class="dv">2</span>))))
<span class="co">#&gt; █─f1 </span>
<span class="co">#&gt; ├─█─f2 </span>
<span class="co">#&gt; │ ├─a </span>
<span class="co">#&gt; │ └─b </span>
<span class="co">#&gt; └─█─f3 </span>
<span class="co">#&gt;   ├─1 </span>
<span class="co">#&gt;   └─█─f4 </span>
<span class="co">#&gt;     └─2</span></code></pre>
<p>Because all function forms in can be written in prefix form (Section <a href="#prefix-form">6.8.2</a>), every R expression can be displayed in this way:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="dv">3</span>)
<span class="co">#&gt; █─`+` </span>
<span class="co">#&gt; ├─1 </span>
<span class="co">#&gt; └─█─`*` </span>
<span class="co">#&gt;   ├─2 </span>
<span class="co">#&gt;   └─3</span></code></pre>
<p>Displaying the AST in this way is a useful tool for exploring R’s grammar, the topic of Section <a href="#grammar">18.4</a>.</p>
</div>
<div id="coding-code" class="section level2">
<h2><span class="header-section-number">17.4</span> Code can generate code</h2>
<p>As well as seeing the tree from code typed by a human, you can also use code to create new trees. There are two main tools: <code>call2()</code> and unquoting.</p>
<p><code>rlang::call2()</code> constructs a function call from its components: the function to call, and the arguments to call it with.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">call2</span>(<span class="st">&quot;f&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="co">#&gt; f(1, 2, 3)</span>
<span class="kw">call2</span>(<span class="st">&quot;+&quot;</span>, <span class="dv">1</span>, <span class="kw">call2</span>(<span class="st">&quot;*&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>))
<span class="co">#&gt; 1 + 2 * 3</span></code></pre>
<p><code>call2()</code> is often convenient to program with, but is a bit clunky for interactive use. An alternative technique is to build complex code trees by combining simpler code trees with a template. <code>expr()</code> and <code>enexpr()</code> have built-in support for this idea via <code>!!</code> (pronounced bang-bang), the <strong>unquote operator</strong>.</p>
<p>The precise details are the topic of Section <a href="#unquoting">19.4</a>, but basically <code>!!x</code> inserts the code tree stored in <code>x</code> into the expression. This makes it easy to build complex trees from simple fragments:</p>
<pre class="sourceCode r"><code class="sourceCode r">xx &lt;-<span class="st"> </span><span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>x)
yy &lt;-<span class="st"> </span><span class="kw">expr</span>(y <span class="op">+</span><span class="st"> </span>y)

<span class="kw">expr</span>(<span class="op">!!</span>xx <span class="op">/</span><span class="st"> </span><span class="op">!!</span>yy)
<span class="co">#&gt; (x + x)/(y + y)</span></code></pre>
<p>Notice that the output preserves the operator precedence so we get <code>(x + x) / (y + y)</code> not <code>x + x / y + y</code> (i.e. <code>x + (x / y) + y</code>). This is important, particularly if you’ve been wondering if it wouldn’t be easier to just paste strings together.</p>
<p>Unquoting gets even more useful when you wrap it up into a function, first using <code>enexpr()</code> to capture the user’s expression, then <code>expr()</code> and <code>!!</code> to create an new expression using a template. The example below shows how you can generate an expression that computes the coefficient of variation:</p>
<pre class="sourceCode r"><code class="sourceCode r">cv &lt;-<span class="st"> </span><span class="cf">function</span>(var) {
  var &lt;-<span class="st"> </span><span class="kw">enexpr</span>(var)
  <span class="kw">expr</span>(<span class="kw">sd</span>(<span class="op">!!</span>var) <span class="op">/</span><span class="st"> </span><span class="kw">mean</span>(<span class="op">!!</span>var))
}

<span class="kw">cv</span>(x)
<span class="co">#&gt; sd(x)/mean(x)</span>
<span class="kw">cv</span>(x <span class="op">+</span><span class="st"> </span>y)
<span class="co">#&gt; sd(x + y)/mean(x + y)</span></code></pre>
<p>(This isn’t very useful here, but being able to create this sort of building block is very useful when solving more complex problems.)</p>
<p>Importantly, this works even when given weird variable names:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cv</span>(<span class="st">`</span><span class="dt">)</span><span class="st">`</span>)
<span class="co">#&gt; sd(`)`)/mean(`)`)</span></code></pre>
<p>Dealing with weird names<span id="fn127" class="footnote" data-pagedown-footnote-number="127" style="white-space: pre-line;">More technically, these are called non-syntactic names and are the topic of Section <a href="#non-syntactic">2.2.1</a>.</span> is another good reason to avoid <code>paste()</code> when generating R code. You might think this is an esoteric concern, but not worrying about it when generating SQL code in web applications led to SQL injection attacks that have collectively cost billions of dollars.</p>
</div>
<div id="eval-intro" class="section level2">
<h2><span class="header-section-number">17.5</span> Evaluation runs code</h2>
<p>Inspecting and modifying code gives you one set of powerful tools. You get another set of powerful tools when you <strong>evaluate</strong>, i.e. execute or run, an expression. Evaluating an expression requires an environment, which tells R what the symbols mean in the expression mean. You’ll learn the details of evaluation in Chapter <a href="#evaluation">20</a>.</p>
<p>The primary tool for evaluating expressions is <code>base::eval()</code>, which takes an expression and an environment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">10</span>))
<span class="co">#&gt; [1] 11</span>
<span class="kw">eval</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">2</span>, <span class="dt">y =</span> <span class="dv">100</span>))
<span class="co">#&gt; [1] 102</span></code></pre>
<p>If you omit the environment, <code>eval</code> uses the current environment:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
y &lt;-<span class="st"> </span><span class="dv">100</span>
<span class="kw">eval</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y))
<span class="co">#&gt; [1] 110</span></code></pre>
<p>One of the big advantages of evaluating code manually is that you can tweak the environment. There are two main reasons to do this:</p>
<ul>
<li>To temporarily override functions to implement a domain specific language.</li>
<li>To add a data mask so you can to refer to variables in a data frame as if
they are variables in an environment.</li>
</ul>
</div>
<div id="eval-funs" class="section level2">
<h2><span class="header-section-number">17.6</span> Customising evaluation with functions</h2>
<p>The above example used an environment that bound <code>x</code> and <code>y</code> to vectors. It’s less obvious that you also bind names to functions, allowing you to override the behaviour of existing functions. This is a big idea that we’ll come back to in Chapter <a href="#translation">21</a> where I explore generating HTML and LaTeX from R. The example below gives you a taste of the power. Here I evalute code in a special environment where <code>*</code> and <code>+</code> have been overridden to work with strings instead of numbers:</p>
<pre class="sourceCode r"><code class="sourceCode r">string_math &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  e &lt;-<span class="st"> </span><span class="kw">env</span>(
    <span class="kw">caller_env</span>(),
    <span class="st">`</span><span class="dt">+</span><span class="st">`</span> =<span class="st"> </span><span class="cf">function</span>(x, y) <span class="kw">paste0</span>(x, y),
    <span class="st">`</span><span class="dt">*</span><span class="st">`</span> =<span class="st"> </span><span class="cf">function</span>(x, y) <span class="kw">strrep</span>(x, y)
  )

  <span class="kw">eval</span>(<span class="kw">enexpr</span>(x), e)
}

name &lt;-<span class="st"> &quot;Hadley&quot;</span>
<span class="kw">string_math</span>(<span class="st">&quot;Hello &quot;</span> <span class="op">+</span><span class="st"> </span>name)
<span class="co">#&gt; [1] &quot;Hello Hadley&quot;</span>
<span class="kw">string_math</span>((<span class="st">&quot;x&quot;</span> <span class="op">*</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> &quot;-y&quot;</span>) <span class="op">*</span><span class="st"> </span><span class="dv">3</span>)
<span class="co">#&gt; [1] &quot;xx-yxx-yxx-y&quot;</span></code></pre>
<p>dplyr takes this idea to the extreme, running code in an environment that generates SQL for execution in a remote database:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="co">#&gt; </span>
<span class="co">#&gt; Attaching package: &#39;dplyr&#39;</span>
<span class="co">#&gt; The following objects are masked from &#39;package:stats&#39;:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     filter, lag</span>
<span class="co">#&gt; The following objects are masked from &#39;package:base&#39;:</span>
<span class="co">#&gt; </span>
<span class="co">#&gt;     intersect, setdiff, setequal, union</span>

con &lt;-<span class="st"> </span>DBI<span class="op">::</span><span class="kw">dbConnect</span>(RSQLite<span class="op">::</span><span class="kw">SQLite</span>(), <span class="dt">filename =</span> <span class="st">&quot;:memory:&quot;</span>)
mtcars_db &lt;-<span class="st"> </span><span class="kw">copy_to</span>(con, mtcars)

mtcars_db <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(cyl <span class="op">&gt;</span><span class="st"> </span><span class="dv">2</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(mpg<span class="op">:</span>hp) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">show_query</span>()
<span class="co">#&gt; &lt;SQL&gt;</span>
<span class="co">#&gt; SELECT `mpg`, `cyl`, `disp`, `hp`</span>
<span class="co">#&gt; FROM `mtcars`</span>
<span class="co">#&gt; WHERE (`cyl` &gt; 2.0)</span>
<span class="co">#&gt; LIMIT 10</span>

DBI<span class="op">::</span><span class="kw">dbDisconnect</span>(con)</code></pre>
</div>
<div id="eval-data" class="section level2">
<h2><span class="header-section-number">17.7</span> Customising evaluation with data</h2>
<p>Rebinding functions is an extremely powerful technique, but it tends to require a lot of investment. A more immediately practical application is modifying evaluation to look for variables in a data frame instead of an environment. This idea powers the base <code>subset()</code> and <code>transform()</code> functions, as well as many tidyverse functions like <code>ggplot2::aes()</code> and <code>dplyr::mutate()</code>. It’s possible to use <code>eval()</code> for this, but there are a few potential pitfalls (Section <a href="#base-evaluation">20.6</a>), so we’ll switch to <code>rlang::eval_tidy()</code> instead.</p>
<p>As well as expression and environment, <code>eval_tidy()</code> also takes a <strong>data mask</strong>, which is typically a data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">y =</span> <span class="kw">sample</span>(<span class="dv">5</span>))
<span class="kw">eval_tidy</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y), df)
<span class="co">#&gt; [1] 2 6 5 9 8</span></code></pre>
<p>Evaluating with a data mask is a useful technique for interactive analysis because it allows you to write <code>x + y</code> rather than <code>df$x + df$y</code>. However, that convenience comes at a cost: ambiguity. In Section <a href="#data-masks">20.4</a> you’ll learn how to deal ambiguity using special <code>.data</code> and <code>.env</code> pronouns.</p>
<p>We can wrap this pattern up into a function by using <code>enexpr()</code>. This gives us a function very similar to <code>base::with()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">with2 &lt;-<span class="st"> </span><span class="cf">function</span>(df, expr) {
  <span class="kw">eval_tidy</span>(<span class="kw">enexpr</span>(expr), df)
}

<span class="kw">with2</span>(df, x <span class="op">+</span><span class="st"> </span>y)
<span class="co">#&gt; [1] 2 6 5 9 8</span></code></pre>
<p>Unfortunately, this function has a subtle bug and we need a new data structure to help deal with it.</p>
</div>
<div id="quosure-intro" class="section level2">
<h2><span class="header-section-number">17.8</span> Quosures</h2>
<p>To make the problem more obvious, I’m going to modify <code>with2()</code>. The basic problem still occurs without this modification but it’s much harder to see.</p>
<pre class="sourceCode r"><code class="sourceCode r">with2 &lt;-<span class="st"> </span><span class="cf">function</span>(df, expr) {
  a &lt;-<span class="st"> </span><span class="dv">1000</span>
  <span class="kw">eval_tidy</span>(<span class="kw">enexpr</span>(expr), df)
}</code></pre>
<p>We can see the problem when we use <code>with2()</code> to refer to a variable called <code>a</code>. We want the value of <code>a</code> to come from the binding we can see (10), not the binding internal to the function (1000):</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
a &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">with2</span>(df, x <span class="op">+</span><span class="st"> </span>a)
<span class="co">#&gt; [1] 1001 1002 1003</span></code></pre>
<p>The problem arises because we need to evaluate the captured expression in the environment where it was written (where <code>a</code> is 10), not the environment inside of <code>with2()</code> (where <code>a</code> is 1000).</p>
<p>Fortunately we call solve this problem by using a new data structure: the <strong>quosure</strong> which bundles an expression with an environment. <code>eval_tidy()</code> knows how to work with quosures so all we need to do is switch out <code>enexpr()</code> for <code>enquo()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">with2 &lt;-<span class="st"> </span><span class="cf">function</span>(df, expr) {
  a &lt;-<span class="st"> </span><span class="dv">1000</span>
  <span class="kw">eval_tidy</span>(<span class="kw">enquo</span>(expr), df)
}

<span class="kw">with2</span>(df, x <span class="op">+</span><span class="st"> </span>a)
<span class="co">#&gt; [1] 11 12 13</span></code></pre>
<p>Whenever you use a data mask, you must always use <code>enquo()</code> instead of <code>enexpr()</code>. This is the topic of Chapter <a href="#evaluation">20</a>.</p>
<!--chapter:end:Big-picture.Rmd-->
</div>
</div>
<div id="expressions" class="section level1">
<h1><span class="header-section-number">18</span> Expressions</h1>
<div id="introduction-18" class="section level2">
<h2><span class="header-section-number">18.1</span> Introduction</h2>
<p></p>
<p>To compute on the language, we first need to understand its structure. That requires some new vocabulary, some new tools, and some new ways of thinking about R code. The first of these is the distinction between an operation and its result. Take the following code, which multiplies a variable <code>x</code> by 10 and saves the result to a new variable called <code>y</code>. It doesn’t work because we haven’t defined a variable called <code>x</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span>x <span class="op">*</span><span class="st"> </span><span class="dv">10</span>
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;x&#39; not found</span></code></pre>
<p>It would be nice if we could capture the intent of the code without executing it. In other words, how can we separate our description of the action from the action itself?</p>
<p>One way is to use <code>rlang::expr()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">expr</span>(y &lt;-<span class="st"> </span>x <span class="op">*</span><span class="st"> </span><span class="dv">10</span>)
z
<span class="co">#&gt; y &lt;- x * 10</span></code></pre>
<p><code>expr()</code> returns an expression, an object that captures the structure of the code without evaluating it (i.e. running it). If you have an expression, you can evaluate it with <code>base::eval()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">4</span>
<span class="kw">eval</span>(z)
y
<span class="co">#&gt; [1] 40</span></code></pre>
<p>The focus of this chapter is the data structures that underlie expressions. Mastering this knowledge will allow you to inspect and modify captured code, and to generate code with code. We’ll come back to <code>expr()</code> in Section <a href="#quasiquotation">19</a>, and to <code>eval()</code> in Chapter <a href="#evaluation">20</a>.</p>
<div id="outline-16" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#ast">18.2</a> introduces the idea of the abstract syntax tree (AST),
and reveals the tree like structure that underlies all R code.</p></li>
<li><p>Section <a href="#expression-details">18.3</a> dives into the details of the data
structures that underpin the AST: constants, symbols, and calls, which
are collectively known as expressions.</p></li>
<li><p>Section <a href="#grammar">18.4</a> covers parsing, the act of converting the linear
sequence of character in code into the AST, and uses that idea to explore
some details of R’s grammar.</p></li>
<li><p>Section <a href="#ast-funs">18.5</a> shows you how you can use recursive functions to
“compute on the language”, writing functions that compute with expressions.</p></li>
<li><p>Section <a href="#expression-special">18.6</a> circles back to three more
specialised data structures: pairlists, missing arguments, and expression
vectors.</p></li>
</ul>
</div>
<div id="prerequisites-11" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>Make sure you’ve read the metaprogramming overview in Chapter <a href="#meta-big-picture">17</a> to get a broad overview of the motivation and the basic vocabulary. You’ll also need the rlang<span id="fn128" class="footnote" data-pagedown-footnote-number="128" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span> package to capture and compute on expressions, and the lobstr<span id="fn129" class="footnote" data-pagedown-footnote-number="129" style="white-space: pre-line;"><a href="https://lobstr.r-lib.org" class="uri">https://lobstr.r-lib.org</a></span> package to visualise them.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)
<span class="kw">library</span>(lobstr)</code></pre>
</div>
</div>
<div id="ast" class="section level2">
<h2><span class="header-section-number">18.2</span> Abstract syntax trees</h2>
<p>
</p>
<p>Expressions are also called <strong>abstract syntax trees</strong> (ASTs) because the structure of code is hierarchical and can be naturally represented as a tree. Understanding this tree structure is crucial for inspecting and modifying expressions (i.e. metaprogramming).</p>
<div id="drawing" class="section level3">
<h3><span class="header-section-number">18.2.1</span> Drawing</h3>
<p></p>
<p>We’ll start by introducing some conventions for drawing ASTs, beginning with a simple call that shows their main components: <code>f(x, &quot;y&quot;, 1)</code>. I’ll draw trees in two ways<span id="fn130" class="footnote" data-pagedown-footnote-number="130" style="white-space: pre-line;">For more complex code, you can also use RStudio’s tree viewer which doesn’t obey quite the same graphical conventions, but allows you to interactively explore large ASTs. Try it out with <code>View(expr(f(x, &quot;y&quot;, 1)))</code>.</span>:</p>
<ul>
<li><p>By “hand” (i.e. with OmniGraffle):</p>
<p><img src="diagrams/expressions/simple.png" width="189" style="display: block; margin: auto;" /></p></li>
<li><p>With <code>lobstr::ast()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">f</span>(x, <span class="st">&quot;y&quot;</span>, <span class="dv">1</span>))
<span class="co">#&gt; █─f </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; ├─&quot;y&quot; </span>
<span class="co">#&gt; └─1</span></code></pre></li>
</ul>
<p>Both approaches share conventions as much as possible:</p>
<ul>
<li><p>The leaves of the tree are either symbols, like <code>f</code> and <code>x</code>, or constants,
like <code>1</code> or <code>&quot;y&quot;</code>. Symbols are drawn in purple and have rounded corners.
Constants have black borders and square corners. Strings and symbols are
easily confused, so strings are always surrounded in quotes.</p></li>
<li><p>The branches of the tree are call objects, which represent function calls,
and are drawn as orange rectangles. The first child (<code>f</code>) is the function
that gets called; the second and subsequent children (<code>x</code>, <code>&quot;y&quot;</code>, and <code>1</code>)
are the arguments to that function.</p></li>
</ul>
<p>Colours will be shown when <em>you</em> call <code>ast()</code>, but do not appear in the book for complicated technical reasons.</p>
<p>The above example only contained one function call, making for a very shallow tree. Most expressions will contain considerably more calls, creating trees with multiple levels. For example, consider the AST for <code>f(g(1, 2), h(3, 4, i()))</code>:</p>
<p><img src="diagrams/expressions/complicated.png" width="302" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">f</span>(<span class="kw">g</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">h</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="kw">i</span>())))
<span class="co">#&gt; █─f </span>
<span class="co">#&gt; ├─█─g </span>
<span class="co">#&gt; │ ├─1 </span>
<span class="co">#&gt; │ └─2 </span>
<span class="co">#&gt; └─█─h </span>
<span class="co">#&gt;   ├─3 </span>
<span class="co">#&gt;   ├─4 </span>
<span class="co">#&gt;   └─█─i</span></code></pre>
<p>You can read the hand-drawn diagrams from left-to-right (ignoring vertical position), and the lobstr-drawn diagrams from top-to-bottom (ignoring horizontal position). The depth within the tree is determined by the nesting of function calls. This also determines evaluation order, as evaluation generally proceeds from deepest-to-shallowest, but this is not guaranteed because of lazy evaluation (Section <a href="#lazy-evaluation">6.5</a>). Also note the appearance of <code>i()</code>, a function call with no arguments; it’s a branch with a single (symbol) leaf.</p>
</div>
<div id="non-code-components" class="section level3">
<h3><span class="header-section-number">18.2.2</span> Non-code components</h3>
<p></p>
<p>You might have wondered what makes these <em>abstract</em> syntax trees. They are abstract because they only capture important structural details of the code, not whitespace or comments:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(
  <span class="kw">f</span>(x,  y)  <span class="co"># important!</span>
)
<span class="co">#&gt; █─f </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─y</span></code></pre>
<p>There’s only one place where whitespace affects the AST:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(y &lt;-<span class="st"> </span>x)
<span class="co">#&gt; █─`&lt;-` </span>
<span class="co">#&gt; ├─y </span>
<span class="co">#&gt; └─x</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(y <span class="op">&lt;</span><span class="st"> </span><span class="op">-</span>x)
<span class="co">#&gt; █─`&lt;` </span>
<span class="co">#&gt; ├─y </span>
<span class="co">#&gt; └─█─`-` </span>
<span class="co">#&gt;   └─x</span></code></pre>
</div>
<div id="infix-calls" class="section level3">
<h3><span class="header-section-number">18.2.3</span> Infix calls</h3>
<p></p>
<p>Every call in R can be written in tree form because any call can be written in prefix form (Section <a href="#prefix-transform">6.8.1</a>). Take <code>y &lt;- x * 10</code> again: what are the functions that are being called? It is not as easy to spot as <code>f(x, 1)</code> because this expression contains two infix calls: <code>&lt;-</code> and <code>*</code>. That means that these two lines of code are equivalent:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span>x <span class="op">*</span><span class="st"> </span><span class="dv">10</span>
<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>(y, <span class="st">`</span><span class="dt">*</span><span class="st">`</span>(x, <span class="dv">10</span>))</code></pre>
<p>And they both have this AST<span id="fn131" class="footnote" data-pagedown-footnote-number="131" style="white-space: pre-line;">The names of non-prefix functions are non-syntactic so I surround them with <code>``</code>, as in Section <a href="#non-syntactic">2.2.1</a>.</span>:</p>
<p><img src="diagrams/expressions/prefix.png" width="217" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(y &lt;-<span class="st"> </span>x <span class="op">*</span><span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; █─`&lt;-` </span>
<span class="co">#&gt; ├─y </span>
<span class="co">#&gt; └─█─`*` </span>
<span class="co">#&gt;   ├─x </span>
<span class="co">#&gt;   └─10</span></code></pre>
<p>There really is no difference between the ASTs, and if you generate an expression with prefix calls, R will still print it in infix form:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr</span>(<span class="st">`</span><span class="dt">&lt;-</span><span class="st">`</span>(y, <span class="st">`</span><span class="dt">*</span><span class="st">`</span>(x, <span class="dv">10</span>)))
<span class="co">#&gt; y &lt;- x * 10</span></code></pre>
<p>The order in which infix operators are applied is governed by a set of rules called operator precedence, and we’ll <code>lobstr::ast()</code> to explore them in Section <a href="#operator-precedence">18.4.1</a>.</p>
</div>
<div id="exercises-52" class="section level3">
<h3><span class="header-section-number">18.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Reconstruct the code represented by the trees below:</p>
<pre><code>#&gt; █─f 
#&gt; └─█─g 
#&gt;   └─█─h
#&gt; █─`+` 
#&gt; ├─█─`+` 
#&gt; │ ├─1 
#&gt; │ └─2 
#&gt; └─3
#&gt; █─`*` 
#&gt; ├─█─`(` 
#&gt; │ └─█─`+` 
#&gt; │   ├─x 
#&gt; │   └─y 
#&gt; └─z</code></pre></li>
<li><p>Draw the following trees by hand then check your answers with
<code>lobstr::ast()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">f</span>(<span class="kw">g</span>(<span class="kw">h</span>(<span class="kw">i</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>))))
<span class="kw">f</span>(<span class="dv">1</span>, <span class="kw">g</span>(<span class="dv">2</span>, <span class="kw">h</span>(<span class="dv">3</span>, <span class="kw">i</span>())))
<span class="kw">f</span>(<span class="kw">g</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">h</span>(<span class="dv">3</span>, <span class="kw">i</span>(<span class="dv">4</span>, <span class="dv">5</span>)))</code></pre></li>
<li><p>What’s happening with the ASTs below? (Hint: carefully read <code>?&quot;^&quot;</code>)</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="st">`</span><span class="dt">x</span><span class="st">`</span> <span class="op">+</span><span class="st"> `</span><span class="dt">y</span><span class="st">`</span>)
<span class="co">#&gt; █─`+` </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─y</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(x <span class="op">**</span><span class="st"> </span>y)
<span class="co">#&gt; █─`^` </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─y</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="dv">1</span> -&gt;<span class="st"> </span>x)
<span class="co">#&gt; █─`&lt;-` </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─1</span></code></pre></li>
<li><p>What is special about the AST below? (Hint: re-read Section
<a href="#fun-components">6.2.1</a>)</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>) {})
<span class="co">#&gt; █─`function` </span>
<span class="co">#&gt; ├─█─x = 1 </span>
<span class="co">#&gt; │ └─y = 2 </span>
<span class="co">#&gt; ├─█─`{` </span>
<span class="co">#&gt; └─&lt;inline srcref&gt;</span></code></pre></li>
<li><p>What does the call tree of an <code>if</code> statement with multiple <code>else if</code>
conditions look like? Why?</p></li>
</ol>
</div>
</div>
<div id="expression-details" class="section level2">
<h2><span class="header-section-number">18.3</span> Expressions</h2>
<p>
</p>
<p>Collectively, the data structures present in the AST are called expressions. An <strong>expression</strong> is any member of the set of base types created by parsing code: constant scalars, symbols, call objects, and pairlists. These are the data structures used to represent captured code from <code>expr()</code>, and <code>is_expression(expr(...))</code> is always true<span id="fn132" class="footnote" data-pagedown-footnote-number="132" style="white-space: pre-line;">It is <em>possible</em> to insert any other base object into an expression, but this is unusual and only needed in rare circumstances. We’ll come back to that idea in Section <a href="#non-standard-ast">19.4.7</a>.</span>. Constants, symbols and call objects are the most important, and are discussed below. Pairlists and empty symbols are more specialised and we’ll come back to them in Sections <a href="#pairlists">18.6.1</a> and Section <a href="#empty-symbol">18.6.2</a>.</p>
<p>NB: In base R documentation “expression” is used to mean two things. As well as the definition above, expression is also used to refer to the type of object returned by <code>expression()</code> and <code>parse()</code>, which are basically lists of expressions as defined above. In this book I’ll call these <strong>expression vectors</strong>, and I’ll come back to them in Section <a href="#expression-vectors">18.6.3</a>.</p>
<div id="constants" class="section level3">
<h3><span class="header-section-number">18.3.1</span> Constants</h3>
<p>
</p>
<p>Scalar constants are the simplest component of the AST. More precisely, a <strong>constant</strong> is either <code>NULL</code> or a length-1 atomic vector (or scalar, Section <a href="#scalars">3.2.1</a>) like <code>TRUE</code>, <code>1L</code>, <code>2.5</code> or <code>&quot;x&quot;</code>. You can test for a constant with <code>rlang::is_syntactic_literal()</code>.</p>
<p>Constants are “self-quoting” in the sense that the expression used to represent a constant is the constant itself:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(<span class="kw">expr</span>(<span class="ot">TRUE</span>), <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">identical</span>(<span class="kw">expr</span>(<span class="dv">1</span>), <span class="dv">1</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">identical</span>(<span class="kw">expr</span>(2L), 2L)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">identical</span>(<span class="kw">expr</span>(<span class="st">&quot;x&quot;</span>), <span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; [1] TRUE</span></code></pre>
</div>
<div id="symbols" class="section level3">
<h3><span class="header-section-number">18.3.2</span> Symbols</h3>
<p>

</p>
<p>A <strong>symbol</strong> represents the name of an object like <code>x</code>, <code>mtcars</code>, or <code>mean</code>. In base R, the terms symbol and name are used interchangeably (i.e. <code>is.name()</code> is identical to <code>is.symbol()</code>), but in this book I used symbol consistently because “name” has many other meanings.</p>
<p>You can create a symbol in two ways: by capturing code that references an object with <code>expr()</code>, or turning a string into a symbol with <code>rlang::sym()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr</span>(x)
<span class="co">#&gt; x</span>
<span class="kw">sym</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; x</span></code></pre>

<p>You can turn a symbol back into a string with <code>as.character()</code> or <code>rlang::as_string()</code>. <code>as_string()</code> has the advantage of clearly signalling that you’ll get a character vector of length 1.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_string</span>(<span class="kw">expr</span>(x))
<span class="co">#&gt; [1] &quot;x&quot;</span></code></pre>
<p>You can recognise a symbol because it’s printed without quotes, <code>str()</code> tells you that it’s a symbol, and <code>is.symbol()</code> is <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">expr</span>(x))
<span class="co">#&gt;  symbol x</span>
<span class="kw">is.symbol</span>(<span class="kw">expr</span>(x))
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>The symbol type is not vectorised, i.e. a symbol is always length 1. If you want multiple symbols, you’ll need to put them in a list, using (e.g.) <code>rlang::syms()</code>.</p>
</div>
<div id="calls" class="section level3">
<h3><span class="header-section-number">18.3.3</span> Calls</h3>
<p>
</p>
<p>A <strong>call object</strong> represents a captured function call. Call objects are a special type of list<span id="fn133" class="footnote" data-pagedown-footnote-number="133" style="white-space: pre-line;">More precisely, they’re pairlists, Section <a href="#pairlists">18.6.1</a>, but this distinction rarely matters.</span> where the first component specifies the function to call (usually a symbol), and the remaining elements are the arguments for that call. Call objects create branches in the AST, because calls can be nested inside other calls.</p>
<p>You can identify a call object when printed because it looks just like a function call. Confusingly <code>typeof()</code> and <code>str()</code> print “language”<span id="fn134" class="footnote" data-pagedown-footnote-number="134" style="white-space: pre-line;">Avoid <code>is.language()</code> which returns <code>TRUE</code> for symbols, calls, and expression vectors.</span> for call objects, but <code>is.call()</code> returns <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">read.table</span>(<span class="st">&quot;important.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>))
<span class="co">#&gt; █─read.table </span>
<span class="co">#&gt; ├─&quot;important.csv&quot; </span>
<span class="co">#&gt; └─row.names = FALSE</span>
x &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">read.table</span>(<span class="st">&quot;important.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>))

<span class="kw">typeof</span>(x)
<span class="co">#&gt; [1] &quot;language&quot;</span>
<span class="kw">is.call</span>(x)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<div id="subsetting-1" class="section level4">
<h4><span class="header-section-number">18.3.3.1</span> Subsetting</h4>
<p></p>
<p>Calls generally behave like lists, i.e. you can use standard subsetting tools. The first element of the call object is the function to call, which is a usually a symbol:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[[<span class="dv">1</span>]]
<span class="co">#&gt; read.table</span>
<span class="kw">is.symbol</span>(x[[<span class="dv">1</span>]])
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>The remainder of the elements are the arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.list</span>(x[<span class="op">-</span><span class="dv">1</span>])
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;important.csv&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $row.names</span>
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>You can extract individual arguments with <code>[[</code> or, if named, <code>$</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[[<span class="dv">2</span>]]
<span class="co">#&gt; [1] &quot;important.csv&quot;</span>
x<span class="op">$</span>row.names
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>You can determine the number of arguments in a call object by subtracting 1 from its length:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(x) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>
<span class="co">#&gt; [1] 2</span></code></pre>
<p>Extracting specific arguments from calls is challenging because of R’s flexible rules for argument matching: it could potentially be in any location, with the full name, with an abbreviated name, or with no name. To work around this problem, you can use <code>rlang::call_standardise()</code> which standardises all arguments to use the full name:
</p>
<pre class="sourceCode r"><code class="sourceCode r">rlang<span class="op">::</span><span class="kw">call_standardise</span>(x)
<span class="co">#&gt; read.table(file = &quot;important.csv&quot;, row.names = FALSE)</span></code></pre>
<p>(NB: If the function uses <code>...</code> it’s not possible to standardise all arguments.)</p>
<p>Calls can be modified in the same way as lists:</p>
<pre class="sourceCode r"><code class="sourceCode r">x<span class="op">$</span>header &lt;-<span class="st"> </span><span class="ot">TRUE</span>
x
<span class="co">#&gt; read.table(&quot;important.csv&quot;, row.names = FALSE, header = TRUE)</span></code></pre>
</div>
<div id="function-position" class="section level4">
<h4><span class="header-section-number">18.3.3.2</span> Function position</h4>
<p></p>
<p>The first element of the call object is the <strong>function position</strong>. This contains the function that will be called when the object is evaluated, and is usually a symbol<span id="fn135" class="footnote" data-pagedown-footnote-number="135" style="white-space: pre-line;">Peculiarly, it can also be a number, as in the expression <code>3()</code>. But this call will always fail to evaluate because a number is not a function.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">foo</span>())
<span class="co">#&gt; █─foo</span></code></pre>
<p>While R allows you to surround the name of the function with quotes, the parser converts it to a symbol:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="st">&quot;foo&quot;</span>())
<span class="co">#&gt; █─foo</span></code></pre>
<p>However, sometimes the function doesn’t exist in the current environment and you need to do some computation to retrieve it: for example, if the function is in another package, is a method of an R6 object, or is created by a function factory. In this case, the function position will be occupied by another call:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(pkg<span class="op">::</span><span class="kw">foo</span>(<span class="dv">1</span>))
<span class="co">#&gt; █─█─`::` </span>
<span class="co">#&gt; │ ├─pkg </span>
<span class="co">#&gt; │ └─foo </span>
<span class="co">#&gt; └─1</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(obj<span class="op">$</span><span class="kw">foo</span>(<span class="dv">1</span>))
<span class="co">#&gt; █─█─`$` </span>
<span class="co">#&gt; │ ├─obj </span>
<span class="co">#&gt; │ └─foo </span>
<span class="co">#&gt; └─1</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="kw">foo</span>(<span class="dv">1</span>)(<span class="dv">2</span>))
<span class="co">#&gt; █─█─foo </span>
<span class="co">#&gt; │ └─1 </span>
<span class="co">#&gt; └─2</span></code></pre>
<p><img src="diagrams/expressions/call-call.png" width="387" style="display: block; margin: auto;" /></p>
</div>
<div id="call2" class="section level4">
<h4><span class="header-section-number">18.3.3.3</span> Constructing</h4>
<p>
</p>
<p>You can construct a call object from its components using <code>rlang::call2()</code>. The first argument is the name of the function to call (either as a string, a symbol, or another call). The remaining arguments will be passed along to the call:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">call2</span>(<span class="st">&quot;mean&quot;</span>, <span class="dt">x =</span> <span class="kw">expr</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; mean(x = x, na.rm = TRUE)</span>
<span class="kw">call2</span>(<span class="kw">expr</span>(base<span class="op">::</span>mean), <span class="dt">x =</span> <span class="kw">expr</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; base::mean(x = x, na.rm = TRUE)</span></code></pre>
<p>Infix calls created in this way still print as usual.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">call2</span>(<span class="st">&quot;&lt;-&quot;</span>, <span class="kw">expr</span>(x), <span class="dv">10</span>)
<span class="co">#&gt; x &lt;- 10</span></code></pre>
<p>Using <code>call2()</code> to create complex expressions is a bit clunky. You’ll learn another technique in Chapter <a href="#quasiquotation">19</a>.</p>
</div>
</div>
<div id="summary" class="section level3">
<h3><span class="header-section-number">18.3.4</span> Summary</h3>
<p>The following table summarises the appearance of the different expression subtypes in <code>str()</code> and <code>typeof()</code>:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><code>str()</code></th>
<th><code>typeof()</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Scalar constant</td>
<td><code>logi</code>/<code>int</code>/<code>num</code>/<code>chr</code></td>
<td><code>logical</code>/<code>integer</code>/<code>double</code>/<code>character</code></td>
</tr>
<tr class="even">
<td>Symbol</td>
<td><code>symbol</code></td>
<td><code>symbol</code></td>
</tr>
<tr class="odd">
<td>Call object</td>
<td><code>language</code></td>
<td><code>language</code></td>
</tr>
<tr class="even">
<td>Pairlist</td>
<td>Dotted pair list</td>
<td><code>pairlist</code></td>
</tr>
<tr class="odd">
<td>Expression vector</td>
<td><code>expression()</code></td>
<td><code>expression</code></td>
</tr>
</tbody>
</table>
<p>Both base R and rlang provide functions for testing for each type of input, although the types covered are slightly different. You can easily tell them apart because all the base functions start with <code>is.</code> and the rlang functions start with <code>is_</code>.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>base</th>
<th>rlang</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Scalar constant</td>
<td>—</td>
<td><code>is_syntactic_literal()</code></td>
</tr>
<tr class="even">
<td>Symbol</td>
<td><code>is.symbol()</code></td>
<td><code>is_symbol()</code></td>
</tr>
<tr class="odd">
<td>Call object</td>
<td><code>is.call()</code></td>
<td><code>is_call()</code></td>
</tr>
<tr class="even">
<td>Pairlist</td>
<td><code>is.pairlist()</code></td>
<td><code>is_pairlist()</code></td>
</tr>
<tr class="odd">
<td>Expression vector</td>
<td><code>is.expression()</code></td>
<td>—</td>
</tr>
</tbody>
</table>
</div>
<div id="exercises-53" class="section level3">
<h3><span class="header-section-number">18.3.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Which two of the six types of atomic vector can’t appear in an expression?
Why? Similarly, why can’t you create an expression that contains an atomic
vector of length greater than one?</p></li>
<li><p>What happens when you subset a call object to remove the first element?
e.g. <code>expr(read.csv(&quot;foo.csv&quot;, header = TRUE))[-1]</code>. Why?</p></li>
<li><p>Describe the differences between the following call objects.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>

<span class="kw">call2</span>(median, x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="kw">call2</span>(<span class="kw">expr</span>(median), x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="kw">call2</span>(median, <span class="kw">expr</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="kw">call2</span>(<span class="kw">expr</span>(median), <span class="kw">expr</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></li>
<li><p><code>rlang::call_standardise()</code> doesn’t work so well for the following calls.
Why? What makes <code>mean()</code> special?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">call_standardise</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)))
<span class="co">#&gt; mean(x = 1:10, na.rm = TRUE)</span>
<span class="kw">call_standardise</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dt">n =</span> T, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)))
<span class="co">#&gt; mean(x = 1:10, n = T)</span>
<span class="kw">call_standardise</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, , <span class="ot">TRUE</span>)))
<span class="co">#&gt; mean(x = 1:10, , TRUE)</span></code></pre></li>
<li><p>Why does this code not make sense?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">foo</span>(<span class="dt">x =</span> <span class="dv">1</span>))
<span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)</code></pre></li>
<li><p>Construct the expression <code>if(x &gt; 1) &quot;a&quot; else &quot;b&quot;</code> using multiple calls to
<code>call2()</code>. How does the code structure reflect the structure of the AST?</p></li>
</ol>
</div>
</div>
<div id="grammar" class="section level2">
<h2><span class="header-section-number">18.4</span> Parsing and grammar</h2>
<p></p>
<p>We’ve talked a lot about expressions and the AST, but not about how expressions are created from code that you type (like <code>&quot;x + y&quot;</code>). The process by which a computer language takes a string and constructs an expression is called <strong>parsing</strong>, and is governed by a set of rules known as a <strong>grammar</strong>. In this section, we’ll use <code>lobstr::ast()</code> to explore some of the details of R’s grammar, and then show how you can transform back and forth between expressions and strings.</p>
<div id="operator-precedence" class="section level3">
<h3><span class="header-section-number">18.4.1</span> Operator precedence</h3>
<p></p>
<p>Infix functions introduce two sources of ambiguity<span id="fn136" class="footnote" data-pagedown-footnote-number="136" style="white-space: pre-line;">This ambiguity does not exist in languages with only prefix or postfix calls. It’s interesting to compare a simple arithmetic operation in Lisp (prefix) and Forth (postfix). In Lisp you’d write <code>(* (+ 1 2) 3))</code>; this avoids ambiguity by requiring parentheses everywhere. In Forth, you’d write <code>1 2 + 3 *</code>; this doesn’t require any parentheses, but does require more thought when reading.</span>. The first source of ambiguity arises from infix functions: what does <code>1 + 2 * 3</code> yield? Do you get 9 (i.e. <code>(1 + 2) * 3</code>), or 7 (i.e. <code>1 + (2 * 3)</code>)? In other words, which of the two possible parse trees below does R use?</p>
<p><img src="diagrams/expressions/ambig-order.png" width="373" style="display: block; margin: auto;" /></p>
<p>Programming languages use conventions called <strong>operator precedence</strong> to resolve this ambiguity. We can use <code>ast()</code> to see what R does:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="dv">3</span>)
<span class="co">#&gt; █─`+` </span>
<span class="co">#&gt; ├─1 </span>
<span class="co">#&gt; └─█─`*` </span>
<span class="co">#&gt;   ├─2 </span>
<span class="co">#&gt;   └─3</span></code></pre>
<p>Predicting the precedence of arithmetic operations is usually easy because it’s drilled into you in school and is consistent across the vast majority of programming languages.</p>
<p>Predicting the precedence of other operators is harder. There’s one particularly surprising case in R: <code>!</code> has a much lower precedence (i.e. it binds less tightly) than you might expect. This allows you to write useful operations like:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="op">!</span>x <span class="op">%in%</span><span class="st"> </span>y)
<span class="co">#&gt; █─`!` </span>
<span class="co">#&gt; └─█─`%in%` </span>
<span class="co">#&gt;   ├─x </span>
<span class="co">#&gt;   └─y</span></code></pre>
<p>R has over 30 infix operators divided into 18 precedence groups. While the details are described in <code>?Syntax</code>, very few people have memorised the complete ordering. If there’s any confusion, use parentheses!</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>((<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span><span class="dv">3</span>)
<span class="co">#&gt; █─`*` </span>
<span class="co">#&gt; ├─█─`(` </span>
<span class="co">#&gt; │ └─█─`+` </span>
<span class="co">#&gt; │   ├─1 </span>
<span class="co">#&gt; │   └─2 </span>
<span class="co">#&gt; └─3</span></code></pre>
<p>Note the appearance of the parentheses in the AST as a call to the <code>(</code> function.</p>
</div>
<div id="associativity" class="section level3">
<h3><span class="header-section-number">18.4.2</span> Associativity</h3>
<p>The second source of ambiguity is introduced by repeated usage of the same infix function. For example, is <code>1 + 2 + 3</code> equivalent to <code>(1 + 2) + 3</code> or to <code>1 + (2 + 3)</code>? This normally doesn’t matter because <code>x + (y + z) == (x + y) + z</code>, i.e. addition is associative, but is needed because some S3 classes define <code>+</code> in a non-associative way. For example, ggplot2 overloads <code>+</code> to build up a complex plot from simple pieces; this is non-associative because earlier layers are drawn underneath later layers (i.e. <code>geom_point()</code> + <code>geom_smooth()</code> does not yield the same plot as <code>geom_smooth()</code> + <code>geom_point()</code>).</p>
<p>In R, most operators are <strong>left-associative</strong>, i.e. the operations on the left are evaluated first:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span>)
<span class="co">#&gt; █─`+` </span>
<span class="co">#&gt; ├─█─`+` </span>
<span class="co">#&gt; │ ├─1 </span>
<span class="co">#&gt; │ └─2 </span>
<span class="co">#&gt; └─3</span></code></pre>
<p>There are two exceptions: exponentiation and assignment.</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="dv">2</span><span class="op">^</span><span class="dv">2</span><span class="op">^</span><span class="dv">3</span>)
<span class="co">#&gt; █─`^` </span>
<span class="co">#&gt; ├─2 </span>
<span class="co">#&gt; └─█─`^` </span>
<span class="co">#&gt;   ├─2 </span>
<span class="co">#&gt;   └─3</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(x &lt;-<span class="st"> </span>y &lt;-<span class="st"> </span>z)
<span class="co">#&gt; █─`&lt;-` </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─█─`&lt;-` </span>
<span class="co">#&gt;   ├─y </span>
<span class="co">#&gt;   └─z</span></code></pre>
</div>
<div id="parsing" class="section level3">
<h3><span class="header-section-number">18.4.3</span> Parsing and deparsing</h3>
<p>
</p>
<p>Most of the time you type code into the console, and R takes care of turning the characters you’ve typed into an AST. But occasionally you have code stored in a string, and you want to parse it yourself. You can do so using <code>rlang::parse_expr()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> &quot;y &lt;- x + 10&quot;</span>
x1
<span class="co">#&gt; [1] &quot;y &lt;- x + 10&quot;</span>
<span class="kw">is.call</span>(x1)
<span class="co">#&gt; [1] FALSE</span>

x2 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">parse_expr</span>(x1)
x2
<span class="co">#&gt; y &lt;- x + 10</span>
<span class="kw">is.call</span>(x2)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p><code>parse_expr()</code> always returns a single expression. If you have multiple expression separated by <code>;</code> or <code>\n</code>, you’ll need to use <code>rlang::parse_exprs()</code>. It returns a list of expressions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x3 &lt;-<span class="st"> &quot;a &lt;- 1; a + 1&quot;</span>
rlang<span class="op">::</span><span class="kw">parse_exprs</span>(x3)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; a &lt;- 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; a + 1</span></code></pre>
<p>If you find yourself working with strings containing code very frequently, you should reconsider your process. Read Chapter <a href="#quasiquotation">19</a> and consider if you can instead more safely generate expressions using quasiquotation.</p>
<div class="base">
<p>The base equivalent to <code>parse_exprs()</code> is <code>parse()</code>. It is a little harder to use because it’s specialised for parsing R code stored in files. You need supply your string to the <code>text</code> argument and it returns an expression vector (Section <a href="#expression-vectors">18.6.3</a>). I recommend turning the output into a list:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.list</span>(<span class="kw">parse</span>(<span class="dt">text =</span> x1))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; y &lt;- x + 10</span></code></pre>
</div>
<p>
</p>
<p>The inverse of parsing is <strong>deparsing</strong>: given an expression, you want the string that would generate it. This happens automatically when you print an expression, and you can get the string yourself with <code>rlang::expr_text()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">expr</span>(y &lt;-<span class="st"> </span>x <span class="op">+</span><span class="st"> </span><span class="dv">10</span>)
<span class="kw">expr_text</span>(z)
<span class="co">#&gt; [1] &quot;y &lt;- x + 10&quot;</span></code></pre>
<p>Parsing and deparsing are not perfectly symmetric because parsing generates an <em>abstract</em> syntax tree. This means we lose backticks around ordinary names, comments, and whitespace:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">expr_text</span>(<span class="kw">expr</span>({
  <span class="co"># This is a comment</span>
  x &lt;-<span class="st">             `</span><span class="dt">x</span><span class="st">`</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
})))
<span class="co">#&gt; {</span>
<span class="co">#&gt;     x &lt;- x + 1</span>
<span class="co">#&gt; }</span></code></pre>
<div class="base">
<p>Be careful when using the base R equivalent, <code>deparse()</code>: it returns a character vector with one element for each line. Whenever you use it, remember that the length of the output might be greater than one, and plan accordingly.</p>
</div>
</div>
<div id="exercises-54" class="section level3">
<h3><span class="header-section-number">18.4.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>R uses parentheses in two slightly different ways as illustrated by
these two calls:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">f</span>((<span class="dv">1</span>))
<span class="st">`</span><span class="dt">(</span><span class="st">`</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<p>Compare and contrast the two uses by referencing the AST.</p></li>
<li><p><code>=</code> can also be used in two ways. Construct a simple example that shows
both uses.</p></li>
<li><p>Does <code>-2^2</code> yield 4 or -4? Why?</p></li>
<li><p>What does <code>!1 + !1</code> return? Why?</p></li>
<li><p>Why does <code>x1 &lt;- x2 &lt;- x3 &lt;- 0</code> work? Describe the two reasons.</p></li>
<li><p>Compare the ASTs of <code>x + y %+% z</code> and <code>x ^ y %+% z</code>. What have you learned
about the precedence of custom infix functions?</p></li>
<li><p>What happens if you call <code>parse_expr()</code> with a string that generates
multiple expressions? e.g. <code>parse_expr(&quot;x + 1; y + 1&quot;)</code></p></li>
<li><p>What happens if you attempt to parse an invalid expression? e.g. <code>&quot;a +&quot;</code>
or <code>&quot;f())&quot;</code>.</p></li>
<li><p><code>deparse()</code> produces vectors when the input is long. For example, the
following call produces a vector of length two:</p>
<pre class="sourceCode r"><code class="sourceCode r">expr &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">g</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c <span class="op">+</span><span class="st"> </span>d <span class="op">+</span><span class="st"> </span>e <span class="op">+</span><span class="st"> </span>f <span class="op">+</span><span class="st"> </span>g <span class="op">+</span><span class="st"> </span>h <span class="op">+</span><span class="st"> </span>i <span class="op">+</span><span class="st"> </span>j <span class="op">+</span><span class="st"> </span>k <span class="op">+</span><span class="st"> </span>l <span class="op">+</span><span class="st"> </span>
<span class="st">  </span>m <span class="op">+</span><span class="st"> </span>n <span class="op">+</span><span class="st"> </span>o <span class="op">+</span><span class="st"> </span>p <span class="op">+</span><span class="st"> </span>q <span class="op">+</span><span class="st"> </span>r <span class="op">+</span><span class="st"> </span>s <span class="op">+</span><span class="st"> </span>t <span class="op">+</span><span class="st"> </span>u <span class="op">+</span><span class="st"> </span>v <span class="op">+</span><span class="st"> </span>w <span class="op">+</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>z))

<span class="kw">deparse</span>(expr)</code></pre>
<p>What does <code>expr_text()</code> do instead?</p></li>
<li><p><code>pairwise.t.test()</code> assumes that <code>deparse()</code> always returns a length one
character vector. Can you construct an input that violates this expectation?
What happens?</p></li>
</ol>
</div>
</div>
<div id="ast-funs" class="section level2">
<h2><span class="header-section-number">18.5</span> Walking the AST with recursive functions</h2>
<p>
</p>
<p>To conclude the chapter I’m going to use everything you’ve learned about ASTs to solve more complicated problems. The inspiration comes from the base codetools package, which provides two interesting functions:</p>
<ul>
<li><p><code>findGlobals()</code> locates all global variables used by a function. This
can be useful if you want to check that your function doesn’t inadvertently
rely on variables defined in their parent environment.</p></li>
<li><p><code>checkUsage()</code> checks for a range of common problems including
unused local variables, unused parameters, and the use of partial
argument matching.</p></li>
</ul>
<p>Getting all of the details of these functions correct is fiddly, so we won’t fully develop the ideas. Instead we’ll focus on the big underlying idea: recursion on the AST. Recursive functions are a natural fit to tree-like data structures because a recursive function is made up of two parts that correspond to the two parts of the tree:</p>
<ul>
<li><p>The <strong>recursive case</strong> handles the nodes in the tree. Typically, you’ll
do something to each child of a node, usually calling the recursive function
again, and then combine the results back together again. For expressions,
you’ll need to handle calls and pairlists (function arguments).</p></li>
<li><p>The <strong>base case</strong> handles the leaves of the tree. The base cases ensure
that the function eventually terminates, by solving the simplest cases
directly. For expressions, you need to handle symbols and constants in the
base case.</p></li>
</ul>
<p>To make this pattern easier to see, we’ll need two helper functions. First we define <code>expr_type()</code> which will return “constant” for constant, “symbol” for symbols, “call”, for calls, “pairlist” for pairlists, and the “type” of anything else:</p>
<pre class="sourceCode r"><code class="sourceCode r">expr_type &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (rlang<span class="op">::</span><span class="kw">is_syntactic_literal</span>(x)) {
    <span class="st">&quot;constant&quot;</span>
  } <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">is.symbol</span>(x)) {
    <span class="st">&quot;symbol&quot;</span>
  } <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">is.call</span>(x)) {
    <span class="st">&quot;call&quot;</span>
  } <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">is.pairlist</span>(x)) {
    <span class="st">&quot;pairlist&quot;</span>
  } <span class="cf">else</span> {
    <span class="kw">typeof</span>(x)
  }
}

<span class="kw">expr_type</span>(<span class="kw">expr</span>(<span class="st">&quot;a&quot;</span>))
<span class="co">#&gt; [1] &quot;constant&quot;</span>
<span class="kw">expr_type</span>(<span class="kw">expr</span>(x))
<span class="co">#&gt; [1] &quot;symbol&quot;</span>
<span class="kw">expr_type</span>(<span class="kw">expr</span>(<span class="kw">f</span>(<span class="dv">1</span>, <span class="dv">2</span>)))
<span class="co">#&gt; [1] &quot;call&quot;</span></code></pre>
<p>We’ll couple this with a wrapper around the switch function:</p>
<pre class="sourceCode r"><code class="sourceCode r">switch_expr &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  <span class="cf">switch</span>(<span class="kw">expr_type</span>(x),
    ...,
    <span class="kw">stop</span>(<span class="st">&quot;Don&#39;t know how to handle type &quot;</span>, <span class="kw">typeof</span>(x), <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  )
}</code></pre>
<p>With these two functions in hand, we can write a basic template for any function that walks the AST using <code>switch()</code> (Section <a href="#switch">5.2.3</a>):</p>
<pre class="sourceCode r"><code class="sourceCode r">recurse_call &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="co"># Base cases</span>
    <span class="dt">symbol =</span> ,
    <span class="dt">constant =</span> ,

    <span class="co"># Recursive cases</span>
    <span class="dt">call =</span> ,
    <span class="dt">pairlist =</span>
  )
}</code></pre>
<p>Typically, solving the base case is easy, so we’ll do that first, then check the results. The recursive cases are a little more tricky, and will often require some functional programming.</p>
<div id="finding-f-and-t" class="section level3">
<h3><span class="header-section-number">18.5.1</span> Finding F and T</h3>
<p>We’ll start with a function that determines whether another function uses the logical abbreviations <code>T</code> and <code>F</code> because using them is often considered to be poor coding practice. Our goal is to return <code>TRUE</code> if the input contains a logical abbreviation, and <code>FALSE</code> otherwise.</p>
<p>Let’s first the type of <code>T</code> vs. <code>TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr_type</span>(<span class="kw">expr</span>(<span class="ot">TRUE</span>))
<span class="co">#&gt; [1] &quot;constant&quot;</span>

<span class="kw">expr_type</span>(<span class="kw">expr</span>(T))
<span class="co">#&gt; [1] &quot;symbol&quot;</span></code></pre>
<p><code>TRUE</code> is parsed as a logical vector of length one, while <code>T</code> is parsed as a name. This tells us how to write our base cases for the recursive function: a constant is never a logical abbreviation, and a symbol is an abbreviation if it’s “F” or “T”:</p>
<pre class="sourceCode r"><code class="sourceCode r">logical_abbr_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="dt">constant =</span> <span class="ot">FALSE</span>,
    <span class="dt">symbol =</span> <span class="kw">as_string</span>(x) <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;F&quot;</span>, <span class="st">&quot;T&quot;</span>)
  )
}

<span class="kw">logical_abbr_rec</span>(<span class="kw">expr</span>(<span class="ot">TRUE</span>))
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">logical_abbr_rec</span>(<span class="kw">expr</span>(T))
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>I’ve written <code>logical_abbr_rec()</code> function assuming that the input will be an expression as this will make the recursive operation simpler. However, when writing a recursive function it’s common to write a wrapper that provides defaults or makes the function a little easier to use. Here we’ll typically make a wrapper that quotes its input (we’ll learn more about that in the next chapter), so we don’t need to use <code>expr()</code> every time.</p>
<pre class="sourceCode r"><code class="sourceCode r">logical_abbr &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">logical_abbr_rec</span>(<span class="kw">enexpr</span>(x))
}

<span class="kw">logical_abbr</span>(T)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">logical_abbr</span>(<span class="ot">FALSE</span>)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>Next we need to implement the recursive cases. Here we want to do the same thing for calls and for pairlists: recursively apply the function to each subcomponent, and return <code>TRUE</code> if any subcomponent contains a logical abbreviation. This is made easy by <code>purrr::some()</code>, which iterates over a list and returns <code>TRUE</code> if the predicate function is true for any element.</p>
<pre class="sourceCode r"><code class="sourceCode r">logical_abbr_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="co"># Base cases</span>
    <span class="dt">constant =</span> <span class="ot">FALSE</span>,
    <span class="dt">symbol =</span> <span class="kw">as_string</span>(x) <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;F&quot;</span>, <span class="st">&quot;T&quot;</span>),

    <span class="co"># Recursive cases</span>
    <span class="dt">call =</span> ,
    <span class="dt">pairlist =</span> purrr<span class="op">::</span><span class="kw">some</span>(x, logical_abbr_rec)
  )
}

<span class="kw">logical_abbr</span>(<span class="kw">mean</span>(x, <span class="dt">na.rm =</span> T))
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">logical_abbr</span>(<span class="cf">function</span>(x, <span class="dt">na.rm =</span> T) <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] TRUE</span></code></pre>
</div>
<div id="finding-all-variables-created-by-assignment" class="section level3">
<h3><span class="header-section-number">18.5.2</span> Finding all variables created by assignment</h3>
<p><code>logical_abbr()</code> is relatively simple: it only returns a single <code>TRUE</code> or <code>FALSE</code>. The next task, listing all variables created by assignment, is a little more complicated. We’ll start simply, and then make the function progressively more rigorous. </p>
<p>We start by looking at the AST for assignment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ast</span>(x &lt;-<span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; █─`&lt;-` </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─10</span></code></pre>
<p>Assignment is a call object where the first element is the symbol <code>&lt;-</code>, the second is the name of variable, and the third is the value to be assigned.</p>
<p>Next, we need to decide what data structure we’re going to use for the results. Here I think it will be easiest if we return a character vector. If we return symbols, we’ll need to use a <code>list()</code> and that makes things a little more complicated.</p>
<p>With that in hand we can start by implementing the base cases and providing a helpful wrapper around the recursive function. Here the base cases are straightforward because we know that neither a symbol nor a constant represents assignment.</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="dt">constant =</span> ,
    <span class="dt">symbol =</span> <span class="kw">character</span>()
  )
}
find_assign &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">find_assign_rec</span>(<span class="kw">enexpr</span>(x))

<span class="kw">find_assign</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; character(0)</span>
<span class="kw">find_assign</span>(x)
<span class="co">#&gt; character(0)</span></code></pre>
<p>Next we implement the recursive cases. This is made easier by a function that should exist in purrr, but currently doesn’t. <code>flat_map_chr()</code> expects <code>.f</code> to return a character vector of arbitrary length, and flattens all results into a single character vector.</p>
<!-- GVW: by this point, will readers have seen the `.x` and `.f` conventions enough that they don't need explanation? -->
<pre class="sourceCode r"><code class="sourceCode r">flat_map_chr &lt;-<span class="st"> </span><span class="cf">function</span>(.x, .f, ...) {
  purrr<span class="op">::</span><span class="kw">flatten_chr</span>(purrr<span class="op">::</span><span class="kw">map</span>(.x, .f, ...))
}

<span class="kw">flat_map_chr</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="op">~</span><span class="st"> </span><span class="kw">rep</span>(., <span class="kw">sample</span>(<span class="dv">3</span>, <span class="dv">1</span>)))
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot;</span></code></pre>
<p>The recursive case for pairlists is straightforward: we iterate over every element of the pairlist (i.e. each function argument) and combine the results. The case for calls is a little bit more complex - if this is a call to <code>&lt;-</code> then we should return the second element of the call:</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="co"># Base cases</span>
    <span class="dt">constant =</span> ,
    <span class="dt">symbol =</span> <span class="kw">character</span>(),

    <span class="co"># Recursive cases</span>
    <span class="dt">pairlist =</span> <span class="kw">flat_map_chr</span>(<span class="kw">as.list</span>(x), find_assign_rec),
    <span class="dt">call =</span> {
      <span class="cf">if</span> (<span class="kw">is_call</span>(x, <span class="st">&quot;&lt;-&quot;</span>)) {
        <span class="kw">as_string</span>(x[[<span class="dv">2</span>]])
      } <span class="cf">else</span> {
        <span class="kw">flat_map_chr</span>(<span class="kw">as.list</span>(x), find_assign_rec)
      }
    }
  )
}

<span class="kw">find_assign</span>(a &lt;-<span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;a&quot;</span>
<span class="kw">find_assign</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  {
    b &lt;-<span class="st"> </span><span class="dv">2</span>
  }
})
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot;</span></code></pre>
<p>Now we need to make our function more robust by coming up with examples intended to break it. What happens when we assign to the same variable multiple times?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">find_assign</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  a &lt;-<span class="st"> </span><span class="dv">2</span>
})
<span class="co">#&gt; [1] &quot;a&quot; &quot;a&quot;</span></code></pre>
<p>It’s easiest to fix this at the level of the wrapper function:</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">unique</span>(<span class="kw">find_assign_rec</span>(<span class="kw">enexpr</span>(x)))

<span class="kw">find_assign</span>({
  a &lt;-<span class="st"> </span><span class="dv">1</span>
  a &lt;-<span class="st"> </span><span class="dv">2</span>
})
<span class="co">#&gt; [1] &quot;a&quot;</span></code></pre>
<p>What happens if we have nested calls to <code>&lt;-</code>? Currently we only return the first. That’s because when <code>&lt;-</code> occurs we immediately terminate recursion.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">find_assign</span>({
  a &lt;-<span class="st"> </span>b &lt;-<span class="st"> </span>c &lt;-<span class="st"> </span><span class="dv">1</span>
})
<span class="co">#&gt; [1] &quot;a&quot;</span></code></pre>
<p>Instead we need to take a more rigorous approach. I think it’s best to keep the recursive function focused on the tree structure, so I’m going to extract out <code>find_assign_call()</code> into a separate function.</p>
<pre class="sourceCode r"><code class="sourceCode r">find_assign_call &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (<span class="kw">is_call</span>(x, <span class="st">&quot;&lt;-&quot;</span>) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">is_symbol</span>(x[[<span class="dv">2</span>]])) {
    lhs &lt;-<span class="st"> </span><span class="kw">as_string</span>(x[[<span class="dv">2</span>]])
    children &lt;-<span class="st"> </span><span class="kw">as.list</span>(x)[<span class="op">-</span><span class="dv">1</span>]
  } <span class="cf">else</span> {
    lhs &lt;-<span class="st"> </span><span class="kw">character</span>()
    children &lt;-<span class="st"> </span><span class="kw">as.list</span>(x)
  }

  <span class="kw">c</span>(lhs, <span class="kw">flat_map_chr</span>(children, find_assign_rec))
}

find_assign_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="co"># Base cases</span>
    <span class="dt">constant =</span> ,
    <span class="dt">symbol =</span> <span class="kw">character</span>(),

    <span class="co"># Recursive cases</span>
    <span class="dt">pairlist =</span> <span class="kw">flat_map_chr</span>(x, find_assign_rec),
    <span class="dt">call =</span> <span class="kw">find_assign_call</span>(x)
  )
}

<span class="kw">find_assign</span>(a &lt;-<span class="st"> </span>b &lt;-<span class="st"> </span>c &lt;-<span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</span>
<span class="kw">find_assign</span>(<span class="kw">system.time</span>(x &lt;-<span class="st"> </span><span class="kw">print</span>(y &lt;-<span class="st"> </span><span class="dv">5</span>)))
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span></code></pre>
<p>The complete version of this function is quite complicated, it’s important to remember we wrote it by working our way up by writing simple component parts.</p>
</div>
<div id="exercises-55" class="section level3">
<h3><span class="header-section-number">18.5.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p><code>logical_abbr()</code> returns <code>TRUE</code> for <code>T(1, 2, 3)</code>. How could you modify
<code>logical_abbr_rec()</code> so that it ignores function calls that use <code>T</code> or <code>F</code>?</p></li>
<li><p><code>logical_abbr()</code> works with expressions. It currently fails when you give it
a function. Why not? How could you modify <code>logical_abbr()</code> to make it
work? What components of a function will you need to recurse over?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">logical_abbr</span>(<span class="cf">function</span>(<span class="dt">x =</span> <span class="ot">TRUE</span>) {
  <span class="kw">g</span>(x <span class="op">+</span><span class="st"> </span>T)
})</code></pre></li>
<li><p>Modify find assignment to also detect assignment using replacement
functions, i.e. <code>names(x) &lt;- y</code>.</p></li>
<li><p>Write a function that extracts all calls to a specified function.</p></li>
</ol>
</div>
</div>
<div id="expression-special" class="section level2">
<h2><span class="header-section-number">18.6</span> Specialised data structures</h2>
<p>There are two data structures and one special symbol that we need to cover for the sake of completeness. They are not usually important in practice.</p>
<div id="pairlists" class="section level3">
<h3><span class="header-section-number">18.6.1</span> Pairlists</h3>
<p></p>
<p>Pairlists are a remnant of R’s past and have been replaced by lists almost everywhere. The only place you are likely to see pairlists in R<span id="fn137" class="footnote" data-pagedown-footnote-number="137" style="white-space: pre-line;">If you’re working in C, you’ll encounter pairlists more often. For example, call objects are also implemented using pairlists.</span> is when working with calls to the “function” function, as the formal arguments to a function are stored in a pairlist:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="cf">function</span>(x, <span class="dt">y =</span> <span class="dv">10</span>) x <span class="op">+</span><span class="st"> </span>y)

args &lt;-<span class="st"> </span>f[[<span class="dv">2</span>]]
args
<span class="co">#&gt; $x</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>
<span class="co">#&gt; [1] 10</span>
<span class="kw">typeof</span>(args)
<span class="co">#&gt; [1] &quot;pairlist&quot;</span></code></pre>
<p>Fortunately, whenever you encounter a pairlist, you can treat it just like a regular list:</p>
<pre class="sourceCode r"><code class="sourceCode r">pl &lt;-<span class="st"> </span><span class="kw">pairlist</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>)
<span class="kw">length</span>(pl)
<span class="co">#&gt; [1] 2</span>
pl<span class="op">$</span>x
<span class="co">#&gt; [1] 1</span></code></pre>
<p>Behind the scenes pairlists are implemented using a different data structure, a linked list instead of an array. That makes subsetting a pairlist much slower than subsetting a list, but this has little practical impact.</p>
</div>
<div id="empty-symbol" class="section level3">
<h3><span class="header-section-number">18.6.2</span> Missing arguments</h3>
<p>
</p>
<p>The special symbol that needs a little extra discussion is the empty symbol, which is used to represent missing arguments (not missing values!). You only need to care about the missing symbol if you’re programmatically creating functions with missing arguments; we’ll come back to that in Section <a href="#unquote-missing">19.4.3</a>.</p>
<p>You can make an empty symbol with <code>missing_arg()</code> (or <code>expr()</code>):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">missing_arg</span>()
<span class="kw">typeof</span>(<span class="kw">missing_arg</span>())
<span class="co">#&gt; [1] &quot;symbol&quot;</span></code></pre>
<p>An empty symbol doesn’t print anything, so you can check if you have one with <code>rlang::is_missing()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is_missing</span>(<span class="kw">missing_arg</span>())
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>You’ll find them in the wild in function formals:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="cf">function</span>(x, <span class="dt">y =</span> <span class="dv">10</span>) x <span class="op">+</span><span class="st"> </span>y)
args &lt;-<span class="st"> </span>f[[<span class="dv">2</span>]]
<span class="kw">is_missing</span>(args[[<span class="dv">1</span>]])
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>This is particularly important for <code>...</code> which is always associated with an empty symbol:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="cf">function</span>(...) <span class="kw">list</span>(...))
args &lt;-<span class="st"> </span>f[[<span class="dv">2</span>]]
<span class="kw">is_missing</span>(args[[<span class="dv">1</span>]])
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>The empty symbol has a peculiar property: if you bind it to a variable, then access that variable, you will get an error:</p>
<pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">missing_arg</span>()
m
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   argument &quot;m&quot; is missing, with no default</span></code></pre>
<p>But you won’t if you store it inside another data structure!</p>
<pre class="sourceCode r"><code class="sourceCode r">ms &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">missing_arg</span>(), <span class="kw">missing_arg</span>())
ms[[<span class="dv">1</span>]]</code></pre>
<p>If you need to preserve the missingness of a variable, <code>rlang::maybe_missing()</code> is often helpful. It allows you to refer to a potentially missing variable without triggering the error. See the documentation for use cases and more details.</p>
</div>
<div id="expression-vectors" class="section level3">
<h3><span class="header-section-number">18.6.3</span> Expression vectors</h3>
<p>
</p>
<p>Finally, we need to briefly discuss the expression vector. Expression vectors are only produced by two base functions: <code>expression()</code> and <code>parse()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">exp1 &lt;-<span class="st"> </span><span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">c</span>(<span class="st">&quot;</span>
<span class="st">x &lt;- 4</span>
<span class="st">x</span>
<span class="st">&quot;</span>))
exp2 &lt;-<span class="st"> </span><span class="kw">expression</span>(x &lt;-<span class="st"> </span><span class="dv">4</span>, x)

<span class="kw">typeof</span>(exp1)
<span class="co">#&gt; [1] &quot;expression&quot;</span>
<span class="kw">typeof</span>(exp2)
<span class="co">#&gt; [1] &quot;expression&quot;</span>

exp1
<span class="co">#&gt; expression(x &lt;- 4, x)</span>
exp2
<span class="co">#&gt; expression(x &lt;- 4, x)</span></code></pre>
<p>Like calls and pairlists, expression vectors behave like lists:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(exp1)
<span class="co">#&gt; [1] 2</span>
exp1[[<span class="dv">1</span>]]
<span class="co">#&gt; x &lt;- 4</span></code></pre>
<p>Conceptually, an expression vector is just a list of expressions. The only difference is that calling <code>eval()</code> on an expression evaluates each individual expression. I don’t believe this advantage merits introducing a new data structure, so instead of expression vectors I just use lists of expressions.</p>
<!--chapter:end:Expressions.Rmd-->
</div>
</div>
</div>
<div id="quasiquotation" class="section level1">
<h1><span class="header-section-number">19</span> Quasiquotation</h1>
<div id="introduction-19" class="section level2">
<h2><span class="header-section-number">19.1</span> Introduction</h2>
<p>Now that you understand the tree structure of R code, it’s time to return to one of the fundamental ideas that make <code>expr()</code> and <code>ast()</code> work: quotation. In tidy evaluation, all quoting functions are actually quasiquoting functions because they also support unquoting. Where quotation is the act of capturing an unevaluated expression, <strong>unquotation</strong> is the ability to selectively evaluate parts of an otherwise quoted expression. Together, this is called quasiquotation. Quasiquotation makes it easy to create functions that combine code written by the function’s author with code written by the function’s user. This helps to solve a wide variety of challenging problems.</p>
<p>Quasiquotation is one of the three pillars of tidy evaluation. You’ll learn about the other two (quosures and the data mask) in Chapter <a href="#evaluation">20</a>. By itself, quasiquotation is most useful for programming, particularly for generating code. But when it’s combined with the other techniques, tidy evaluation becomes a powerful tool for data analysis.</p>
<div id="outline-17" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#quasi-motivation">19.2</a> motivates the development of quasiquotation
with a function, <code>cement()</code>, that works like <code>paste()</code> but automatically
“quotes” its arguments so that you don’t have to.</p></li>
<li><p>Section <a href="#quoting">19.3</a> gives you the tools to quote expressions, whether
they come from you or the user, or whether you use rlang or base R tools.</p></li>
<li><p>Section <a href="#unquoting">19.4</a> introduces the biggest difference between rlang
quoting functions and base quoting function: unquoting with <code>!!</code> and <code>!!!</code>.</p></li>
<li><p>Section <a href="#base-nonquote">19.5</a> discusses the three main “non-quoting”
techniques that base R functions uses to disable quoting behaviour.</p></li>
<li><p>Section <a href="#tidy-dots">19.6</a> explores another place that you can use <code>!!!</code>,
functions that take <code>...</code>. It also introduces the special <code>:=</code> operator,
which allows you to dynamically change argument names.</p></li>
<li><p>Section <a href="#expr-case-studies">19.7</a> shows a few practical uses of quoting to solve
problems that naturally require some code generation.</p></li>
<li><p>Section <a href="#history">19.8</a> finishes up with a little history of quasiquotation
for those who are interested.</p></li>
</ul>
</div>
<div id="prerequisites-12" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>Make sure you’ve read the metaprogramming overview in Chapter <a href="#meta-big-picture">17</a> to get a broad overview of the motivation and the basic vocabulary, and that you’re familiar with the tree structure of expressions as described in Section <a href="#expression-details">18.3</a>.</p>
<p>Code-wise, we’ll mostly be using the tools from rlang<span id="fn138" class="footnote" data-pagedown-footnote-number="138" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span>, but at the end of the chapter you’ll also see some powerful applications in conjunction with purrr<span id="fn139" class="footnote" data-pagedown-footnote-number="139" style="white-space: pre-line;"><a href="https://purrr.tidyverse.org" class="uri">https://purrr.tidyverse.org</a></span>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)
<span class="kw">library</span>(purrr)</code></pre>
</div>
<div id="related-work" class="section level3 unnumbered">
<h3>Related work</h3>
<p>
</p>
<p>Quoting functions have deep connections to Lisp <strong>macros</strong>. But macros are usually run at compile-time, which doesn’t exist in R, and they always input and output ASTs. See <span class="citation">Lumley (<a href="#ref-lumley-2001">2001</a>)</span> for one approach to implementing them in R. Quoting functions are more closely related to the more esoteric Lisp <strong>fexprs</strong><span id="fn140" class="footnote" data-pagedown-footnote-number="140" style="white-space: pre-line;"><a href="http://en.wikipedia.org/wiki/Fexpr" class="uri">http://en.wikipedia.org/wiki/Fexpr</a></span>, functions where all arguments are quoted by default. These terms are useful to know when looking for related work in other programming languages.</p>
</div>
</div>
<div id="quasi-motivation" class="section level2">
<h2><span class="header-section-number">19.2</span> Motivation</h2>
<p>We’ll start with a concrete example that helps motivate the need for unquoting, and hence quasiquotation. Imagine you’re creating a lot of strings by joining together words:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">paste</span>(<span class="st">&quot;Good&quot;</span>, <span class="st">&quot;morning&quot;</span>, <span class="st">&quot;Hadley&quot;</span>)
<span class="co">#&gt; [1] &quot;Good morning Hadley&quot;</span>
<span class="kw">paste</span>(<span class="st">&quot;Good&quot;</span>, <span class="st">&quot;afternoon&quot;</span>, <span class="st">&quot;Alice&quot;</span>)
<span class="co">#&gt; [1] &quot;Good afternoon Alice&quot;</span></code></pre>
<p>You are sick and tired of writing all those quotes, and instead you just want to use bare words. To that end, you’ve written the following function. (Don’t worry about the implementation for now; you’ll learn about the pieces later.)</p>
<pre class="sourceCode r"><code class="sourceCode r">cement &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  args &lt;-<span class="st"> </span><span class="kw">ensyms</span>(...)
  <span class="kw">paste</span>(purrr<span class="op">::</span><span class="kw">map</span>(args, as_string), <span class="dt">collapse =</span> <span class="st">&quot; &quot;</span>)
}

<span class="kw">cement</span>(Good, morning, Hadley)
<span class="co">#&gt; [1] &quot;Good morning Hadley&quot;</span>
<span class="kw">cement</span>(Good, afternoon, Alice)
<span class="co">#&gt; [1] &quot;Good afternoon Alice&quot;</span></code></pre>
<p>Formally, this function quotes all of its inputs. You can think of it as automatically putting quotation marks around each argument. That’s not precisely true as the intermediate objects it generates are expressions, not strings, but it’s a useful approximation, and the root meaning of the term “quote”.</p>
<p>This function is nice because we no longer need to type quotation marks. The problem comes when we want to use variables. It’s easy to use variables with <code>paste()</code>: just don’t surround them with quotation marks.</p>
<pre class="sourceCode r"><code class="sourceCode r">name &lt;-<span class="st"> &quot;Hadley&quot;</span>
time &lt;-<span class="st"> &quot;morning&quot;</span>

<span class="kw">paste</span>(<span class="st">&quot;Good&quot;</span>, time, name)
<span class="co">#&gt; [1] &quot;Good morning Hadley&quot;</span></code></pre>
<p>Obviously this doesn’t work with <code>cement()</code> because every input is automatically quoted:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cement</span>(Good, time, name)
<span class="co">#&gt; [1] &quot;Good time name&quot;</span></code></pre>
<p>We need some way to explicitly <em>unquote</em> the input to tell <code>cement()</code> to remove the automatic quote marks. Here we need <code>time</code> and <code>name</code> to be treated differently to <code>Good</code>. Quasiquotation gives us a standard tool to do so: <code>!!</code>, called “unquote”, and pronounced bang-bang. <code>!!</code> tells a quoting function to drop the implicit quotes:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cement</span>(Good, <span class="op">!!</span>time, <span class="op">!!</span>name)
<span class="co">#&gt; [1] &quot;Good morning Hadley&quot;</span></code></pre>
<p>It’s useful to compare <code>cement()</code> and <code>paste()</code> directly. <code>paste()</code> evaluates its arguments, so we must quote where needed; <code>cement()</code> quotes its arguments, so we must unquote where needed.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">paste</span>(<span class="st">&quot;Good&quot;</span>, time, name)
<span class="kw">cement</span>(Good, <span class="op">!!</span>time, <span class="op">!!</span>name)</code></pre>
<div id="vocabulary" class="section level3">
<h3><span class="header-section-number">19.2.1</span> Vocabulary</h3>
<p>
</p>
<p>The distinction between quoted and evaluated arguments is important:</p>
<ul>
<li><p>An <strong>evaluated</strong> argument obeys R’s usual evaluation rules.</p></li>
<li><p>A <strong>quoted</strong> argument is captured by the function, and is processed in
some custom way.</p></li>
</ul>
<p><code>paste()</code> evaluates all its arguments; <code>cement()</code> quotes all its arguments.</p>
<p>If you’re ever unsure about whether an argument is quoted or evaluated, try executing the code outside of the function. If it doesn’t work or does something different, then that argument is quoted. For example, you can use this technique to determine that the first argument to <code>library()</code> is quoted:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># works</span>
<span class="kw">library</span>(MASS)

<span class="co"># fails</span>
MASS
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;MASS&#39; not found</span></code></pre>
<p>Talking about whether an argument is quoted or evaluated is a more precise way of stating whether or not a function uses non-standard evaluation (NSE). I will sometimes use “quoting function” as short-hand for a “function that quotes one or more arguments”, but generally, I’ll talk about quoted arguments since that is the level at which the difference applies.</p>
</div>
<div id="exercises-56" class="section level3">
<h3><span class="header-section-number">19.2.2</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>For each function in the following base R code, identify which arguments
are quoted and which are evaluated.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)

mtcars2 &lt;-<span class="st"> </span><span class="kw">subset</span>(mtcars, cyl <span class="op">==</span><span class="st"> </span><span class="dv">4</span>)

<span class="kw">with</span>(mtcars2, <span class="kw">sum</span>(vs))
<span class="kw">sum</span>(mtcars2<span class="op">$</span>am)

<span class="kw">rm</span>(mtcars2)</code></pre></li>
<li><p>For each function in the following tidyverse code, identify which arguments
are quoted and which are evaluated.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">library</span>(ggplot2)

by_cyl &lt;-<span class="st"> </span>mtcars <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(cyl) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(mpg))

<span class="kw">ggplot</span>(by_cyl, <span class="kw">aes</span>(cyl, mean)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</code></pre></li>
</ol>
</div>
</div>
<div id="quoting" class="section level2">
<h2><span class="header-section-number">19.3</span> Quoting</h2>
<p></p>
<p>The first part of quasiquotation is quotation: capturing an expression without evaluating it. We’ll need a pair of functions because the expression can be supplied directly or indirectly, via lazily-evaluated function argument. I’ll start with the rlang quoting functions, then circle back to those provided by base R.</p>
<div id="capturing-expressions" class="section level3">
<h3><span class="header-section-number">19.3.1</span> Capturing expressions</h3>
<p>

</p>
<p>There are four important quoting functions. For interactive exploration, the most important is <code>expr()</code>, which captures its argument exactly as provided:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y)
<span class="co">#&gt; x + y</span>
<span class="kw">expr</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span><span class="dv">3</span>)
<span class="co">#&gt; 1/2/3</span></code></pre>
<p>(Remember that white space and comments are not part of the expression, so will not be captured by a quoting function.)</p>
<p><code>expr()</code> is great for interactive exploration, because it captures what you, the developer, typed. It’s not so useful inside a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">expr</span>(x)
<span class="kw">f1</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c)
<span class="co">#&gt; x</span></code></pre>

<p>We need another function to solve this problem: <code>enexpr()</code>. This captures what the caller supplied to the function by looking at the internal promise object that powers lazy evaluation (Section <a href="#promises">6.5.1</a>).</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">enexpr</span>(x)
<span class="kw">f2</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c)
<span class="co">#&gt; a + b + c</span></code></pre>
<p>(It’s called “en”-<code>expr()</code> by analogy to enrich. Enriching someone makes them richer; <code>enexpr()</code>ing a argument makes it an expression.)</p>
<p>To capture all arguments in <code>...</code>, use <code>enexprs()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(...) <span class="kw">enexprs</span>(...)
<span class="kw">f</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">10</span> <span class="op">*</span><span class="st"> </span>z)
<span class="co">#&gt; $x</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>
<span class="co">#&gt; 10 * z</span></code></pre>
<p>Finally, <code>exprs()</code> is useful interactively to make a list of expressions:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exprs</span>(<span class="dt">x =</span> x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>, <span class="dt">y =</span> y <span class="op">^</span><span class="st"> </span><span class="dv">3</span>, <span class="dt">z =</span> z <span class="op">^</span><span class="st"> </span><span class="dv">4</span>)
<span class="co"># shorthand for</span>
<span class="co"># list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))</span></code></pre>
<p>In short, use <code>enexpr()</code> and <code>enexprs()</code> to capture the expressions supplied as arguments <em>by the user</em>. Use <code>expr()</code> and <code>exprs()</code> to capture expressions that <em>you</em> supply.</p>
</div>
<div id="capturing-symbols" class="section level3">
<h3><span class="header-section-number">19.3.2</span> Capturing symbols</h3>
<p>
</p>
<p>Sometimes you only want to allow the user to specify a variable name, not an arbitrary expression. In this case, you can use <code>ensym()</code> or <code>ensyms()</code>. These are variants of <code>enexpr()</code> and <code>enexprs()</code> that check the captured expression is either symbol or a string (which is converted to a symbol<span id="fn141" class="footnote" data-pagedown-footnote-number="141" style="white-space: pre-line;">This is for compatibility with base R, which allows you to provide a string instead of a symbol in many places: <code>&quot;x&quot; &lt;- 1</code>, <code>&quot;foo&quot;(x, y)</code>, <code>c(&quot;x&quot; = 1)</code>.</span>). <code>ensym()</code> and <code>ensyms()</code> throw an error if given anything else.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(...) <span class="kw">ensyms</span>(...)
<span class="kw">f</span>(x)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; x</span>
<span class="kw">f</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; x</span></code></pre>
</div>
<div id="with-base-r" class="section level3">
<h3><span class="header-section-number">19.3.3</span> With base R</h3>
<p>
</p>
<p>Each rlang function described above has an equivalent in base R. They primary difference is that the base equivalents do not support unquoting (which we’ll talk about very soon). This make them quoting functions, rather than quasiquoting functions.</p>
<p>The base equivalent of <code>expr()</code> is <code>quote()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quote</span>(x <span class="op">+</span><span class="st"> </span>y)
<span class="co">#&gt; x + y</span></code></pre>
<p>The base function closest to <code>enexpr()</code> is <code>substitute()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f3 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">substitute</span>(x)
<span class="kw">f3</span>(x <span class="op">+</span><span class="st"> </span>y)
<span class="co">#&gt; x + y</span></code></pre>

<p>The base equivalent to <code>exprs()</code> is <code>alist()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alist</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> x <span class="op">+</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; $x</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>
<span class="co">#&gt; x + 2</span></code></pre>
<p>The equivalent to <code>enexprs()</code> is an undocumented feature of <code>substitute()</code><span id="fn143" class="footnote" data-pagedown-footnote-number="143" style="white-space: pre-line;">Discovered by Peter Meilstrup and described in R-devel on 2018-08-13<span id="fn142" class="footnote" data-pagedown-footnote-number="142" style="white-space: pre-line;"><a href="http://r.789695.n4.nabble.com/substitute-on-arguments-in-ellipsis-quot-dot-dot-dot-quot-td4751658.html" class="uri">http://r.789695.n4.nabble.com/substitute-on-arguments-in-ellipsis-quot-dot-dot-dot-quot-td4751658.html</a></span>.</span>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(...) <span class="kw">as.list</span>(<span class="kw">substitute</span>(<span class="kw">...</span>()))
<span class="kw">f</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">10</span> <span class="op">*</span><span class="st"> </span>z)
<span class="co">#&gt; $x</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $y</span>
<span class="co">#&gt; 10 * z</span></code></pre>
<p>There are two other important base quoting functions that we’ll cover elsewhere:</p>
<ul>
<li><p><code>bquote()</code> provides a limited form of quasiquotation, and is discussed in
Section <a href="#base-nonquote">19.5</a>.</p></li>
<li><p><code>~</code>, the formula, is a quoting function that also captures the environment.
It’s the inspiration for quosures, the topic of the next chapter, and is
discussed in Section <a href="#quosure-impl">20.3.4</a>.</p></li>
</ul>
</div>
<div id="substitution" class="section level3">
<h3><span class="header-section-number">19.3.4</span> Substitution</h3>

<p>You’ll most often see <code>substitute()</code> used to capture unevaluated arguments. However, as well as quoting, <code>substitute()</code> also does “substitution”: if you give it an expression, rather than a symbol, it will substitute in the values of symbols defined in the current environment.</p>
<pre class="sourceCode r"><code class="sourceCode r">f4 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">substitute</span>(x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)
<span class="kw">f4</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c)
<span class="co">#&gt; (a + b + c) * 2</span></code></pre>
<p>I think this makes code hard to understand, because if it is taken out of context, you can’t tell if the goal of <code>substitute(x + y)</code> is to replace <code>x</code>, <code>y</code>, or both. If you do want to use <code>substitute()</code> for substitution, I recommend that you use the second argument to make your goal clear:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">substitute</span>(x <span class="op">*</span><span class="st"> </span>y <span class="op">*</span><span class="st"> </span>z, <span class="kw">list</span>(<span class="dt">x =</span> <span class="dv">10</span>, <span class="dt">y =</span> <span class="kw">quote</span>(a <span class="op">+</span><span class="st"> </span>b)))
<span class="co">#&gt; 10 * (a + b) * z</span></code></pre>
</div>
<div id="summary-1" class="section level3">
<h3><span class="header-section-number">19.3.5</span> Summary</h3>
<p>When quoting (i.e. capturing code), there are two important distinctions:</p>
<ul>
<li><p>Is it supplied by the developer of the code or the user of the code?
I.e. is it fixed (supplied in the body of the function) or varying (supplied
via an argument)?</p></li>
<li><p>Do you want to capture a single expression or multiple expressions?</p></li>
</ul>
<p>This leads to a 2 x 2 table of functions for rlang, Table <a href="#tab:quoting-rlang">19.1</a>, and base R, Table <a href="#tab:quoting-base">19.2</a>.</p>
<table>
<caption><span id="tab:quoting-rlang">Table 19.1: </span> rlang quasiquoting functions</caption>
<thead>
<tr class="header">
<th></th>
<th>Developer</th>
<th>User</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>One</td>
<td><code>expr()</code></td>
<td><code>enexpr()</code></td>
</tr>
<tr class="even">
<td>Many</td>
<td><code>exprs()</code></td>
<td><code>enexprs()</code></td>
</tr>
</tbody>
</table>
<table>
<caption><span id="tab:quoting-base">Table 19.2: </span> base R quoting functions</caption>
<thead>
<tr class="header">
<th></th>
<th>Developer</th>
<th>User</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>One</td>
<td><code>quote()</code></td>
<td><code>substitute()</code></td>
</tr>
<tr class="even">
<td>Many</td>
<td><code>alist()</code></td>
<td><code>as.list(substitute(...()))</code></td>
</tr>
</tbody>
</table>
</div>
<div id="exercises-57" class="section level3">
<h3><span class="header-section-number">19.3.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How is <code>expr()</code> implemented? Look at its source code.</p></li>
<li><p>Compare and contrast the following two functions. Can you predict the
output before running them?</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  <span class="kw">exprs</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)
}
f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  <span class="kw">enexprs</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)
}
<span class="kw">f1</span>(a <span class="op">+</span><span class="st"> </span>b, c <span class="op">+</span><span class="st"> </span>d)
<span class="kw">f2</span>(a <span class="op">+</span><span class="st"> </span>b, c <span class="op">+</span><span class="st"> </span>d)</code></pre></li>
<li><p>What happens if you try to use <code>enexpr()</code> with an expression (i.e.
<code>enexpr(x + y)</code> ? What happens if <code>enexpr()</code> is passed a missing argument?</p></li>
<li><p>How are <code>exprs(a)</code> and <code>exprs(a = )</code> different? Think about both the
input and the output.</p></li>
<li><p>What are other differences between <code>exprs()</code> and <code>alist()</code>? Read the
documentation for the named arguments of <code>exprs()</code> to find out.</p></li>
<li><p>The documentation for <code>substitute()</code> says:</p>
<blockquote>
<p>Substitution takes place by examining each component of the parse tree
as follows:</p>
<ul>
<li>If it is not a bound symbol in <code>env</code>, it is unchanged.</li>
<li>If it is a promise object (i.e., a formal argument to a function)
the expression slot of the promise replaces the symbol.</li>
<li>If it is an ordinary variable, its value is substituted;</li>
<li>Unless <code>env</code> is .GlobalEnv in which case the symbol is left
unchanged.</li>
</ul>
</blockquote>
<p>Create examples that illustrate each of the four different cases.</p></li>
</ol>
</div>
</div>
<div id="unquoting" class="section level2">
<h2><span class="header-section-number">19.4</span> Unquoting</h2>
<p>

</p>
<p>So far, you’ve only seen relatively small advantages of the rlang quoting functions over the base R quoting functions: they have a more consistent naming scheme. The big difference is that rlang quoting functions are actually quasiquoting functions because they can also unquote.</p>
<p>Unquoting allows you to selectively evaluate parts of the expression that would otherwise be quoted, which effectively allows you to merge together ASTs using a template AST. Since base functions don’t use unquoting, they instead use a variety of other techniques, which you’ll learn about in Section <a href="#base-nonquote">19.5</a>.</p>
<p>Unquoting is one inverse of quoting. It allows you to selectively evaluate code inside <code>expr()</code>, so that <code>expr(!!x)</code> is equivalent to <code>x</code>. In Chapter <a href="#evaluation">20</a>, you’ll learn about another inverse, evaluation. This happens outside <code>expr()</code>, so that <code>eval(expr(x))</code> is equivalent to <code>x</code>.</p>
<div id="unquoting-one-argument" class="section level3">
<h3><span class="header-section-number">19.4.1</span> Unquoting one argument</h3>

<p>Use <code>!!</code> to unquote a single argument in a function call. <code>!!</code> takes a single expression, evaluates it, and inlines the result in the AST.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">expr</span>(a <span class="op">+</span><span class="st"> </span>b <span class="op">+</span><span class="st"> </span>c)
<span class="kw">expr</span>(<span class="kw">f</span>(<span class="op">!!</span>x, y))
<span class="co">#&gt; f(a + b + c, y)</span></code></pre>
<p>I think this is easiest to understand with a diagram. <code>!!</code> introduces a placeholder in the AST, shown with dotted borders. Here the placeholder <code>x</code> is replaced by an AST, illustrated by a dotted connection.</p>
<p><img src="diagrams/quotation/bang-bang.png" width="260" style="display: block; margin: auto;" /></p>
<p>As well as call objects, <code>!!</code> also works with symbols and constants:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">sym</span>(<span class="st">&quot;y&quot;</span>)
b &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">expr</span>(<span class="kw">f</span>(<span class="op">!!</span>a, <span class="op">!!</span>b))
<span class="co">#&gt; f(y, 1)</span></code></pre>
<p><img src="diagrams/quotation/simple.png" width="226" style="display: block; margin: auto;" /></p>
<p>If the right-hand side of <code>!!</code> is a function call, <code>!!</code> will evaluate it and insert the results:</p>
<pre class="sourceCode r"><code class="sourceCode r">mean_rm &lt;-<span class="st"> </span><span class="cf">function</span>(var) {
  var &lt;-<span class="st"> </span><span class="kw">ensym</span>(var)
  <span class="kw">expr</span>(<span class="kw">mean</span>(<span class="op">!!</span>var, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
}
<span class="kw">expr</span>(<span class="op">!!</span><span class="kw">mean_rm</span>(x) <span class="op">+</span><span class="st"> </span><span class="op">!!</span><span class="kw">mean_rm</span>(y))
<span class="co">#&gt; mean(x, na.rm = TRUE) + mean(y, na.rm = TRUE)</span></code></pre>
<p><code>!!</code> preserves operator precedence because it works with expressions.</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
x2 &lt;-<span class="st"> </span><span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span><span class="dv">2</span>)

<span class="kw">expr</span>(<span class="op">!!</span>x1 <span class="op">/</span><span class="st"> </span><span class="op">!!</span>x2)
<span class="co">#&gt; (x + 1)/(x + 2)</span></code></pre>
<p><img src="diagrams/quotation/infix.png" width="430" style="display: block; margin: auto;" /></p>
<p>If we simply pasted the text of the expressions together, we’d end up with <code>x + 1 / x + 2</code>, which has a very different AST:</p>
<p><img src="diagrams/quotation/infix-bad.png" width="283" style="display: block; margin: auto;" /></p>
</div>
<div id="unquoting-a-function" class="section level3">
<h3><span class="header-section-number">19.4.2</span> Unquoting a function</h3>
<p></p>
<p><code>!!</code> is most commonly used to replace the arguments to a function, but you can also use it to replace the function itself. The only challenge here is operator precedence: <code>expr(!!f(x, y))</code> unquotes the result of <code>f(x, y)</code>, so you need an extra pair of parentheses.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(foo)
<span class="kw">expr</span>((<span class="op">!!</span>f)(x, y))
<span class="co">#&gt; foo(x, y)</span></code></pre>
<p>This also works when <code>f</code> is itself a call:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(pkg<span class="op">::</span>foo)
<span class="kw">expr</span>((<span class="op">!!</span>f)(x, y))
<span class="co">#&gt; pkg::foo(x, y)</span></code></pre>
<p><img src="diagrams/quotation/fun.png" width="298" style="display: block; margin: auto;" /></p>
<p>Because of the large number of parentheses involved, it can be clearer to use <code>rlang::call2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">expr</span>(pkg<span class="op">::</span>foo)
<span class="kw">call2</span>(f, <span class="kw">expr</span>(x), <span class="kw">expr</span>(y))
<span class="co">#&gt; pkg::foo(x, y)</span></code></pre>
</div>
<div id="unquote-missing" class="section level3">
<h3><span class="header-section-number">19.4.3</span> Unquoting a missing argument</h3>
<p>
</p>
<p>Very occasionally it is useful to unquote a missing argument (Section <a href="#empty-symbol">18.6.2</a>), but the naive approach doesn’t work:</p>
<pre class="sourceCode r"><code class="sourceCode r">arg &lt;-<span class="st"> </span><span class="kw">missing_arg</span>()
<span class="kw">expr</span>(<span class="kw">foo</span>(<span class="op">!!</span>arg, <span class="op">!!</span>arg))
<span class="co">#&gt; Error in enexpr(expr):</span>
<span class="co">#&gt;   argument &quot;arg&quot; is missing, with no default</span></code></pre>
<p>You can work around this with the <code>rlang::maybe_missing()</code> helper:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr</span>(<span class="kw">foo</span>(<span class="op">!!</span><span class="kw">maybe_missing</span>(arg), <span class="op">!!</span><span class="kw">maybe_missing</span>(arg)))
<span class="co">#&gt; foo(, )</span></code></pre>
</div>
<div id="unquoting-in-special-forms" class="section level3">
<h3><span class="header-section-number">19.4.4</span> Unquoting in special forms</h3>
<p>
</p>
<p>There are a few special forms where unquoting is a syntax error. Take <code>$</code> for example: it must always be followed by the name of a variable, not another expression. This means attempting to unquote with <code>$</code> will fail with a syntax error:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr</span>(df<span class="op">$!!</span>x)
<span class="co">#&gt; Error: unexpected &#39;!&#39; in &quot;expr(df$!&quot;</span></code></pre>
<p>To make unquoting work, you’ll need to use the prefix form (Section <a href="#prefix-transform">6.8.1</a>):</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">expr</span>(x)
<span class="kw">expr</span>(<span class="st">`</span><span class="dt">$</span><span class="st">`</span>(df, <span class="op">!!</span>x))
<span class="co">#&gt; df$x</span></code></pre>
</div>
<div id="unquoting-many-arguments" class="section level3">
<h3><span class="header-section-number">19.4.5</span> Unquoting many arguments</h3>

<p>

</p>
<p><code>!!</code> is a one-to-one replacement. <code>!!!</code> (called “unquote-splice”, and pronounced bang-bang-bang) is a one-to-many replacement. It takes a list of expressions and inserts them at the location of the <code>!!!</code>:</p>
<!-- GVW: brief note to explain why `!!` can't be made smart enough to do this automatically? -->
<pre class="sourceCode r"><code class="sourceCode r">xs &lt;-<span class="st"> </span><span class="kw">exprs</span>(<span class="dv">1</span>, a, <span class="op">-</span>b)
<span class="kw">expr</span>(<span class="kw">f</span>(<span class="op">!!!</span>xs, y))
<span class="co">#&gt; f(1, a, -b, y)</span>

<span class="co"># Or with names</span>
ys &lt;-<span class="st"> </span><span class="kw">set_names</span>(xs, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
<span class="kw">expr</span>(<span class="kw">f</span>(<span class="op">!!!</span>ys, <span class="dt">d =</span> <span class="dv">4</span>))
<span class="co">#&gt; f(a = 1, b = a, c = -b, d = 4)</span></code></pre>
<p><img src="diagrams/quotation/bang-bang-bang.png" width="373" style="display: block; margin: auto;" /></p>
<p><code>!!!</code> can be used in any rlang function that takes <code>...</code> regardless of whether or not <code>...</code> is quoted or evaluated. We’ll come back to this in Section <a href="#tidy-dots">19.6</a>; for now note that this can be useful in <code>call2()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">call2</span>(<span class="st">&quot;f&quot;</span>, <span class="op">!!!</span>xs, <span class="kw">expr</span>(y))
<span class="co">#&gt; f(1, a, -b, y)</span></code></pre>
</div>
<div id="the-polite-fiction-of" class="section level3">
<h3><span class="header-section-number">19.4.6</span> The polite fiction of <code>!!</code></h3>
<p>So far we have acted as if <code>!!</code> and <code>!!!</code> are regular prefix operators like <code>+</code> , <code>-</code>, and <code>!</code>. They’re not. From R’s perspective, <code>!!</code> and <code>!!!</code> are simply the repeated application of <code>!</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="op">!!</span><span class="ot">TRUE</span>
<span class="co">#&gt; [1] TRUE</span>
<span class="op">!!!</span><span class="ot">TRUE</span>
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p><code>!!</code> and <code>!!!</code> behave specially inside all quoting functions powered by rlang, where they behave like real operators with precedence equivalent to unary <code>+</code> and <code>-</code>. This requires considerable work inside rlang, but means that you can write <code>!!x + !!y</code> instead of <code>(!!x) + (!!y)</code>.</p>
<p>The biggest downside<span id="fn144" class="footnote" data-pagedown-footnote-number="144" style="white-space: pre-line;">Prior to R 3.5.1, there was another major downside: the R deparser treated <code>!!x</code> as <code>!(!x)</code>. This is why in old versions of R you might see extra parentheses when printing expressions. The good news is that these parentheses are not real and can be safely ignored most of the time. The bad news is that they will become real if you reparse that printed output to R code. These roundtripped functions will not work as expected since <code>!(!x)</code> does not unquote.</span> to using a fake operator is that you might get silent errors when misusing <code>!!</code> outside of quasiquoting functions. Most of the time this is not an issue because <code>!!</code> is typically used to unquote expressions or quosures. Since expressions are not supported by the negation operator, you will get an argument type error in this case:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">quote</span>(variable)
<span class="op">!!</span>x
<span class="co">#&gt; Error in !x:</span>
<span class="co">#&gt;   invalid argument type</span></code></pre>
<p>But you can get silently incorrect results when working with numeric values:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)
y &lt;-<span class="st"> </span><span class="dv">100</span>
<span class="kw">with</span>(df, x <span class="op">+</span><span class="st"> </span><span class="op">!!</span>y)
<span class="co">#&gt; [1] 2 3 4 5 6</span></code></pre>
<p>Given these drawbacks, you might wonder why we introduced new syntax instead of using regular function calls. Indeed, early versions of tidy evaluation used function calls like <code>UQ()</code> and <code>UQS()</code>. However, they’re not really function calls, and pretending they are leads to a misleading mental mode. We chose <code>!!</code> and <code>!!!</code> as the least-bad solution:</p>
<ul>
<li><p>The are visually strong and don’t look like existing syntax. When you
see <code>!!x</code> or <code>!!!x</code> it’s clear that something unusual is happening.</p></li>
<li><p>They overrides a rarely used piece of syntax, as double negation is not a
common pattern in R<span id="fn145" class="footnote" data-pagedown-footnote-number="145" style="white-space: pre-line;">Unlike, say, javascript, where <code>!!x</code> is a commonly used shortcut to convert an integer into a logical.</span>. If you you do need it, you can just
add parentheses <code>!(!x)</code>.</p></li>
</ul>
</div>
<div id="non-standard-ast" class="section level3">
<h3><span class="header-section-number">19.4.7</span> Non-standard ASTs</h3>
<p></p>
<p>With unquoting, it’s easy to create non-standard ASTs, i.e. ASTs that contain components that are not expressions. (It is also possible to create non-standard ASTs by directly manipulating the underlying objects, but it’s harder to do so accidentally.) These are valid, and occasionally useful, but their correct use is beyond the scope of this book. However, it’s important to learn about them, because they can be deparsed, and hence printed, in misleading ways.</p>
<p>For example, if you inline more complex objects, their attributes are not printed. This can lead to confusing output:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">class</span>(<span class="op">!!</span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">10</span>)))
x1
<span class="co">#&gt; class(list(x = 10))</span>
<span class="kw">eval</span>(x1)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre>
<p>You have two main tools to reduce this confusion: <code>rlang::expr_print()</code> and <code>lobstr::ast()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr_print</span>(x1)
<span class="co">#&gt; class(&lt;data.frame&gt;)</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="op">!!</span>x1)
<span class="co">#&gt; █─class </span>
<span class="co">#&gt; └─&lt;inline data.frame&gt;</span></code></pre>
<p>Another confusing case arises if you inline an integer sequence:</p>
<pre class="sourceCode r"><code class="sourceCode r">x2 &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">f</span>(<span class="op">!!</span><span class="kw">c</span>(1L, 2L, 3L, 4L, 5L)))
x2
<span class="co">#&gt; f(1:5)</span>
<span class="kw">expr_print</span>(x2)
<span class="co">#&gt; f(&lt;int: 1L, 2L, 3L, 4L, 5L&gt;)</span>
lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="op">!!</span>x2)
<span class="co">#&gt; █─f </span>
<span class="co">#&gt; └─&lt;inline integer&gt;</span></code></pre>
<p>It’s also possible to create regular ASTs that can not be generated from code because of operator precedence. In this case, R will print parentheses that do not exist in the AST:</p>
<pre class="sourceCode r"><code class="sourceCode r">x3 &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="op">!!</span><span class="kw">expr</span>(<span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span>))
x3
<span class="co">#&gt; 1 + (2 + 3)</span>

lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="op">!!</span>x3)
<span class="co">#&gt; █─`+` </span>
<span class="co">#&gt; ├─1 </span>
<span class="co">#&gt; └─█─`+` </span>
<span class="co">#&gt;   ├─2 </span>
<span class="co">#&gt;   └─3</span></code></pre>
</div>
<div id="exercises-58" class="section level3">
<h3><span class="header-section-number">19.4.8</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Given the following components:</p>
<pre class="sourceCode r"><code class="sourceCode r">xy &lt;-<span class="st"> </span><span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y)
xz &lt;-<span class="st"> </span><span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>z)
yz &lt;-<span class="st"> </span><span class="kw">expr</span>(y <span class="op">+</span><span class="st"> </span>z)
abc &lt;-<span class="st"> </span><span class="kw">exprs</span>(a, b, c)</code></pre>
<p>Use quasiquotation to construct the following calls:</p>
<pre class="sourceCode r"><code class="sourceCode r">(x <span class="op">+</span><span class="st"> </span>y) <span class="op">/</span><span class="st"> </span>(y <span class="op">+</span><span class="st"> </span>z)
<span class="op">-</span>(x <span class="op">+</span><span class="st"> </span>z) <span class="op">^</span><span class="st"> </span>(y <span class="op">+</span><span class="st"> </span>z)
(x <span class="op">+</span><span class="st"> </span>y) <span class="op">+</span><span class="st"> </span>(y <span class="op">+</span><span class="st"> </span>z) <span class="op">-</span><span class="st"> </span>(x <span class="op">+</span><span class="st"> </span>y)
<span class="kw">atan2</span>(x <span class="op">+</span><span class="st"> </span>y, y <span class="op">+</span><span class="st"> </span>z)
<span class="kw">sum</span>(x <span class="op">+</span><span class="st"> </span>y, x <span class="op">+</span><span class="st"> </span>y, y <span class="op">+</span><span class="st"> </span>z)
<span class="kw">sum</span>(a, b, c)
<span class="kw">mean</span>(<span class="kw">c</span>(a, b, c), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="kw">foo</span>(<span class="dt">a =</span> x <span class="op">+</span><span class="st"> </span>y, <span class="dt">b =</span> y <span class="op">+</span><span class="st"> </span>z)</code></pre></li>
<li><p>The following two calls print the same, but are actually different:</p>
<pre class="sourceCode r"><code class="sourceCode r">(a &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)))
<span class="co">#&gt; mean(1:10)</span>
(b &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">mean</span>(<span class="op">!!</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))))
<span class="co">#&gt; mean(1:10)</span>
<span class="kw">identical</span>(a, b)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>What’s the difference? Which one is more natural?</p></li>
</ol>
</div>
</div>
<div id="base-nonquote" class="section level2">
<h2><span class="header-section-number">19.5</span> Non-quoting</h2>

<p></p>
<p>Base R has one function that implements quasiquotation: <code>bquote()</code>. It uses <code>.()</code> for unquoting:</p>
<pre class="sourceCode r"><code class="sourceCode r">xyz &lt;-<span class="st"> </span><span class="kw">bquote</span>((x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>z))
<span class="kw">bquote</span>(<span class="op">-</span>.(xyz) <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; -(x + y + z)/2</span></code></pre>
<p><code>bquote()</code> isn’t used by any other function in base R, and has had relatively little impact on how R code is written. There are three challenges to effective use of <code>bquote()</code>:</p>
<ul>
<li><p>It is only easily used with your code; it is hard to apply it to arbitrary
code supplied by a user.</p></li>
<li><p>It does not provide an unquote-splice operator that allows you to unquote
multiple expressions stored in a list.</p></li>
<li><p>It lacks the ability to handle code accompanied by an environment, which
is crucial for functions that evaluate code in the context of a data frame,
like <code>subset()</code> and friends.</p></li>
</ul>
<p>Instead functions that quote an argument use some other technique to allow indirect specification. Rather than using use unquoting all base R approaches selectively turn quoting off, so I call them <strong>non-quoting</strong> techniques.</p>
<p>There are four basic forms seen in base R:</p>
<ul>
<li><p>A pair of quoting and non-quoting functions. For example, <code>$</code> has two
arguments, and the second argument is quoted. This is easier to see if you
write in prefix form: <code>mtcars$cyl</code> is equivalent to <code>`$`(mtcars, cyl)</code>.
If you want to refer to a variable indirectly, you use <code>[[</code>, as it
takes the name of a variable as a string.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">var =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>)
var &lt;-<span class="st"> &quot;y&quot;</span>

x<span class="op">$</span>var
<span class="co">#&gt; [1] 1</span>
x[[var]]
<span class="co">#&gt; [1] 2</span></code></pre>
<p>There are three other quoting functions closely related to <code>$</code>: <code>subset()</code>,
<code>transform()</code>, and <code>with()</code>. These are seen as wrappers around <code>$</code> only
suitable for interactive use so they all have the same non-quoting
alternative: <code>[</code></p>
<p><code>&lt;-</code>/<code>assign()</code> and <code>::</code>/<code>getExportedValue()</code> work similarly to <code>$</code>/<code>[</code>.

</p></li>
<li><p>A pair of quoting and non-quoting arguments. For example, <code>rm()</code> allows
you to provide bare variable names in <code>...</code>, or a character vector of
variable names in <code>list</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">rm</span>(x)

y &lt;-<span class="st"> </span><span class="dv">2</span>
vars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;vars&quot;</span>)
<span class="kw">rm</span>(<span class="dt">list =</span> vars)</code></pre>
<p><code>data()</code> and <code>save()</code> work similarly.
</p></li>
<li><p>An argument that controls whether a different argument is quoting or
non-quoting. For example, in <code>library()</code>, the <code>character.only</code> argument
controls the quoting behaviour of the first argument, <code>package</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(MASS)

pkg &lt;-<span class="st"> &quot;MASS&quot;</span>
<span class="kw">library</span>(pkg, <span class="dt">character.only =</span> <span class="ot">TRUE</span>)</code></pre>
<p><code>demo()</code>, <code>detach()</code>, <code>example()</code>, and <code>require()</code> work similarly.
</p></li>
<li><p>Quoting if evaluation fails. For example, the first argument to <code>help()</code>
is non-quoting if it evaluates to a string; if evaluation fails, the
first argument is quoted.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Shows help for var</span>
<span class="kw">help</span>(var)

var &lt;-<span class="st"> &quot;mean&quot;</span>
<span class="co"># Shows help for mean</span>
<span class="kw">help</span>(var)

var &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="co"># Shows help for var</span>
<span class="kw">help</span>(var)</code></pre>
<p><code>ls()</code>, <code>page()</code>, and <code>match.fun()</code> work similarly.
</p></li>
</ul>

<p>Another important class of quoting functions are the base modelling and plotting functions, which follow the so-called standard non-standard evaluation rules: <a href="http://developer.r-project.org/nonstandard-eval.pdf" class="uri">http://developer.r-project.org/nonstandard-eval.pdf</a>. For example, <code>lm()</code> quotes the <code>weight</code> and <code>subset</code> arguments, and when used with a formula argument, the plotting function quotes the aesthetic arguments (<code>col</code>, <code>cex</code>, etc):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">palette</span>(RColorBrewer<span class="op">::</span><span class="kw">brewer.pal</span>(<span class="dv">3</span>, <span class="st">&quot;Set1&quot;</span>))
<span class="kw">plot</span>(
  Sepal.Length <span class="op">~</span><span class="st"> </span>Petal.Length, 
  <span class="dt">data =</span> iris, 
  <span class="dt">col =</span> Species, 
  <span class="dt">pch =</span> <span class="dv">20</span>, 
  <span class="dt">cex =</span> <span class="dv">2</span>
)</code></pre>
<p><img src="Quotation_files/figure-html/unnamed-chunk-58-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>These functions have no built-in options for indirect specification, but you’ll learn how to simulate unquoting in Section <a href="#base-nonquote">19.5</a>.</p>
</div>
<div id="tidy-dots" class="section level2">
<h2><span class="header-section-number">19.6</span> Dot-dot-dot (<code>...</code>)</h2>

<p></p>
<!-- GVW: this seems a long way away from the introduction of `!!!` earlier - move this up above non-quoting in base R? -->
<p><code>!!!</code> is useful because it’s not uncommon to have a list of expressions that you want to insert into a call. It turns out that this pattern is common elsewhere. Take the following two motivating problems:</p>
<ul>
<li><p>What do you do if the elements you want to put in <code>...</code> are already stored
in a list? For example, imagine you have a list of data frames that
you want to <code>rbind()</code> together:</p>
<pre class="sourceCode r"><code class="sourceCode r">dfs &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">a =</span> <span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>),
  <span class="dt">b =</span> <span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">4</span>)
)</code></pre>
<p>You could solve this specific case with <code>rbind(dfs$a, dfs$b)</code>, but how
do you generalise that solution to a list of arbitrary length?</p></li>
<li><p>What do you do if you want to supply the argument name indirectly? For
example, imagine you want to create a single column data frame where
the name of the column is specified in a variable:</p>
<pre class="sourceCode r"><code class="sourceCode r">var &lt;-<span class="st"> &quot;x&quot;</span>
val &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">9</span>)</code></pre>
<p>In this case, you could create a data frame and then change names
(i.e. <code>setNames(data.frame(val), var)</code>), but this feels inelegant.
How can we do better?</p></li>
</ul>
<p>One way to think about these problems is to draw explicit parallels to quasiquotation:</p>
<ul>
<li><p>Row-binding multiple data frames is like unquote-splicing: we want to inline
individual elements of the list into the call:</p>
<pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span><span class="kw">bind_rows</span>(<span class="op">!!!</span>dfs)
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 2</span>
<span class="co">#&gt; 2 3 4</span></code></pre>
<p>When used in this context, the behaviour of <code>!!!</code> is known as “spatting” in
Ruby, Go, PHP, and Julia. It is closely related to <code>*args</code> (star-args) and
<code>**kwarg</code> (star-star-kwargs) in Python, which are sometimes called argument
unpacking.
</p></li>
<li><p>The second problem is like unquoting the left-hand side of <code>=</code>: rather
than interpreting <code>var</code> literally, we want to use the value stored in the
variable called <code>var</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">tibble<span class="op">::</span><span class="kw">tibble</span>(<span class="op">!!</span>var <span class="op">:</span><span class="er">=</span><span class="st"> </span>val)
<span class="co">#&gt; # A tibble: 3 x 1</span>
<span class="co">#&gt;       x</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1     4</span>
<span class="co">#&gt; 2     3</span>
<span class="co">#&gt; 3     9</span></code></pre>
<p>Note the use of <code>:=</code> (pronounced colon-equals) rather than <code>=</code>. Unfortunately
we need this new operation because R’s grammar does not allow expressions as
argument names:</p>
<pre class="sourceCode r"><code class="sourceCode r">tibble<span class="op">::</span><span class="kw">tibble</span>(<span class="op">!!</span><span class="dt">var =</span> value)
<span class="co">#&gt; Error: unexpected &#39;=&#39; in &quot;tibble::tibble(!!var =&quot;</span></code></pre>
<p><code>:=</code> is like a vestigial organ: it’s recognised by R’s parser, but it
doesn’t have any code associated with it. It looks like an <code>=</code> but allows
expressions on either side, making it a more flexible alternative to <code>=</code>.
It is used in data.table for similar reasons.
</p></li>
</ul>
<!-- GVW: I think `:=` needs/deserves more than a fly-by in a bullet point... -->
<p>Base R takes a different approach, which we’ll come back to Section @ref{do-call}.</p>
<p>We say functions that support these tools, without quoting arguments, have <strong>tidy dots</strong><span id="fn146" class="footnote" data-pagedown-footnote-number="146" style="white-space: pre-line;">This is admittedly not the most creative of names, but it clearly suggests it’s something that has been added to R after the fact.</span>. To gain tidy dots behaviour in your own function, all you need to do is use <code>list2()</code>.</p>
<div id="examples" class="section level3">
<h3><span class="header-section-number">19.6.1</span> Examples</h3>
<p></p>
<p>One place we could use <code>list2()</code> is to create a wrapper around <code>attributes()</code> that allows us to set attributes flexibly:</p>
<pre class="sourceCode r"><code class="sourceCode r">set_attr &lt;-<span class="st"> </span><span class="cf">function</span>(.x, ...) {
  attr &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">list2</span>(...)
  <span class="kw">attributes</span>(.x) &lt;-<span class="st"> </span>attr
  .x
}

attrs &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>)
attr_name &lt;-<span class="st"> &quot;z&quot;</span>

<span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">set_attr</span>(<span class="dt">w =</span> <span class="dv">0</span>, <span class="op">!!!</span>attrs, <span class="op">!!</span>attr_name <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="dv">3</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt;  int [1:10] 1 2 3 4 5 6 7 8 9 10</span>
<span class="co">#&gt;  - attr(*, &quot;w&quot;)= num 0</span>
<span class="co">#&gt;  - attr(*, &quot;x&quot;)= num 1</span>
<span class="co">#&gt;  - attr(*, &quot;y&quot;)= num 2</span>
<span class="co">#&gt;  - attr(*, &quot;z&quot;)= num 3</span></code></pre>
</div>
<div id="exec" class="section level3">
<h3><span class="header-section-number">19.6.2</span> <code>exec()</code></h3>

<p>What if you want to use this technique with a function that doesn’t have tidy dots? One option is to use <code>rlang::exec()</code> to call a function with some arguments supplied directly (in <code>...</code>) and others indirectly (in a list):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Directly</span>
<span class="kw">exec</span>(<span class="st">&quot;mean&quot;</span>, <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">trim =</span> <span class="fl">0.1</span>)
<span class="co">#&gt; [1] 5.5</span>

<span class="co"># Indirectly</span>
args &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">trim =</span> <span class="fl">0.1</span>)
<span class="kw">exec</span>(<span class="st">&quot;mean&quot;</span>, <span class="op">!!!</span>args)
<span class="co">#&gt; [1] 5.5</span>

<span class="co"># Mixed</span>
params &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">trim =</span> <span class="fl">0.1</span>)
<span class="kw">exec</span>(<span class="st">&quot;mean&quot;</span>, <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="op">!!!</span>params)
<span class="co">#&gt; [1] 5.5</span></code></pre>
<p><code>rlang::exec()</code> also makes it possible to supply argument names indirectly:</p>
<pre class="sourceCode r"><code class="sourceCode r">arg_name &lt;-<span class="st"> &quot;na.rm&quot;</span>
arg_val &lt;-<span class="st"> </span><span class="ot">TRUE</span>
<span class="kw">exec</span>(<span class="st">&quot;mean&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="op">!!</span>arg_name <span class="op">:</span><span class="er">=</span><span class="st"> </span>arg_val)
<span class="co">#&gt; [1] 5.5</span></code></pre>
<p>And finally, it’s useful if you have a vector of function names or a list of functions that you want to call with the same arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">runif</span>(<span class="dv">10</span>), <span class="ot">NA</span>)
funs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;sd&quot;</span>)

purrr<span class="op">::</span><span class="kw">map_dbl</span>(funs, exec, x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0.444 0.482 0.298</span></code></pre>
<p><code>exec()</code> is closely related to <code>call2()</code>; where <code>call2()</code> returns an expression, <code>exec()</code> evaluates it.</p>
</div>
<div id="dots_list" class="section level3">
<h3><span class="header-section-number">19.6.3</span> <code>dots_list()</code></h3>

<p><code>list2()</code> provides one other handy feature: by default it will ignore any empty arguments at the end. This is useful in functions like <code>tibble::tibble()</code> because it means that you can easily change the order of variables without worrying about the final comma:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Can easily move x to first entry:</span>
tibble<span class="op">::</span><span class="kw">tibble</span>(
  <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,
  <span class="dt">z =</span> <span class="dv">3</span><span class="op">:-</span><span class="dv">1</span>,
  <span class="dt">x =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>,
)

<span class="co"># Need to remove comma from z and add comma to x</span>
<span class="kw">data.frame</span>(
  <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,
  <span class="dt">z =</span> <span class="dv">3</span><span class="op">:-</span><span class="dv">1</span>,
  <span class="dt">x =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>
)</code></pre>
<p><code>list2()</code> is a wrapper around <code>rlang::dots_list()</code> with defaults set to the most commonly used settings. You can get more control by calling <code>dots_list()</code> directly:</p>
<ul>
<li><p><code>.ignore_empty</code> allows you to control exactly which arguments are ignored.
The default ignores a single trailing argument to get the behaviour
describe above, but you can choose to ignore all missing arguments, or
no missing arguments.</p></li>
<li><p><code>.homonoyms</code> controls what happens if multiple arguments use the same name:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">dots_list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">x =</span> <span class="dv">2</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ x: num 1</span>
<span class="co">#&gt;  $ x: num 2</span>
<span class="kw">str</span>(<span class="kw">dots_list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">x =</span> <span class="dv">2</span>, <span class="dt">.homonyms =</span> <span class="st">&quot;first&quot;</span>))
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ x: num 1</span>
<span class="kw">str</span>(<span class="kw">dots_list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">x =</span> <span class="dv">2</span>, <span class="dt">.homonyms =</span> <span class="st">&quot;last&quot;</span>))
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ x: num 2</span>
<span class="kw">str</span>(<span class="kw">dots_list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">x =</span> <span class="dv">2</span>, <span class="dt">.homonyms =</span> <span class="st">&quot;error&quot;</span>))
<span class="co">#&gt; Error: Arguments can&#39;t have the same name.</span>
<span class="co">#&gt; We found multiple arguments named `x` at positions 1 and 2</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─utils::str(dots_list(x = 1, x = 2, .homonyms = &quot;error&quot;))</span>
<span class="co">#&gt;  2. ├─rlang::dots_list(x = 1, x = 2, .homonyms = &quot;error&quot;)</span>
<span class="co">#&gt;  3. └─rlang:::abort_dots_homonyms(x, y)</span></code></pre></li>
<li><p>If there are empty arguments that are not ignored, <code>.preserve_empty</code>
controls what to do with them. The default throws an error; setting
<code>.preserve_empty = TRUE</code> instead returns missing symbols. This is useful
if you’re using <code>dots_list()</code> to generate function calls.</p></li>
</ul>
</div>
<div id="do-call" class="section level3">
<h3><span class="header-section-number">19.6.4</span> With base R</h3>
<p>
</p>
<p>Base R provides a Swiss army knife to solve these problems: <code>do.call()</code>. <code>do.call()</code> has two main arguments. The first argument, <code>what</code>, gives a function to call. The second argument, <code>args</code>, is a list of arguments to pass to that function, and so <code>do.call(&quot;f&quot;, list(x, y, z))</code> is equivalent to <code>f(x, y, z)</code>.</p>
<ul>
<li><p><code>do.call()</code> gives a straightforward solution to <code>rbind()</code>ing together many
data frames:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">do.call</span>(<span class="st">&quot;rbind&quot;</span>, dfs)
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; a 1 2</span>
<span class="co">#&gt; b 3 4</span></code></pre></li>
<li><p>With a little more work, we can use <code>do.call()</code> to solve the second problem.
We first create a list of arguments, then name that, then use <code>do.call()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">args &lt;-<span class="st"> </span><span class="kw">list</span>(val)
<span class="kw">names</span>(args) &lt;-<span class="st"> </span>var

<span class="kw">do.call</span>(<span class="st">&quot;data.frame&quot;</span>, args)
<span class="co">#&gt;   x</span>
<span class="co">#&gt; 1 4</span>
<span class="co">#&gt; 2 3</span>
<span class="co">#&gt; 3 9</span></code></pre></li>
</ul>
<p>Some base functions (including <code>interaction()</code>, <code>expand.grid()</code>, <code>options()</code>, and <code>par()</code>) use a trick to avoid <code>do.call()</code>: if the first component of <code>...</code> is a list, they’ll take its components instead of looking at the other elements of <code>...</code>. The implementation looks something like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  dots &lt;-<span class="st"> </span><span class="kw">list</span>(...)
  <span class="cf">if</span> (<span class="kw">length</span>(dots) <span class="op">==</span><span class="st"> </span><span class="dv">1</span> <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">is.list</span>(dots[[<span class="dv">1</span>]])) {
    dots &lt;-<span class="st"> </span>dots[[<span class="dv">1</span>]]
  }
  
  <span class="co"># Do something</span>
  ...
}</code></pre>
<p>Another approach to avoiding <code>do.call()</code> is found in the <code>RCurl::getURL()</code> function written by Duncan Temple Lang. <code>getURL()</code> takes both <code>...</code> and <code>.opts</code> which are concatenated together. This looks something like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(..., .dots) {
  dots &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">list</span>(...), .dots)
  <span class="co"># Do something</span>
}</code></pre>
<p>At the time I discovered it, I found this technique particularly compelling so you can see it used throughout the tidyverse. Now, however, I prefer the approach described next.</p>
</div>
<div id="exercises-59" class="section level3">
<h3><span class="header-section-number">19.6.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>One way to implement <code>exec()</code> is shown below. Describe how it works. What are the
key ideas?</p>
<pre class="sourceCode r"><code class="sourceCode r">exec &lt;-<span class="st"> </span><span class="cf">function</span>(f, ..., <span class="dt">.env =</span> <span class="kw">caller_env</span>()) {
  args &lt;-<span class="st"> </span><span class="kw">list2</span>(...)
  <span class="kw">do.call</span>(f, args, <span class="dt">envir =</span> .env)
}</code></pre></li>
<li><p>Carefully read the source code for <code>interaction()</code>, <code>expand.grid()</code>, and
<code>par()</code>. Compare and contrast the techniques they use for switching
between dots and list behaviour.</p></li>
<li><p>Explain the problem with this definition of <code>set_attr()</code></p>
<pre class="sourceCode r"><code class="sourceCode r">set_attr &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  attr &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">list2</span>(...)
  <span class="kw">attributes</span>(x) &lt;-<span class="st"> </span>attr
  x
}
<span class="kw">set_attr</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">x =</span> <span class="dv">10</span>)
<span class="co">#&gt; Error in attributes(x) &lt;- attr:</span>
<span class="co">#&gt;   attributes must be named</span></code></pre></li>
</ol>
</div>
</div>
<div id="expr-case-studies" class="section level2">
<h2><span class="header-section-number">19.7</span> Case studies</h2>
<p>To make the ideas of quasiquotation concrete, this section contains a few small case studies that use it to solve real problems. Some of the case studies also use purrr: I find the combination of quasiquotation and functional programming to be particularly elegant.</p>
<div id="lobstrast" class="section level3">
<h3><span class="header-section-number">19.7.1</span> <code>lobstr::ast()</code></h3>
<p></p>
<p>Quasiquotation allows us to solve an annoying problem with <code>lobstr::ast()</code>: what happens if we’ve already captured the expression?</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">foo</span>(x, y))
lobstr<span class="op">::</span><span class="kw">ast</span>(z)
<span class="co">#&gt; z</span></code></pre>
<p>Because <code>ast()</code> quotes its first argument, we can use <code>!!</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">lobstr<span class="op">::</span><span class="kw">ast</span>(<span class="op">!!</span>z)
<span class="co">#&gt; █─foo </span>
<span class="co">#&gt; ├─x </span>
<span class="co">#&gt; └─y</span></code></pre>
</div>
<div id="map-reduce-to-generate-code" class="section level3">
<h3><span class="header-section-number">19.7.2</span> Map-reduce to generate code</h3>
<p>Quasiquotation gives us powerful tools for generating code, particularly when combined with <code>purrr::map()</code> and <code>purr::reduce()</code>. For example, assume you have a linear model specified by the following coefficients:</p>
<pre class="sourceCode r"><code class="sourceCode r">intercept &lt;-<span class="st"> </span><span class="dv">10</span>
coefs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">x1 =</span> <span class="dv">5</span>, <span class="dt">x2 =</span> <span class="dv">-4</span>)</code></pre>
<p>And you want to convert it into an expression like <code>10 + (x1 * 5) + (x2 * -4)</code>. The first thing we need to do is turn the character names vector into a list of symbols. <code>rlang::syms()</code> is designed precisely for this case:</p>
<pre class="sourceCode r"><code class="sourceCode r">coef_sym &lt;-<span class="st"> </span><span class="kw">syms</span>(<span class="kw">names</span>(coefs))
coef_sym
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; x1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; x2</span></code></pre>
<p>Next we need to combine each variable name with its coefficient. We can do this by combining <code>rlang::expr()</code> with <code>purrr::map2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">summands &lt;-<span class="st"> </span><span class="kw">map2</span>(coef_sym, coefs, <span class="op">~</span><span class="st"> </span><span class="kw">expr</span>((<span class="op">!!</span>.x <span class="op">*</span><span class="st"> </span><span class="op">!!</span>.y)))
summands
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; (x1 * 5)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; (x2 * -4)</span></code></pre>
<p>In this case, the intercept is also a part of the sum, although it doesn’t involve a multiplication. We can just add it to the start of the <code>summands</code> vector:</p>
<pre class="sourceCode r"><code class="sourceCode r">summands &lt;-<span class="st"> </span><span class="kw">c</span>(intercept, summands)
summands
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 10</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; (x1 * 5)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; (x2 * -4)</span></code></pre>
<p>Finally, we need to reduce (Section <a href="#reduce">9.5</a>) the individual terms into a single sum by adding the pieces together:</p>
<pre class="sourceCode r"><code class="sourceCode r">eq &lt;-<span class="st"> </span><span class="kw">reduce</span>(summands, <span class="op">~</span><span class="st"> </span><span class="kw">expr</span>(<span class="op">!!</span>.x <span class="op">+</span><span class="st"> </span><span class="op">!!</span>.y))
eq
<span class="co">#&gt; 10 + (x1 * 5) + (x2 * -4)</span></code></pre>
<p>We could make this even more general by allowing the user to supply the name of the coefficient, and instead of assuming many different variables, index into a single one.</p>
<pre class="sourceCode r"><code class="sourceCode r">var &lt;-<span class="st"> </span><span class="kw">expr</span>(y)
coef_sym &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="kw">seq_along</span>(coefs), <span class="op">~</span><span class="st"> </span><span class="kw">expr</span>((<span class="op">!!</span>var)[[<span class="op">!!</span>.x]]))
coef_sym
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; y[[1L]]</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; y[[2L]]</span></code></pre>
<p>And finish by wrapping this up in a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">linear &lt;-<span class="st"> </span><span class="cf">function</span>(var, val) {
  var &lt;-<span class="st"> </span><span class="kw">ensym</span>(var)
  coef_name &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="kw">seq_along</span>(val[<span class="op">-</span><span class="dv">1</span>]), <span class="op">~</span><span class="st"> </span><span class="kw">expr</span>((<span class="op">!!</span>var)[[<span class="op">!!</span>.x]]))

  summands &lt;-<span class="st"> </span><span class="kw">map2</span>(val[<span class="op">-</span><span class="dv">1</span>], coef_name, <span class="op">~</span><span class="st"> </span><span class="kw">expr</span>((<span class="op">!!</span>.x <span class="op">*</span><span class="st"> </span><span class="op">!!</span>.y)))
  summands &lt;-<span class="st"> </span><span class="kw">c</span>(val[[<span class="dv">1</span>]], summands)

  <span class="kw">reduce</span>(summands, <span class="op">~</span><span class="st"> </span><span class="kw">expr</span>(<span class="op">!!</span>.x <span class="op">+</span><span class="st"> </span><span class="op">!!</span>.y))
}

<span class="kw">linear</span>(x, <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">5</span>, <span class="dv">-4</span>))
<span class="co">#&gt; 10 + (5 * x[[1L]]) + (-4 * x[[2L]])</span></code></pre>
<p>Note the use of <code>ensym()</code>: we want the user to supply the name of a single variable, not a more complex expression.</p>
</div>
<div id="slicing-an-array" class="section level3">
<h3><span class="header-section-number">19.7.3</span> Slicing an array</h3>
<p></p>
<p>An occasionally useful tool missing from base R is the ability to extract a slice of an array given a dimension and an index. For example, we’d like to write <code>slice(x, 2, 1)</code> to extract the first slice along the second dimension, i.e. <code>x[, 1, ]</code>. This is a moderately challenging problem because it requires working with missing arguments.</p>
<p>We’ll need to generate a call with multiple missing arguments. We first generate a list of missing arguments with <code>rep()</code> and <code>missing_arg()</code>, then unquote-splice them into a call:</p>
<pre class="sourceCode r"><code class="sourceCode r">indices &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">missing_arg</span>()), <span class="dv">3</span>)
<span class="kw">expr</span>(x[<span class="op">!!!</span>indices])
<span class="co">#&gt; x[, , ]</span></code></pre>
<p>Then we use subset-assignment to insert the index in the desired position:</p>
<pre class="sourceCode r"><code class="sourceCode r">indices[[<span class="dv">2</span>]] &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">expr</span>(x[<span class="op">!!!</span>indices])
<span class="co">#&gt; x[, 1, ]</span></code></pre>
<p>We then wrap this into a function, using a couple of <code>stopifnot()</code>s to make the interface clear:</p>
<pre class="sourceCode r"><code class="sourceCode r">slice &lt;-<span class="st"> </span><span class="cf">function</span>(x, along, index) {
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(along) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(index) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
    
  nd &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">dim</span>(x))
  indices &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">list</span>(<span class="kw">missing_arg</span>()), nd)
  indices[[along]] &lt;-<span class="st"> </span>index
  
  <span class="kw">expr</span>(x[<span class="op">!!!</span>indices])
}

x &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">sample</span>(<span class="dv">30</span>), <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>))
<span class="kw">slice</span>(x, <span class="dv">1</span>, <span class="dv">3</span>)
<span class="co">#&gt; x[3, , ]</span>
<span class="kw">slice</span>(x, <span class="dv">2</span>, <span class="dv">2</span>)
<span class="co">#&gt; x[, 2, ]</span>
<span class="kw">slice</span>(x, <span class="dv">3</span>, <span class="dv">1</span>)
<span class="co">#&gt; x[, , 1]</span></code></pre>
<p>A real <code>slice()</code> would evaluate the generated call (Chapter <a href="#evaluation">20</a>), but here I think it’s more illuminating to see the code that’s generated, as that’s the hard part of the challenge.</p>
</div>
<div id="new-function" class="section level3">
<h3><span class="header-section-number">19.7.4</span> Creating functions</h3>
<p>
</p>
<p>Another powerful application of quotation is creating functions “by hand”, using <code>rlang::new_function()</code>. It’s a function that create a function from its three components (Section <a href="#fun-components">6.2.1</a>) arguments, body, and (optionally) an environment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">new_function</span>(
  <span class="kw">exprs</span>(<span class="dt">x =</span> , <span class="dt">y =</span> ), 
  <span class="kw">expr</span>({x <span class="op">+</span><span class="st"> </span>y})
)
<span class="co">#&gt; function (x, y) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     x + y</span>
<span class="co">#&gt; }</span></code></pre>
<p>NB: the empty arguments in <code>exprs()</code> generates arguments with no defaults.</p>
<p>One use of <code>new_function()</code> is as an alternative to function factories with scalar or symbol arguments. For example, we could write a function that generates functions that raise a function to the power of a number.</p>
<pre class="sourceCode r"><code class="sourceCode r">power &lt;-<span class="st"> </span><span class="cf">function</span>(exponent) {
  <span class="kw">new_function</span>(
    <span class="kw">exprs</span>(<span class="dt">x =</span> ), 
    <span class="kw">expr</span>({
      x <span class="op">^</span><span class="st"> </span><span class="op">!!</span>exponent
    }), 
    <span class="kw">caller_env</span>()
  )
}
<span class="kw">power</span>(<span class="fl">0.5</span>)
<span class="co">#&gt; function (x) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     x^0.5</span>
<span class="co">#&gt; }</span></code></pre>
<p>Another application of <code>new_function()</code> is for functions that work like <code>graphics::curve()</code>, which allows you to plot a mathematical expression without creating a function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">curve</span>(<span class="kw">sin</span>(<span class="kw">exp</span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>x)), <span class="dt">n =</span> <span class="dv">1000</span>)</code></pre>
<p><img src="Quotation_files/figure-html/curve-demo-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Here <code>x</code> is a pronoun: it doesn’t represent a single concrete value, but is instead a placeholder that varies over the range of the plot. One way to implement <code>curve()</code> is to turn that expression into a function with a single argument, <code>x</code>, then call that function:</p>
<pre class="sourceCode r"><code class="sourceCode r">curve2 &lt;-<span class="st"> </span><span class="cf">function</span>(expr, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">n =</span> <span class="dv">100</span>) {
  expr &lt;-<span class="st"> </span><span class="kw">enexpr</span>(expr)
  f &lt;-<span class="st"> </span><span class="kw">new_function</span>(<span class="kw">exprs</span>(<span class="dt">x =</span> ), expr)
  
  x &lt;-<span class="st"> </span><span class="kw">seq</span>(xlim[<span class="dv">1</span>], xlim[<span class="dv">2</span>], <span class="dt">length =</span> n)
  y &lt;-<span class="st"> </span><span class="kw">f</span>(x)

  <span class="kw">plot</span>(x, y, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, <span class="dt">ylab =</span> <span class="kw">expr_text</span>(expr))
}
<span class="kw">curve2</span>(<span class="kw">sin</span>(<span class="kw">exp</span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>x)), <span class="dt">n =</span> <span class="dv">1000</span>)</code></pre>
<p>Functions like <code>curve()</code> that use an expression containing a pronoun are known as <strong>anaphoric</strong> functions<span id="fn150" class="footnote" data-pagedown-footnote-number="150" style="white-space: pre-line;">Anaphoric comes from the linguistics term “anaphora”, an expression that is context dependent. Anaphoric functions are found in Arc<span id="fn147" class="footnote" data-pagedown-footnote-number="147" style="white-space: pre-line;"><a href="http://www.arcfn.com/doc/anaphoric.html" class="uri">http://www.arcfn.com/doc/anaphoric.html</a></span> (a LISP like language), Perl<span id="fn148" class="footnote" data-pagedown-footnote-number="148" style="white-space: pre-line;"><a href="http://www.perlmonks.org/index.pl?node_id=666047" class="uri">http://www.perlmonks.org/index.pl?node_id=666047</a></span>, and Clojure<span id="fn149" class="footnote" data-pagedown-footnote-number="149" style="white-space: pre-line;"><a href="http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit" class="uri">http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit</a></span>.</span>.</p>
</div>
<div id="exercises-60" class="section level3">
<h3><span class="header-section-number">19.7.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In the linear-model example, we could replace the <code>expr()</code> in
<code>reduce(summands, ~ expr(!!.x + !!.y))</code> with <code>call2()</code>:
<code>reduce(summands, call2, &quot;+&quot;)</code>. Compare and contrast the two
approaches. Which do you think is easier to read?</p></li>
<li><p>Re-implement the Box-Cox transform defined below using unquoting and
<code>new_function()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">bc &lt;-<span class="st"> </span><span class="cf">function</span>(lambda) {
  <span class="cf">if</span> (lambda <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="cf">function</span>(x) <span class="kw">log</span>(x)
  } <span class="cf">else</span> {
    <span class="cf">function</span>(x) (x <span class="op">^</span><span class="st"> </span>lambda <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span>lambda
  }
}</code></pre></li>
<li><p>Re-implement the simple <code>compose()</code> defined below using quasiquotation and
<code>new_function()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">compose &lt;-<span class="st"> </span><span class="cf">function</span>(f, g) {
  <span class="cf">function</span>(...) <span class="kw">f</span>(<span class="kw">g</span>(...))
}</code></pre></li>
</ol>
</div>
</div>
<div id="history" class="section level2">
<h2><span class="header-section-number">19.8</span> History</h2>
<p>The idea of quasiquotation is an old one. It was first developed by the philosopher Willard van Orman Quine<span id="fn151" class="footnote" data-pagedown-footnote-number="151" style="white-space: pre-line;">You might be familiar with the name Quine from “quines”, computer programs that return a copy of their own source when run.</span> in the early 1940s. It’s needed in philosophy<span id="fn152" class="footnote" data-pagedown-footnote-number="152" style="white-space: pre-line;">A fun connection between philosophy and R is in <a href="https://johnmacfarlane.net/142/substitutional-quantifiers.pdf" class="uri">https://johnmacfarlane.net/142/substitutional-quantifiers.pdf</a>; this article is written by philosophy professor John MacFarlane, the author of pandoc, which powers RMarkdown.</span> because it helps when precisely delineating the use and mention of words, i.e. distinguishing between the object and the words we use to refer to that object.</p>
<p>Quasiquotation was first used in a programming language, LISP, in the mid-1970s <span class="citation">(Bawden <a href="#ref-bawden-1999">1999</a>)</span>. LISP has one quoting function <code>`</code>, and uses <code>,</code> for unquoting. Most languages with a LISP heritage behave similarly. For example, racket (<code>`</code> and <code>@</code>), Clojure (<code>`</code> and <code>~</code>), and Julia (<code>:</code> and <code>@</code>) all have quasiquotation tools that differ only slightly from LISP. These languages have a single quoting function and you must call it explicitly.</p>
<p>In R, however, many functions quote one or more inputs. This introduces ambiguity (because you need to read the documentation to determine if an argument is quoted or not), but allows for concise and elegant data exploration code. In base R, only one function supports quasiquotation: <code>bquote()</code>, written in 2003 by Thomas Lumley. However, <code>bquote()</code> has some major limitations which prevented it from having a wide impact on R code (Section <a href="#base-nonquote">19.5</a>).</p>
<p>My attempt to resolve these limitations lead to the lazyeval package (2014-2015). Unfortunately, my analysis of the problem was incomplete and while lazyeval solves some problems, it create others. It was not until I started working with Lionel Henry on the problem that all the pieces finally fell into place and we create the full tidy evaluation framework (2017). Despite the newness of tidy evaluation, I teach it here because it is a rich and powerful theory that, once mastered, makes many hard problems much easier.</p>
<!--chapter:end:Quotation.Rmd-->
</div>
</div>
<div id="evaluation" class="section level1">
<h1><span class="header-section-number">20</span> Evaluation</h1>
<div id="introduction-20" class="section level2">
<h2><span class="header-section-number">20.1</span> Introduction</h2>
<p>The user-facing inverse of quotation is unquotation: it gives the <em>user</em> the ability to selectively evaluate parts of an otherwise quoted argument. The developer-facing complement of quotation is evaluation: this gives the <em>developer</em> the ability to evaluate quoted expressions in custom environments to achieve specific goals.</p>
<p>This chapter begins with a discussion of evaluation in its purest form. You’ll learn how <code>eval()</code> evaluates an expression in an environment, and then how it can be used to implement a number of important base R functions. Once you have the basics under your belt, you’ll learn extensions to evaluation that are needed for robustness. There are two big new ideas:</p>
<ul>
<li><p>The quosure: a data structure that captures an expression along with its
associated environment, as found in function arguments.</p></li>
<li><p>The data mask, which makes it easier to evaluate an expression in the
context of a data frame. This introduces potential evaluation ambiguity
which we’ll then resolve with data pronouns.</p></li>
</ul>
<p>Together, quasiquotation, quosures, and data masks form what we call <strong>tidy evaluation</strong>, or tidy eval for short. Tidy eval provides a principled approach to non-standard evaluation that makes it possible to use such functions both interactively and embedded with other functions. Tidy evaluation is the most important practical implication of all this theory so we’ll spend a little time exploring the implications. The chapter finishes off with a discussion of the closest related approaches in base R, and how you can program around their drawbacks.</p>
<div id="outline-18" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#eval">20.2</a> discusses the basics of evaluation using <code>eval()</code>,
and shows how you can use it to implement key functions like <code>local()</code>
and <code>source()</code>.</p></li>
<li><p>Section <a href="#quosures">20.3</a> introduces a new data structure, the quosure, which
combines an expression with an environment. You’ll learn how to capture
them from promises, and evaluate them using <code>rlang::eval_tidy()</code>.</p></li>
<li><p>Section <a href="#data-masks">20.4</a> extends evaluation with the “data mask”, which
makes it trivial to intermingle symbols bound in an environment with
variables found in a data frame.</p></li>
<li><p>Section <a href="#tidy-evaluation">20.5</a> shows how to use tidy evaluation in practice,
focussing on the common pattern of quoting and unquoting, and how to
handle ambiguity with pronouns.</p></li>
<li><p>Section <a href="#base-evaluation">20.6</a> circles back to evaluation in base R,
discusses some of the downsides, and shows how to use quasiquotation and
evaluation to wrap functions that use NSE.</p></li>
</ul>
</div>
<div id="prerequisites-13" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>You’ll need to be familiar with the content of Chapter <a href="#expressions">18</a> and Chapter <a href="#quasiquotation">19</a>, as well as the environment data structure (Section <a href="#env-basics">7.2</a>) and the caller environment (Section <a href="#call-stack">7.5</a>).</p>
<p>We’ll continue to use rlang<span id="fn153" class="footnote" data-pagedown-footnote-number="153" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span> and purrr<span id="fn154" class="footnote" data-pagedown-footnote-number="154" style="white-space: pre-line;"><a href="https://purrr.tidyverse.org" class="uri">https://purrr.tidyverse.org</a></span>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)
<span class="kw">library</span>(purrr)</code></pre>
</div>
</div>
<div id="eval" class="section level2">
<h2><span class="header-section-number">20.2</span> Evaluation basics</h2>
<p>
</p>
<p>Here we’ll explore the details of <code>eval()</code> which we briefly mentioned in the last chapter. It has two key arguments: <code>expr</code> and <code>envir</code>. The first argument, <code>expr</code>, is the object to evaluate, typically a symbol or expression<span id="fn155" class="footnote" data-pagedown-footnote-number="155" style="white-space: pre-line;">All other objects yield themselves when evaluated; i.e. <code>eval_bare(x)</code> yields <code>x</code>, except when <code>x</code> is a symbol or expression.</span>. None of the evaluation functions quote their inputs, so you’ll usually use them with <code>expr()</code> or similar:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">eval</span>(<span class="kw">expr</span>(x))
<span class="co">#&gt; [1] 10</span>

y &lt;-<span class="st"> </span><span class="dv">2</span>
<span class="kw">eval</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y))
<span class="co">#&gt; [1] 12</span></code></pre>
<p>The second argument, <code>env</code>, gives the environment in which the expression should be evaluated, i.e. where to look for the values of <code>x</code>, <code>y</code>, and <code>+</code>. By default, this is the current environment, i.e. the calling environment of <code>eval()</code>, but you can override it if you want:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1000</span>))
<span class="co">#&gt; [1] 1002</span></code></pre>
<p>The first argument is evaluated, not quoted, which can lead to confusing results once if you use a custom environment and forget to manually quote:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">print</span>(x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1000</span>))
<span class="co">#&gt; [1] 11</span>
<span class="co">#&gt; [1] 11</span>

<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">print</span>(x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1000</span>))
<span class="co">#&gt; [1] 1001</span></code></pre>
<div class="sidebar">
<p><strong>Expression vectors</strong>
</p>
<p><code>base::eval()</code> has special behaviour for expression <em>vectors</em>, evaluating each component in turn. This makes for a very compact implementation of <code>source2()</code> because <code>base::parse()</code> also returns an expression object:</p>
<pre class="sourceCode r"><code class="sourceCode r">source3 &lt;-<span class="st"> </span><span class="cf">function</span>(file, <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  lines &lt;-<span class="st"> </span><span class="kw">parse</span>(file)
  res &lt;-<span class="st"> </span><span class="kw">eval</span>(lines, <span class="dt">envir =</span> env)
  <span class="kw">invisible</span>(res)
}</code></pre>
<p>While <code>source3()</code> is considerably more concise than <code>source2()</code>, this is the only advantage to expression vectors. Overall I don’t believe this benefit outweighs the cost of introducing a new data structure, and hence this book avoids the use of expression vectors.</p>
</div>
<p>Now that you’ve seen the basics, let’s explore some applications. We’ll focus primarily on base R functions that you might have used before, reimplementing the underlying principles using rlang.</p>
<div id="application-local" class="section level3">
<h3><span class="header-section-number">20.2.1</span> Application: <code>local()</code></h3>

<p>Sometimes you want to perform a chunk of calculation that creates some intermediate variables. The intermediate variables have no long-term use and could be quite large, so you’d rather not keep them around. One approach is to clean up after yourself using <code>rm()</code>; another is to wrap the code in a function and just call it once. A more elegant approach is to use <code>local()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Clean up variables created earlier</span>
<span class="kw">rm</span>(x, y)

foo &lt;-<span class="st"> </span><span class="kw">local</span>({
  x &lt;-<span class="st"> </span><span class="dv">10</span>
  y &lt;-<span class="st"> </span><span class="dv">200</span>
  x <span class="op">+</span><span class="st"> </span>y
})

foo
<span class="co">#&gt; [1] 210</span>
x
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;x&#39; not found</span>
y
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;y&#39; not found</span></code></pre>
<p>The essence of <code>local()</code> is quite simple and re-implemented below. We capture the input expression, and create a new environment in which to evaluate it. This is a new environment (so assignment doesn’t affect the existing environment) with the caller environment as parent (so that <code>expr</code> can still access variables in that environment). This effectively emulates running <code>expr</code> as if it was inside a function (i.e. it’s lexically scoped, Section <a href="#lexical-scoping">6.4</a>).</p>
<pre class="sourceCode r"><code class="sourceCode r">local2 &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  env &lt;-<span class="st"> </span><span class="kw">env</span>(<span class="kw">caller_env</span>())
  <span class="kw">eval_bare</span>(<span class="kw">enexpr</span>(expr), env)
}

foo &lt;-<span class="st"> </span><span class="kw">local2</span>({
  x &lt;-<span class="st"> </span><span class="dv">10</span>
  y &lt;-<span class="st"> </span><span class="dv">200</span>
  x <span class="op">+</span><span class="st"> </span>y
})

foo
<span class="co">#&gt; [1] 210</span>
x
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;x&#39; not found</span>
y
<span class="co">#&gt; Error in eval(expr, envir, enclos):</span>
<span class="co">#&gt;   object &#39;y&#39; not found</span></code></pre>
<p>Understanding how <code>base::local()</code> works is harder, as it uses <code>eval()</code> and <code>substitute()</code> together in rather complicated ways. Figuring out exactly what’s going on is good practice if you really want to understand the subtleties of <code>substitute()</code> and the base <code>eval()</code> functions, so is included in the exercises below.</p>
</div>
<div id="application-source" class="section level3">
<h3><span class="header-section-number">20.2.2</span> Application: <code>source()</code></h3>

<p>We can create a simple version of <code>source()</code> by combining <code>eval()</code> with <code>parse_expr()</code> from Section <a href="#parsing">18.4.3</a>. We read in the file from disk, use <code>parse_expr()</code> to parse the string into a list of expressions, and then use <code>eval_bare()</code> to evaluate each element in turn. This version evaluates the code in the caller environment, and invisibly returns the result of the last expression in the file just like <code>base::source()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">source2 &lt;-<span class="st"> </span><span class="cf">function</span>(path, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  file &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">readLines</span>(path, <span class="dt">warn =</span> <span class="ot">FALSE</span>), <span class="dt">collapse =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  exprs &lt;-<span class="st"> </span><span class="kw">parse_exprs</span>(file)

  res &lt;-<span class="st"> </span><span class="ot">NULL</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(exprs)) {
    res &lt;-<span class="st"> </span><span class="kw">eval</span>(exprs[[i]], env)
  }

  <span class="kw">invisible</span>(res)
}</code></pre>
<p>The real <code>source()</code> is considerably more complicated because it can <code>echo</code> input and output, and has many other settings that control its behaviour.</p>
</div>
<div id="gotcha-function" class="section level3">
<h3><span class="header-section-number">20.2.3</span> Gotcha: <code>function()</code></h3>
<p>
</p>
<p>There’s one small gotcha that you should be aware of if you’re using <code>eval_bare()</code> and <code>expr()</code> to generate functions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
y &lt;-<span class="st"> </span><span class="dv">20</span>
f &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">expr</span>(<span class="cf">function</span>(x, y) <span class="op">!!</span>x <span class="op">+</span><span class="st"> </span><span class="op">!!</span>y))
f
<span class="co">#&gt; function(x, y) !!x + !!y</span></code></pre>
<p>This function doesn’t look like it will work, but it does:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">f</span>()
<span class="co">#&gt; [1] 30</span></code></pre>
<p>This is because, if available, functions print their <code>srcref</code> attribute (Section <a href="#fun-components">6.2.1</a>), and because <code>srcref</code> is a base R feature it’s unaware of quasiquotation.</p>
<p>To work around this problem, either use <code>new_function()</code> (Section <a href="#new-function">19.7.4</a>) or remove the <code>srcref</code> attribute:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(f, <span class="st">&quot;srcref&quot;</span>) &lt;-<span class="st"> </span><span class="ot">NULL</span>
f
<span class="co">#&gt; function (x, y) </span>
<span class="co">#&gt; 10 + 20</span></code></pre>
</div>
<div id="exercises-61" class="section level3">
<h3><span class="header-section-number">20.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Carefully read the documentation for <code>source()</code>. What environment does it
use by default? What if you supply <code>local = TRUE</code>? How do you provide
a custom environment?</p></li>
<li><p>Predict the results of the following lines of code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>))))))
<span class="kw">eval</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>)))))))
<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="kw">eval</span>(<span class="kw">expr</span>(<span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>)))))))</code></pre></li>
<li><p>Fill in the function bodies below to re-implement <code>get()</code> using <code>sym()</code>
and <code>eval()</code>, and<code>assign()</code> using <code>sym()</code>, <code>expr()</code>, and <code>eval()</code>. Don’t
worry about the multiple ways of choosing an environment that <code>get()</code> and
<code>assign()</code> support; assume that the user supplies it explicitly</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># name is a string</span>
get2 &lt;-<span class="st"> </span><span class="cf">function</span>(name, env) {}
assign2 &lt;-<span class="st"> </span><span class="cf">function</span>(name, value, env) {}</code></pre></li>
<li><p>Modify <code>source2()</code> so it returns the result of <em>every</em> expression,
not just the last one. Can you eliminate the for loop?</p></li>
<li><p>We can make <code>base::local()</code> slightly easier to understand by spreading
out over multiple lines:</p>
<pre class="sourceCode r"><code class="sourceCode r">local3 &lt;-<span class="st"> </span><span class="cf">function</span>(expr, <span class="dt">envir =</span> <span class="kw">new.env</span>()) {
  call &lt;-<span class="st"> </span><span class="kw">substitute</span>(<span class="kw">eval</span>(<span class="kw">quote</span>(expr), envir))
  <span class="kw">eval</span>(call, <span class="dt">envir =</span> <span class="kw">parent.frame</span>())
}</code></pre>
<p>Explain how <code>local()</code> works in words. (Hint: you might want to <code>print(call)</code>
to help understand what <code>substitute()</code> is doing, and read the documentation
to remind yourself what environment <code>new.env()</code> will inherit from.)</p></li>
</ol>
</div>
</div>
<div id="quosures" class="section level2">
<h2><span class="header-section-number">20.3</span> Quosures</h2>
<p></p>
<p>Almost every use of <code>eval()</code> involves both an expression and environment. This coupling is so important that we need a data structure that can hold both pieces. Base R does not have such a structure<span id="fn156" class="footnote" data-pagedown-footnote-number="156" style="white-space: pre-line;">Technically a formula combines an expression and environment, but formulas are tightly coupled to modelling so a new data structure makes sense.</span> so rlang fills the gap with the <strong>quosure</strong>, an object that contains an expression and an environment. The name is a portmanteau of quoting and closure, because a quosure both quotes the expression and encloses the environment. Quosures reify the internal promise object (Section <a href="#promises">6.5.1</a>) into something that you can program with.</p>
<p>In this section, you’ll learn how to create and manipulate quosures, and a little about how they are implemented.</p>
<div id="creating" class="section level3">
<h3><span class="header-section-number">20.3.1</span> Creating</h3>
<p></p>
<p>There are three ways to create quosures:</p>
<ul>
<li><p>Use <code>enquo()</code> and <code>enquos()</code> to capture user-supplied expressions.
The vast majority of quosures should be created this way.</p>
<pre class="sourceCode r"><code class="sourceCode r">foo &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">enquo</span>(x)
<span class="kw">foo</span>(a <span class="op">+</span><span class="st"> </span>b)
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^a + b</span>
<span class="co">#&gt; env:  global</span></code></pre></li>
<li><p><code>quo()</code> and <code>quos()</code> exist to match to <code>expr()</code> and <code>exprs()</code>, but
they are included only for the sake of completeness and are needed very
rarely. If you find yourself using them, think carefully if <code>expr()</code> and
careful unquoting can eliminate the need to capture the environment.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quo</span>(x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>z)
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x + y + z</span>
<span class="co">#&gt; env:  global</span></code></pre>
<p></p></li>
<li><p><code>new_quosure()</code> create a quosure from its components: an expression and
an environment. This is rarely needed in practice, but is useful for
learning, so is used a lot in this chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">10</span>))
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x + y</span>
<span class="co">#&gt; env:  0x5b87988</span></code></pre></li>
</ul>
</div>
<div id="evaluating" class="section level3">
<h3><span class="header-section-number">20.3.2</span> Evaluating</h3>
<p>

</p>
<p>Quosures are paired with a new evaluation function <code>eval_tidy()</code> that takes a single quosure instead of a expression-environment pair. It is straightforward to use:</p>
<pre class="sourceCode r"><code class="sourceCode r">q1 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">10</span>))
<span class="kw">eval_tidy</span>(q1)
<span class="co">#&gt; [1] 11</span></code></pre>
<p>For this simple case, <code>eval_tidy(q1)</code> is basically a shortcut for <code>eval_bare(get_expr(q1), get_env(q2))</code>. However, it has two important features that you’ll learn about later in the chapter: it supports nested quosures (Section <a href="#nested-quosures">20.3.5</a>) and pronouns (Section <a href="#pronouns">20.4.2</a>).</p>
</div>
<div id="quosure-dots" class="section level3">
<h3><span class="header-section-number">20.3.3</span> Dots</h3>

<p>Quosures are typically just a convenience: they make code cleaner because you only have one object to pass around, instead of two. They are, however, essential when it comes to working with <code>...</code> because it’s possible for each argument passed to … to be associated with a different environment. In the following example note that both quosures have the same expression, <code>x</code>, but a different environment:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  x &lt;-<span class="st"> </span><span class="dv">1</span>
  <span class="kw">g</span>(..., <span class="dt">f =</span> x)
}
g &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  <span class="kw">enquos</span>(...)
}

x &lt;-<span class="st"> </span><span class="dv">0</span>
qs &lt;-<span class="st"> </span><span class="kw">f</span>(<span class="dt">global =</span> x)
qs
<span class="co">#&gt; &lt;list_of&lt;quosure&gt;&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $global</span>
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x</span>
<span class="co">#&gt; env:  global</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $f</span>
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x</span>
<span class="co">#&gt; env:  0x5776020</span></code></pre>
<p>That means that when you evaluate them, you get the correct results:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(qs, eval_tidy)
<span class="co">#&gt; global      f </span>
<span class="co">#&gt;      0      1</span></code></pre>
<p>Correctly evaluating the elements of <code>...</code> was one of the original motivations for the development of quosures.</p>
</div>
<div id="quosure-impl" class="section level3">
<h3><span class="header-section-number">20.3.4</span> Under the hood</h3>
<p>
</p>
<p>Quosures were inspired by R’s formulas, because formulas capture an expression and an environment:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="er">~</span><span class="kw">runif</span>(<span class="dv">3</span>)
<span class="kw">str</span>(f)
<span class="co">#&gt; Class &#39;formula&#39;  language ~runif(3)</span>
<span class="co">#&gt;   ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt;</span></code></pre>
<p>An early version of tidy evaluation used formulas instead of quosures, as an attractive feature of <code>~</code> is that it provides quoting with a single keystroke. Unfortunately, however, there is no clean way to make <code>~</code> a quasiquoting function.</p>
<p>Quosures are a subclass of formulas:</p>
<pre class="sourceCode r"><code class="sourceCode r">q4 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span>z))
<span class="kw">class</span>(q4)
<span class="co">#&gt; [1] &quot;quosure&quot; &quot;formula&quot;</span></code></pre>
<p>Which means that under the hood, quosures, like formulas, are a call object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is_call</span>(q4)
<span class="co">#&gt; [1] TRUE</span>

q4[[<span class="dv">1</span>]]
<span class="co">#&gt; `~`</span>
q4[[<span class="dv">2</span>]]
<span class="co">#&gt; x + y + z</span></code></pre>
<p>With an attribute that stores the environment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(q4, <span class="st">&quot;.Environment&quot;</span>)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span></code></pre>
<p>If you need to extract the expression or environment, don’t rely on these implementation details. Instead use <code>get_expr()</code> and <code>get_env()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_expr</span>(q4)
<span class="co">#&gt; x + y + z</span>
<span class="kw">get_env</span>(q4)
<span class="co">#&gt; &lt;environment: R_GlobalEnv&gt;</span></code></pre>
</div>
<div id="nested-quosures" class="section level3">
<h3><span class="header-section-number">20.3.5</span> Nested quosures</h3>
<p></p>
<p>It’s possible to use quasiquotation to embed a quosure in an expression. This is an advanced tool, and most of the time you don’t need to think about it because it just works, but I talk about it here so you can spot nested quosures in the wild and not be confused. Take this example, which inlines two quosures into an expression:</p>
<pre class="sourceCode r"><code class="sourceCode r">q2 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1</span>))
q3 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">10</span>))

x &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="op">!!</span>q2 <span class="op">+</span><span class="st"> </span><span class="op">!!</span>q3)</code></pre>
<p>It evaluates correctly with <code>eval_tidy()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">eval_tidy</span>(x)
<span class="co">#&gt; [1] 11</span></code></pre>
<p>However, if you print it, you only see the <code>x</code>s, with their formula heritage leaking through:</p>
<pre class="sourceCode r"><code class="sourceCode r">x
<span class="co">#&gt; (~x) + ~x</span></code></pre>
<p>You can get a better display with <code>rlang::expr_print()</code> (Section <a href="#non-standard-ast">19.4.7</a>):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">expr_print</span>(x)
<span class="co">#&gt; (^x) + (^x)</span></code></pre>
<p>When you use <code>expr_print()</code> in the console, quosures are coloured according to their environment, making it easier to spot when symbols are bound to different variables.</p>
</div>
<div id="exercises-62" class="section level3">
<h3><span class="header-section-number">20.3.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Predict what evaluating each of the following quosures will return if
evaluated.</p>
<pre class="sourceCode r"><code class="sourceCode r">q1 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">1</span>))
q1
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x</span>
<span class="co">#&gt; env:  0x53ade90</span>

q2 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span><span class="op">!!</span>q1), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">10</span>))
q2
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x + (^x)</span>
<span class="co">#&gt; env:  0x5aaf080</span>

q3 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span><span class="op">!!</span>q2), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">100</span>))
q3
<span class="co">#&gt; &lt;quosure&gt;</span>
<span class="co">#&gt; expr: ^x + (^x + (^x))</span>
<span class="co">#&gt; env:  0x5d552b0</span></code></pre></li>
<li><p>Write an <code>enenv()</code> function that captures the environment associated
with an argument. (Hint: this should only require two function calls.)</p></li>
</ol>
</div>
</div>
<div id="data-masks" class="section level2">
<h2><span class="header-section-number">20.4</span> Data masks</h2>
<p></p>
<p>In this section, you’ll learn about the <strong>data mask</strong>, a data frame where the evaluated code will look first for variable definitions. The data mask is the key idea that powers base functions like <code>with()</code>, <code>subset()</code> and <code>transform()</code>, and is used throughout the tidyverse in packages like dplyr and ggplot2.</p>
<div id="basics-3" class="section level3">
<h3><span class="header-section-number">20.4.1</span> Basics</h3>

<p>The data mask allows you to mingle variables from an environment and and data frame in a single expression. You supply the data mask as the second argument to <code>eval_tidy()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">q1 &lt;-<span class="st"> </span><span class="kw">new_quosure</span>(<span class="kw">expr</span>(x <span class="op">*</span><span class="st"> </span>y), <span class="kw">env</span>(<span class="dt">x =</span> <span class="dv">100</span>))
df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)

<span class="kw">eval_tidy</span>(q1, df)
<span class="co">#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000</span></code></pre>
<p>This code is a little hard to follow because there’s so much syntax as we’re creating every object from from scratch. It’s easier to see what’s going on if we make a little wrapper. I call this <code>with2()</code> because it’s equivalent to <code>base::with()</code>.
</p>
<pre class="sourceCode r"><code class="sourceCode r">with2 &lt;-<span class="st"> </span><span class="cf">function</span>(data, expr) {
  expr &lt;-<span class="st"> </span><span class="kw">enquo</span>(expr)
  <span class="kw">eval_tidy</span>(expr, data)
}</code></pre>
<p>We can now rewrite the code above as below:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">100</span>
<span class="kw">with2</span>(df, x <span class="op">*</span><span class="st"> </span>y)
<span class="co">#&gt;  [1]  100  200  300  400  500  600  700  800  900 1000</span></code></pre>
<p><code>base::eval()</code> has similar functionality, although it doesn’t call it a data mask. Instead you can supply a data frame to the second argument and an environment to the third. That gives the following implementation of <code>with()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">with3 &lt;-<span class="st"> </span><span class="cf">function</span>(data, expr) {
  expr &lt;-<span class="st"> </span><span class="kw">substitute</span>(expr)
  <span class="kw">eval</span>(expr, data, <span class="kw">caller_env</span>())
}</code></pre>
</div>
<div id="pronouns" class="section level3">
<h3><span class="header-section-number">20.4.2</span> Pronouns</h3>
<p>

</p>
<p>Using a data mask introduces ambiguity. For example, in the following code you can’t know whether <code>x</code> will come from the data mask or the environment, unless you know what variables are found in <code>df</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">with2</span>(df, x)</code></pre>
<p>That makes code harder to reason about (because you need to know more context), which can introduce bugs. To resolve that issue, the data mask provides two pronouns: <code>.data</code> and <code>.env</code>.</p>
<ul>
<li><code>.data$x</code> always refers to <code>x</code> in the data mask.</li>
<li><code>.env$x</code> always refers to <code>x</code> in the environment.</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span>
df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">2</span>)

<span class="kw">with2</span>(df, .data<span class="op">$</span>x)
<span class="co">#&gt; [1] 2</span>
<span class="kw">with2</span>(df, .env<span class="op">$</span>x)
<span class="co">#&gt; [1] 1</span></code></pre>
<p>You can also subset <code>.data</code> and <code>.env</code> using <code>[[</code>, e.g. <code>.data[[&quot;x&quot;]]</code>. Otherwise the pronouns are special objects and you shouldn’t expect them to behave like data frames or environments. In particular, they throw error if the object isn’t found:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">with2</span>(df, .data<span class="op">$</span>y)
<span class="co">#&gt; Error: Column `y` not found in `.data`</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─global::with2(df, .data$y)</span>
<span class="co">#&gt;  2. │ └─rlang::eval_tidy(expr, data)</span>
<span class="co">#&gt;  3. ├─y</span>
<span class="co">#&gt;  4. ├─rlang:::`$.rlang_data_pronoun`(.data, y)</span>
<span class="co">#&gt;  5. │ └─rlang:::data_pronoun_get(x, nm)</span>
<span class="co">#&gt;  6. └─rlang:::abort_data_pronoun(x)</span></code></pre>
</div>
<div id="subset" class="section level3">
<h3><span class="header-section-number">20.4.3</span> Application: <code>subset()</code></h3>

<p>We’ll explore tidy evaluation in the context of <code>base::subset()</code>, because it’s a simple yet powerful function that makes a common data manipulation challenge easier. If you haven’t used it before, <code>subset()</code>, like <code>dplyr::filter()</code>, provides a convenient way of selecting rows of a data frame. You give it some data, along with an expression that is evaluated in the context of that data. This considerably reduces the number of times you need to type the name of the data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">sample_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">b =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">c =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>))

<span class="co"># Shorthand for sample_df[sample_df$a &gt;= 4, ]</span>
<span class="kw">subset</span>(sample_df, a <span class="op">&gt;=</span><span class="st"> </span><span class="dv">4</span>)
<span class="co">#&gt;   a b c</span>
<span class="co">#&gt; 4 4 2 4</span>
<span class="co">#&gt; 5 5 1 1</span>

<span class="co"># Shorthand for sample_df[sample_df$b == sample_df$c, ]</span>
<span class="kw">subset</span>(sample_df, b <span class="op">==</span><span class="st"> </span>c)
<span class="co">#&gt;   a b c</span>
<span class="co">#&gt; 1 1 5 5</span>
<span class="co">#&gt; 5 5 1 1</span></code></pre>
<p>The core of our version of <code>subset()</code>, <code>subset2()</code>, is quite simple. It takes two arguments: a data frame, <code>data</code>, and an expression, <code>rows</code>. We evaluate <code>rows</code> using <code>df</code> as a data mask, then use the results to subset the data frame with <code>[</code>. I’ve included a very simple check to ensure the result is a logical vector; real code would do more to create an informative error.</p>
<pre class="sourceCode r"><code class="sourceCode r">subset2 &lt;-<span class="st"> </span><span class="cf">function</span>(data, rows) {
  rows &lt;-<span class="st"> </span><span class="kw">enquo</span>(rows)
  rows_val &lt;-<span class="st"> </span><span class="kw">eval_tidy</span>(rows, data)
  <span class="kw">stopifnot</span>(<span class="kw">is.logical</span>(rows_val))

  data[rows_val, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
}

<span class="kw">subset2</span>(sample_df, b <span class="op">==</span><span class="st"> </span>c)
<span class="co">#&gt;   a b c</span>
<span class="co">#&gt; 1 1 5 5</span>
<span class="co">#&gt; 5 5 1 1</span></code></pre>
</div>
<div id="application-transform" class="section level3">
<h3><span class="header-section-number">20.4.4</span> Application: transform</h3>

<p>A more complicated situation is <code>base::transform()</code> which allows you to add new variables to a data frame, evaluating their expressions in the context of the existing variables:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>), <span class="dt">y =</span> <span class="kw">runif</span>(<span class="dv">3</span>))
<span class="kw">transform</span>(df, <span class="dt">x =</span> <span class="op">-</span>x, <span class="dt">y2 =</span> <span class="dv">2</span> <span class="op">*</span><span class="st"> </span>y)
<span class="co">#&gt;    x      y    y2</span>
<span class="co">#&gt; 1 -2 0.0808 0.162</span>
<span class="co">#&gt; 2 -3 0.8343 1.669</span>
<span class="co">#&gt; 3 -1 0.6008 1.202</span></code></pre>
<p>Again, our own <code>transform2()</code> requires little code. We capture the unevalated <code>...</code> with <code>enquos(...)</code>, and then evaluate each expression using a for loop. Real code would do more error checking to ensure that each input is named and evaluates to a vector the same length as <code>data</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">transform2 &lt;-<span class="st"> </span><span class="cf">function</span>(.data, ...) {
  dots &lt;-<span class="st"> </span><span class="kw">enquos</span>(...)

  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(dots)) {
    name &lt;-<span class="st"> </span><span class="kw">names</span>(dots)[[i]]
    dot &lt;-<span class="st"> </span>dots[[i]]

    .data[[name]] &lt;-<span class="st"> </span><span class="kw">eval_tidy</span>(dot, .data)
  }

  .data
}

<span class="kw">transform2</span>(df, <span class="dt">x2 =</span> x <span class="op">*</span><span class="st"> </span><span class="dv">2</span>, <span class="dt">y =</span> <span class="op">-</span>y)
<span class="co">#&gt;   x       y x2</span>
<span class="co">#&gt; 1 2 -0.0808  4</span>
<span class="co">#&gt; 2 3 -0.8343  6</span>
<span class="co">#&gt; 3 1 -0.6008  2</span></code></pre>
<p>NB: I named the first argument <code>.data</code> to avoid problems if the user tried to create a variable called <code>data</code>. They will still have problems if they attempt to create a variable called <code>.data</code>, but this is much less likely. This is the same reasoning that leads to the <code>.x</code> and <code>.f</code> arguments to <code>map()</code> (Section <a href="#argument-names">9.2.4</a>).</p>
</div>
<div id="select" class="section level3">
<h3><span class="header-section-number">20.4.5</span> Application: <code>select()</code></h3>

<p>A data mask will typically be a data frame, but it’s sometimes useful to provide a list filled with more exotic contents. This is basically how the <code>select</code> argument in <code>base::subset()</code> works. It allows you to refer to variables as if they were numbers:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>, <span class="dt">d =</span> <span class="dv">4</span>, <span class="dt">e =</span> <span class="dv">5</span>)
<span class="kw">subset</span>(df, <span class="dt">select =</span> b<span class="op">:</span>d)
<span class="co">#&gt;   b c d</span>
<span class="co">#&gt; 1 2 3 4</span></code></pre>
<p>The key idea is to create a named list where each component gives the position of the corresponding variable:</p>
<pre class="sourceCode r"><code class="sourceCode r">vars &lt;-<span class="st"> </span><span class="kw">as.list</span>(<span class="kw">set_names</span>(<span class="kw">seq_along</span>(df), <span class="kw">names</span>(df)))
<span class="kw">str</span>(vars)
<span class="co">#&gt; List of 5</span>
<span class="co">#&gt;  $ a: int 1</span>
<span class="co">#&gt;  $ b: int 2</span>
<span class="co">#&gt;  $ c: int 3</span>
<span class="co">#&gt;  $ d: int 4</span>
<span class="co">#&gt;  $ e: int 5</span></code></pre>
<p>Then implementation is again only a few lines of code:</p>
<pre class="sourceCode r"><code class="sourceCode r">select2 &lt;-<span class="st"> </span><span class="cf">function</span>(data, ...) {
  dots &lt;-<span class="st"> </span><span class="kw">enquos</span>(...)

  vars &lt;-<span class="st"> </span><span class="kw">as.list</span>(<span class="kw">set_names</span>(<span class="kw">seq_along</span>(data), <span class="kw">names</span>(data)))
  cols &lt;-<span class="st"> </span><span class="kw">unlist</span>(<span class="kw">map</span>(dots, eval_tidy, vars))

  df[, cols, drop =<span class="st"> </span><span class="ot">FALSE</span>]
}
<span class="kw">select2</span>(df, b<span class="op">:</span>d)
<span class="co">#&gt;   b c d</span>
<span class="co">#&gt; 1 2 3 4</span></code></pre>
<p><code>dplyr::select()</code> takes this idea and runs with it, providing a number of helpers that allow you to select variables based on their names (e.g. <code>starts_with(&quot;x&quot;)</code> or <code>ends_with(&quot;_a&quot;</code>)).</p>
</div>
<div id="exercises-63" class="section level3">
<h3><span class="header-section-number">20.4.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why did I use a for loop in <code>transform2()</code> instead of <code>map()</code>?
Consider <code>transform2(df, x = x * 2, x = x * 2)</code>.</p></li>
<li><p>Here’s an alternative implementation of <code>subset2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">subset3 &lt;-<span class="st"> </span><span class="cf">function</span>(data, rows) {
  rows &lt;-<span class="st"> </span><span class="kw">enquo</span>(rows)
  <span class="kw">eval_tidy</span>(<span class="kw">expr</span>(data[<span class="op">!!</span>rows, , <span class="dt">drop =</span> <span class="ot">FALSE</span>]), <span class="dt">data =</span> data)
}

df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="kw">subset3</span>(df, x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<p>Compare and contrast <code>subset3()</code> to <code>subset2()</code>. What are its advantages
and disadvantages?</p></li>
<li><p>The following function implements the basics of <code>dplyr::arrange()</code>.
Annotate each line with a comment explaining what it does. Can you
explain why <code>!!.na.last</code> is strictly correct, but omitting the <code>!!</code>
is unlikely to cause problems?</p>
<pre class="sourceCode r"><code class="sourceCode r">arrange2 &lt;-<span class="st"> </span><span class="cf">function</span>(.df, ..., <span class="dt">.na.last =</span> <span class="ot">TRUE</span>) {
  args &lt;-<span class="st"> </span><span class="kw">enquos</span>(...)

  order_call &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">order</span>(<span class="op">!!!</span>args, <span class="dt">na.last =</span> <span class="op">!!</span>.na.last))

  ord &lt;-<span class="st"> </span><span class="kw">eval_tidy</span>(order_call, .df)
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(ord) <span class="op">==</span><span class="st"> </span><span class="kw">nrow</span>(.df))

  .df[ord, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
}</code></pre></li>
</ol>
</div>
</div>
<div id="tidy-evaluation" class="section level2">
<h2><span class="header-section-number">20.5</span> Using tidy evaluation</h2>
<p>While it’s important to understand how <code>eval_tidy()</code> works, most of the time you won’t call it directly. Instead, you’ll usually use it indirectly by calling a function that uses <code>eval_tidy()</code>. This section will give a few practical examples of wrapping functions that use tidy evaluation.</p>
<div id="quoting-and-unquoting" class="section level3">
<h3><span class="header-section-number">20.5.1</span> Quoting and unquoting</h3>
<p>

</p>
<p>Imagine we have written a function that resamples a dataset:</p>
<pre class="sourceCode r"><code class="sourceCode r">resample &lt;-<span class="st"> </span><span class="cf">function</span>(df, n) {
  idx &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(df), n, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
  df[idx, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
}</code></pre>
<p>We want to create a new function that allows us to resample and subset in a single step. Our naive approach doesn’t work:</p>
<pre class="sourceCode r"><code class="sourceCode r">subsample &lt;-<span class="st"> </span><span class="cf">function</span>(df, cond, <span class="dt">n =</span> <span class="kw">nrow</span>(df)) {
  df &lt;-<span class="st"> </span><span class="kw">subset2</span>(df, cond)
  <span class="kw">resample</span>(df, n)
}

df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)
<span class="kw">subsample</span>(df, x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; Error in eval_tidy(rows, data):</span>
<span class="co">#&gt;   object &#39;x&#39; not found</span></code></pre>
<p><code>subsample()</code> doesn’t quote any arguments so <code>cond</code> is evaluated normally (not in a data mask), and we get an error when it tries to find a binding for <code>x</code>. To fix this problem we need to quote <code>cond</code>, and then unquote it when we pass it on ot <code>subset2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">subsample &lt;-<span class="st"> </span><span class="cf">function</span>(df, cond, <span class="dt">n =</span> <span class="kw">nrow</span>(df)) {
  cond &lt;-<span class="st"> </span><span class="kw">enquo</span>(cond)

  df &lt;-<span class="st"> </span><span class="kw">subset2</span>(df, <span class="op">!!</span>cond)
  <span class="kw">resample</span>(df, n)
}

<span class="kw">subsample</span>(df, x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt;     x y</span>
<span class="co">#&gt; 1   1 1</span>
<span class="co">#&gt; 1.1 1 1</span>
<span class="co">#&gt; 2   1 2</span></code></pre>
<p>This is a very common pattern; whenever you call a quoting function with arguments from the user, you need to quote them yourself and then unquote.</p>
<!-- GVW: I really, really want a diagram here to show the various objects in play at each step - it took me a long time to figure out why quote/unquote was needed, and I still have to go back and review it each time I run into it. -->
</div>
<div id="handling-ambiguity" class="section level3">
<h3><span class="header-section-number">20.5.2</span> Handling ambiguity</h3>
<p></p>
<p>In the case above, we needed to think about tidy evaluation because of quasiquotation. We also need to think about tidy evaluation even when the wrapper doesn’t need to quote any arguments. Take this wrapper around <code>subset2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">threshold_x &lt;-<span class="st"> </span><span class="cf">function</span>(df, val) {
  <span class="kw">subset2</span>(df, x <span class="op">&gt;=</span><span class="st"> </span>val)
}</code></pre>
<p>This function can silently return an incorrect result in two situations:</p>
<ul>
<li><p>When <code>x</code> exists in the calling environment, but not in <code>df</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">10</span>
no_x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="kw">threshold_x</span>(no_x, <span class="dv">2</span>)
<span class="co">#&gt;   y</span>
<span class="co">#&gt; 1 1</span>
<span class="co">#&gt; 2 2</span>
<span class="co">#&gt; 3 3</span></code></pre></li>
<li><p>When <code>val</code> exists in <code>df</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">has_val &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">val =</span> <span class="dv">9</span><span class="op">:</span><span class="dv">11</span>)
<span class="kw">threshold_x</span>(has_val, <span class="dv">2</span>)
<span class="co">#&gt; [1] x   val</span>
<span class="co">#&gt; &lt;0 rows&gt; (or 0-length row.names)</span></code></pre></li>
</ul>
<p>These failure modes arise because tidy evaluation is ambiguous: each variable can be found in <strong>either</strong> the data mask <strong>or</strong> the environment. To make this function safe we need to remove the ambiguity using the <code>.data</code> and <code>.env</code> pronouns:</p>
<pre class="sourceCode r"><code class="sourceCode r">threshold_x &lt;-<span class="st"> </span><span class="cf">function</span>(df, val) {
  <span class="kw">subset2</span>(df, .data<span class="op">$</span>x <span class="op">&gt;=</span><span class="st"> </span>.env<span class="op">$</span>val)
}

x &lt;-<span class="st"> </span><span class="dv">10</span>
<span class="kw">threshold_x</span>(no_x, <span class="dv">2</span>)
<span class="co">#&gt; Error: Column `x` not found in `.data`</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─global::threshold_x(no_x, 2)</span>
<span class="co">#&gt;  2. │ └─global::subset2(df, .data$x &gt;= .env$val)</span>
<span class="co">#&gt;  3. │   └─rlang::eval_tidy(rows, data)</span>
<span class="co">#&gt;  4. ├─x</span>
<span class="co">#&gt;  5. ├─rlang:::`$.rlang_data_pronoun`(.data, x)</span>
<span class="co">#&gt;  6. │ └─rlang:::data_pronoun_get(x, nm)</span>
<span class="co">#&gt;  7. └─rlang:::abort_data_pronoun(x)</span>
<span class="kw">threshold_x</span>(has_val, <span class="dv">2</span>)
<span class="co">#&gt;   x val</span>
<span class="co">#&gt; 2 2  10</span>
<span class="co">#&gt; 3 3  11</span></code></pre>
<p>Generally, whenever you use the <code>.env</code> pronoun, you can use unquoting instead:</p>
<pre class="sourceCode r"><code class="sourceCode r">threshold_x &lt;-<span class="st"> </span><span class="cf">function</span>(df, val) {
  <span class="kw">subset2</span>(df, .data<span class="op">$</span>x <span class="op">&gt;=</span><span class="st"> </span><span class="op">!!</span>val)
}</code></pre>
<p>There are subtle differences in when <code>val</code> is evaluated. If you unquote, <code>val</code> will be early evaluated by <code>enquo()</code>; if you use a pronoun, <code>val</code> will be lazily evaluated by <code>eval_tidy()</code>. These differences are usually unimportant, so pick the form that looks most natural.</p>
</div>
<div id="quoting-and-ambiguity" class="section level3">
<h3><span class="header-section-number">20.5.3</span> Quoting and ambiguity</h3>
<p>To finish our discussion let’s consider the case where we have both quoting and potential ambiguity. I’ll generalise <code>threshold_x()</code> slightly so that the user can pick the variable used for thresholding. Here I used <code>.data[[var]]</code> because it makes the code a little simpler; in the exercises you’ll have a chance to explore how you might use <code>$</code> instead.</p>
<pre class="sourceCode r"><code class="sourceCode r">threshold_var &lt;-<span class="st"> </span><span class="cf">function</span>(df, var, val) {
  var &lt;-<span class="st"> </span><span class="kw">as_string</span>(<span class="kw">ensym</span>(var))
  <span class="kw">subset2</span>(df, .data[[var]] <span class="op">&gt;=</span><span class="st"> </span><span class="op">!!</span>val)
}

df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="kw">threshold_var</span>(df, x, <span class="dv">8</span>)
<span class="co">#&gt;     x</span>
<span class="co">#&gt; 8   8</span>
<span class="co">#&gt; 9   9</span>
<span class="co">#&gt; 10 10</span></code></pre>
<p>It is not always the responsibility of the function author to avoid ambiguity. Imagine we generalise further to allow thresholding based on any expression:</p>
<pre class="sourceCode r"><code class="sourceCode r">threshold_expr &lt;-<span class="st"> </span><span class="cf">function</span>(df, expr, val) {
  expr &lt;-<span class="st"> </span><span class="kw">enquo</span>(expr)
  <span class="kw">subset2</span>(df, <span class="op">!!</span>expr <span class="op">&gt;=</span><span class="st"> </span><span class="op">!!</span>val)
}</code></pre>
<p>It’s not possible to evaluate <code>expr</code> only the data mask, because the data mask doesn’t include any functions like <code>+</code> or <code>==</code>. Here, it’s the user’s responsibility to avoid ambiguity. As a general rule of thumb, as a function author it’s your responsibility to avoid ambiguity with any expressions that you create; it’s the user’s responsibility to avoid ambiguity in expressions that they create.</p>
</div>
<div id="exercises-64" class="section level3">
<h3><span class="header-section-number">20.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>I’ve included an alternative implementation of <code>threshold_var()</code> below.
What makes it different to the approach I used above? What make it harder?</p>
<pre class="sourceCode r"><code class="sourceCode r">threshold_var &lt;-<span class="st"> </span><span class="cf">function</span>(df, var, val) {
  var &lt;-<span class="st"> </span><span class="kw">ensym</span>(var)
  <span class="kw">subset2</span>(df, <span class="st">`</span><span class="dt">$</span><span class="st">`</span>(.data, <span class="op">!!</span>var) <span class="op">&gt;=</span><span class="st"> </span><span class="op">!!</span>val)
}</code></pre></li>
</ol>
</div>
</div>
<div id="base-evaluation" class="section level2">
<h2><span class="header-section-number">20.6</span> Base evaluation</h2>
<p></p>
<p>Now that you understand tidy evaluation, it’s time to come back to the alternative approaches taken by base R. Here I’ll explore the two most common uses in base R:</p>
<ul>
<li><p><code>substitute()</code> and evaluation in the caller environment, as used by
<code>subset()</code>. I’ll use this technique to motivate why this technique is not
programming friendly, as warned about in the <code>subset()</code> documentation.</p></li>
<li><p><code>match.call()</code>, call manipulation, and evaluation in the caller environment,
as used by <code>write.csv()</code> and <code>lm()</code>. I’ll use this technique to motivate how
quasiquotation and (regular) evaluation can help you write wrappers such
functions.</p></li>
</ul>
<p>These two approaches are common forms of non-standard evaluation (NSE).</p>
<div id="substitute" class="section level3">
<h3><span class="header-section-number">20.6.1</span> <code>substitute()</code></h3>

<p>The most common form of NSE in base R is <code>substitute()</code> + <code>eval()</code>. The following code shows how you might write the core of <code>subset()</code> in this style using <code>substitute()</code> and <code>eval()</code> rather than <code>enquo()</code> and <code>eval_tidy()</code>. I repeat the code introduced in Section <a href="#subset">20.4.3</a> so you can compare easily. The main difference is the evaluation environment: in <code>subset_base()</code> the argument is evaluated in the caller environment, while in <code>subset_tidy()</code>, it’s evaluated in the environment where it was defined.</p>
<pre class="sourceCode r"><code class="sourceCode r">subset_base &lt;-<span class="st"> </span><span class="cf">function</span>(data, rows) {
  rows &lt;-<span class="st"> </span><span class="kw">substitute</span>(rows)
  rows_val &lt;-<span class="st"> </span><span class="kw">eval</span>(rows, data, <span class="kw">caller_env</span>())
  <span class="kw">stopifnot</span>(<span class="kw">is.logical</span>(rows_val))

  data[rows_val, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
}

subset_tidy &lt;-<span class="st"> </span><span class="cf">function</span>(data, rows) {
  rows &lt;-<span class="st"> </span><span class="kw">enquo</span>(rows)
  rows_val &lt;-<span class="st"> </span><span class="kw">eval_tidy</span>(rows, data)
  <span class="kw">stopifnot</span>(<span class="kw">is.logical</span>(rows_val))

  data[rows_val, , drop =<span class="st"> </span><span class="ot">FALSE</span>]
}</code></pre>
<div id="programming-with-subset" class="section level4">
<h4><span class="header-section-number">20.6.1.1</span> Programming with <code>subset()</code></h4>

<p>The documentation of <code>subset()</code> includes the following warning:</p>
<blockquote>
<p>This is a convenience function intended for use interactively. For
programming it is better to use the standard subsetting functions like <code>[</code>,
and in particular the non-standard evaluation of argument <code>subset</code> can have
unanticipated consequences.</p>
</blockquote>
<p>There are main three problems:</p>
<ul>
<li><p><code>base::subset()</code> always evaluates <code>rows</code> in the calling environment, but
if <code>...</code> has been used, then the expression might need to be evaluated
elsewhere:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(df, ...) {
  xval &lt;-<span class="st"> </span><span class="dv">3</span>
  <span class="kw">subset_base</span>(df, ...)
}

my_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>)
xval &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">f1</span>(my_df, x <span class="op">==</span><span class="st"> </span>xval)
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 3 3 1</span></code></pre>
<p>This may seems like an esoteric concern, but it means that <code>subset_base()</code>
cannot reliably work with functionals like <code>map()</code> or <code>lapply()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">local</span>({
  zzz &lt;-<span class="st"> </span><span class="dv">2</span>
  dfs &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>), <span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>))
  <span class="kw">lapply</span>(dfs, subset_base, x <span class="op">==</span><span class="st"> </span>zzz)
})
<span class="co">#&gt; Error in eval(rows, data, caller_env()):</span>
<span class="co">#&gt;   object &#39;zzz&#39; not found</span></code></pre></li>
<li><p>Calling <code>subset()</code> from another function requires some care: you have
to use <code>substitute()</code> to capture a call to <code>subset()</code> complete expression,
and then evaluate. I think this code is hard to understand because
<code>substitute()</code> doesn’t use a syntactic marker for unquoting. Here I print
the generated call to make it a little easier to see what’s happening.</p>
<pre class="sourceCode r"><code class="sourceCode r">f2 &lt;-<span class="st"> </span><span class="cf">function</span>(df1, expr) {
  call &lt;-<span class="st"> </span><span class="kw">substitute</span>(<span class="kw">subset_base</span>(df1, expr))
  <span class="kw">expr_print</span>(call)
  <span class="kw">eval</span>(call, <span class="kw">caller_env</span>())
}

my_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>)
<span class="kw">f2</span>(my_df, x <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; subset_base(my_df, x == 1)</span>
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 3</span></code></pre></li>
<li><p><code>eval()</code> doesn’t provide any pronouns so there’s no way to require part of
the expression to come from the data. As far as I can tell, there’s no
way to make the following function safe except by manually checking for the
presence of <code>z</code> variable in <code>df</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">f3 &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  call &lt;-<span class="st"> </span><span class="kw">substitute</span>(<span class="kw">subset_base</span>(df, z <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>))
  <span class="kw">expr_print</span>(call)
  <span class="kw">eval</span>(call, <span class="kw">caller_env</span>())
}

my_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>)
z &lt;-<span class="st"> </span><span class="dv">-1</span>
<span class="kw">f3</span>(my_df)
<span class="co">#&gt; subset_base(my_df, z &gt; 0)</span>
<span class="co">#&gt; [1] x y</span>
<span class="co">#&gt; &lt;0 rows&gt; (or 0-length row.names)</span></code></pre></li>
</ul>
</div>
<div id="what-about" class="section level4">
<h4><span class="header-section-number">20.6.1.2</span> What about <code>[</code>?</h4>
<p>Given that tidy evaluation is quite complex, why not simply use <code>[</code> as <code>?subset</code> recommends? Primarily, it seems unappealing to me to have functions that can only be used interactively, and never inside another function.</p>
<p>Additionally, even the simple <code>subset()</code> function provides two useful features compared to <code>[</code>:</p>
<ul>
<li><p>It sets <code>drop = FALSE</code> by default, so it’s guaranteed to return a data frame.</p></li>
<li><p>It drops rows where the condition evaluates to <code>NA</code>.</p></li>
</ul>
<p>That means <code>subset(df, x == y)</code> is not equivalent to <code>df[x == y,]</code> as you might expect. Instead, it is equivalent to <code>df[x == y &amp; !is.na(x == y), , drop = FALSE]</code>: that’s a lot more typing! Real-life alternatives to <code>subset()</code>, like <code>dplyr::filter()</code>, do even more. For example, <code>dplyr::filter()</code> can translate R expressions to SQL so that they can be executed in a database. This makes programming with <code>filter()</code> relatively more important.</p>
</div>
</div>
<div id="match.call" class="section level3">
<h3><span class="header-section-number">20.6.2</span> <code>match.call()</code></h3>

<p>Another common form of NSE is to capture the complete call with <code>match.call()</code>, modify it, and evaluate the result. <code>match.call()</code> is similar to <code>substitute()</code>, but instead of capturing a single argument, it captures the complete call. It doesn’t have an equivalent in rlang.</p>
<pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, z) {
  <span class="kw">match.call</span>()
}
<span class="kw">g</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dt">z =</span> <span class="dv">3</span>)
<span class="co">#&gt; g(x = 1, y = 2, z = 3)</span></code></pre>
<p>One prominent user of <code>match.call()</code> is <code>write.csv()</code>, which basically works by transforming the call into a call to <code>write.table()</code> with the appropriate arguments set. The following code shows the heart of <code>write.csv()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">write.csv &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  call &lt;-<span class="st"> </span><span class="kw">match.call</span>(write.table, <span class="dt">expand.dots =</span> <span class="ot">TRUE</span>)

  call[[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="kw">quote</span>(write.table)
  call<span class="op">$</span>sep &lt;-<span class="st"> &quot;,&quot;</span>
  call<span class="op">$</span>dec &lt;-<span class="st"> &quot;.&quot;</span>

  <span class="kw">eval</span>(call, <span class="kw">parent.frame</span>())
}</code></pre>
<p>I don’t think this technique is a good idea because you can achieve the same result without NSE:</p>
<pre class="sourceCode r"><code class="sourceCode r">write.csv &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  <span class="kw">write.table</span>(..., <span class="dt">sep =</span> <span class="st">&quot;,&quot;</span>, <span class="dt">dec =</span> <span class="st">&quot;.&quot;</span>)
}</code></pre>
<p>Nevertheless, it’s important to understand this technique because it’s commonly used in modelling functions. These functions also prominently print the captured call, which poses some special challenges, as you’ll see next.</p>
<div id="wrapping-modelling-functions" class="section level4">
<h4><span class="header-section-number">20.6.2.1</span> Wrapping modelling functions</h4>

<p>To begin, consider the simplest possible wrapper around <code>lm()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">lm2 &lt;-<span class="st"> </span><span class="cf">function</span>(formula, data) {
  <span class="kw">lm</span>(formula, data)
}</code></pre>
<p>This wrapper works, but is suboptimal because <code>lm()</code> captures its call and displays it when printing.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lm2</span>(mpg <span class="op">~</span><span class="st"> </span>disp, mtcars)
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = formula, data = data)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;     29.5999      -0.0412</span></code></pre>
<p>Fixing this is important because this call is the chief way that you see the model specification when printing the model. To overcome this problem, we need to capture the arguments, create the call to <code>lm()</code> using unquoting, then evaluate that call. To make it easier to see what’s going on, I’ll also print the expression we generate. This will become more useful as the calls get more complicated.</p>
<pre class="sourceCode r"><code class="sourceCode r">lm3 &lt;-<span class="st"> </span><span class="cf">function</span>(formula, data, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  formula &lt;-<span class="st"> </span><span class="kw">enexpr</span>(formula)
  data &lt;-<span class="st"> </span><span class="kw">enexpr</span>(data)

  lm_call &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">lm</span>(<span class="op">!!</span>formula, <span class="dt">data =</span> <span class="op">!!</span>data))
  <span class="kw">expr_print</span>(lm_call)
  <span class="kw">eval</span>(lm_call, env)
}

<span class="kw">lm3</span>(mpg <span class="op">~</span><span class="st"> </span>disp, mtcars)
<span class="co">#&gt; lm(mpg ~ disp, data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ disp, data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)         disp  </span>
<span class="co">#&gt;     29.5999      -0.0412</span></code></pre>
<p>There are three pieces that you’ll use whenever wrapping a base NSE function in this way:</p>
<ul>
<li><p>You capture the unevaluated arguments using <code>enexpr()</code>, and capture the caller
environment using <code>caller_env()</code>.</p></li>
<li><p>You generate a new expression using <code>expr()</code> and unquoting.</p></li>
<li><p>You evaluate that expression in the caller environment. You have to accept
that the function will not work correctly if the arguments are not defined
in the caller environment. Providing the <code>env</code> argument at least provides
a hook that experts can use if the default environment isn’t correct.</p></li>
</ul>
<p>The use of <code>enexpr()</code> has a nice side-effect: we can use unquoting to generate formulas dynamically:</p>
<pre class="sourceCode r"><code class="sourceCode r">resp &lt;-<span class="st"> </span><span class="kw">expr</span>(mpg)
disp1 &lt;-<span class="st"> </span><span class="kw">expr</span>(vs)
disp2 &lt;-<span class="st"> </span><span class="kw">expr</span>(wt)
<span class="kw">lm3</span>(<span class="op">!!</span>resp <span class="op">~</span><span class="st"> </span><span class="op">!!</span>disp1 <span class="op">+</span><span class="st"> </span><span class="op">!!</span>disp2, mtcars)
<span class="co">#&gt; lm(mpg ~ vs + wt, data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = mpg ~ vs + wt, data = mtcars)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)           vs           wt  </span>
<span class="co">#&gt;       33.00         3.15        -4.44</span></code></pre>
</div>
<div id="the-evaluation-environment" class="section level4">
<h4><span class="header-section-number">20.6.2.2</span> The evaluation environment</h4>
<p>What if you want to mingle objects supplied by the user with objects that you create in the function? For example, imagine you want to make an auto-resampling version of <code>lm()</code>. You might write it like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">resample_lm0 &lt;-<span class="st"> </span><span class="cf">function</span>(formula, data, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  formula &lt;-<span class="st"> </span><span class="kw">enexpr</span>(formula)
  resample_data &lt;-<span class="st"> </span><span class="kw">resample</span>(data, <span class="dt">n =</span> <span class="kw">nrow</span>(data))

  lm_call &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">lm</span>(<span class="op">!!</span>formula, <span class="dt">data =</span> resample_data))
  <span class="kw">expr_print</span>(lm_call)
  <span class="kw">eval</span>(lm_call, env)
}

df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">y =</span> <span class="dv">5</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>) <span class="op">+</span><span class="st"> </span><span class="kw">round</span>(<span class="kw">rnorm</span>(<span class="dv">10</span>), <span class="dv">2</span>))
<span class="kw">resample_lm0</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> df)
<span class="co">#&gt; lm(y ~ x, data = resample_data)</span>
<span class="co">#&gt; Error in is.data.frame(data):</span>
<span class="co">#&gt;   object &#39;resample_data&#39; not found</span></code></pre>
<p>Why doesn’t this code work? We’re evaluating <code>lm_call</code> in the caller environment, but <code>resample_data</code> exists in the execution environment. We could instead evaluate in the execution environment of <code>resample_lm0()</code>, but there’s no guarantee that <code>formula</code> could be evaluated in that environment.</p>
<p>There are two basic ways to overcome this challenge:</p>
<ol style="list-style-type: decimal">
<li><p>Unquote the data frame into the call. This means that no lookup has
to occur, but has all the problems of inlining expressions (Section
<a href="#non-standard-ast">19.4.7</a>). For modelling functions this means that the
captured call is suboptimal:</p>
<pre class="sourceCode r"><code class="sourceCode r">resample_lm1 &lt;-<span class="st"> </span><span class="cf">function</span>(formula, data, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  formula &lt;-<span class="st"> </span><span class="kw">enexpr</span>(formula)
  resample_data &lt;-<span class="st"> </span><span class="kw">resample</span>(data, <span class="dt">n =</span> <span class="kw">nrow</span>(data))

  lm_call &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">lm</span>(<span class="op">!!</span>formula, <span class="dt">data =</span> <span class="op">!!</span>resample_data))
  <span class="kw">expr_print</span>(lm_call)
  <span class="kw">eval</span>(lm_call, env)
}
<span class="kw">resample_lm1</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> df)<span class="op">$</span>call
<span class="co">#&gt; lm(y ~ x, data = &lt;data.frame&gt;)</span>
<span class="co">#&gt; lm(formula = y ~ x, data = list(x = c(8L, 10L, 2L, 3L, 7L, 5L, </span>
<span class="co">#&gt; 7L, 7L, 1L, 8L), y = c(28.45, 37.07, 11.62, 15.15, 25.72, 19.75, </span>
<span class="co">#&gt; 25.72, 25.72, 7.99, 28.45)))</span></code></pre></li>
<li><p>Alternatively you can create a new environment that inherits from the
caller, and bind variables that you’ve created inside the
function to that environment.</p>
<pre class="sourceCode r"><code class="sourceCode r">resample_lm2 &lt;-<span class="st"> </span><span class="cf">function</span>(formula, data, <span class="dt">env =</span> <span class="kw">caller_env</span>()) {
  formula &lt;-<span class="st"> </span><span class="kw">enexpr</span>(formula)
  resample_data &lt;-<span class="st"> </span><span class="kw">resample</span>(data, <span class="dt">n =</span> <span class="kw">nrow</span>(data))

  lm_env &lt;-<span class="st"> </span><span class="kw">env</span>(env, <span class="dt">resample_data =</span> resample_data)
  lm_call &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">lm</span>(<span class="op">!!</span>formula, <span class="dt">data =</span> resample_data))
  <span class="kw">expr_print</span>(lm_call)
  <span class="kw">eval</span>(lm_call, lm_env)
}
<span class="kw">resample_lm2</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> df)
<span class="co">#&gt; lm(y ~ x, data = resample_data)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Call:</span>
<span class="co">#&gt; lm(formula = y ~ x, data = resample_data)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Coefficients:</span>
<span class="co">#&gt; (Intercept)            x  </span>
<span class="co">#&gt;        3.06         3.30</span></code></pre>
<p>This is more work, but gives the cleanest specification.</p></li>
</ol>
</div>
</div>
<div id="exercises-65" class="section level3">
<h3><span class="header-section-number">20.6.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why does this function fail?</p>
<pre class="sourceCode r"><code class="sourceCode r">lm3a &lt;-<span class="st"> </span><span class="cf">function</span>(formula, data) {
  formula &lt;-<span class="st"> </span><span class="kw">enexpr</span>(formula)

  lm_call &lt;-<span class="st"> </span><span class="kw">expr</span>(<span class="kw">lm</span>(<span class="op">!!</span>formula, <span class="dt">data =</span> data))
  <span class="kw">eval</span>(lm_call, <span class="kw">caller_env</span>())
}
<span class="kw">lm3a</span>(mpg <span class="op">~</span><span class="st"> </span>disp, mtcars)<span class="op">$</span>call
<span class="co">#&gt; Error in as.data.frame.default(data, optional = TRUE):</span>
<span class="co">#&gt;   cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame</span></code></pre></li>
<li><p>When model building, typically the response and data are relatively
constant while you rapidly experiment with different predictors. Write a
small wrapper that allows you to reduce duplication in the code below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>disp, <span class="dt">data =</span> mtcars)
<span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp), <span class="dt">data =</span> mtcars)
<span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>disp <span class="op">*</span><span class="st"> </span>cyl, <span class="dt">data =</span> mtcars)</code></pre></li>
<li><p>Another way to way to write <code>resample_lm()</code> would be to include the
resmaple expression (<code>data[sample(nrow(data), replace = TRUE), , drop = FALSE]</code>)
in the data argument. Implement that approach. What are the advantages?
What are the disadvantages?</p></li>
</ol>
<!--chapter:end:Evaluation.Rmd-->
</div>
</div>
</div>
<div id="translation" class="section level1">
<h1><span class="header-section-number">21</span> Translating R code</h1>
<div id="introduction-21" class="section level2">
<h2><span class="header-section-number">21.1</span> Introduction</h2>
<p>The combination of first-class environments, lexical scoping, and metaprogramming gives us a powerful toolkit for translating R code into other languages. One fully-fledged example of this idea is dbplyr, which powers the database backends for dplyr, allowing you to express data manipulation in R and automatically translate it into SQL. You can see the key idea in <code>translate_sql()</code> which takes R code and returns the equivalent SQL:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dbplyr)
<span class="kw">translate_sql</span>(x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; &lt;SQL&gt; POWER(&quot;x&quot;, 2.0)</span>
<span class="kw">translate_sql</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span> <span class="op">&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is.na</span>(x))
<span class="co">#&gt; &lt;SQL&gt; &quot;x&quot; &lt; 5.0 AND NOT(((&quot;x&quot;) IS NULL))</span>
<span class="kw">translate_sql</span>(<span class="op">!</span>first <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;John&quot;</span>, <span class="st">&quot;Roger&quot;</span>, <span class="st">&quot;Robert&quot;</span>))
<span class="co">#&gt; &lt;SQL&gt; NOT(&quot;first&quot; IN (&#39;John&#39;, &#39;Roger&#39;, &#39;Robert&#39;))</span>
<span class="kw">translate_sql</span>(select <span class="op">==</span><span class="st"> </span><span class="dv">7</span>)
<span class="co">#&gt; &lt;SQL&gt; &quot;select&quot; = 7.0</span></code></pre>
<p>Translating R to SQL is complex because of the many idiosyncrasies of SQL dialects, so here I’ll develop two simple, but useful, domain specific languages (DSL): one to generate HTML, and the other to generate mathematical equations in LaTeX.</p>
<p>If you’re interested in learning more about domain specific languages in general, I highly recommend <em>Domain Specific Languages</em> <span class="citation">(Fowler <a href="#ref-dsls">2010</a>)</span>. It discusses many options for creating a DSL and provides many examples of different languages.</p>
<div id="outline-19" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#html">21.2</a> creates a DSL for generating HTML, using quasiquotation
and purrr to generate a function for each HTML tag, then tidy evaluation to
easily access them.</p></li>
<li><p>Section <a href="#latex">21.3</a> transforms mathematically R code into its LaTeX
equivalent using a combination of tidy evaluation and expression walking.</p></li>
</ul>
</div>
<div id="prerequisites-14" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>This chapter together pulls together many techniques discussed elsewhere in the book. In particular, you’ll need to understand environments, expressions, tidy evaluation, and a little functional programming and S3. We’ll use rlang<span id="fn157" class="footnote" data-pagedown-footnote-number="157" style="white-space: pre-line;"><a href="https://rlang.r-lib.org" class="uri">https://rlang.r-lib.org</a></span> for metaprogramming tools, and purrr<span id="fn158" class="footnote" data-pagedown-footnote-number="158" style="white-space: pre-line;"><a href="https://purrr.tidyverse.org" class="uri">https://purrr.tidyverse.org</a></span> for functional programming.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rlang)
<span class="kw">library</span>(purrr)</code></pre>
</div>
</div>
<div id="html" class="section level2">
<h2><span class="header-section-number">21.2</span> HTML</h2>
<p></p>
<p>HTML (HyperText Markup Language) is the language that underlies the majority of the web. It’s a special case of SGML (Standard Generalised Markup Language), and it’s similar but not identical to XML (eXtensible Markup Language). HTML looks like this:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;body&gt;</span>
  <span class="kw">&lt;h1</span><span class="ot"> id=</span><span class="st">&#39;first&#39;</span><span class="kw">&gt;</span>A heading<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;p&gt;</span>Some text <span class="dv">&amp;amp;</span> <span class="kw">&lt;b&gt;</span>some bold text.<span class="kw">&lt;/b&gt;&lt;/p&gt;</span>
  <span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">&#39;myimg.png&#39;</span><span class="ot"> width=</span><span class="st">&#39;100&#39;</span><span class="ot"> height=</span><span class="st">&#39;100&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/body&gt;</span></code></pre>
<p>Even if you’ve never looked at HTML before, you can still see that the key component of its coding structure is tags, which look like <code>&lt;tag&gt;&lt;/tag&gt;</code> or <code>&lt;tag /&gt;</code>. Tags can be nested within other tags and intermingled with text. There are over 100 HTML tags, but in this chapter we’ll focus on just a handful:</p>
<ul>
<li><code>&lt;body&gt;</code> is the top-level tag that contains all content.</li>
<li><code>&lt;h1&gt;</code> defines a top level heading.</li>
<li><code>&lt;p&gt;</code> defines a paragraph.</li>
<li><code>&lt;b&gt;</code> emboldens text.</li>
<li><code>&lt;img&gt;</code> embeds an image.</li>
</ul>
<p>Tags can have named <strong>attributes</strong> which look like <code>&lt;tag name1='value1' name2='value2'&gt;&lt;/tag&gt;</code>. Two of the most important attributes are <code>id</code> and <code>class</code>, which are used in conjunction with CSS (Cascading Style Sheets) to control the visual appearance of the page.</p>
<p><strong>Void tags</strong>, like <code>&lt;img&gt;</code>, don’t have any children, and are written <code>&lt;img /&gt;</code>, not <code>&lt;img&gt;&lt;/img&gt;</code>. Since they have no content, attributes are more important, and <code>img</code> has three that are used with almost every image: <code>src</code> (where the image lives), <code>width</code>, and <code>height</code>.</p>
<p>Because <code>&lt;</code> and <code>&gt;</code> have special meanings in HTML, you can’t write them directly. Instead you have to use the HTML <strong>escapes</strong>: <code>&amp;gt;</code> and <code>&amp;lt;</code>. And since those escapes use <code>&amp;</code>, if you want a literal ampersand you have to escape it as <code>&amp;amp;</code>.</p>
<div id="goal" class="section level3">
<h3><span class="header-section-number">21.2.1</span> Goal</h3>
<p>Our goal is to make it easy to generate HTML from R. To give a concrete example, we want to generate the following HTML:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;body&gt;</span>
  <span class="kw">&lt;h1</span><span class="ot"> id=</span><span class="st">&#39;first&#39;</span><span class="kw">&gt;</span>A heading<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;p&gt;</span>Some text <span class="dv">&amp;amp;</span> <span class="kw">&lt;b&gt;</span>some bold text.<span class="kw">&lt;/b&gt;&lt;/p&gt;</span>
  <span class="kw">&lt;img</span><span class="ot"> src=</span><span class="st">&#39;myimg.png&#39;</span><span class="ot"> width=</span><span class="st">&#39;100&#39;</span><span class="ot"> height=</span><span class="st">&#39;100&#39;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/body&gt;</span></code></pre>
<p>Using the following code that matches the structure of the HTML as closely as possible:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">with_html</span>(
  <span class="kw">body</span>(
    <span class="kw">h1</span>(<span class="st">&quot;A heading&quot;</span>, <span class="dt">id =</span> <span class="st">&quot;first&quot;</span>),
    <span class="kw">p</span>(<span class="st">&quot;Some text &amp;&quot;</span>, <span class="kw">b</span>(<span class="st">&quot;some bold text.&quot;</span>)),
    <span class="kw">img</span>(<span class="dt">src =</span> <span class="st">&quot;myimg.png&quot;</span>, <span class="dt">width =</span> <span class="dv">100</span>, <span class="dt">height =</span> <span class="dv">100</span>)
  )
)</code></pre>
<p>This DSL has the following three properties:</p>
<ul>
<li><p>The nesting of function calls matches the nesting of tags.</p></li>
<li><p>Unnamed arguments become the content of the tag, and named arguments
become their attributes.</p></li>
<li><p><code>&amp;</code> and other special characters are automatically escaped.</p></li>
</ul>
</div>
<div id="escaping" class="section level3">
<h3><span class="header-section-number">21.2.2</span> Escaping</h3>
<p></p>
<p>Escaping is so fundamental to translation that it’ll be our first topic. There are two related challenges:</p>
<ul>
<li><p>In user input, we need to automatically escape <code>&amp;</code>, <code>&lt;</code> and <code>&gt;</code>.</p></li>
<li><p>At the same time we need to make sure that the <code>&amp;</code>, <code>&lt;</code> and <code>&gt;</code> we generate
are not double-escaped (i.e. that we don’t accidentally generate <code>&amp;amp;amp;</code>, <code>&amp;amp;lt;</code> and <code>&amp;amp;gt;</code>).</p></li>
</ul>
<p>The easiest way to do this is to create an S3 class (Section <a href="#s3-classes">13.3</a>) that distinguishes between regular text (that needs escaping) and HTML (that doesn’t).</p>
<pre class="sourceCode r"><code class="sourceCode r">html &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">structure</span>(x, <span class="dt">class =</span> <span class="st">&quot;advr_html&quot;</span>)

print.advr_html &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...) {
  out &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">&quot;&lt;HTML&gt; &quot;</span>, x)
  <span class="kw">cat</span>(<span class="kw">paste</span>(<span class="kw">strwrap</span>(out), <span class="dt">collapse =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
}</code></pre>
<p>We then write an escape generic. It has two important methods:</p>
<ul>
<li><p><code>escape.character()</code> takes a regular character vector and returns an HTML
vector with special characters (<code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>) escaped.</p></li>
<li><p><code>escape.advr_html()</code> leaves already escaped HTML alone.</p></li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">escape &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">UseMethod</span>(<span class="st">&quot;escape&quot;</span>)

escape.character &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;&amp;&quot;</span>, <span class="st">&quot;&amp;amp;&quot;</span>, x)
  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;&lt;&quot;</span>, <span class="st">&quot;&amp;lt;&quot;</span>, x)
  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;&gt;&quot;</span>, <span class="st">&quot;&amp;gt;&quot;</span>, x)

  <span class="kw">html</span>(x)
}

escape.advr_html &lt;-<span class="st"> </span><span class="cf">function</span>(x) x</code></pre>
<p>Now we check that it works</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">escape</span>(<span class="st">&quot;This is some text.&quot;</span>)
<span class="co">#&gt; &lt;HTML&gt; This is some text.</span>
<span class="kw">escape</span>(<span class="st">&quot;x &gt; 1 &amp; y &lt; 2&quot;</span>)
<span class="co">#&gt; &lt;HTML&gt; x &amp;gt; 1 &amp;amp; y &amp;lt; 2</span>

<span class="co"># Double escaping is not a problem</span>
<span class="kw">escape</span>(<span class="kw">escape</span>(<span class="st">&quot;This is some text. 1 &gt; 2&quot;</span>))
<span class="co">#&gt; &lt;HTML&gt; This is some text. 1 &amp;gt; 2</span>

<span class="co"># And text we know is HTML doesn&#39;t get escaped.</span>
<span class="kw">escape</span>(<span class="kw">html</span>(<span class="st">&quot;&lt;hr /&gt;&quot;</span>))
<span class="co">#&gt; &lt;HTML&gt; &lt;hr /&gt;</span></code></pre>
<p>Conveniently, this also allows a user to opt out of our escaping if they know the content is already escaped.</p>
</div>
<div id="basic-tag-functions" class="section level3">
<h3><span class="header-section-number">21.2.3</span> Basic tag functions</h3>
<p>Next, we’ll write a one-tag function by hand, then figure out how to generalise it so we can generate a function for every tag with code.</p>
<p>Let’s start with <code>&lt;p&gt;</code>. HTML tags can have both attributes (e.g., id or class) and children (like <code>&lt;b&gt;</code> or <code>&lt;i&gt;</code>). We need some way of separating these in the function call. Given that attributes are named and children are not, it seems natural to use named and unnamed arguments for them respectively. For example, a call to <code>p()</code> might look like:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">p</span>(<span class="st">&quot;Some text. &quot;</span>, <span class="kw">b</span>(<span class="kw">i</span>(<span class="st">&quot;some bold italic text&quot;</span>)), <span class="dt">class =</span> <span class="st">&quot;mypara&quot;</span>)</code></pre>
<p>We could list all the possible attributes of the <code>&lt;p&gt;</code> tag in the function definition, but that’s hard because there are many attributes, and because it’s possible to use custom attributes<span id="fn159" class="footnote" data-pagedown-footnote-number="159" style="white-space: pre-line;"><a href="http://html5doctor.com/html5-custom-data-attributes/" class="uri">http://html5doctor.com/html5-custom-data-attributes/</a></span>. Instead, we’ll use <code>...</code> and separate the components based on whether or not they are named. With this in mind, we create a helper function that wraps around <code>rlang::list2()</code> (Section <a href="#tidy-dots">19.6</a>) and returns named and unnamed components separately:</p>
<pre class="sourceCode r"><code class="sourceCode r">dots_partition &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  dots &lt;-<span class="st"> </span><span class="kw">list2</span>(...)

  is_named &lt;-<span class="st"> </span><span class="kw">names</span>(dots) <span class="op">!=</span><span class="st"> &quot;&quot;</span>
  <span class="kw">list</span>(
    <span class="dt">named =</span> dots[is_named],
    <span class="dt">unnamed =</span> dots[<span class="op">!</span>is_named]
  )
}

<span class="kw">str</span>(<span class="kw">dots_partition</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dv">2</span>, <span class="dt">b =</span> <span class="dv">3</span>, <span class="dv">4</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ named  :List of 2</span>
<span class="co">#&gt;   ..$ a: num 1</span>
<span class="co">#&gt;   ..$ b: num 3</span>
<span class="co">#&gt;  $ unnamed:List of 2</span>
<span class="co">#&gt;   ..$ : num 2</span>
<span class="co">#&gt;   ..$ : num 4</span></code></pre>
<p>We can now create our <code>p()</code> function. Notice that there’s one new function here: <code>html_attributes()</code>. It takes a named list and returns the HTML attribute specification as a string. It’s a little complicated (in part, because it deals with some idiosyncrasies of HTML that I haven’t mentioned here), but it’s not that important and doesn’t introduce any new programming ideas, so I won’t discuss it in detail. You can find the source online<span id="fn160" class="footnote" data-pagedown-footnote-number="160" style="white-space: pre-line;"><a href="https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r" class="uri">https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r</a></span> if you want to work through it yourself.</p>
<!-- GVW: possible/useful to show a very simple version of `html_attributes`, then point out one or two cases for which it fails, then tell them to read the source? I'm always nervous when someone tells me "you don't need to worry about the details of this" -->
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">source</span>(<span class="st">&quot;dsl-html-attributes.r&quot;</span>)
p &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
  dots &lt;-<span class="st"> </span><span class="kw">dots_partition</span>(...)
  attribs &lt;-<span class="st"> </span><span class="kw">html_attributes</span>(dots<span class="op">$</span>named)
  children &lt;-<span class="st"> </span><span class="kw">map_chr</span>(dots<span class="op">$</span>unnamed, escape)

  <span class="kw">html</span>(<span class="kw">paste0</span>(
    <span class="st">&quot;&lt;p&quot;</span>, attribs, <span class="st">&quot;&gt;&quot;</span>,
    <span class="kw">paste</span>(children, <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>),
    <span class="st">&quot;&lt;/p&gt;&quot;</span>
  ))
}

<span class="kw">p</span>(<span class="st">&quot;Some text&quot;</span>)
<span class="co">#&gt; &lt;HTML&gt; &lt;p&gt;&lt;/p&gt;</span>
<span class="kw">p</span>(<span class="st">&quot;Some text&quot;</span>, <span class="dt">id =</span> <span class="st">&quot;myid&quot;</span>)
<span class="co">#&gt; &lt;HTML&gt; &lt;p id=&#39;myid&#39;&gt;Some text&lt;/p&gt;</span>
<span class="kw">p</span>(<span class="st">&quot;Some text&quot;</span>, <span class="dt">class =</span> <span class="st">&quot;important&quot;</span>, <span class="st">`</span><span class="dt">data-value</span><span class="st">`</span> =<span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; &lt;HTML&gt; &lt;p class=&#39;important&#39; data-value=&#39;10&#39;&gt;Some text&lt;/p&gt;</span></code></pre>
</div>
<div id="tag-functions" class="section level3">
<h3><span class="header-section-number">21.2.4</span> Tag functions</h3>
<p>It’s straightforward to adapt <code>p()</code> to other tags: we just need to replace <code>&quot;p&quot;</code> with the name of the tag. One elegant way to do that is to create a function with <code>rlang::new_function()</code> (Section <a href="#new-function">19.7.4</a>), using unquoting and <code>paste0()</code> to generate the starting and ending tags.</p>
<pre class="sourceCode r"><code class="sourceCode r">tag &lt;-<span class="st"> </span><span class="cf">function</span>(tag) {
  <span class="kw">new_function</span>(
    <span class="kw">exprs</span>(<span class="dt">... =</span> ),
    <span class="kw">expr</span>({
      dots &lt;-<span class="st"> </span><span class="kw">dots_partition</span>(...)
      attribs &lt;-<span class="st"> </span><span class="kw">html_attributes</span>(dots<span class="op">$</span>named)
      children &lt;-<span class="st"> </span><span class="kw">map_chr</span>(dots<span class="op">$</span>unnamed, escape)

      <span class="kw">html</span>(<span class="kw">paste0</span>(
        <span class="op">!!</span><span class="kw">paste0</span>(<span class="st">&quot;&lt;&quot;</span>, tag), attribs, <span class="st">&quot;&gt;&quot;</span>,
        <span class="kw">paste</span>(children, <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>),
        <span class="op">!!</span><span class="kw">paste0</span>(<span class="st">&quot;&lt;/&quot;</span>, tag, <span class="st">&quot;&gt;&quot;</span>)
      ))
    }),
    <span class="kw">caller_env</span>()
  )
}
<span class="kw">tag</span>(<span class="st">&quot;b&quot;</span>)
<span class="co">#&gt; function (...) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     dots &lt;- dots_partition(...)</span>
<span class="co">#&gt;     attribs &lt;- html_attributes(dots$named)</span>
<span class="co">#&gt;     children &lt;- map_chr(dots$unnamed, escape)</span>
<span class="co">#&gt;     html(paste0(&quot;&lt;b&quot;, attribs, &quot;&gt;&quot;, paste(children, collapse = &quot;&quot;), </span>
<span class="co">#&gt;         &quot;&lt;/b&gt;&quot;))</span>
<span class="co">#&gt; }</span></code></pre>
<p>We need the weird <code>exprs(... = )</code> syntax to generate the empty <code>...</code> argument in the tag function. See Section <a href="#empty-symbol">18.6.2</a> for more details.</p>
<p>Now we can run our earlier example:</p>
<pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">tag</span>(<span class="st">&quot;p&quot;</span>)
b &lt;-<span class="st"> </span><span class="kw">tag</span>(<span class="st">&quot;b&quot;</span>)
i &lt;-<span class="st"> </span><span class="kw">tag</span>(<span class="st">&quot;i&quot;</span>)
<span class="kw">p</span>(<span class="st">&quot;Some text. &quot;</span>, <span class="kw">b</span>(<span class="kw">i</span>(<span class="st">&quot;some bold italic text&quot;</span>)), <span class="dt">class =</span> <span class="st">&quot;mypara&quot;</span>)
<span class="co">#&gt; &lt;HTML&gt; &lt;p class=&#39;mypara&#39;&gt;Some text. &lt;b&gt;&lt;/b&gt;&lt;/p&gt;</span></code></pre>
<p>Before we generate functions for every possible HTML tag, we need to create a variant that handles void tags. <code>void_tag()</code> is quite similar to <code>tag()</code>, but it throws an error if there are any unnamed tags, and the tag itself looks a little different.</p>
<pre class="sourceCode r"><code class="sourceCode r">void_tag &lt;-<span class="st"> </span><span class="cf">function</span>(tag) {
  <span class="kw">new_function</span>(
    <span class="kw">exprs</span>(<span class="dt">... =</span> ),
    <span class="kw">expr</span>({
      dots &lt;-<span class="st"> </span><span class="kw">dots_partition</span>(...)
      <span class="cf">if</span> (<span class="kw">length</span>(dots<span class="op">$</span>unnamed) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
        <span class="kw">abort</span>(<span class="op">!!</span><span class="kw">paste0</span>(<span class="st">&quot;&lt;&quot;</span>, tag, <span class="st">&quot;&gt; must not have unnamed arguments&quot;</span>))
      }
      attribs &lt;-<span class="st"> </span><span class="kw">html_attributes</span>(dots<span class="op">$</span>named)

      <span class="kw">html</span>(<span class="kw">paste0</span>(<span class="op">!!</span><span class="kw">paste0</span>(<span class="st">&quot;&lt;&quot;</span>, tag), attribs, <span class="st">&quot; /&gt;&quot;</span>))
    }),
    <span class="kw">caller_env</span>()
  )
}

img &lt;-<span class="st"> </span><span class="kw">void_tag</span>(<span class="st">&quot;img&quot;</span>)
img
<span class="co">#&gt; function (...) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     dots &lt;- dots_partition(...)</span>
<span class="co">#&gt;     if (length(dots$unnamed) &gt; 0) {</span>
<span class="co">#&gt;         abort(&quot;&lt;img&gt; must not have unnamed arguments&quot;)</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     attribs &lt;- html_attributes(dots$named)</span>
<span class="co">#&gt;     html(paste0(&quot;&lt;img&quot;, attribs, &quot; /&gt;&quot;))</span>
<span class="co">#&gt; }</span>
<span class="kw">img</span>(<span class="dt">src =</span> <span class="st">&quot;myimage.png&quot;</span>, <span class="dt">width =</span> <span class="dv">100</span>, <span class="dt">height =</span> <span class="dv">100</span>)
<span class="co">#&gt; &lt;HTML&gt; &lt;img src=&#39;myimage.png&#39; width=&#39;100&#39; height=&#39;100&#39; /&gt;</span></code></pre>
</div>
<div id="html-env" class="section level3">
<h3><span class="header-section-number">21.2.5</span> Processing all tags</h3>
<p>Next we need to generate these functions for every tag. We’ll start with a list of all HTML tags:</p>
<pre class="sourceCode r"><code class="sourceCode r">tags &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;abbr&quot;</span>, <span class="st">&quot;address&quot;</span>, <span class="st">&quot;article&quot;</span>, <span class="st">&quot;aside&quot;</span>, <span class="st">&quot;audio&quot;</span>,
  <span class="st">&quot;b&quot;</span>,<span class="st">&quot;bdi&quot;</span>, <span class="st">&quot;bdo&quot;</span>, <span class="st">&quot;blockquote&quot;</span>, <span class="st">&quot;body&quot;</span>, <span class="st">&quot;button&quot;</span>, <span class="st">&quot;canvas&quot;</span>,
  <span class="st">&quot;caption&quot;</span>,<span class="st">&quot;cite&quot;</span>, <span class="st">&quot;code&quot;</span>, <span class="st">&quot;colgroup&quot;</span>, <span class="st">&quot;data&quot;</span>, <span class="st">&quot;datalist&quot;</span>,
  <span class="st">&quot;dd&quot;</span>, <span class="st">&quot;del&quot;</span>,<span class="st">&quot;details&quot;</span>, <span class="st">&quot;dfn&quot;</span>, <span class="st">&quot;div&quot;</span>, <span class="st">&quot;dl&quot;</span>, <span class="st">&quot;dt&quot;</span>, <span class="st">&quot;em&quot;</span>,
  <span class="st">&quot;eventsource&quot;</span>,<span class="st">&quot;fieldset&quot;</span>, <span class="st">&quot;figcaption&quot;</span>, <span class="st">&quot;figure&quot;</span>, <span class="st">&quot;footer&quot;</span>,
  <span class="st">&quot;form&quot;</span>, <span class="st">&quot;h1&quot;</span>, <span class="st">&quot;h2&quot;</span>, <span class="st">&quot;h3&quot;</span>, <span class="st">&quot;h4&quot;</span>, <span class="st">&quot;h5&quot;</span>, <span class="st">&quot;h6&quot;</span>, <span class="st">&quot;head&quot;</span>, <span class="st">&quot;header&quot;</span>,
  <span class="st">&quot;hgroup&quot;</span>, <span class="st">&quot;html&quot;</span>, <span class="st">&quot;i&quot;</span>,<span class="st">&quot;iframe&quot;</span>, <span class="st">&quot;ins&quot;</span>, <span class="st">&quot;kbd&quot;</span>, <span class="st">&quot;label&quot;</span>,
  <span class="st">&quot;legend&quot;</span>, <span class="st">&quot;li&quot;</span>, <span class="st">&quot;mark&quot;</span>, <span class="st">&quot;map&quot;</span>,<span class="st">&quot;menu&quot;</span>, <span class="st">&quot;meter&quot;</span>, <span class="st">&quot;nav&quot;</span>,
  <span class="st">&quot;noscript&quot;</span>, <span class="st">&quot;object&quot;</span>, <span class="st">&quot;ol&quot;</span>, <span class="st">&quot;optgroup&quot;</span>, <span class="st">&quot;option&quot;</span>, <span class="st">&quot;output&quot;</span>,
  <span class="st">&quot;p&quot;</span>, <span class="st">&quot;pre&quot;</span>, <span class="st">&quot;progress&quot;</span>, <span class="st">&quot;q&quot;</span>, <span class="st">&quot;ruby&quot;</span>, <span class="st">&quot;rp&quot;</span>,<span class="st">&quot;rt&quot;</span>, <span class="st">&quot;s&quot;</span>, <span class="st">&quot;samp&quot;</span>,
  <span class="st">&quot;script&quot;</span>, <span class="st">&quot;section&quot;</span>, <span class="st">&quot;select&quot;</span>, <span class="st">&quot;small&quot;</span>, <span class="st">&quot;span&quot;</span>, <span class="st">&quot;strong&quot;</span>,
  <span class="st">&quot;style&quot;</span>, <span class="st">&quot;sub&quot;</span>, <span class="st">&quot;summary&quot;</span>, <span class="st">&quot;sup&quot;</span>, <span class="st">&quot;table&quot;</span>, <span class="st">&quot;tbody&quot;</span>, <span class="st">&quot;td&quot;</span>,
  <span class="st">&quot;textarea&quot;</span>, <span class="st">&quot;tfoot&quot;</span>, <span class="st">&quot;th&quot;</span>, <span class="st">&quot;thead&quot;</span>, <span class="st">&quot;time&quot;</span>, <span class="st">&quot;title&quot;</span>, <span class="st">&quot;tr&quot;</span>,
  <span class="st">&quot;u&quot;</span>, <span class="st">&quot;ul&quot;</span>, <span class="st">&quot;var&quot;</span>, <span class="st">&quot;video&quot;</span>
)

void_tags &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;area&quot;</span>, <span class="st">&quot;base&quot;</span>, <span class="st">&quot;br&quot;</span>, <span class="st">&quot;col&quot;</span>, <span class="st">&quot;command&quot;</span>, <span class="st">&quot;embed&quot;</span>,
  <span class="st">&quot;hr&quot;</span>, <span class="st">&quot;img&quot;</span>, <span class="st">&quot;input&quot;</span>, <span class="st">&quot;keygen&quot;</span>, <span class="st">&quot;link&quot;</span>, <span class="st">&quot;meta&quot;</span>, <span class="st">&quot;param&quot;</span>,
  <span class="st">&quot;source&quot;</span>, <span class="st">&quot;track&quot;</span>, <span class="st">&quot;wbr&quot;</span>
)</code></pre>
<p>If you look at this list carefully, you’ll see there are quite a few tags that have the same name as base R functions (<code>body</code>, <code>col</code>, <code>q</code>, <code>source</code>, <code>sub</code>, <code>summary</code>, <code>table</code>). This means we don’t want to make all the functions available by default, either in the global environment or in a package. Instead, we’ll put them in a list (like in Section <a href="#functional-factories">10.5</a>) and then provide a helper to make it easy to use them when desired. First, we make a named list containing all the tag functions:</p>
<pre class="sourceCode r"><code class="sourceCode r">html_tags &lt;-<span class="st"> </span><span class="kw">c</span>(
  tags <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">set_names</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map</span>(tag),
  void_tags <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">set_names</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map</span>(void_tag)
)</code></pre>
<p>This gives us an explicit (but verbose) way to create HTML:</p>
<pre class="sourceCode r"><code class="sourceCode r">html_tags<span class="op">$</span><span class="kw">p</span>(
  <span class="st">&quot;Some text. &quot;</span>,
  html_tags<span class="op">$</span><span class="kw">b</span>(html_tags<span class="op">$</span><span class="kw">i</span>(<span class="st">&quot;some bold italic text&quot;</span>)),
  <span class="dt">class =</span> <span class="st">&quot;mypara&quot;</span>
)
<span class="co">#&gt; &lt;HTML&gt; &lt;p class=&#39;mypara&#39;&gt;Some text. &lt;b&gt;&lt;/b&gt;&lt;/p&gt;</span></code></pre>
<p>We can then finish off our HTML DSL with a function that allows us to evaluate code in the context of that list. Here we slightly abuse the data mask, passing it a list of functions rather than a data frame. This is quick hack to mingle the execution environment of <code>code</code> with the functions in <code>html_tags</code>.</p>

<pre class="sourceCode r"><code class="sourceCode r">with_html &lt;-<span class="st"> </span><span class="cf">function</span>(code) {
  code &lt;-<span class="st"> </span><span class="kw">enquo</span>(code)
  <span class="kw">eval_tidy</span>(code, html_tags)
}</code></pre>
<p>This gives us a succinct API which allows us to write HTML when we need it but doesn’t clutter up the namespace when we don’t.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">with_html</span>(
  <span class="kw">body</span>(
    <span class="kw">h1</span>(<span class="st">&quot;A heading&quot;</span>, <span class="dt">id =</span> <span class="st">&quot;first&quot;</span>),
    <span class="kw">p</span>(<span class="st">&quot;Some text &amp;&quot;</span>, <span class="kw">b</span>(<span class="st">&quot;some bold text.&quot;</span>)),
    <span class="kw">img</span>(<span class="dt">src =</span> <span class="st">&quot;myimg.png&quot;</span>, <span class="dt">width =</span> <span class="dv">100</span>, <span class="dt">height =</span> <span class="dv">100</span>)
  )
)
<span class="co">#&gt; &lt;HTML&gt; &lt;body&gt;&lt;/body&gt;</span></code></pre>
<p>If you want to access the R function overridden by an HTML tag with the same name inside <code>with_html()</code>, you can use the full <code>package::function</code> specification.</p>
</div>
<div id="exercises-66" class="section level3">
<h3><span class="header-section-number">21.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>The escaping rules for <code>&lt;script&gt;</code> tags are different because they contain
JavaScript, not HTML. Instead of escaping angle brackets or ampersands,
you need to escape <code>&lt;/script&gt;</code> so that the tag isn’t closed too early.
For example, <code>script(&quot;'&lt;/script&gt;'&quot;)</code>, shouldn’t generate this:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span><span class="st">&#39;&lt;/script&gt;&#39;</span><span class="kw">&lt;/script&gt;</span></code></pre>
<p>But</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script&gt;</span><span class="st">&#39;&lt;\/script&gt;&#39;</span><span class="kw">&lt;/script&gt;</span></code></pre>
<p>Adapt the <code>escape()</code> to follow these rules when a new argument <code>script</code>
is set to <code>TRUE</code>.</p></li>
<li><p>The use of <code>...</code> for all functions has some big downsides. There’s no
input validation and there will be little information in the
documentation or autocomplete about how they are used in the function.
Create a new function that, when given a named list of tags and their
attribute names (like below), creates tag functions with named arguments.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">list</span>(
  <span class="dt">a =</span> <span class="kw">c</span>(<span class="st">&quot;href&quot;</span>),
  <span class="dt">img =</span> <span class="kw">c</span>(<span class="st">&quot;src&quot;</span>, <span class="st">&quot;width&quot;</span>, <span class="st">&quot;height&quot;</span>)
)</code></pre>
<p>All tags should get <code>class</code> and <code>id</code> attributes.</p></li>
<li><p>Reason about the following code that calls <code>with_html()</code> referencing objects
from the environment. Will it work or fail? Why? Run the code to
verify your predictions.</p>
<pre class="sourceCode r"><code class="sourceCode r">greeting &lt;-<span class="st"> &quot;Hello!&quot;</span>
<span class="kw">with_html</span>(<span class="kw">p</span>(greeting))

p &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="st">&quot;p&quot;</span>
address &lt;-<span class="st"> &quot;123 anywhere street&quot;</span>
<span class="kw">with_html</span>(<span class="kw">p</span>(address))</code></pre></li>
<li><p>Currently the HTML doesn’t look terribly pretty, and it’s hard to see the
structure. How could you adapt <code>tag()</code> to do indenting and formatting?
(You may need to do some research into block vs inline tags.)</p></li>
</ol>
</div>
</div>
<div id="latex" class="section level2">
<h2><span class="header-section-number">21.3</span> LaTeX</h2>
<p></p>
<p>The next DSL will convert R expressions into their LaTeX math equivalents. (This is a bit like <code>?plotmath</code>, but for text instead of plots.) LaTeX is the lingua franca of mathematicians and statisticians: it’s common to use LaTeX notation whenever you want to express an equation in text, like in email. Since many reports are produced using both R and LaTeX, it might be useful to be able to automatically convert mathematical expressions from one language to the other.</p>
<p>Because we need to convert both functions and names, this mathematical DSL will be more complicated than the HTML DSL. We’ll also need to create a “default” conversion, so that symbols that we don’t know about get a standard conversion. This means that we can no longer use just evaluation: we also need to walk the abstract syntax tree (AST).</p>
<div id="latex-mathematics" class="section level3">
<h3><span class="header-section-number">21.3.1</span> LaTeX mathematics</h3>
<p>Before we begin, let’s quickly cover how formulas are expressed in LaTeX. The full standard is very complex, but fortunately is well documented<span id="fn161" class="footnote" data-pagedown-footnote-number="161" style="white-space: pre-line;"><a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics" class="uri">http://en.wikibooks.org/wiki/LaTeX/Mathematics</a></span>, and the most common commands have a fairly simple structure:</p>
<ul>
<li><p>Most simple mathematical equations are written in the same way you’d type
them in R: <code>x * y</code>, <code>z ^ 5</code>. Subscripts are written using <code>_</code> (e.g., <code>x_1</code>).</p></li>
<li><p>Special characters start with a <code>\</code>: <code>\pi</code> = π, <code>\pm</code> = ±, and so on.
There are a huge number of symbols available in LaTeX: searching online for
<code>latex math symbols</code> returns many
lists<span id="fn162" class="footnote" data-pagedown-footnote-number="162" style="white-space: pre-line;"><a href="http://www.sunilpatel.co.uk/latex-type/latex-math-symbols/" class="uri">http://www.sunilpatel.co.uk/latex-type/latex-math-symbols/</a></span>.
There’s even a service<span id="fn163" class="footnote" data-pagedown-footnote-number="163" style="white-space: pre-line;"><a href="http://detexify.kirelabs.org/classify.html" class="uri">http://detexify.kirelabs.org/classify.html</a></span> that
will look up the symbol you sketch in the browser.</p></li>
<li><p>More complicated functions look like <code>\name{arg1}{arg2}</code>. For example, to
write a fraction you’d use <code>\frac{a}{b}</code>. To write a square root, you’d use
<code>\sqrt{a}</code>.</p></li>
<li><p>To group elements together use <code>{}</code>: i.e., <code>x ^ a + b</code> vs. <code>x ^ {a + b}</code>.</p></li>
<li><p>In good math typesetting, a distinction is made between variables and
functions. But without extra information, LaTeX doesn’t know whether
<code>f(a * b)</code> represents calling the function <code>f</code> with input <code>a * b</code>,
or is shorthand for <code>f * (a * b)</code>. If <code>f</code> is a function, you can tell
LaTeX to typeset it using an upright font with <code>\textrm{f}(a * b)</code>.
(The <code>rm</code> stands for “Roman”, the opposite of italics.)</p></li>
</ul>
</div>
<div id="goal-1" class="section level3">
<h3><span class="header-section-number">21.3.2</span> Goal</h3>
<p>Our goal is to use these rules to automatically convert an R expression to its appropriate LaTeX representation. We’ll tackle this in four stages:</p>
<ul>
<li><p>Convert known symbols: <code>pi</code> → <code>\pi</code></p></li>
<li><p>Leave other symbols unchanged: <code>x</code> → <code>x</code>, <code>y</code> → <code>y</code></p></li>
<li><p>Convert known functions to their special forms: <code>sqrt(frac(a, b))</code> →
<code>\sqrt{\frac{a, b}}</code></p></li>
<li><p>Wrap unknown functions with <code>\textrm</code>: <code>f(a)</code> → <code>\textrm{f}(a)</code></p></li>
</ul>
<p>We’ll code this translation in the opposite direction of what we did with the HTML DSL. We’ll start with infrastructure, because that makes it easy to experiment with our DSL, and then work our way back down to generate the desired output.</p>
</div>
<div id="to_math" class="section level3">
<h3><span class="header-section-number">21.3.3</span> <code>to_math</code>()</h3>
<p>To begin, we need a wrapper function that will convert R expressions into LaTeX math expressions. This will work like <code>to_html()</code> by capturing the unevaluated expression and evaluating it in a special environment. There are two main differences:</p>
<ul>
<li><p>The evaluation environment is no longer constant, as it has to vary depending on
the input. This is necessary to handle unknown symbols and functions.</p></li>
<li><p>We never evaluate in the argument environment because we’re translating every
function to a LaTeX expression. The user will need to use explicitly <code>!!</code> in
order to evaluate normally.</p></li>
</ul>
<p>This gives us:</p>
<pre class="sourceCode r"><code class="sourceCode r">to_math &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  expr &lt;-<span class="st"> </span><span class="kw">enexpr</span>(x)
  out &lt;-<span class="st"> </span><span class="kw">eval_bare</span>(expr, <span class="kw">latex_env</span>(expr))

  <span class="kw">latex</span>(out)
}

latex &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">structure</span>(x, <span class="dt">class =</span> <span class="st">&quot;advr_latex&quot;</span>)
print.advr_latex &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">cat</span>(<span class="st">&quot;&lt;LATEX&gt; &quot;</span>, x, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
}</code></pre>
<p>Next we’ll build up <code>latex_env()</code>, starting simply and getting progressively more complex.</p>
</div>
<div id="known-symbols" class="section level3">
<h3><span class="header-section-number">21.3.4</span> Known symbols</h3>
<p>Our first step is to create an environment that will convert the special LaTeX symbols used for Greek character, e.g., <code>pi</code> to <code>\pi</code>. We’ll use the trick from Section <a href="#subset">20.4.3</a> to bind the symbol <code>pi</code> to the value <code>&quot;\pi&quot;</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">greek &lt;-<span class="st"> </span><span class="kw">c</span>(
  <span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;theta&quot;</span>, <span class="st">&quot;tau&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;vartheta&quot;</span>, <span class="st">&quot;pi&quot;</span>, <span class="st">&quot;upsilon&quot;</span>,
  <span class="st">&quot;gamma&quot;</span>, <span class="st">&quot;varpi&quot;</span>, <span class="st">&quot;phi&quot;</span>, <span class="st">&quot;delta&quot;</span>, <span class="st">&quot;kappa&quot;</span>, <span class="st">&quot;rho&quot;</span>,
  <span class="st">&quot;varphi&quot;</span>, <span class="st">&quot;epsilon&quot;</span>, <span class="st">&quot;lambda&quot;</span>, <span class="st">&quot;varrho&quot;</span>, <span class="st">&quot;chi&quot;</span>, <span class="st">&quot;varepsilon&quot;</span>,
  <span class="st">&quot;mu&quot;</span>, <span class="st">&quot;sigma&quot;</span>, <span class="st">&quot;psi&quot;</span>, <span class="st">&quot;zeta&quot;</span>, <span class="st">&quot;nu&quot;</span>, <span class="st">&quot;varsigma&quot;</span>, <span class="st">&quot;omega&quot;</span>, <span class="st">&quot;eta&quot;</span>,
  <span class="st">&quot;xi&quot;</span>, <span class="st">&quot;Gamma&quot;</span>, <span class="st">&quot;Lambda&quot;</span>, <span class="st">&quot;Sigma&quot;</span>, <span class="st">&quot;Psi&quot;</span>, <span class="st">&quot;Delta&quot;</span>, <span class="st">&quot;Xi&quot;</span>,
  <span class="st">&quot;Upsilon&quot;</span>, <span class="st">&quot;Omega&quot;</span>, <span class="st">&quot;Theta&quot;</span>, <span class="st">&quot;Pi&quot;</span>, <span class="st">&quot;Phi&quot;</span>
)
greek_list &lt;-<span class="st"> </span><span class="kw">set_names</span>(<span class="kw">paste0</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">&quot;</span>, greek), greek)
greek_env &lt;-<span class="st"> </span><span class="kw">as_environment</span>(greek_list)</code></pre>
<p>We can then check it:</p>
<pre class="sourceCode r"><code class="sourceCode r">latex_env &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  greek_env
}

<span class="kw">to_math</span>(pi)
<span class="co">#&gt; &lt;LATEX&gt; \pi</span>
<span class="kw">to_math</span>(beta)
<span class="co">#&gt; &lt;LATEX&gt; \beta</span></code></pre>
<p>Looks good so far!</p>
</div>
<div id="unknown-symbols" class="section level3">
<h3><span class="header-section-number">21.3.5</span> Unknown symbols</h3>
<p>If a symbol isn’t Greek, we want to leave it as is. This is tricky because we don’t know in advance what symbols will be used, and we can’t possibly generate them all. Instead, we’ll use the approach described in Section <a href="#ast-funs">18.5</a>: walking the AST and to find all symbols. This gives us <code>all_names_rec()</code> and helper <code>all_names()</code>:</p>
<!-- GVW: on first reading I wondered why you bothered to define `switch_expr`, since it only appears to be used once.  Then I saw that there's a second call much further down. Highlight this somehow? -->
<pre class="sourceCode r"><code class="sourceCode r">all_names_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="dt">constant =</span> <span class="kw">character</span>(),
    <span class="dt">symbol =</span>   <span class="kw">as.character</span>(x),
    <span class="dt">call =</span>     <span class="kw">flat_map_chr</span>(<span class="kw">as.list</span>(x[<span class="op">-</span><span class="dv">1</span>]), all_names)
  )
}

all_names &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">unique</span>(<span class="kw">all_names_rec</span>(x))
}

<span class="kw">all_names</span>(<span class="kw">expr</span>(x <span class="op">+</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span><span class="kw">f</span>(a, b, c, <span class="dv">10</span>)))
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></code></pre>
<p>We now want to take that list of symbols and convert it to an environment so that each symbol is mapped to its corresponding string representation (e.g., so <code>eval(quote(x), env)</code> yields <code>&quot;x&quot;</code>). We again use the pattern of converting a named character vector to a list, then converting the list to an environment.</p>
<pre class="sourceCode r"><code class="sourceCode r">latex_env &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  names &lt;-<span class="st"> </span><span class="kw">all_names</span>(expr)
  symbol_env &lt;-<span class="st"> </span><span class="kw">as_environment</span>(<span class="kw">set_names</span>(names))

  symbol_env
}

<span class="kw">to_math</span>(x)
<span class="co">#&gt; &lt;LATEX&gt; x</span>
<span class="kw">to_math</span>(longvariablename)
<span class="co">#&gt; &lt;LATEX&gt; longvariablename</span>
<span class="kw">to_math</span>(pi)
<span class="co">#&gt; &lt;LATEX&gt; pi</span></code></pre>
<p>This works, but we need to combine it with the Greek symbols environment. Since we want to give preference to Greek over defaults (e.g., <code>to_math(pi)</code> should give <code>&quot;\\pi&quot;</code>, not <code>&quot;pi&quot;</code>), <code>symbol_env</code> needs to be the parent of <code>greek_env</code>. To do that, we need to make a copy of <code>greek_env</code> with a new parent. This gives us a function that can convert both known (Greek) and unknown symbols.</p>
<pre class="sourceCode r"><code class="sourceCode r">latex_env &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="co"># Unknown symbols</span>
  names &lt;-<span class="st"> </span><span class="kw">all_names</span>(expr)
  symbol_env &lt;-<span class="st"> </span><span class="kw">as_environment</span>(<span class="kw">set_names</span>(names))

  <span class="co"># Known symbols</span>
  <span class="kw">env_clone</span>(greek_env, <span class="dt">parent =</span> symbol_env)
}

<span class="kw">to_math</span>(x)
<span class="co">#&gt; &lt;LATEX&gt; x</span>
<span class="kw">to_math</span>(longvariablename)
<span class="co">#&gt; &lt;LATEX&gt; longvariablename</span>
<span class="kw">to_math</span>(pi)
<span class="co">#&gt; &lt;LATEX&gt; \pi</span></code></pre>
</div>
<div id="known-functions" class="section level3">
<h3><span class="header-section-number">21.3.6</span> Known functions</h3>
<p>Next we’ll add functions to our DSL. We’ll start with a couple of helpers that make it easy to add new unary and binary operators. These functions are very simple: they only assemble strings.</p>
<pre class="sourceCode r"><code class="sourceCode r">unary_op &lt;-<span class="st"> </span><span class="cf">function</span>(left, right) {
  <span class="kw">new_function</span>(
    <span class="kw">exprs</span>(<span class="dt">e1 =</span> ),
    <span class="kw">expr</span>(
      <span class="kw">paste0</span>(<span class="op">!!</span>left, e1, <span class="op">!!</span>right)
    ),
    <span class="kw">caller_env</span>()
  )
}

binary_op &lt;-<span class="st"> </span><span class="cf">function</span>(sep) {
  <span class="kw">new_function</span>(
    <span class="kw">exprs</span>(<span class="dt">e1 =</span> , <span class="dt">e2 =</span> ),
    <span class="kw">expr</span>(
      <span class="kw">paste0</span>(e1, <span class="op">!!</span>sep, e2)
    ),
    <span class="kw">caller_env</span>()
  )
}

<span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">sqrt{&quot;</span>, <span class="st">&quot;}&quot;</span>)
<span class="co">#&gt; function (e1) </span>
<span class="co">#&gt; paste0(&quot;\\sqrt{&quot;, e1, &quot;}&quot;)</span>
<span class="kw">binary_op</span>(<span class="st">&quot;+&quot;</span>)
<span class="co">#&gt; function (e1, e2) </span>
<span class="co">#&gt; paste0(e1, &quot;+&quot;, e2)</span></code></pre>
<p>Using these helpers, we can map a few illustrative examples of converting R to LaTeX. Note that with R’s lexical scoping rules helping us, we can easily provide new meanings for standard functions like <code>+</code>, <code>-</code>, and <code>*</code>, and even <code>(</code> and <code>{</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Binary operators</span>
f_env &lt;-<span class="st"> </span><span class="kw">child_env</span>(
  <span class="dt">.parent =</span> <span class="kw">empty_env</span>(),
  <span class="st">`</span><span class="dt">+</span><span class="st">`</span> =<span class="st"> </span><span class="kw">binary_op</span>(<span class="st">&quot; + &quot;</span>),
  <span class="st">`</span><span class="dt">-</span><span class="st">`</span> =<span class="st"> </span><span class="kw">binary_op</span>(<span class="st">&quot; - &quot;</span>),
  <span class="st">`</span><span class="dt">*</span><span class="st">`</span> =<span class="st"> </span><span class="kw">binary_op</span>(<span class="st">&quot; * &quot;</span>),
  <span class="st">`</span><span class="dt">/</span><span class="st">`</span> =<span class="st"> </span><span class="kw">binary_op</span>(<span class="st">&quot; / &quot;</span>),
  <span class="st">`</span><span class="dt">^</span><span class="st">`</span> =<span class="st"> </span><span class="kw">binary_op</span>(<span class="st">&quot;^&quot;</span>),
  <span class="st">`</span><span class="dt">[</span><span class="st">`</span> =<span class="st"> </span><span class="kw">binary_op</span>(<span class="st">&quot;_&quot;</span>),

  <span class="co"># Grouping</span>
  <span class="st">`</span><span class="dt">{</span><span class="st">`</span> =<span class="st"> </span><span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">left{ &quot;</span>, <span class="st">&quot; </span><span class="ch">\\</span><span class="st">right}&quot;</span>),
  <span class="st">`</span><span class="dt">(</span><span class="st">`</span> =<span class="st"> </span><span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">left( &quot;</span>, <span class="st">&quot; </span><span class="ch">\\</span><span class="st">right)&quot;</span>),
  <span class="dt">paste =</span> paste,

  <span class="co"># Other math functions</span>
  <span class="dt">sqrt =</span> <span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">sqrt{&quot;</span>, <span class="st">&quot;}&quot;</span>),
  <span class="dt">sin =</span>  <span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">sin(&quot;</span>, <span class="st">&quot;)&quot;</span>),
  <span class="dt">log =</span>  <span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">log(&quot;</span>, <span class="st">&quot;)&quot;</span>),
  <span class="dt">abs =</span>  <span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">left| &quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">right| &quot;</span>),
  <span class="dt">frac =</span> <span class="cf">function</span>(a, b) {
    <span class="kw">paste0</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">frac{&quot;</span>, a, <span class="st">&quot;}{&quot;</span>, b, <span class="st">&quot;}&quot;</span>)
  },

  <span class="co"># Labelling</span>
  <span class="dt">hat =</span>   <span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">hat{&quot;</span>, <span class="st">&quot;}&quot;</span>),
  <span class="dt">tilde =</span> <span class="kw">unary_op</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">tilde{&quot;</span>, <span class="st">&quot;}&quot;</span>)
)</code></pre>
<p>We again modify <code>latex_env()</code> to include this environment. It should be the last environment R looks for names in so that expressions like <code>sin(sin)</code> will work.</p>
<pre class="sourceCode r"><code class="sourceCode r">latex_env &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  <span class="co"># Known functions</span>
  f_env

  <span class="co"># Default symbols</span>
  names &lt;-<span class="st"> </span><span class="kw">all_names</span>(expr)
  symbol_env &lt;-<span class="st"> </span><span class="kw">as_environment</span>(<span class="kw">set_names</span>(names), <span class="dt">parent =</span> f_env)

  <span class="co"># Known symbols</span>
  greek_env &lt;-<span class="st"> </span><span class="kw">env_clone</span>(greek_env, <span class="dt">parent =</span> symbol_env)

  greek_env
}

<span class="kw">to_math</span>(<span class="kw">sin</span>(x <span class="op">+</span><span class="st"> </span>pi))
<span class="co">#&gt; &lt;LATEX&gt; \sin(x + \pi)</span>
<span class="kw">to_math</span>(<span class="kw">log</span>(x[i]<span class="op">^</span><span class="dv">2</span>))
<span class="co">#&gt; &lt;LATEX&gt; \log(x_i^2)</span>
<span class="kw">to_math</span>(<span class="kw">sin</span>(sin))
<span class="co">#&gt; &lt;LATEX&gt; \sin(sin)</span></code></pre>
</div>
<div id="unknown-functions" class="section level3">
<h3><span class="header-section-number">21.3.7</span> Unknown functions</h3>
<p>Finally, we’ll add a default for functions that we don’t yet know about. Like the unknown names, we can’t know in advance what these will be, so we again walk the AST to find them:</p>
<pre class="sourceCode r"><code class="sourceCode r">all_calls_rec &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">switch_expr</span>(x,
    <span class="dt">constant =</span> ,
    <span class="dt">symbol =</span>   <span class="kw">character</span>(),
    <span class="dt">call =</span> {
      fname &lt;-<span class="st"> </span><span class="kw">as.character</span>(x[[<span class="dv">1</span>]])
      children &lt;-<span class="st"> </span><span class="kw">flat_map_chr</span>(<span class="kw">as.list</span>(x[<span class="op">-</span><span class="dv">1</span>]), all_calls)
      <span class="kw">c</span>(fname, children)
    }
  )
}
all_calls &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="kw">unique</span>(<span class="kw">all_calls_rec</span>(x))
}

<span class="kw">all_calls</span>(<span class="kw">expr</span>(<span class="kw">f</span>(g <span class="op">+</span><span class="st"> </span>b, c, <span class="kw">d</span>(a))))
<span class="co">#&gt; [1] &quot;f&quot; &quot;+&quot; &quot;d&quot;</span></code></pre>
<p>We need a closure that will generate the functions for each unknown call:</p>
<pre class="sourceCode r"><code class="sourceCode r">unknown_op &lt;-<span class="st"> </span><span class="cf">function</span>(op) {
  <span class="kw">new_function</span>(
    <span class="kw">exprs</span>(<span class="dt">... =</span> ),
    <span class="kw">expr</span>({
      contents &lt;-<span class="st"> </span><span class="kw">paste</span>(..., <span class="dt">collapse =</span> <span class="st">&quot;, &quot;</span>)
      <span class="kw">paste0</span>(<span class="op">!!</span><span class="kw">paste0</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">mathrm{&quot;</span>, op, <span class="st">&quot;}(&quot;</span>), contents, <span class="st">&quot;)&quot;</span>)
    })
  )
}
<span class="kw">unknown_op</span>(<span class="st">&quot;foo&quot;</span>)
<span class="co">#&gt; function (...) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     contents &lt;- paste(..., collapse = &quot;, &quot;)</span>
<span class="co">#&gt;     paste0(&quot;\\mathrm{foo}(&quot;, contents, &quot;)&quot;)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: 0x48bd6b8&gt;</span></code></pre>
<p>And again we update <code>latex_env()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">latex_env &lt;-<span class="st"> </span><span class="cf">function</span>(expr) {
  calls &lt;-<span class="st"> </span><span class="kw">all_calls</span>(expr)
  call_list &lt;-<span class="st"> </span><span class="kw">map</span>(<span class="kw">set_names</span>(calls), unknown_op)
  call_env &lt;-<span class="st"> </span><span class="kw">as_environment</span>(call_list)

  <span class="co"># Known functions</span>
  f_env &lt;-<span class="st"> </span><span class="kw">env_clone</span>(f_env, call_env)

  <span class="co"># Default symbols</span>
  names &lt;-<span class="st"> </span><span class="kw">all_names</span>(expr)
  symbol_env &lt;-<span class="st"> </span><span class="kw">as_environment</span>(<span class="kw">set_names</span>(names), <span class="dt">parent =</span> f_env)

  <span class="co"># Known symbols</span>
  greek_env &lt;-<span class="st"> </span><span class="kw">env_clone</span>(greek_env, <span class="dt">parent =</span> symbol_env)
  greek_env
}</code></pre>
<p>This completes our original requirements:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">to_math</span>(<span class="kw">sin</span>(pi) <span class="op">+</span><span class="st"> </span><span class="kw">f</span>(a))
<span class="co">#&gt; &lt;LATEX&gt; \sin(\pi) + \mathrm{f}(a)</span></code></pre>
<p>You could certainly take this idea further and translate types of mathematical expression, but you should not need any additional metaprogramming tools.</p>
</div>
<div id="exercises-67" class="section level3">
<h3><span class="header-section-number">21.3.8</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Add escaping. The special symbols that should be escaped by adding a backslash
in front of them are <code>\</code>, <code>$</code>, and <code>%</code>. Just as with HTML, you’ll need to
make sure you don’t end up double-escaping. So you’ll need to create a small
S3 class and then use that in function operators. That will also allow you
to embed arbitrary LaTeX if needed.</p></li>
<li><p>Complete the DSL to support all the functions that <code>plotmath</code> supports.</p></li>
</ol>
<!--chapter:end:Translation.Rmd-->
</div>
</div>
</div>
<div id="part-techniques" class="section level1 unnumbered">
<h1><span class="header-section-number">V</span> Techniques</h1>
</div>
<div id="introduction-22" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>The final four chapters cover two general programming techniques: finding and fixing bugs, and finding and fixing performance issues.</p>
<p>In Chapter <a href="#debugging">22</a>, we’ll first talking debugging, because finding the root cause of error can be extremely frustrating. Fortunately R has some great tools for debugging, and when they’re coupled with a solid strategy, you should be able to find the root cause for most problems rapidly and relatively painlessly.</p>
<p>The remaining three chapters focus on performance, first measuring it (Chapter <a href="#perf-measure">23</a>) and then improving it (Chapters <a href="#perf-improve">24</a> and <a href="#rcpp">25</a>). Tools to measuring and improve performance are particularly important because R is not a fast language. This is not an accident: R was purposely designed to make interactive data analysis easier for humans, not to make computers as fast as possible. While R is slow compared to other programming languages, for most purposes, it’s fast enough. These chapters help you handle the cases where is no longer fast enough, either by improving the performance of your R code, or by switching to a language, C++, that is designed for performance.</p>
<!--chapter:end:Techniques.Rmd-->
</div>
<div id="debugging" class="section level1">
<h1><span class="header-section-number">22</span> Debugging</h1>
<div id="introduction-23" class="section level2">
<h2><span class="header-section-number">22.1</span> Introduction</h2>
<p>

</p>
<p>What do you do when R code throws an unexpected error? What tools do you have to find and fix the problem? This chapter will teach you the art and science of debugging, starting with a general strategy, then following up with specific tools.</p>
<p>I’ll show the tools provided both by R itself, as well as the RStudio IDE. I recommend using RStudio’s tools if possible, but I’ll also show you the equivalents that work everywhere. You may also want to refer to the official RStudio debugging documentation<span id="fn164" class="footnote" data-pagedown-footnote-number="164" style="white-space: pre-line;"><a href="https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio" class="uri">https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio</a></span> which always reflects the latest version of RStudio.</p>
<p>NB: You shouldn’t need to use these tools when writing <em>new</em> functions. If you find yourself using them frequently with new code, reconsider your approach. Instead of trying to write one big function all at once, work interactively on small pieces. If you start small, you can quickly identify why something doesn’t work, and don’t need sophisticated debugging tools.</p>
<div id="outline-20" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#debugging-strategy">22.2</a> outlines a general strategy for
finding and fixing errors.</p></li>
<li><p>Section <a href="#traceback">22.3</a> introduces you to the <code>traceback()</code> function
which helps you locate exactly where an error occurred.</p></li>
<li><p>Section <a href="#browser">22.4</a> shows you how to pause the execution of a function
and launch environment where you can interactively explore what’s happening.</p></li>
<li><p>Section <a href="#non-interactive-debugging">22.5</a> discusses the challenging problem
of debugging when you’re running code non-interactively.</p></li>
<li><p>Section <a href="#non-error-failures">22.6</a> discusses a handful of non-error problems
that occassionally also need debugging.</p></li>
</ul>
</div>
</div>
<div id="debugging-strategy" class="section level2">
<h2><span class="header-section-number">22.2</span> Overall approach</h2>
<blockquote>
<p>“Finding your bug is a process of confirming the many things
that you believe are true — until you find one which is not
true.”</p>
<p>—Norm Matloff</p>
</blockquote>
<p>Finding the root cause of a problem is always challenging. Most bugs are subtle and hard to find because if they were obvious, you would’ve avoided them in the first place. A good strategy helps. Below I outline a four step process that I have found useful:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Google!</strong></p>
<p>Whenever you see an error message, start by googling it. If you’re lucky,
you’ll discover that it’s a common error with a known solution. When
googling, improve your chances of a good match by removing any variable
names or values that are specific to your problem.</p>
<p>You can automate this process with the errorist <span class="citation">(Balamuta <a href="#ref-errorist">2018</a><a href="#ref-errorist">a</a>)</span> and searcher
<span class="citation">(Balamuta <a href="#ref-searcher">2018</a><a href="#ref-searcher">b</a>)</span> packages. See their websites for more details.</p></li>
<li><p><strong>Make it repeatable</strong></p>
<p>To find the root cause of an error, you’re going to need to execute the
code many times as you consider and reject hypotheses. To make that
iteration as quick possible, it’s worth some upfront investment to make
the problem both easy and fast to reproduce.</p>
<p>Start by creating a reproducible example (Section <a href="#getting-help">1.7</a>).
Next, make the example minimal by removing code and simplifying data.
As you do this, you may discover inputs that don’t trigger the error.
Make note of them: they will be helpful when diagnosing the root cause.</p>
<p>If you’re using automated testing, this is also a good time to create an
automated test case. If your existing test coverage is low, take the
opportunity to add some nearby tests to ensure that existing good behaviour
is preserved. This reduces the chances of creating a new bug.</p></li>
<li><p><strong>Figure out where it is</strong></p>
<p>If you’re lucky, one of the tools in the following section will help you to
quickly identify the line of code that’s causing the bug. Usually, however,
you’ll have to think a bit more about the problem. It’s a great idea to
adopt the scientific method. Generate hypotheses, design experiments to test
them, and record your results. This may seem like a lot of work, but a
systematic approach will end up saving you time. I often waste a lot of time
relying on my intuition to solve a bug (“oh, it must be an off-by-one error,
so I’ll just subtract 1 here”), when I would have been better off taking a
systematic approach.</p>
<p>If this fails, you might need to ask help from someone else. If you’ve
followed the previous step, you’ll have a small example that’s easy to
share with others. That makes it much easier for other people to look at
the problem, and more likely to help you find a solution.</p></li>
<li><p><strong>Fix it and test it</strong></p>
<p>Once you’ve found the bug, you need to figure out how to fix it and to check
that the fix actually worked. Again, it’s very useful to have automated
tests in place. Not only does this help to ensure that you’ve actually fixed
the bug, it also helps to ensure you haven’t introduced any new bugs in the
process. In the absence of automated tests, make sure to carefully record
the correct output, and check against the inputs that previously failed.</p></li>
</ol>
</div>
<div id="traceback" class="section level2">
<h2><span class="header-section-number">22.3</span> Locate the error</h2>
<p>
</p>
<p>Once you’ve made the error repeatable, the next step is to figure out where it comes from. The most important tool for this part of the process is <code>traceback()</code>, which shows you the sequence of calls (aka the call stack, Section <a href="#call-stack">7.5</a>) that lead to the error.</p>
<p>Here’s a simple example: you can see that <code>f()</code> calls <code>g()</code> calls <code>h()</code> calls <code>i()</code> that checks its argument is numeric:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(a) <span class="kw">g</span>(a)
g &lt;-<span class="st"> </span><span class="cf">function</span>(b) <span class="kw">h</span>(b)
h &lt;-<span class="st"> </span><span class="cf">function</span>(c) <span class="kw">i</span>(c)
i &lt;-<span class="st"> </span><span class="cf">function</span>(d) {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.numeric</span>(d)) {
    <span class="kw">stop</span>(<span class="st">&quot;`d` must be numeric&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
  d <span class="op">+</span><span class="st"> </span><span class="dv">10</span>
}</code></pre>
<p>When we run <code>f(&quot;a&quot;)</code> code in RStudio we see:</p>
<p><img src="screenshots/debugging/rstudio-error.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Two options appear to the right of the error message: “Show Traceback” and “Rerun with Debug”. If you click “Show traceback” you see:</p>
<p><img src="screenshots/debugging/rstudio-traceback.png" width="100%" style="display: block; margin: auto;" /></p>
<p>If you’re not using RStudio, you can use <code>traceback()</code> to get the same information (sans pretty formatting):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">traceback</span>()
<span class="co">#&gt; 5: stop(&quot;`d` must be numeric&quot;, call. = FALSE) at debugging.R#6</span>
<span class="co">#&gt; 4: i(c) at debugging.R#3</span>
<span class="co">#&gt; 3: h(b) at debugging.R#2</span>
<span class="co">#&gt; 2: g(a) at debugging.R#1</span>
<span class="co">#&gt; 1: f(&quot;a&quot;)</span></code></pre>
<p>NB: You read the <code>traceback()</code> output from bottom to top: the initial call is <code>f()</code>, which calls <code>g()</code>, then <code>h()</code>, then <code>i()</code>, which triggers the error. If you’re calling code that you <code>source()</code>d into R, the traceback will also display the location of the function, in the form <code>filename.r#linenumber</code>. These are clickable in RStudio, and will take you to the corresponding line of code in the editor.</p>
<div id="debug-lazy" class="section level3">
<h3><span class="header-section-number">22.3.1</span> Lazy evaluation</h3>

<p>One drawback to <code>traceback()</code> is that it always linearises the call tree, which can be confusing if there is much lazy evaluation involved (Section <a href="#lazy-call-stack">7.5.2</a>). For example, take the following example where the error happens when evaluating the first argument to <code>f()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">j &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">k</span>()
k &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">stop</span>(<span class="st">&quot;Oops!&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
<span class="kw">f</span>(<span class="kw">j</span>())
<span class="co">#&gt; Error: Oops!</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">traceback</span>()
<span class="co">#&gt; 7: stop(&quot;Oops!&quot;) at #1</span>
<span class="co">#&gt; 6: k() at #1</span>
<span class="co">#&gt; 5: j() at debugging.R#1</span>
<span class="co">#&gt; 4: i(c) at debugging.R#3</span>
<span class="co">#&gt; 3: h(b) at debugging.R#2</span>
<span class="co">#&gt; 2: g(a) at debugging.R#1</span>
<span class="co">#&gt; 1: f(j())</span></code></pre>
<p>You can using <code>rlang::with_abort()</code> and <code>rlang::last_trace()</code> to see the call tree. Here, I think it makes it much easier to see the source of the problem. Look at the last branch of of the call tree so see that the error comes from <code>j()</code> calling <code>k()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">rlang<span class="op">::</span><span class="kw">with_abort</span>(<span class="kw">f</span>(<span class="kw">j</span>()))
<span class="co">#&gt; Error: Oops!</span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─rlang::with_abort(f(j()))</span>
<span class="co">#&gt;  2. │ └─base::withCallingHandlers(...)</span>
<span class="co">#&gt;  3. ├─global::f(j())</span>
<span class="co">#&gt;  4. │ └─global::g(a)</span>
<span class="co">#&gt;  5. │   └─global::h(b)</span>
<span class="co">#&gt;  6. │     └─global::i(c)</span>
<span class="co">#&gt;  7. └─global::j()</span>
<span class="co">#&gt;  8.   └─global::k()</span>
rlang<span class="op">::</span><span class="kw">last_trace</span>()
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─rlang::with_abort(f(j()))</span>
<span class="co">#&gt;  2. │ └─base::withCallingHandlers(...)</span>
<span class="co">#&gt;  3. ├─global::f(j())</span>
<span class="co">#&gt;  4. │ └─global::g(a)</span>
<span class="co">#&gt;  5. │   └─global::h(b)</span>
<span class="co">#&gt;  6. │     └─global::i(c)</span>
<span class="co">#&gt;  7. └─global::j()</span>
<span class="co">#&gt;  8.   └─global::k()</span></code></pre>
<p>NB: <code>rlang::last_trace()</code> is ordered in the opposite way to <code>traceback()</code>. We’ll come back to that issue in Section <a href="#call-stack-ordering">22.4.2.4</a>.</p>
</div>
</div>
<div id="browser" class="section level2">
<h2><span class="header-section-number">22.4</span> The interactive debugger</h2>
<p>
</p>
<p>Sometimes, the precise location of the error is enough to let you track it down and fix it. Frequently, however, you need more information, and the easiest way to get it is with the interactive debugger which allows you to pause execution of a function and interactively explore its state.</p>
<p>If you’re using RStudio, the easiest way to enter the interactive debugger is through RStudio’s “Rerun with Debug” tool. This reruns the command that created the error, pausing execution where the error occurred. Otherwise, you can insert a call to <code>browser()</code> where you want to pause, and re-run the function yourself. For example, we could insert a call <code>browser()</code> in <code>g()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(b) {
  <span class="kw">browser</span>()
  <span class="kw">h</span>(b)
}
<span class="kw">f</span>(<span class="dv">10</span>)</code></pre>
<p><code>browser()</code> is just a regular function call which means that you can run it conditionally by wrapping it in an <code>if</code> statement:</p>
<pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(b) {
  <span class="cf">if</span> (b <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="kw">browser</span>()
  }
  <span class="kw">h</span>(b)
}</code></pre>
<p>In either case, you’ll end up in an interactive environment <em>inside</em> the function where you can run arbitrary R code to explore the current state. You’ll know when you’re in the interactive debugger because you get a special prompt:</p>
<pre><code>Browse[1]&gt; </code></pre>
<p>In RStudio, you’ll see the corresponding code in the editor (with the statement that will be run next highlighted), objects in the current environment in the “Environment” pane, and the call stack in the “Traceback” pane.</p>
<div id="browser-commands" class="section level3">
<h3><span class="header-section-number">22.4.1</span> <code>browser()</code> commands</h3>
<p>As well as allowing you to run regular R code, <code>browser()</code> provides a few special commands. You can use them by either typing short text commands, or by clicking a button in the RStudio toolbar, Figure <a href="#fig:debug-toolbar">22.1</a>:</p>
<div class="figure" style="text-align: center"><span id="fig:debug-toolbar"></span>
<img src="screenshots/debug-toolbar.png" alt="RStudio debugging toolbar" width="50%" />
<p class="caption">
Figure 22.1: RStudio debugging toolbar
</p>
</div>
<ul>
<li><p>Next, <code>n</code>: executes the next step in the function. If you have a
variable named <code>n</code>, you’ll need <code>print(n)</code> to display its value.</p></li>
<li><p>Step into, <img src="screenshots/step-into.png" width="20" /> or <code>s</code>:
works like next, but if the next step is a function, it will step into that
function so you can explore it interactively.</p></li>
<li><p>Finish, <img src="screenshots/finish-loop.png" width="20" /> or <code>f</code>:
finishes execution of the current loop or function.</p></li>
<li><p>Continue, <code>c</code>: leaves interactive debugging and continues regular execution
of the function. This is useful if you’ve fixed the bad state and want to
check that the function proceeds correctly.</p></li>
<li><p>Stop, <code>Q</code>: stops debugging, terminates the function, and returns to the global
workspace. Use this once you’ve figured out where the problem is, and you’re
ready to fix it and reload the code.</p></li>
</ul>
<p>There are two other slightly less useful commands that aren’t available in the toolbar:</p>
<ul>
<li><p>Enter: repeats the previous command. I find this too easy to activate
accidentally, so I turn it off using <code>options(browserNLdisabled = TRUE)</code>.
</p></li>
<li><p><code>where</code>: prints stack trace of active calls (the interactive equivalent of
<code>traceback</code>).</p></li>
</ul>
</div>
<div id="alternatives" class="section level3">
<h3><span class="header-section-number">22.4.2</span> Alternatives</h3>
<p>There are three alternatives to using <code>browser()</code>: setting breakpoints in RStudio, <code>option(error = recover)</code>, and <code>debug()</code> and friends.</p>
<div id="breakpoints" class="section level4">
<h4><span class="header-section-number">22.4.2.1</span> Breakpoints</h4>
<p></p>
<p>In RStudio, you can set a breakpoint by clicking to the left of the line number, or pressing <code>Shift + F9</code>. Breakpoints behave similarly to <code>browser()</code> but they are easier to set (one click instead of nine key presses), and you don’t run the risk of accidentally including a <code>browser()</code> statement in your source code. There are two small downsides to breakpoints:</p>
<ul>
<li><p>There are a few unusual situations in which breakpoints will not work.
Read breakpoint troubleshooting<span id="fn165" class="footnote" data-pagedown-footnote-number="165" style="white-space: pre-line;"><a href="http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting" class="uri">http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting</a></span> for more details.</p></li>
<li><p>RStudio currently does not support conditional breakpoints.</p></li>
</ul>
</div>
<div id="recover" class="section level4">
<h4><span class="header-section-number">22.4.2.2</span> <code>recover()</code></h4>
<p>
</p>
<p>Another way to activate <code>browser()</code> is to use <code>options(error = recover)</code>. Now when you get an error, you’ll get an interactive prompt that displays the traceback and gives you the ability to interactively debug inside any of the frames:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">error =</span> recover)
<span class="kw">f</span>(<span class="st">&quot;x&quot;</span>)
<span class="co">#&gt; Error: `d` must be numeric</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Enter a frame number, or 0 to exit   </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; 1: f(&quot;x&quot;)</span>
<span class="co">#&gt; 2: debugging.R#1: g(a)</span>
<span class="co">#&gt; 3: debugging.R#2: h(b)</span>
<span class="co">#&gt; 4: debugging.R#3: i(c)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Selection:</span></code></pre>
<p>You can return to default error handling with <code>options(error = NULL)</code>.</p>
</div>
<div id="debug" class="section level4">
<h4><span class="header-section-number">22.4.2.3</span> <code>debug()</code></h4>

<p>Another approach is to call a function that inserts the <code>browser()</code> call for you:</p>
<ul>
<li><p><code>debug()</code> inserts a browser statement in the first line of the specified
function. <code>undebug()</code> removes it. Alternatively, you can use <code>debugonce()</code>
to browse only on the next run.</p></li>
<li><p><code>utils::setBreakpoint()</code> works similarly, but instead of taking a function
name, it takes a file name and line number and finds the appropriate function
for you.</p></li>
</ul>
<p>These two functions are both special cases of <code>trace()</code>, which inserts arbitrary code at any position in an existing function. <code>trace()</code> is occasionally useful when you’re debugging code that you don’t have the source for. To remove tracing from a function, use <code>untrace()</code>. You can only perform one trace per function, but that one trace can call multiple functions.</p>
</div>
<div id="call-stack-ordering" class="section level4">
<h4><span class="header-section-number">22.4.2.4</span> The call stack</h4>
<p></p>
<p>Unfortunately, the call stacks printed by <code>traceback()</code>, <code>browser()</code> &amp; <code>where</code>, and <code>recover()</code> are not consistent. The following table shows how the call stacks from a simple nested set of calls are displayed by the three tools. The numbering is different between <code>traceback()</code> and <code>where</code>, and <code>recover()</code> displays calls in the opposite order.</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>traceback()</code></th>
<th align="left"><code>where</code></th>
<th align="left"><code>recover()</code></th>
<th align="left">rlang functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>5: stop(&quot;...&quot;)</code></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>4: i(c)</code></td>
<td align="left"><code>where 1: i(c)</code></td>
<td align="left"><code>1: f()</code></td>
<td align="left"><code>1. └─global::f(10)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>3: h(b)</code></td>
<td align="left"><code>where 2: h(b)</code></td>
<td align="left"><code>2: g(a)</code></td>
<td align="left"><code>2.   └─global::g(a)</code></td>
</tr>
<tr class="even">
<td align="left"><code>2: g(a)</code></td>
<td align="left"><code>where 3: g(a)</code></td>
<td align="left"><code>3: h(b)</code></td>
<td align="left"><code>3.     └─global::h(b)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>1: f(&quot;a&quot;)</code></td>
<td align="left"><code>where 4: f(&quot;a&quot;)</code></td>
<td align="left"><code>4: i(&quot;a&quot;)</code></td>
<td align="left"><code>4.       └─global::i(&quot;a&quot;)</code></td>
</tr>
</tbody>
</table>
<p>RStudio displays calls in the same order as <code>traceback()</code>. rlang functions use the same ordering and numbering as <code>recover()</code>, but also use indenting to reinforce the hierarchy of calls.</p>
</div>
</div>
<div id="debug-compiled" class="section level3">
<h3><span class="header-section-number">22.4.3</span> Compiled code</h3>
<p></p>
<p>It is also possible to use an interactive debugger (gdb or lldb) for compiled code (like C or C++). Unfortunately that’s beyond the scope of this book, but there are a few resources that you might find useful:</p>
<ul>
<li><a href="http://r-pkgs.had.co.nz/src.html#src-debugging" class="uri">http://r-pkgs.had.co.nz/src.html#src-debugging</a></li>
<li><a href="https://github.com/wch/r-debug/blob/master/debugging-r.md" class="uri">https://github.com/wch/r-debug/blob/master/debugging-r.md</a></li>
<li><a href="http://kevinushey.github.io/blog/2015/04/05/debugging-with-valgrind/" class="uri">http://kevinushey.github.io/blog/2015/04/05/debugging-with-valgrind/</a></li>
<li><a href="https://www.jimhester.com/2018/08/22/debugging-rstudio/" class="uri">https://www.jimhester.com/2018/08/22/debugging-rstudio/</a></li>
</ul>
</div>
</div>
<div id="non-interactive-debugging" class="section level2">
<h2><span class="header-section-number">22.5</span> Non-interactive debugging</h2>
<p></p>
<p>Debugging is most challenging when you can’t run code interactively, typically because it’s part of some pipeline run automatically (possibly on another computer), or because the error doesn’t occur when you run same code interactively. This can be extremely frustrating!</p>
<p>This section will give you some useful tools, but don’t forget the general strategy in Section <a href="#debugging-strategy">22.2</a>. When you can’t explore interactively, it’s particularly important to spend some time making the problem as small as possible so you can iterate quickly. Sometimes <code>callr::r(f, list(1, 2))</code> can useful; this calls <code>f(1, 2)</code> in a fresh session, and can be a useful way to reproduce the problem.</p>
<p>You might also want to double check for these common issues:</p>
<ul>
<li><p>Is the global environment different? Have you loaded different packages?
Are there objects left around from previous sessions that are causing
differences?</p></li>
<li><p>Is the working directory different?</p></li>
<li><p>Is the <code>PATH</code> environment variable, which determines where external
commands (like <code>git</code>) are found, different?</p></li>
<li><p>Is the <code>R_LIBS</code> environment variable, which determines where <code>library()</code>
looks for packages, different?</p></li>
</ul>
<div id="dump.frames" class="section level3">
<h3><span class="header-section-number">22.5.1</span> <code>dump.frames()</code></h3>

<p><code>dump.frames()</code> is the equivalent to <code>recover()</code> for non-interactive code; it saves a <code>last.dump.rda</code> file in the working directory. Later, an interactive session, you can later <code>load(&quot;last.dump.rda&quot;); debugger()</code> to enter an interactive debugger with the same interface as <code>recover()</code>. This lets you “cheat”, interactively debugging code that was run non-interactively.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># In batch R process ----</span>
dump_and_quit &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="co"># Save debugging info to file last.dump.rda</span>
  <span class="kw">dump.frames</span>(<span class="dt">to.file =</span> <span class="ot">TRUE</span>)
  <span class="co"># Quit R with error status</span>
  <span class="kw">q</span>(<span class="dt">status =</span> <span class="dv">1</span>)
}
<span class="kw">options</span>(<span class="dt">error =</span> dump_and_quit)

<span class="co"># In a later interactive session ----</span>
<span class="kw">load</span>(<span class="st">&quot;last.dump.rda&quot;</span>)
<span class="kw">debugger</span>()</code></pre>
</div>
<div id="print-debugging" class="section level3">
<h3><span class="header-section-number">22.5.2</span> Print debugging</h3>
<p></p>
<p>If <code>dump.frames()</code> doesn’t help, a good fallback is <strong>print debugging</strong>, where you insert numerous print statements to precisely locate the problem, and see the values of important variables. Print debugging is slow and primitive, but it always works, so it’s particularly useful if you can’t get a good traceback. Start by inserting coarse-grained markers, and then make them progressively more fine-grained as you determine exactly where the problem is.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(a) {
  <span class="kw">cat</span>(<span class="st">&quot;f()</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">g</span>(a)
}
g &lt;-<span class="st"> </span><span class="cf">function</span>(b) {
  <span class="kw">cat</span>(<span class="st">&quot;g()</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">cat</span>(<span class="st">&quot;b =&quot;</span>, b, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">h</span>(b)
}
h &lt;-<span class="st"> </span><span class="cf">function</span>(c) {
  <span class="kw">cat</span>(<span class="st">&quot;i()</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">i</span>(c)
}

<span class="kw">f</span>(<span class="dv">10</span>)
<span class="co">#&gt; f()</span>
<span class="co">#&gt; g()</span>
<span class="co">#&gt; b = 10 </span>
<span class="co">#&gt; i()</span>
<span class="co">#&gt; [1] 20</span></code></pre>
<p>Print debugging is particularly useful for compiled code because it’s not uncommon for the compiler to modify your code to such an extent you can’t figure out the root problem even when inside an interactive debugger.</p>
</div>
<div id="rmarkdown" class="section level3">
<h3><span class="header-section-number">22.5.3</span> RMarkdown</h3>
<p></p>
<!-- Adapted from https://whattheyforgot.org/debugging-r-code.html#debugging-in-rmarkdown-documents -->
<p>Debugging code inside RMarkdown files requires some special tools. First, if you’re knitting the file using RStudio, switch to calling <code>rmarkdown::render(&quot;path/to/file.Rmd&quot;)</code> instead. This runs the code in the current session, which makes it easier to debug. If doing this makes the problem go away, you’ll need to figure out what makes the environments different.</p>
<p>If the problem persists, you’ll need to use your interactive debugging skills. Whatever method you use, you’ll need an extra step: in the error handler, you’ll need to call <code>sink()</code>. This removes the default “sink” that knitr uses to capture all output, and ensures that you can see the results in the console. For example, to use <code>recover()</code> with RMarkdown, you’d put the following code in your setup block:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">error =</span> <span class="cf">function</span>() {
  <span class="kw">sink</span>()
  <span class="kw">recover</span>()
})</code></pre>
<p>This will generate a warning about “no sink to remove” when knitr completes; you can safely ignore this warning.</p>
<p>If you simply want to a traceback, the easiest option is to use <code>rlang::trace_back()</code>, taking advantage of the <code>rlang_trace_top_env</code> option. This ensures that you only see the traceback from your code, not all of the functions called by RMarkdown and knitr.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">rlang_trace_top_env =</span> rlang<span class="op">::</span><span class="kw">current_env</span>())
<span class="kw">options</span>(<span class="dt">error =</span> <span class="cf">function</span>() {
  <span class="kw">sink</span>()
  <span class="kw">print</span>(rlang<span class="op">::</span><span class="kw">trace_back</span>(<span class="dt">bottom =</span> <span class="kw">sys.frame</span>(<span class="op">-</span><span class="dv">1</span>)), <span class="dt">simplify =</span> <span class="st">&quot;none&quot;</span>)
})</code></pre>
</div>
</div>
<div id="non-error-failures" class="section level2">
<h2><span class="header-section-number">22.6</span> Non-error failures</h2>
<p>


</p>
<p>There are other ways for a function to fail apart from throwing an error:</p>
<ul>
<li><p>A function may generate an unexpected warning. The easiest way to track down
warnings is to convert them into errors with <code>options(warn = 2)</code> and use the
in the call stack, like <code>doWithOneRestart()</code>, <code>withOneRestart()</code>,
regular debugging tools. When you do this you’ll see some extra calls
<code>withRestarts()</code>, and <code>.signalSimpleWarning()</code>. Ignore these: they are
internal functions used to turn warnings into errors.</p></li>
<li><p>A function may generate an unexpected message. You can use
<code>rlang::with_abort()</code> to turn these messages into errors:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">g</span>()
g &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">message</span>(<span class="st">&quot;Hi!&quot;</span>)
<span class="kw">f</span>()
<span class="co">#&gt; Hi!</span>

rlang<span class="op">::</span><span class="kw">with_abort</span>(<span class="kw">f</span>(), <span class="st">&quot;message&quot;</span>)
<span class="co">#&gt; Error: Hi!</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; Backtrace:</span>
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─rlang::with_abort(f(), &quot;message&quot;)</span>
<span class="co">#&gt;  2. │ └─base::withCallingHandlers(...)</span>
<span class="co">#&gt;  3. └─global::f()</span>
<span class="co">#&gt;  4.   └─global::g()</span>
rlang<span class="op">::</span><span class="kw">last_trace</span>()
<span class="co">#&gt;     █</span>
<span class="co">#&gt;  1. ├─rlang::with_abort(f(), &quot;message&quot;)</span>
<span class="co">#&gt;  2. │ └─base::withCallingHandlers(...)</span>
<span class="co">#&gt;  3. └─global::f()</span>
<span class="co">#&gt;  4.   └─global::g()</span></code></pre></li>
<li><p>A function might never return. This is particularly hard to debug
automatically, but sometimes terminating the function and looking at the
<code>traceback()</code> is informative. Otherwise, use use print debugging,
as in Section <a href="#print-debugging">22.5.2</a>.</p></li>
<li><p>The worst scenario is that your code might crash R completely, leaving you
with no way to interactively debug your code. This indicates a bug in
compiled (C or C++) code.</p>
<p>If it’s in your compiled code, you’ll need to follow the links in Section
<a href="#debug-compiled">22.4.3</a> and learn how to use an interactive C debugger
(or insert many print statements).</p>
<p>If it’s in a package or base R, you’ll need to contact the package
maintainer. In either case, work on making the smallest possible
reprex (Section <a href="#getting-help">1.7</a>) to help the developer help you.</p></li>
</ul>
<!--chapter:end:Debugging.Rmd-->
</div>
</div>
<div id="perf-measure" class="section level1">
<h1><span class="header-section-number">23</span> Measuring performance</h1>
<p></p>
<div id="introduction-24" class="section level2">
<h2><span class="header-section-number">23.1</span> Introduction</h2>
<blockquote>
<p>“Programmers waste enormous amounts of time thinking about, or worrying
about, the speed of noncritical parts of their programs, and these attempts
at efficiency actually have a strong negative impact when debugging and
maintenance are considered.”</p>
<p>— Donald Knuth.</p>
</blockquote>
<p>Before you can make your code faster, you first need to figure out what’s making it slow. This sounds easy, but it’s not. Even experienced programmers have a hard time identifying bottlenecks in their code. So instead of relying on your intuition, you should <strong>profile</strong> your code: measure the run-time of each line of code using realistic inputs.</p>
<p>Once you’ve identified bottlenecks you’ll need to carefully experiment with alternatives to find faster code that is still equivalent. In Chapter <a href="#perf-improve">24</a> you’ll learn a bunch of ways to speed up code, but first you need to learn how to <strong>microbenchmark</strong> so that you can precisely measure the difference in performance.</p>
<div id="outline-21" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#profiling">23.2</a> shows you how to use profiling tools to dig into
exactly what is making code slow.</p></li>
<li><p>Section <a href="#microbenchmarking">23.3</a> shows how to use microbenchmarking to
explore alternative implementations and figure out exactly which one is
fastest.</p></li>
</ul>
</div>
<div id="prerequisites-15" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>We’ll use profvis<span id="fn166" class="footnote" data-pagedown-footnote-number="166" style="white-space: pre-line;"><a href="https://rstudio.github.io/profvis/" class="uri">https://rstudio.github.io/profvis/</a></span> for profiling, and bench<span id="fn167" class="footnote" data-pagedown-footnote-number="167" style="white-space: pre-line;"><a href="https://bench.r-lib.org/" class="uri">https://bench.r-lib.org/</a></span> for microbenchmarking.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(profvis)
<span class="kw">library</span>(bench)</code></pre>
</div>
</div>
<div id="profiling" class="section level2">
<h2><span class="header-section-number">23.2</span> Profiling</h2>
<p>
</p>
<p>Across programming languages, the primary tool used to understand code performance is the profiler. There are a number of different types of profilers ,but R uses a fairly simple type called a sampling or statistical profiler. A sampling profiler stops the execution of code every few milliseconds and records the call stack (i.e. which function is currently executing, and the funcion that function, and so on). For example, consider <code>f()</code>, below:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">pause</span>(<span class="fl">0.1</span>)
  <span class="kw">g</span>()
  <span class="kw">h</span>()
}
g &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">pause</span>(<span class="fl">0.1</span>)
  <span class="kw">h</span>()
}
h &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">pause</span>(<span class="fl">0.1</span>)
}</code></pre>
<p>(I use <code>profvis::pause()</code> instead of <code>Sys.sleep()</code> because <code>Sys.sleep()</code> does not appear in profiling outputs because as far as R can tell, it doesn’t use up any computing time.) </p>
<p>If we profiled the execution of <code>f()</code>, stopping the execution of code every 0.1 s, we’d see a profile like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;pause&quot;</span> <span class="st">&quot;f&quot;</span> 
<span class="st">&quot;pause&quot;</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;g&quot;</span>
<span class="st">&quot;pause&quot;</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;g&quot;</span> <span class="st">&quot;h&quot;</span>
<span class="st">&quot;pause&quot;</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;h&quot;</span></code></pre>
<p>Each line represents one “tick” of the profiler (0.1 s in this case), and function calls are recorded from right to left: the first line shows <code>f()</code> calling <code>pause()</code>. It shows that the code spends 0.1 s running <code>f()</code>, then 0.2 s running <code>g()</code>, then 0.1 s running <code>h()</code>.</p>
<p>If we actually profile <code>f()</code>, using <code>utils::Rprof()</code> as in the code below, we’re unlikely to get such a clear result.</p>
<pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">tempfile</span>()
<span class="kw">Rprof</span>(tmp, <span class="dt">interval =</span> <span class="fl">0.1</span>)
<span class="kw">f</span>()
<span class="kw">Rprof</span>(<span class="ot">NULL</span>)
<span class="kw">writeLines</span>(<span class="kw">readLines</span>(tmp))
<span class="co">#&gt; sample.interval=100000</span>
<span class="co">#&gt; &quot;pause&quot; &quot;g&quot; &quot;f&quot; </span>
<span class="co">#&gt; &quot;pause&quot; &quot;h&quot; &quot;g&quot; &quot;f&quot; </span>
<span class="co">#&gt; &quot;pause&quot; &quot;h&quot; &quot;f&quot; </span></code></pre>
<p>That’s because all profilers must make a fundamental trade-off between accuracy and performance. The compromise that makes, using a sampling profiler, only has minimal impact on performance, but is fundamentally stochastic because there’s some variability in both the accuracy of the timer and in the time taken by each operation. That means each time that you profile you’ll get a slightly different answer. Fortunately, the variability most affects functions that take very little time ot run, which are also the functions that we’re least interested in.</p>
<div id="visualising-profiles" class="section level3">
<h3><span class="header-section-number">23.2.1</span> Visualising profiles</h3>

<p>The default profiling resolution is quite small, so if your function takes even a few seconds it will generate hundreds of samples. That quickly grows beyond our ability to look at directly, so instead of using <code>uils::Rprof()</code> we’ll use the profvis package to visualise aggregates. profvis also connects profiling data back to the underlying source code, making it easier to build up a mental model of what you need to change. If you find profvis doesn’t help for your code, you might try one of the other options like <code>utils::summaryRprof()</code> or the proftools package <span class="citation">(Tierney and Jarjour <a href="#ref-proftools">2016</a>)</span>.</p>
<p>There are two ways to use profvis:</p>
<ul>
<li><p>From the “Profile” menu in RStudio.</p></li>
<li><p>With <code>profvis::profvis()</code>. I recommend storing your code in a separate
file and <code>source()</code>ing it in; this will ensure you get the best connection
between profiling data and source code.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">source</span>(<span class="st">&quot;profiling-example.R&quot;</span>)
<span class="kw">profvis</span>(<span class="kw">f</span>())</code></pre></li>
</ul>
<p>After profiling is complete, profvis will open an interactive HTML document that allows you to explore the results. There are two panes, as shown in Figure <a href="#fig:flamegraph">23.1</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:flamegraph"></span>
<img src="screenshots/performance/flamegraph.png" alt="profvis output showing source on top and flame graph below." width="100%" />
<p class="caption">
Figure 23.1: profvis output showing source on top and flame graph below.
</p>
</div>
<p>The top pane shows the source code, overlaid with bar graphs for memory and execution time for each line of code. Here I’ll focus on time, and we’ll come back to memory shortly. This display gives you a good overall feel for the bottlenecks but doesn’t always help you precisely identify the cause. Here, for example, you can see that <code>h()</code> takes 150ms, twice as long as <code>g()</code>; that’s not because the function itself is slower, but because it’s called twice as often.</p>
<p>The bottom pane displays a <strong>flame graph</strong> showing the full call stack. This allows you to see the full sequence of calls leading to each function, allowing you to see that <code>h()</code> is called from two different places. In this display you can mouse over individual calls to get more information, and see the corresponding line of source code, as in Figure <a href="#fig:perf-info">23.2</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:perf-info"></span>
<img src="screenshots/performance/info.png" alt="Hovering over a call in the flamegraph highlights the corresponding line of code, and displays additional information about performance." width="100%" />
<p class="caption">
Figure 23.2: Hovering over a call in the flamegraph highlights the corresponding line of code, and displays additional information about performance.
</p>
</div>
<p>Alternatively, you can use the <strong>data tab</strong>, Figure <a href="#fig:perf-tree">23.3</a> lets you interactively dive into the tree of performance data. This is basically the same display as the flame graph (rotated 90°), but it’s more useful when you have very large or deeply nested call stacks because you can choose to interactively zoom into only selected components.</p>
<div class="figure" style="text-align: center"><span id="fig:perf-tree"></span>
<img src="screenshots/performance/tree.png" alt="The data gives an interactive tree that allows you to selectively zoom into key components" width="100%" />
<p class="caption">
Figure 23.3: The data gives an interactive tree that allows you to selectively zoom into key components
</p>
</div>
</div>
<div id="memory-profiling" class="section level3">
<h3><span class="header-section-number">23.2.2</span> Memory profiling</h3>
<p>

</p>
<p>There is a special entry in the flame graph that doesn’t correspond to your code: <code>&lt;GC&gt;</code>, which indicates that the garbage collector is running. If <code>&lt;GC&gt;</code> is taking a lot of time, it’s usually an indicating that you’re creating many short-lived objects. For example, take this small snippet of code:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">integer</span>()
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) {
  x &lt;-<span class="st"> </span><span class="kw">c</span>(x, i)
}</code></pre>
<p>If you profile it, you’ll see that most of the time is spent in the garbage collector, Figure <a href="#fig:perf-memory">23.4</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:perf-memory"></span>
<img src="screenshots/performance/memory.png" alt="Profiling a loop that modifies an existing variable reveals that most time is spent in the garbage collector (`&lt;GC&gt;`)" width="100%" />
<p class="caption">
Figure 23.4: Profiling a loop that modifies an existing variable reveals that most time is spent in the garbage collector (<code>&lt;GC&gt;</code>)
</p>
</div>
<p>When you see the garbage collector taking up a lot of time in your own code, you can often figure out the source of the problem by looking at the memory column: you’ll see a line where large amounts of memory are being allocated (the bar on the right) and freed (the bar on the left). Here the problem arises because of copy-on-modify (Section <a href="#copy-on-modify">2.3</a>): each iteration of the loop creates another copy of <code>x</code>. You’ll learn strategies to resolve this type of problem in Section <a href="#avoid-copies">24.6</a>.</p>
</div>
<div id="limitations" class="section level3">
<h3><span class="header-section-number">23.2.3</span> Limitations</h3>
<p></p>
<p>There are some other limitations to profiling:</p>
<ul>
<li><p>Profiling does not extend to C code. You can see if your R code calls C/C++
code but not what functions are called inside of your C/C++ code.
Unfortunately, tools for profiling compiled code are beyond the scope of
this book; start by looking at <a href="https://github.com/r-prof/jointprof" class="uri">https://github.com/r-prof/jointprof</a>.</p></li>
<li><p>If you’re doing a lot of functional programming with anonymous functions,
it can be hard to figure out exactly which function is being called.
The easiest way to work around this is to name your functions.</p></li>
<li><p>Lazy evaluation means that arguments are often evaluated inside another
function, and this complicates the call stack (Section
<a href="#lazy-call-stack">7.5.2</a>). Unfortunately R’s profiler doesn’t store enough
information to disentangle lazy evaluation so that in the following code,
profiling would make it seem like <code>i()</code> was called by <code>j()</code> because the
argument isn’t evaluated until it’s needed by <code>j()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">pause</span>(<span class="fl">0.1</span>)
  <span class="dv">10</span>
}
j &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  x <span class="op">+</span><span class="st"> </span><span class="dv">10</span>
}
<span class="kw">j</span>(<span class="kw">i</span>())</code></pre>
<p>If this is confusing, use <code>force()</code> (Section @ref{forcing-evaluation}) to
force computation to happen earlier.</p></li>
</ul>
</div>
<div id="exercises-68" class="section level3">
<h3><span class="header-section-number">23.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Profile the following function with <code>torture = TRUE</code>. What is
surprising? Read the source code of <code>rm()</code> to figure out what’s going on.</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">n =</span> <span class="fl">1e5</span>) {
  x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, n)
  <span class="kw">rm</span>(x)
}</code></pre></li>
</ol>
</div>
</div>
<div id="microbenchmarking" class="section level2">
<h2><span class="header-section-number">23.3</span> Microbenchmarking</h2>
<p>
</p>
<p>A <strong>microbenchmark</strong> is a measurement of the performance of a very small piece of code, something that might take milliseconds (ms), microseconds (µs), or nanoseconds (ns) to run. Microbenchmarks are useful for comparing small snippets of code for specific tasks. Be very wary of generalising the results of microbenchmarks to real code: the observed differences in microbenchmarks will typically be dominated by higher-order effects in real code; a deep understanding of subatomic physics is not very helpful when baking.</p>
<p>A great tool for microbenchmarking in R is the bench package <span class="citation">(Hester <a href="#ref-bench">2018</a>)</span>. bench uses a a high precision timer, making it possible to compare operations that only take a tiny amount of time. For example, the following code compares the speed of two approaches to computing a square root.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)
(lb &lt;-<span class="st"> </span>bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">sqrt</span>(x),
  x <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span>
))
<span class="co">#&gt; # A tibble: 2 x 10</span>
<span class="co">#&gt;   expression      min    mean median     max `itr/sec` mem_alloc  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:t&gt; &lt;bch:&gt; &lt;bch:t&gt;     &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 sqrt(x)    583.01ns  1.22µs 1.11µs  37.7µs   821609.      848B     0</span>
<span class="co">#&gt; 2 x^0.5        9.01µs 10.06µs 9.45µs 136.3µs    99362.      848B     0</span>
<span class="co">#&gt; # … with 2 more variables: n_itr &lt;int&gt;, total_time &lt;bch:tm&gt;</span></code></pre>
<p>By default, <code>bench::mark()</code> runs each expression at least once (<code>min_iterations = 1</code>), and at most enough times to take 0.5s (<code>min_time = 0.5</code>). It checks that each run returns the same value which is typically what you when microbenchmarking; if you want to compare the speed of expressions that return different values, set <code>check = FALSE</code>.</p>
<div id="benchmark-results" class="section level3">
<h3><span class="header-section-number">23.3.1</span> <code>bench::mark()</code> results</h3>

<p><code>bench::mark()</code> returns the results as a tibble, with one row for each input expression, and the following columns:</p>
<ul>
<li><p><code>min</code>, <code>mean</code>, <code>median</code>, <code>max</code>, and <code>itr/sec</code> summarise the time taken by the
expression. Focus on the minimum (the best possible running time) and the
median (the typical time). In this example, you can see that using the
special purpose <code>sqrt()</code> function is faster than the general exponentiation
operator.</p>
<p>You can visualise the distribution of the individual timings with <code>plot()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(lb)</code></pre>
<p><img src="Perf-measure_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The distribution tends to be heavily right-skewed (note that the x-axis is
already on a log scale!), which is why you should avoid comparing means.
You’ll also often see multimodality because your computer is running
something else in the background.</p></li>
<li><p><code>mem_alloc</code> tells you the amount of memory allocated by the first run,
and <code>n_gc()</code> tells you the total number of garbage collections over all
runs. These are useful for assessing the memory usage of the expression.</p></li>
<li><p><code>n_itr</code> and <code>total_time</code> tells you how many times the expression was
evaluated and how long that took in total. <code>n_itr</code> will always be
greater than the <code>min_iteration</code> parameter, and <code>total_time</code> will always
be greater than the <code>min_time</code> parameter.</p></li>
<li><p><code>result</code>, <code>memory</code>, <code>time</code>, and <code>gc</code> are list-columns that store the
raw underlying data.</p></li>
</ul>
<p>Because the result is a special type of tibble, you can use <code>[</code> to select just the most important columns. I’ll do that frequently in the next chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r">lb[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 2 x 5</span>
<span class="co">#&gt;   expression      min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 sqrt(x)    583.01ns   1.11µs   821609.     0</span>
<span class="co">#&gt; 2 x^0.5        9.01µs   9.45µs    99362.     0</span></code></pre>
</div>
<div id="interpreting-results" class="section level3">
<h3><span class="header-section-number">23.3.2</span> Interpreting results</h3>
<p>As with all microbenchmarks, pay careful attention to the units: here, each computation takes about 580 ns, 580 billionths of a second. To help calibrate the impact of a microbenchmark on run time, it’s useful to think about how many times a function needs to run before it takes a second. If a microbenchmark takes:</p>
<ul>
<li>1 ms, then one thousand calls takes a second.</li>
<li>1 µs, then one million calls takes a second.</li>
<li>1 ns, then one billion calls takes a second.</li>
</ul>
<p>The <code>sqrt()</code> function takes about 580 ns, or 0.58 µs, to compute the square root of 100 numbers. That means if you repeated the operation a million times, it would take 0.58 s, and hence changing the way you compute the square root is unlikely to significantly affect real code. This is the reason you need to exercise care when generalising microbenchmarking results.</p>
</div>
<div id="exercises-69" class="section level3">
<h3><span class="header-section-number">23.3.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Instead of using <code>bench::mark()</code>, you could use the built-in function
<code>system.time()</code>. But <code>system.time()</code> is much less precise, so you’ll
need to repeat each operation many times with a loop, and then divide
to find the average time of each operation, as in the code below.</p>
<pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="fl">1e6</span>
<span class="kw">system.time</span>(<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) <span class="kw">sqrt</span>(x)) <span class="op">/</span><span class="st"> </span>n
<span class="kw">system.time</span>(<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) x <span class="op">^</span><span class="st"> </span><span class="fl">0.5</span>) <span class="op">/</span><span class="st"> </span>n</code></pre>
<p>How do the estimates from <code>system.time()</code> compare to those from
<code>bench::mark()</code>? Why are they different?</p></li>
<li><p>Here are two other ways to compute the square root of a vector. Which
do you think will be fastest? Which will be slowest? Use microbenchmarking
to test your answers.</p>
<pre class="sourceCode r"><code class="sourceCode r">x <span class="op">^</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)
<span class="kw">exp</span>(<span class="kw">log</span>(x) <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)</code></pre></li>
</ol>
<!--chapter:end:Perf-measure.Rmd-->
</div>
</div>
</div>
<div id="perf-improve" class="section level1">
<h1><span class="header-section-number">24</span> Improving performance</h1>
<div id="introduction-25" class="section level2">
<h2><span class="header-section-number">24.1</span> Introduction</h2>
<p></p>
<blockquote>
<p>“We should forget about small efficiencies, say about 97% of the time:
premature optimization is the root of all evil. Yet we should not pass up our
opportunities in that critical 3%. A good programmer will not be lulled
into complacency by such reasoning, he will be wise to look carefully at
the critical code; but only after that code has been identified.”</p>
<p>— Donald Knuth.</p>
</blockquote>
<p>Once you’ve used profiling to identify a bottleneck, you need to make it faster. It’s difficult to provide general advice on improving performance, but I try my best with four techniques that can be applied in many situations. I’ll also suggest a general strategy for performance optimisation that helps ensure that your faster code is still correct.</p>
<p>It’s easy to get caught up in trying to remove all bottlenecks. Don’t! Your time is valuable and is better spent analysing your data, not eliminating possible inefficiencies in your code. Be pragmatic: don’t spend hours of your time to save seconds of computer time. To enforce this advice, you should set a goal time for your code and optimise only up to that goal. This means you will not eliminate all bottlenecks. Some you will not get to because you’ve met your goal. Others you may need to pass over and accept either because there is no quick and easy solution or because the code is already well optimised and no significant improvement is possible. Accept these possibilities and move on to the next candidate.</p>
<p>If you’d like to learn more about the performance characteristics of the R language itself, I’d highly recommend “Evaluating the Design of the R Language” <span class="citation">(Morandat et al. <a href="#ref-r-design">2012</a>)</span>. It draws conclusions by combining a modified R interpreter with a wide set of code found in the wild.</p>
<div id="outline-22" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#code-organisation">24.2</a> teaches you how to organise
your code to make optimisation as easy, and bug free, as possible.</p></li>
<li><p>Section <a href="#already-solved">24.3</a> reminds you to look for existing
solutions.</p></li>
<li><p>Section <a href="#be-lazy">24.4</a> emphasises the importance of
being lazy: often the easiest way to make a function faster is to
let it to do less work.</p></li>
<li><p>Section <a href="#vectorise">24.5</a> concisely defines vectorisation, and shows you
how to make the most of built-in functions.</p></li>
<li><p>Section <a href="#avoid-copies">24.6</a> discusses the performance perils of
copying data.</p></li>
<li><p>Section <a href="#t-test">24.7</a> pulls all the pieces together into a case
study showing how to speed up repeated t-tests by ~1000x.</p></li>
<li><p>Section <a href="#more-techniques">24.8</a> finishes the chapter with pointers to
more resources that will help you write fast code.</p></li>
</ul>
</div>
<div id="prerequisites-16" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>We’ll use bench<span id="fn168" class="footnote" data-pagedown-footnote-number="168" style="white-space: pre-line;"><a href="https://bench.r-lib.org/" class="uri">https://bench.r-lib.org/</a></span> to precisely compare the performance of small self-contained code chunks.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bench)</code></pre>
</div>
</div>
<div id="code-organisation" class="section level2">
<h2><span class="header-section-number">24.2</span> Code organisation</h2>
<p></p>
<p>There are two traps that are easy to fall into when trying to make your code faster:</p>
<ol style="list-style-type: decimal">
<li>Writing faster but incorrect code.</li>
<li>Writing code that you think is faster, but is actually no better.</li>
</ol>
<p>The strategy outlined below will help you avoid these pitfalls.</p>
<p>When tackling a bottleneck, you’re likely to come up with multiple approaches. Write a function for each approach, encapsulating all relevant behaviour. This makes it easier to check that each approach returns the correct result and to time how long it takes to run. To demonstrate the strategy, I’ll compare two approaches for computing the mean:</p>
<pre class="sourceCode r"><code class="sourceCode r">mean1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">mean</span>(x)
mean2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">sum</span>(x) <span class="op">/</span><span class="st"> </span><span class="kw">length</span>(x)</code></pre>
<p>I recommend that you keep a record of everything you try, even the failures. If a similar problem occurs in the future, it’ll be useful to see everything you’ve tried. To do this I recommend RMarkdown, which makes it easy to intermingle code with detailed comments and notes.</p>
<p>Next, generate a representative test case. The case should be big enough to capture the essence of your problem but small enough that it only a few seconds at most. You don’t want it to take too long because you’ll need to run the test case many times to compare approaches. On the other hand, you don’t want the case to be too small because then results might not scale up to the real problem. Hre I’m going to use 100,000 numbers:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e5</span>)</code></pre>
<p>Now use <code>bench::mark()</code> to precisely compare the variations. <code>bench::mark()</code> automatically checks that all calls return the same values. This doesn’t guarantee that the function behaves the same for all inputs, so in an ideal world you’ll also have unit tests to make sure you don’t accidentally change the behaviour of the function.</p>
<pre class="sourceCode r"><code class="sourceCode r">bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">mean1</span>(x),
  <span class="kw">mean2</span>(x)
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 2 x 5</span>
<span class="co">#&gt;   expression      min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 mean1(x)      227µs    238µs     4182.     0</span>
<span class="co">#&gt; 2 mean2(x)      113µs    114µs     8447.     0</span></code></pre>
<p>(You might be surprised by the results: <code>mean(x)</code> is considerably slower than <code>sum(x) / length(x)</code>. This is because, among other reasons, <code>mean(x)</code> makes two passes over the vector to be more numerically accurate.)</p>
<p>If you’d like to see this strategy in action, I’ve used it a few times on stackoverflow:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/22515525#22518603" class="uri">http://stackoverflow.com/questions/22515525#22518603</a></li>
<li><a href="http://stackoverflow.com/questions/22515175#22515856" class="uri">http://stackoverflow.com/questions/22515175#22515856</a></li>
<li><a href="http://stackoverflow.com/questions/3476015#22511936" class="uri">http://stackoverflow.com/questions/3476015#22511936</a></li>
</ul>
</div>
<div id="already-solved" class="section level2">
<h2><span class="header-section-number">24.3</span> Check for existing solutions</h2>
<p>Once you’ve organised your code and captured all the variations you can think of, it’s natural to see what others have done. You are part of a large community, and it’s quite possible that someone has already tackled the same problem. Two good places to start are:</p>
<ul>
<li><p>CRAN task views<span id="fn169" class="footnote" data-pagedown-footnote-number="169" style="white-space: pre-line;"><a href="http://cran.rstudio.com/web/views/" class="uri">http://cran.rstudio.com/web/views/</a></span>. If there’s a
CRAN task view related to your problem domain, it’s worth looking at
the packages listed there.</p></li>
<li><p>Reverse dependencies of Rcpp, as listed on its
CRAN page<span id="fn170" class="footnote" data-pagedown-footnote-number="170" style="white-space: pre-line;"><a href="http://cran.r-project.org/web/packages/Rcpp" class="uri">http://cran.r-project.org/web/packages/Rcpp</a></span>. Since these
packages use C++, they’re likely to be fast.</p></li>
</ul>
<p>Otherwise, the challenge is describing your bottleneck in a way that helps you find related problems and solutions. Knowing the name of the problem or its synonyms will make this search much easier. But because you don’t know what it’s called, it’s hard to search for it! The best way to solve this problem is to read widely so that you can build up your own vocabulary over time. Alternatively, ask others. Talk to your colleagues and brainstorm some possible names, then search on Google and StackOverflow. It’s often helpful to restrict your search to R related pages. For Google, try rseek<span id="fn171" class="footnote" data-pagedown-footnote-number="171" style="white-space: pre-line;"><a href="http://www.rseek.org/" class="uri">http://www.rseek.org/</a></span>. For stackoverflow, restrict your search by including the R tag, <code>[R]</code>, in your search.</p>
<p>Record all solutions that you find, not just those that immediately appear to be faster. Some solutions might be slower initially, but end up being faster because they’re easier to optimise. You may also be able to combine the fastest parts from different approaches. If you’ve found a solution that’s fast enough, congratulations! Otherwise, read on.</p>
<div id="exercises-70" class="section level3">
<h3><span class="header-section-number">24.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What are faster alternatives to <code>lm()</code>? Which are specifically designed
to work with larger datasets?</p></li>
<li><p>What package implements a version of <code>match()</code> that’s faster for
repeated lookups? How much faster is it?</p></li>
<li><p>List four functions (not just those in base R) that convert a string into a
date time object. What are their strengths and weaknesses?</p></li>
<li><p>Which packages provide the ability to compute a rolling mean?</p></li>
<li><p>What are the alternatives to <code>optim()</code>?</p></li>
</ol>
</div>
</div>
<div id="be-lazy" class="section level2">
<h2><span class="header-section-number">24.4</span> Do as little as possible</h2>
<p>The easiest way to make a function faster is to let it do less work. One way to do that is use a function tailored to a more specific type of input or output, or to a more specific problem. For example:</p>
<ul>
<li><p><code>rowSums()</code>, <code>colSums()</code>, <code>rowMeans()</code>, and <code>colMeans()</code> are faster than
equivalent invocations that use <code>apply()</code> because they are vectorised
(Section <a href="#vectorise">24.5</a>).</p></li>
<li><p><code>vapply()</code> is faster than <code>sapply()</code> because it pre-specifies the output
type.</p></li>
<li><p>If you want to see if a vector contains a single value, <code>any(x == 10)</code>
is much faster than <code>10 %in% x</code> because testing equality is simpler
than testing set inclusion.</p></li>
</ul>
<p>Having this knowledge at your fingertips requires knowing that alternative functions exist: you need to have a good vocabulary. Expand your vocab by regularly reading R code. Good places to read code are the R-help mailing list<span id="fn172" class="footnote" data-pagedown-footnote-number="172" style="white-space: pre-line;"><a href="https://stat.ethz.ch/mailman/listinfo/r-help" class="uri">https://stat.ethz.ch/mailman/listinfo/r-help</a></span> and StackOverflow<span id="fn173" class="footnote" data-pagedown-footnote-number="173" style="white-space: pre-line;"><a href="http://stackoverflow.com/questions/tagged/r" class="uri">http://stackoverflow.com/questions/tagged/r</a></span>.</p>
<p>Some functions coerce their inputs into a specific type. If your input is not the right type, the function has to do extra work. Instead, look for a function that works with your data as it is, or consider changing the way you store your data. The most common example of this problem is using <code>apply()</code> on a data frame. <code>apply()</code> always turns its input into a matrix. Not only is this error prone (because a data frame is more general than a matrix), it is also slower.</p>
<p>Other functions will do less work if you give them more information about the problem. It’s always worthwhile to carefully read the documentation and experiment with different arguments. Some examples that I’ve discovered in the past include:</p>
<ul>
<li><p><code>read.csv()</code>: specify known column types with <code>colClasses</code>. (Also consider
switching to <code>readr::read_csv()</code> or <code>data.table::fread()</code> which are
considerably faster than <code>read.csv()</code>.)</p></li>
<li><p><code>factor()</code>: specify known levels with <code>levels</code>.</p></li>
<li><p><code>cut()</code>: don’t generate labels with <code>labels = FALSE</code> if you don’t need them,
or, even better, use <code>findInterval()</code> as mentioned in the “see also” section
of the documentation.</p></li>
<li><p><code>unlist(x, use.names = FALSE)</code> is much faster than <code>unlist(x)</code>.</p></li>
<li><p><code>interaction()</code>: if you only need combinations that exist in the data, use
<code>drop = TRUE</code>.</p></li>
</ul>
<p>Below, I explore how you might improve apply this strategy to improve the performance of <code>mean()</code> and <code>as.data.frame()</code>.</p>
<div id="mean" class="section level3">
<h3><span class="header-section-number">24.4.1</span> <code>mean()</code></h3>

<p></p>
<p>Sometimes you can make a function faster by avoiding method dispatch. If you’re calling a method in a tight loop, you can avoid some of the costs by doing the method lookup only once:</p>
<ul>
<li><p>For S3, you can do this by calling <code>generic.class()</code> instead of <code>generic()</code>.</p></li>
<li><p>For S4, you can do this by using <code>getMethod()</code> to find the method, saving
it to a variable, and then calling that function.</p></li>
</ul>
<p>For example, calling <code>mean.default()</code> is quite a bit faster than calling <code>mean()</code> for small vectors:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e2</span>)

bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">mean</span>(x),
  <span class="kw">mean.default</span>(x)
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 2 x 5</span>
<span class="co">#&gt;   expression           min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;           &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 mean(x)           2.61µs   3.15µs   271350.     1</span>
<span class="co">#&gt; 2 mean.default(x)   1.25µs   1.44µs   632599.     0</span></code></pre>
<p>This optimisation is a little risky. While <code>mean.default()</code> is almost twice as fast for 100 values, it will fail in surprising ways if <code>x</code> is not a numeric vector.</p>
<p>An even riskier optimisation is to directly call the underlying <code>.Internal</code> function. This is faster because it doesn’t do any input checking or handle NA’s, so you are buying speed at the cost of safety.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e2</span>)
bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">mean</span>(x),
  <span class="kw">mean.default</span>(x),
  <span class="kw">.Internal</span>(<span class="kw">mean</span>(x))
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 3 x 5</span>
<span class="co">#&gt;   expression              min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;              &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 mean(x)              2.58µs   3.03µs   275922.     1</span>
<span class="co">#&gt; 2 mean.default(x)      1.23µs   1.46µs   555858.     0</span>
<span class="co">#&gt; 3 .Internal(mean(x)) 342.03ns 362.05ns  2519643.     0</span></code></pre>
<p>NB: most of these differences arise because <code>x</code> is small. If you increase the size the differences basically disappear, because most of the time is now spent computing the mean, not finding the underlying implementation. This is a good reminder that the size of the input matters, and you should motivate your optimisations based on realistic data.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e4</span>)
bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">mean</span>(x),
  <span class="kw">mean.default</span>(x),
  <span class="kw">.Internal</span>(<span class="kw">mean</span>(x))
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 3 x 5</span>
<span class="co">#&gt;   expression              min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;              &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 mean(x)              24.8µs   25.3µs    38157.     1</span>
<span class="co">#&gt; 2 mean.default(x)      23.4µs   23.7µs    41134.     0</span>
<span class="co">#&gt; 3 .Internal(mean(x))   22.4µs   22.5µs    42865.     0</span></code></pre>
</div>
<div id="as.data.frame" class="section level3">
<h3><span class="header-section-number">24.4.2</span> <code>as.data.frame()</code></h3>

<p>Knowing that you’re dealing with a specific type of input can be another way to write faster code. For example, <code>as.data.frame()</code> is quite slow because it coerces each element into a data frame and then <code>rbind()</code>s them together. If you have a named list with vectors of equal length, you can directly transform it into a data frame. In this case, if you can make strong assumptions about your input, you can write a method that’s considerably faster than the default.</p>
<pre class="sourceCode r"><code class="sourceCode r">quickdf &lt;-<span class="st"> </span><span class="cf">function</span>(l) {
  <span class="kw">class</span>(l) &lt;-<span class="st"> &quot;data.frame&quot;</span>
  <span class="kw">attr</span>(l, <span class="st">&quot;row.names&quot;</span>) &lt;-<span class="st"> </span><span class="kw">.set_row_names</span>(<span class="kw">length</span>(l[[<span class="dv">1</span>]]))
  l
}

l &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">26</span>, <span class="cf">function</span>(i) <span class="kw">runif</span>(<span class="fl">1e3</span>))
<span class="kw">names</span>(l) &lt;-<span class="st"> </span>letters

bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="dt">as.data.frame =</span> <span class="kw">as.data.frame</span>(l),
  <span class="dt">quick_df      =</span> <span class="kw">quickdf</span>(l)
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 2 x 5</span>
<span class="co">#&gt;   expression         min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;         &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 as.data.frame   1.07ms   1.13ms      874.     7</span>
<span class="co">#&gt; 2 quick_df        6.16µs   7.29µs   121926.     2</span></code></pre>
<p>Again, note the trade-off. This method is fast because it’s dangerous. If you give it bad inputs, you’ll get a corrupt data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quickdf</span>(<span class="kw">list</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>))
<span class="co">#&gt; Warning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else</span>
<span class="co">#&gt; x, : corrupt data frame: columns will be truncated or padded with NAs</span>
<span class="co">#&gt;   x y</span>
<span class="co">#&gt; 1 1 1</span></code></pre>
<p>To come up with this minimal method, I carefully read through and then rewrote the source code for <code>as.data.frame.list()</code> and <code>data.frame()</code>. I made many small changes, each time checking that I hadn’t broken existing behaviour. After several hours work, I was able to isolate the minimal code shown above. This is a very useful technique. Most base R functions are written for flexibility and functionality, not performance. Thus, rewriting for your specific need can often yield substantial improvements. To do this, you’ll need to read the source code. It can be complex and confusing, but don’t give up!</p>
</div>
<div id="exercises-71" class="section level3">
<h3><span class="header-section-number">24.4.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What’s the difference between <code>rowSums()</code> and <code>.rowSums()</code>?</p></li>
<li><p>Make a faster version of <code>chisq.test()</code> that only computes the chi-square
test statistic when the input is two numeric vectors with no missing
values. You can try simplifying <code>chisq.test()</code> or by coding from the
mathematical definition<span id="fn174" class="footnote" data-pagedown-footnote-number="174" style="white-space: pre-line;"><a href="http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test" class="uri">http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test</a></span>.</p></li>
<li><p>Can you make a faster version of <code>table()</code> for the case of an input of
two integer vectors with no missing values? Can you use it to
speed up your chi-square test?</p></li>
</ol>
</div>
</div>
<div id="vectorise" class="section level2">
<h2><span class="header-section-number">24.5</span> Vectorise</h2>
<p></p>
<p>If you’ve used R for any length of time, you’ve probably heard the admonishment to “vectorise your code”. But what does that actually mean? Vectorising your code is not just about avoiding for loops, although that’s often a step. Vectorising is about taking a “whole object” approach to a problem, thinking about vectors, not scalars. There are two key attributes of a vectorised function:</p>
<ul>
<li><p>It makes many problems simpler. Instead of having to think about the
components of a vector, you only think about entire vectors.</p></li>
<li><p>The loops in a vectorised function are written in C instead of R. Loops in C
are much faster because they have much less overhead.</p></li>
</ul>
<p>Chapter <a href="#functionals">9</a> stressed the importance of vectorised code as a higher level abstraction. Vectorisation is also important for writing fast R code. This doesn’t mean simply using <code>map()</code> or <code>lapply()</code>. Instead, vectorisation means finding the existing R function that is implemented in C and most closely applies to your problem.</p>
<p>Vectorised functions that apply to many common performance bottlenecks include:</p>
<ul>
<li><p><code>rowSums()</code>, <code>colSums()</code>, <code>rowMeans()</code>, and <code>colMeans()</code>. These vectorised
matrix functions will always be faster than using <code>apply()</code>. You can
sometimes use these functions to build other vectorised functions.</p>
<pre class="sourceCode r"><code class="sourceCode r">rowAny &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">rowSums</span>(x) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>
rowAll &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">rowSums</span>(x) <span class="op">==</span><span class="st"> </span><span class="kw">ncol</span>(x)</code></pre></li>
<li><p>Vectorised subsetting can lead to big improvements in speed. Remember the
techniques behind lookup tables (Section <a href="#lookup-tables">4.5.1</a>) and matching
and merging by hand (Section <a href="#matching-merging">4.5.2</a>). Also
remember that you can use subsetting assignment to replace multiple values in
a single step. If <code>x</code> is a vector, matrix or data frame then
<code>x[is.na(x)] &lt;- 0</code> will replace all missing values with 0.</p></li>
<li><p>If you’re extracting or replacing values in scattered locations in a matrix
or data frame, subset with an integer matrix.
See Section <a href="#matrix-subsetting">4.2.3</a> for more details.</p></li>
<li><p>If you’re converting continuous values to categorical make sure you know
how to use <code>cut()</code> and <code>findInterval()</code>.</p></li>
<li><p>Be aware of vectorised functions like <code>cumsum()</code> and <code>diff()</code>.</p></li>
</ul>
<p>Matrix algebra is a general example of vectorisation. There loops are executed by highly tuned external libraries like BLAS. If you can figure out a way to use matrix algebra to solve your problem, you’ll often get a very fast solution. The ability to solve problems with matrix algebra is a product of experience. A good place to start is to ask people with experience in your domain.</p>
<p>The downside of vectorisation is that it makes it harder to predict how operations will scale. The following example measures how long it takes to use character subsetting to lookup 1, 10, and 100 elements from a list. You might expect that looking up 10 elements would take 10x as long as looking up 1, and that looking up 100 elements would take 10x longer again. In fact, the following example shows that it only takes about ~10x longer to look up 100 elements than it does to look up 1. That happens because once you get to a certain size, the internal implementation switches to a strategy that has a higher set up cost, but scales better.</p>
<pre class="sourceCode r"><code class="sourceCode r">lookup &lt;-<span class="st"> </span><span class="kw">setNames</span>(<span class="kw">as.list</span>(<span class="kw">sample</span>(<span class="dv">100</span>, <span class="dv">26</span>)), letters)

x1 &lt;-<span class="st"> &quot;j&quot;</span>
x10 &lt;-<span class="st"> </span><span class="kw">sample</span>(letters, <span class="dv">10</span>)
x100 &lt;-<span class="st"> </span><span class="kw">sample</span>(letters, <span class="dv">100</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)

bench<span class="op">::</span><span class="kw">mark</span>(
  lookup[x1],
  lookup[x10],
  lookup[x100],
  <span class="dt">check =</span> <span class="ot">FALSE</span>
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 3 x 5</span>
<span class="co">#&gt;   expression        min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;        &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 lookup[x1]      500ns 601.05ns  1505352.     0</span>
<span class="co">#&gt; 2 lookup[x10]    1.53µs   1.67µs   499800.     0</span>
<span class="co">#&gt; 3 lookup[x100]   4.38µs   5.04µs   178117.     1</span></code></pre>
<p>Vectorisation won’t solve every problem, and rather than torturing an existing algorithm into one that uses a vectorised approach, you’re often better off writing your own vectorised function in C++. You’ll learn how to do so in Chapter <a href="#rcpp">25</a>.</p>
<div id="exercises-72" class="section level3">
<h3><span class="header-section-number">24.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>The density functions, e.g., <code>dnorm()</code>, have a common interface. Which
arguments are vectorised over? What does <code>rnorm(10, mean = 10:1)</code> do?</p></li>
<li><p>Compare the speed of <code>apply(x, 1, sum)</code> with <code>rowSums(x)</code> for varying sizes
of <code>x</code>.</p></li>
<li><p>How can you use <code>crossprod()</code> to compute a weighted sum? How much faster is
it than the naive <code>sum(x * w)</code>?</p></li>
</ol>
</div>
</div>
<div id="avoid-copies" class="section level2">
<h2><span class="header-section-number">24.6</span> Avoid copies</h2>
<p>
</p>
<p>A pernicious source of slow R code is growing an object with a loop. Whenever you use <code>c()</code>, <code>append()</code>, <code>cbind()</code>, <code>rbind()</code>, or <code>paste()</code> to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. If you’re repeating this many times, like in a for loop, this can be quite expensive. You’ve entered Circle 2 of the “R inferno”<span id="fn175" class="footnote" data-pagedown-footnote-number="175" style="white-space: pre-line;"><a href="http://www.burns-stat.com/pages/Tutor/R_inferno.pdf" class="uri">http://www.burns-stat.com/pages/Tutor/R_inferno.pdf</a></span>.</p>
<p>You saw one example of this type of problem in Section <a href="#memory-profiling">23.2.2</a>, so here I’ll show a slightly more complex example of the same basic issue. We first generate some random strings, and then combine them either iteratively with a loop using <code>collapse()</code>, or in a single pass using <code>paste()</code>. Note that the performance of <code>collapse()</code> gets relatively worse as the number of strings grows: combining 100 strings takes almost 30 times longer than combining 10 strings.</p>
<pre class="sourceCode r"><code class="sourceCode r">random_string &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="kw">paste</span>(<span class="kw">sample</span>(letters, <span class="dv">50</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>)
}
strings10 &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">10</span>, <span class="kw">random_string</span>())
strings100 &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">100</span>, <span class="kw">random_string</span>())

collapse &lt;-<span class="st"> </span><span class="cf">function</span>(xs) {
  out &lt;-<span class="st"> &quot;&quot;</span>
  <span class="cf">for</span> (x <span class="cf">in</span> xs) {
    out &lt;-<span class="st"> </span><span class="kw">paste0</span>(out, x)
  }
  out
}

bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="dt">loop10  =</span> <span class="kw">collapse</span>(strings10),
  <span class="dt">loop100 =</span> <span class="kw">collapse</span>(strings100),
  <span class="dt">vec10   =</span> <span class="kw">paste</span>(strings10, <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>),
  <span class="dt">vec100  =</span> <span class="kw">paste</span>(strings100, <span class="dt">collapse =</span> <span class="st">&quot;&quot;</span>),
  <span class="dt">check =</span> <span class="ot">FALSE</span>
)[<span class="kw">c</span>(<span class="st">&quot;expression&quot;</span>, <span class="st">&quot;min&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;itr/sec&quot;</span>, <span class="st">&quot;n_gc&quot;</span>)]
<span class="co">#&gt; # A tibble: 4 x 5</span>
<span class="co">#&gt;   expression      min   median `itr/sec`  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 loop10      19.85µs  22.33µs    42400.     3</span>
<span class="co">#&gt; 2 loop100    808.68µs 833.17µs     1190.     1</span>
<span class="co">#&gt; 3 vec10        4.91µs   5.12µs   175979.     1</span>
<span class="co">#&gt; 4 vec100      39.17µs  40.31µs    23771.     0</span></code></pre>
<p>Modifying an object in a loop, e.g., <code>x[i] &lt;- y</code>, can also create a copy, depending on the class of <code>x</code>. Section <a href="#single-binding">2.5.1</a> discusses this issue in more depth and gives you some tools to determine when you’re making copies.</p>
</div>
<div id="t-test" class="section level2">
<h2><span class="header-section-number">24.7</span> Case study: t-test</h2>
<p>The following case study shows how to make t-tests faster using some of the techniques described above. It’s based on an example in “Computing thousands of test statistics simultaneously in R”<span id="fn176" class="footnote" data-pagedown-footnote-number="176" style="white-space: pre-line;"><a href="http://stat-computing.org/newsletter/issues/scgn-18-1.pdf" class="uri">http://stat-computing.org/newsletter/issues/scgn-18-1.pdf</a></span> by Holger Schwender and Tina Müller. I thoroughly recommend reading the paper in full to see the same idea applied to other tests.</p>
<p>Imagine we have run 1000 experiments (rows), each of which collects data on 50 individuals (columns). The first 25 individuals in each experiment are assigned to group 1 and the rest to group 2. We’ll first generate some random data to represent this problem:</p>
<pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="dv">1000</span>
n &lt;-<span class="st"> </span><span class="dv">50</span>
X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(m <span class="op">*</span><span class="st"> </span>n, <span class="dt">mean =</span> <span class="dv">10</span>, <span class="dt">sd =</span> <span class="dv">3</span>), <span class="dt">nrow =</span> m)
grp &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">each =</span> n <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)</code></pre>
<p>For data in this form, there are two ways to use <code>t.test()</code>. We can either use the formula interface or provide two vectors, one for each group. Timing reveals that the formula interface is considerably slower.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
    <span class="kw">t.test</span>(X[i, ] <span class="op">~</span><span class="st"> </span>grp)<span class="op">$</span>statistic
  }
)
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.876   0.000   0.879</span>
<span class="kw">system.time</span>(
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
    <span class="kw">t.test</span>(X[i, grp <span class="op">==</span><span class="st"> </span><span class="dv">1</span>], X[i, grp <span class="op">==</span><span class="st"> </span><span class="dv">2</span>])<span class="op">$</span>statistic
  }
)
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.196   0.000   0.200</span></code></pre>
<p>Of course, a for loop computes, but doesn’t save the values. We can <code>map_dbl()</code> (Section <a href="#map-atomic">9.2.1</a>) to do that. This adds a little overhead:</p>
<pre class="sourceCode r"><code class="sourceCode r">compT &lt;-<span class="st"> </span><span class="cf">function</span>(i){
  <span class="kw">t.test</span>(X[i, grp <span class="op">==</span><span class="st"> </span><span class="dv">1</span>], X[i, grp <span class="op">==</span><span class="st"> </span><span class="dv">2</span>])<span class="op">$</span>statistic
}
<span class="kw">system.time</span>(t1 &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">map_dbl</span>(<span class="dv">1</span><span class="op">:</span>m, compT))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.204   0.000   0.205</span></code></pre>
<p>How can we make this faster? First, we could try doing less work. If you look at the source code of <code>stats:::t.test.default()</code>, you’ll see that it does a lot more than just compute the t-statistic. It also computes the p-value and formats the output for printing. We can try to make our code faster by stripping out those pieces.</p>
<pre class="sourceCode r"><code class="sourceCode r">my_t &lt;-<span class="st"> </span><span class="cf">function</span>(x, grp) {
  t_stat &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
    m &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
    n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
    var &lt;-<span class="st"> </span><span class="kw">sum</span>((x <span class="op">-</span><span class="st"> </span>m) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>) <span class="op">/</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)

    <span class="kw">list</span>(<span class="dt">m =</span> m, <span class="dt">n =</span> n, <span class="dt">var =</span> var)
  }

  g1 &lt;-<span class="st"> </span><span class="kw">t_stat</span>(x[grp <span class="op">==</span><span class="st"> </span><span class="dv">1</span>])
  g2 &lt;-<span class="st"> </span><span class="kw">t_stat</span>(x[grp <span class="op">==</span><span class="st"> </span><span class="dv">2</span>])

  se_total &lt;-<span class="st"> </span><span class="kw">sqrt</span>(g1<span class="op">$</span>var <span class="op">/</span><span class="st"> </span>g1<span class="op">$</span>n <span class="op">+</span><span class="st"> </span>g2<span class="op">$</span>var <span class="op">/</span><span class="st"> </span>g2<span class="op">$</span>n)
  (g1<span class="op">$</span>m <span class="op">-</span><span class="st"> </span>g2<span class="op">$</span>m) <span class="op">/</span><span class="st"> </span>se_total
}

<span class="kw">system.time</span>(t2 &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw">map_dbl</span>(<span class="dv">1</span><span class="op">:</span>m, <span class="op">~</span><span class="st"> </span><span class="kw">my_t</span>(X[.,], grp)))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.028   0.000   0.029</span>
<span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(t1, t2))</code></pre>
<p>This gives us about a 6x speed improvement.</p>
<p>Now that we have a fairly simple function, we can make it faster still by vectorising it. Instead of looping over the array outside the function, we will modify <code>t_stat()</code> to work with a matrix of values. Thus, <code>mean()</code> becomes <code>rowMeans()</code>, <code>length()</code> becomes <code>ncol()</code>, and <code>sum()</code> becomes <code>rowSums()</code>. The rest of the code stays the same.</p>
<pre class="sourceCode r"><code class="sourceCode r">rowtstat &lt;-<span class="st"> </span><span class="cf">function</span>(X, grp){
  t_stat &lt;-<span class="st"> </span><span class="cf">function</span>(X) {
    m &lt;-<span class="st"> </span><span class="kw">rowMeans</span>(X)
    n &lt;-<span class="st"> </span><span class="kw">ncol</span>(X)
    var &lt;-<span class="st"> </span><span class="kw">rowSums</span>((X <span class="op">-</span><span class="st"> </span>m) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>) <span class="op">/</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)

    <span class="kw">list</span>(<span class="dt">m =</span> m, <span class="dt">n =</span> n, <span class="dt">var =</span> var)
  }

  g1 &lt;-<span class="st"> </span><span class="kw">t_stat</span>(X[, grp <span class="op">==</span><span class="st"> </span><span class="dv">1</span>])
  g2 &lt;-<span class="st"> </span><span class="kw">t_stat</span>(X[, grp <span class="op">==</span><span class="st"> </span><span class="dv">2</span>])

  se_total &lt;-<span class="st"> </span><span class="kw">sqrt</span>(g1<span class="op">$</span>var <span class="op">/</span><span class="st"> </span>g1<span class="op">$</span>n <span class="op">+</span><span class="st"> </span>g2<span class="op">$</span>var <span class="op">/</span><span class="st"> </span>g2<span class="op">$</span>n)
  (g1<span class="op">$</span>m <span class="op">-</span><span class="st"> </span>g2<span class="op">$</span>m) <span class="op">/</span><span class="st"> </span>se_total
}
<span class="kw">system.time</span>(t3 &lt;-<span class="st"> </span><span class="kw">rowtstat</span>(X, grp))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;   0.008   0.000   0.012</span>
<span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(t1, t3))</code></pre>
<p>That’s much faster! It’s at least 40x faster than our previous effort, and around 1000x faster than where we started.</p>
</div>
<div id="more-techniques" class="section level2">
<h2><span class="header-section-number">24.8</span> Other techniques</h2>
<p>Being able to write fast R code is part of being a good R programmer. Beyond the specific hints in this chapter, if you want to write fast R code, you’ll need to improve your general programming skills. Some ways to do this are to:</p>
<ul>
<li><p>Read R blogs<span id="fn177" class="footnote" data-pagedown-footnote-number="177" style="white-space: pre-line;"><a href="http://www.r-bloggers.com/" class="uri">http://www.r-bloggers.com/</a></span> to see what performance
problems other people have struggled with, and how they have made their
code faster.</p></li>
<li><p>Read other R programming books, like “The Art of R Programming”
<span class="citation">(Matloff <a href="#ref-art-r-prog">2011</a>)</span> or Patrick Burns’
<em>R Inferno</em><span id="fn178" class="footnote" data-pagedown-footnote-number="178" style="white-space: pre-line;"><a href="http://www.burns-stat.com/documents/books/the-r-inferno/" class="uri">http://www.burns-stat.com/documents/books/the-r-inferno/</a></span> to
learn about common traps.</p></li>
<li><p>Take an algorithms and data structure course to learn some
well known ways of tackling certain classes of problems. I have heard
good things about Princeton’s
Algorithms course<span id="fn179" class="footnote" data-pagedown-footnote-number="179" style="white-space: pre-line;"><a href="https://www.coursera.org/course/algs4partI" class="uri">https://www.coursera.org/course/algs4partI</a></span> offered on
Coursera.</p></li>
<li><p>Learn how to parallelise your code. Two places to start are
“Parallel R” <span class="citation">(McCallum and Weston <a href="#ref-parallel-r">2011</a>)</span> and “Parallel Computing for Data Science”
<span class="citation">(Matloff <a href="#ref-parcomp-ds">2015</a>)</span>.</p></li>
<li><p>Read general books about optimisation like “Mature optimisation” <span class="citation">(Bueno <a href="#ref-mature-opt">2013</a>)</span>
or the “Pragmatic Programmer” <span class="citation">(Hunt and Thomas <a href="#ref-pragprog">1990</a>)</span>.</p></li>
</ul>
<p>You can also reach out to the community for help. StackOverflow can be a useful resource. You’ll need to put some effort into creating an easily digestible example that also captures the salient features of your problem. If your example is too complex, few people will have the time and motivation to attempt a solution. If it’s too simple, you’ll get answers that solve the toy problem but not the real problem. If you also try to answer questions on StackOverflow, you’ll quickly get a feel for what makes a good question.</p>
<!--chapter:end:Perf-improve.Rmd-->
</div>
</div>
<div id="rcpp" class="section level1">
<h1><span class="header-section-number">25</span> Rewriting R code in C++</h1>
<div id="introduction-26" class="section level2">
<h2><span class="header-section-number">25.1</span> Introduction</h2>
<p>Sometimes R code just isn’t fast enough. You’ve used profiling to figure out where your bottlenecks are, and you’ve done everything you can in R, but your code still isn’t fast enough. In this chapter you’ll learn how to improve performance by rewriting key functions in C++. This magic comes by way of the Rcpp<span id="fn180" class="footnote" data-pagedown-footnote-number="180" style="white-space: pre-line;"><a href="http://www.rcpp.org/" class="uri">http://www.rcpp.org/</a></span> package <span class="citation">(Eddelbuettel and François <a href="#ref-Rcpp">2011</a>)</span> (with key contributions by Doug Bates, John Chambers, and JJ Allaire).</p>
<p>Rcpp makes it very simple to connect C++ to R. While it is <em>possible</em> to write C or Fortran code for use in R, it will be painful by comparison. Rcpp provides a clean, approachable API that lets you write high-performance code, insulated from R’s complex C API.  </p>
<p>Typical bottlenecks that C++ can address include:</p>
<ul>
<li><p>Loops that can’t be easily vectorised because subsequent iterations depend
on previous ones.</p></li>
<li><p>Recursive functions, or problems which involve calling functions millions of
times. The overhead of calling a function in C++ is much lower than in R.</p></li>
<li><p>Problems that require advanced data structures and algorithms that R doesn’t
provide. Through the standard template library (STL), C++ has efficient
implementations of many important data structures, from ordered maps to
double-ended queues.</p></li>
</ul>
<p>The aim of this chapter is to discuss only those aspects of C++ and Rcpp that are absolutely necessary to help you eliminate bottlenecks in your code. We won’t spend much time on advanced features like object oriented programming or templates because the focus is on writing small, self-contained functions, not big programs. A working knowledge of C++ is helpful, but not essential. Many good tutorials and references are freely available, including <a href="http://www.learncpp.com/" class="uri">http://www.learncpp.com/</a> and <a href="https://en.cppreference.com/w/cpp" class="uri">https://en.cppreference.com/w/cpp</a>. For more advanced topics, the <em>Effective C++</em> series by Scott Meyers is a popular choice.</p>
<div id="outline-23" class="section level3 unnumbered">
<h3>Outline</h3>
<ul>
<li><p>Section <a href="#rcpp-intro">25.2</a> teaches you how to write C++ by
converting simple R functions to their C++ equivalents. You’ll learn how
C++ differs from R, and what the key scalar, vector, and matrix classes
are called.</p></li>
<li><p>Section <a href="#sourceCpp">25.2.5</a> shows you how to use <code>sourceCpp()</code> to load
a C++ file from disk in the same way you use <code>source()</code> to load a file of
R code.</p></li>
<li><p>Section <a href="#rcpp-classes">25.3</a> discusses how to modify
attributes from Rcpp, and mentions some of the other important classes.</p></li>
<li><p>Section <a href="#rcpp-na">25.4</a> teaches you how to work with R’s missing values
in C++.</p></li>
<li><p>Section <a href="#stl">25.5</a> shows you how to use some of the most important data
structures and algorithms from the standard template library, or STL,
built-in to C++.</p></li>
<li><p>Section <a href="#rcpp-case-studies">25.6</a> shows two real case studies where
Rcpp was used to get considerable performance improvements.</p></li>
<li><p>Section <a href="#rcpp-package">25.7</a> teaches you how to add C++ code
to a package.</p></li>
<li><p>Section <a href="#rcpp-more">25.8</a> concludes the chapter with pointers to
more resources to help you learn Rcpp and C++.</p></li>
</ul>
</div>
<div id="prerequisites-17" class="section level3 unnumbered">
<h3>Prerequisites</h3>
<p>We’ll use Rcpp<span id="fn181" class="footnote" data-pagedown-footnote-number="181" style="white-space: pre-line;"><a href="http://www.rcpp.org/" class="uri">http://www.rcpp.org/</a></span> to call C++ from R:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(Rcpp)</code></pre>
<p>You’ll also need a working C++ compiler. To get it:</p>
<ul>
<li>On Windows, install Rtools<span id="fn182" class="footnote" data-pagedown-footnote-number="182" style="white-space: pre-line;"><a href="http://cran.r-project.org/bin/windows/Rtools/" class="uri">http://cran.r-project.org/bin/windows/Rtools/</a></span>.</li>
<li>On Mac, install Xcode from the app store.</li>
<li>On Linux, <code>sudo apt-get install r-base-dev</code> or similar.</li>
</ul>
</div>
</div>
<div id="rcpp-intro" class="section level2">
<h2><span class="header-section-number">25.2</span> Getting started with C++</h2>
<p><code>cppFunction()</code> allows you to write C++ functions in R: </p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cppFunction</span>(<span class="st">&#39;int add(int x, int y, int z) {</span>
<span class="st">  int sum = x + y + z;</span>
<span class="st">  return sum;</span>
<span class="st">}&#39;</span>)
<span class="co"># add works like a regular R function</span>
add
<span class="co">#&gt; function (x, y, z) </span>
<span class="co">#&gt; .Call(&lt;pointer: 0x7fa64801df60&gt;, x, y, z)</span>
<span class="kw">add</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
<span class="co">#&gt; [1] 6</span></code></pre>
<p>When you run this code, Rcpp will compile the C++ code and construct an R function that connects to the compiled C++ function. There’s a lot going on underneath the hood but Rcpp takes care of all the details so you don’t need to worry about it.</p>
<p>The following sections will teach you the basics by translating simple R functions to their C++ equivalents. We’ll start simple with a function that has no inputs and a scalar output, and then get progressively more complicated:</p>
<ul>
<li>Scalar input and scalar output</li>
<li>Vector input and scalar output</li>
<li>Vector input and vector output</li>
<li>Matrix input and vector output</li>
</ul>
<div id="no-inputs-scalar-output" class="section level3">
<h3><span class="header-section-number">25.2.1</span> No inputs, scalar output</h3>
<p>Let’s start with a very simple function. It has no arguments and always returns the integer 1:</p>
<pre class="sourceCode r"><code class="sourceCode r">one &lt;-<span class="st"> </span><span class="cf">function</span>() 1L</code></pre>
<p>The equivalent C++ function is:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> one() {
  <span class="cf">return</span> <span class="dv">1</span>;
}</code></pre>
<p>We can compile and use this from R with <code>cppFunction()</code></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cppFunction</span>(<span class="st">&#39;int one() {</span>
<span class="st">  return 1;</span>
<span class="st">}&#39;</span>)</code></pre>
<p>This small function illustrates a number of important differences between R and C++:</p>
<ul>
<li><p>The syntax to create a function looks like the syntax to call a function;
you don’t use assignment to create functions as you do in R.</p></li>
<li><p>You must declare the type of output the function returns. This function
returns an <code>int</code> (a scalar integer). The classes for the most common types
of R vectors are: <code>NumericVector</code>, <code>IntegerVector</code>, <code>CharacterVector</code>, and
<code>LogicalVector</code>.</p></li>
<li><p>Scalars and vectors are different. The scalar equivalents of numeric,
integer, character, and logical vectors are: <code>double</code>, <code>int</code>, <code>String</code>, and
<code>bool</code>.</p></li>
<li><p>You must use an explicit <code>return</code> statement to return a value from a
function.</p></li>
<li><p>Every statement is terminated by a <code>;</code>.</p></li>
</ul>
</div>
<div id="scalar-input-scalar-output" class="section level3">
<h3><span class="header-section-number">25.2.2</span> Scalar input, scalar output</h3>
<p>The next example function implements a scalar version of the <code>sign()</code> function which returns 1 if the input is positive, and -1 if it’s negative:</p>
<pre class="sourceCode r"><code class="sourceCode r">signR &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="dv">1</span>
  } <span class="cf">else</span> <span class="cf">if</span> (x <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="dv">0</span>
  } <span class="cf">else</span> {
    <span class="dv">-1</span>
  }
}

<span class="kw">cppFunction</span>(<span class="st">&#39;int signC(int x) {</span>
<span class="st">  if (x &gt; 0) {</span>
<span class="st">    return 1;</span>
<span class="st">  } else if (x == 0) {</span>
<span class="st">    return 0;</span>
<span class="st">  } else {</span>
<span class="st">    return -1;</span>
<span class="st">  }</span>
<span class="st">}&#39;</span>)</code></pre>
<p>In the C++ version:</p>
<ul>
<li><p>We declare the type of each input in the same way we declare the type of the
output. While this makes the code a little more verbose, it also makes it
very obvious what type of input the function needs.</p></li>
<li><p>The <code>if</code> syntax is identical — while there are some big differences between
R and C++, there are also lots of similarities! C++ also has a <code>while</code>
statement that works the same way as R’s. As in R you can use <code>break</code> to
exit the loop, but to skip one iteration you need to use <code>continue</code> instead
of <code>next</code>.</p></li>
</ul>
</div>
<div id="vector-input-scalar-output" class="section level3">
<h3><span class="header-section-number">25.2.3</span> Vector input, scalar output</h3>
<p>One big difference between R and C++ is that the cost of loops is much lower in C++. For example, we could implement the <code>sum</code> function in R using a loop. If you’ve been programming in R a while, you’ll probably have a visceral reaction to this function!</p>
<pre class="sourceCode r"><code class="sourceCode r">sumR &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  total &lt;-<span class="st"> </span><span class="dv">0</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
    total &lt;-<span class="st"> </span>total <span class="op">+</span><span class="st"> </span>x[i]
  }
  total
}</code></pre>
<p>In C++, loops have very little overhead, so it’s fine to use them. In Section <a href="#stl">25.5</a>, you’ll see alternatives to <code>for</code> loops that more clearly express your intent; they’re not faster, but they can make your code easier to understand.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cppFunction</span>(<span class="st">&#39;double sumC(NumericVector x) {</span>
<span class="st">  int n = x.size();</span>
<span class="st">  double total = 0;</span>
<span class="st">  for(int i = 0; i &lt; n; ++i) {</span>
<span class="st">    total += x[i];</span>
<span class="st">  }</span>
<span class="st">  return total;</span>
<span class="st">}&#39;</span>)</code></pre>
<p>The C++ version is similar, but:</p>
<ul>
<li><p>To find the length of the vector, we use the <code>.size()</code> method, which returns
an integer. C++ methods are called with <code>.</code> (i.e., a full stop).</p></li>
<li><p>The <code>for</code> statement has a different syntax: <code>for(init; check; increment)</code>.
This loop is initialised by creating a new variable called <code>i</code> with value 0.
Before each iteration we check that <code>i &lt; n</code>, and terminate the loop if it’s
not. After each iteration, we increment the value of <code>i</code> by one, using the
special prefix operator <code>++</code> which increases the value of <code>i</code> by 1.</p></li>
<li><p>In C++, vector indices start at 0, which means that the last element is
at position <code>n - 1</code>. I’ll say this again because it’s so important:
<strong>IN C++, VECTOR INDICES START AT 0</strong>! This is a very common
source of bugs when converting R functions to C++.</p></li>
<li><p>Use <code>=</code> for assignment, not <code>&lt;-</code>.</p></li>
<li><p>C++ provides operators that modify in-place: <code>total += x[i]</code> is equivalent to
<code>total = total + x[i]</code>. Similar in-place operators are <code>-=</code>, <code>*=</code>, and <code>/=</code>.</p></li>
</ul>
<p>This is a good example of where C++ is much more efficient than R. As shown by the following microbenchmark, <code>sumC()</code> is competitive with the built-in (and highly optimised) <code>sum()</code>, while <code>sumR()</code> is several orders of magnitude slower.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>)
bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">sum</span>(x),
  <span class="kw">sumC</span>(x),
  <span class="kw">sumR</span>(x)
)[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]
<span class="co">#&gt; # A tibble: 3 x 6</span>
<span class="co">#&gt;   expression      min     mean   median      max `itr/sec`</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1 sum(x)       1.31µs   1.55µs   1.33µs     89µs   645441.</span>
<span class="co">#&gt; 2 sumC(x)      3.25µs   4.73µs   4.81µs   1.08ms   211326.</span>
<span class="co">#&gt; 3 sumR(x)     38.77µs  41.02µs   39.6µs  133.8µs    24377.</span></code></pre>
</div>
<div id="vector-input-vector-output" class="section level3">
<h3><span class="header-section-number">25.2.4</span> Vector input, vector output</h3>
<!-- FIXME: come up with better example. Also fix in two other places it occurs -->
<p>Next we’ll create a function that computes the Euclidean distance between a value and a vector of values:</p>
<pre class="sourceCode r"><code class="sourceCode r">pdistR &lt;-<span class="st"> </span><span class="cf">function</span>(x, ys) {
  <span class="kw">sqrt</span>((x <span class="op">-</span><span class="st"> </span>ys) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>)
}</code></pre>
<p>In R, it’s not obvious that we want <code>x</code> to be a scalar from the function definition, and we’d need to make that clear in the documentation. That’s not a problem in the C++ version because we have to be explicit about types:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cppFunction</span>(<span class="st">&#39;NumericVector pdistC(double x, NumericVector ys) {</span>
<span class="st">  int n = ys.size();</span>
<span class="st">  NumericVector out(n);</span>

<span class="st">  for(int i = 0; i &lt; n; ++i) {</span>
<span class="st">    out[i] = sqrt(pow(ys[i] - x, 2.0));</span>
<span class="st">  }</span>
<span class="st">  return out;</span>
<span class="st">}&#39;</span>)</code></pre>
<p>This function introduces only a few new concepts:</p>
<ul>
<li><p>We create a new numeric vector of length <code>n</code> with a constructor:
<code>NumericVector out(n)</code>. Another useful way of making a vector is to copy an
existing one: <code>NumericVector zs = clone(ys)</code>.</p></li>
<li><p>C++ uses <code>pow()</code>, not <code>^</code>, for exponentiation.</p></li>
</ul>
<p>Note that because the R version is fully vectorised, it’s already going to be fast.</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e6</span>)
bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">pdistR</span>(<span class="fl">0.5</span>, y),
  <span class="kw">pdistC</span>(<span class="fl">0.5</span>, y)
)[<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>]
<span class="co">#&gt; # A tibble: 2 x 6</span>
<span class="co">#&gt;   expression          min     mean   median      max `itr/sec`</span>
<span class="co">#&gt;   &lt;chr&gt;          &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1 pdistR(0.5, y)   8.76ms    9.3ms   9.07ms  11.94ms      107.</span>
<span class="co">#&gt; 2 pdistC(0.5, y)   4.83ms   5.02ms   4.92ms   5.37ms      199.</span></code></pre>
<p>On my computer, it takes around 5 ms with a 1 million element <code>y</code> vector. The C++ function is about 2.5x faster, ~2 ms, but assuming it took you 10 minutes to write the C++ function, you’d need to run it ~200,000 times to make rewriting worthwhile. The reason why the C++ function is faster is subtle, and relates to memory management. The R version needs to create an intermediate vector the same length as y (<code>x - ys</code>), and allocating memory is an expensive operation. The C++ function avoids this overhead because it uses an intermediate scalar.</p>
</div>
<div id="sourceCpp" class="section level3">
<h3><span class="header-section-number">25.2.5</span> Using sourceCpp</h3>
<p>So far, we’ve used inline C++ with <code>cppFunction()</code>. This makes presentation simpler, but for real problems, it’s usually easier to use stand-alone C++ files and then source them into R using <code>sourceCpp()</code>. This lets you take advantage of text editor support for C++ files (e.g., syntax highlighting) as well as making it easier to identify the line numbers in compilation errors. </p>
<p>Your stand-alone C++ file should have extension <code>.cpp</code>, and needs to start with:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;</code></pre>
<p>And for each function that you want available within R, you need to prefix it with:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::export]]</span></code></pre>
<div class="sidebar">
<p>If you’re familiar with roxygen2, you might wonder how this relates to <code>@export</code>. <code>Rcpp::export</code> controls whether a function is exported from C++ to R; <code>@export</code> controls whether a function is exported from a package and made available to the user.</p>
</div>
<p>You can embed R code in special C++ comment blocks. This is really convenient if you want to run some test code:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/*** R</span>
<span class="co"># This is R code</span>
<span class="co">*/</span></code></pre>
<p>The R code is run with <code>source(echo = TRUE)</code> so you don’t need to explicitly print output.</p>
<p>To compile the C++ code, use <code>sourceCpp(&quot;path/to/file.cpp&quot;)</code>. This will create the matching R functions and add them to your current session. Note that these functions can not be saved in a <code>.Rdata</code> file and reloaded in a later session; they must be recreated each time you restart R.</p>
<p>For example, running <code>sourceCpp()</code> on the following file implements mean in C++ and then compares it to the built-in <code>mean()</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">double</span> meanC(NumericVector x) {
  <span class="dt">int</span> n = x.size();
  <span class="dt">double</span> total = <span class="dv">0</span>;

  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    total += x[i];
  }
  <span class="cf">return</span> total / n;
}

<span class="co">/*** R</span>
<span class="co">x &lt;- runif(1e5)</span>
<span class="co">bench::mark(</span>
<span class="co">  mean(x),</span>
<span class="co">  meanC(x)</span>
<span class="co">)</span>
<span class="co">*/</span></code></pre>
<p>NB: if you run this code yourself, you’ll notice that <code>meanC()</code> is much faster than the built-in <code>mean()</code>. This is because it trades numerical accuracy for speed.</p>
<p>For the remainder of this chapter C++ code will be presented stand-alone rather than wrapped in a call to <code>cppFunction</code>. If you want to try compiling and/or modifying the examples you should paste them into a C++ source file that includes the elements described above. This is easy to do in RMarkdown: all you need to do is specify <code>engine = &quot;Rcpp&quot;</code>.</p>
</div>
<div id="exercises-73" class="section level3">
<h3><span class="header-section-number">25.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>With the basics of C++ in hand, it’s now a great time to practice by reading
and writing some simple C++ functions. For each of the following functions,
read the code and figure out what the corresponding base R function is. You
might not understand every part of the code yet, but you should be able to
figure out the basics of what the function does.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> f1(NumericVector x) {
  <span class="dt">int</span> n = x.size();
  <span class="dt">double</span> y = <span class="dv">0</span>;

  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    y += x[i] / n;
  }
  <span class="cf">return</span> y;
}

NumericVector f2(NumericVector x) {
  <span class="dt">int</span> n = x.size();
  NumericVector out(n);

  out[<span class="dv">0</span>] = x[<span class="dv">0</span>];
  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; ++i) {
    out[i] = out[i - <span class="dv">1</span>] + x[i];
  }
  <span class="cf">return</span> out;
}

<span class="dt">bool</span> f3(LogicalVector x) {
  <span class="dt">int</span> n = x.size();

  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    <span class="cf">if</span> (x[i]) <span class="cf">return</span> <span class="kw">true</span>;
  }
  <span class="cf">return</span> <span class="kw">false</span>;
}

<span class="dt">int</span> f4(Function pred, List x) {
  <span class="dt">int</span> n = x.size();

  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    LogicalVector res = pred(x[i]);
    <span class="cf">if</span> (res[<span class="dv">0</span>]) <span class="cf">return</span> i + <span class="dv">1</span>;
  }
  <span class="cf">return</span> <span class="dv">0</span>;
}

NumericVector f5(NumericVector x, NumericVector y) {
  <span class="dt">int</span> n = <span class="bu">std::</span>max(x.size(), y.size());
  NumericVector x1 = rep_len(x, n);
  NumericVector y1 = rep_len(y, n);

  NumericVector out(n);

  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    out[i] = <span class="bu">std::</span>min(x1[i], y1[i]);
  }

  <span class="cf">return</span> out;
}</code></pre></li>
<li><p>To practice your function writing skills, convert the following functions
into C++. For now, assume the inputs have no missing values.</p>
<ol style="list-style-type: decimal">
<li><p><code>all()</code></p></li>
<li><p><code>cumprod()</code>, <code>cummin()</code>, <code>cummax()</code>.</p></li>
<li><p><code>diff()</code>. Start by assuming lag 1, and then generalise for lag <code>n</code>.</p></li>
<li><p><code>range()</code>.</p></li>
<li><p><code>var()</code>. Read about the approaches you can take on
wikipedia<span id="fn183" class="footnote" data-pagedown-footnote-number="183" style="white-space: pre-line;"><a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance" class="uri">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a></span>.
Whenever implementing a numerical algorithm, it’s always good to check
what is already known about the problem.</p></li>
</ol></li>
</ol>
</div>
</div>
<div id="rcpp-classes" class="section level2">
<h2><span class="header-section-number">25.3</span> Other classes</h2>
<p>You’ve already seen the basic vector classes (<code>IntegerVector</code>, <code>NumericVector</code>, <code>LogicalVector</code>, <code>CharacterVector</code>) and their scalar (<code>int</code>, <code>double</code>, <code>bool</code>, <code>String</code>) equivalents. Rcpp also provides wrappers for all other base data types. The most important are for lists and data frames, functions, and attributes, as described below. Rcpp also provides classes for more types like <code>Environment</code>, <code>DottedPair</code>, <code>Language</code>, <code>Symbol</code>, etc, but these are beyond the scope of this chapter.</p>
<div id="lists-and-data-frames" class="section level3">
<h3><span class="header-section-number">25.3.1</span> Lists and data frames</h3>
<p>Rcpp also provides <code>List</code> and <code>DataFrame</code> classes, but they are more useful for output than input. This is because lists and data frames can contain arbitrary classes but C++ needs to know their classes in advance. If the list has known structure (e.g., it’s an S3 object), you can extract the components and manually convert them to their C++ equivalents with <code>as()</code>. For example, the object created by <code>lm()</code>, the function that fits a linear model, is a list whose components are always of the same type. The following code illustrates how you might extract the mean percentage error (<code>mpe()</code>) of a linear model. This isn’t a good example of when to use C++, because it’s so easily implemented in R, but it shows how to work with an important S3 class. Note the use of <code>.inherits()</code> and the <code>stop()</code> to check that the object really is a linear model.  </p>
<!-- FIXME: needs better motivation -->
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">double</span> mpe(List mod) {
  <span class="cf">if</span> (!mod.inherits(<span class="st">&quot;lm&quot;</span>)) stop(<span class="st">&quot;Input must be a linear model&quot;</span>);

  NumericVector resid = as&lt;NumericVector&gt;(mod[<span class="st">&quot;residuals&quot;</span>]);
  NumericVector fitted = as&lt;NumericVector&gt;(mod[<span class="st">&quot;fitted.values&quot;</span>]);

  <span class="dt">int</span> n = resid.size();
  <span class="dt">double</span> err = <span class="dv">0</span>;
  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    err += resid[i] / (fitted[i] + resid[i]);
  }
  <span class="cf">return</span> err / n;
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> mtcars)
<span class="kw">mpe</span>(mod)
<span class="co">#&gt; [1] -0.0154</span></code></pre>
</div>
<div id="functions-rcpp" class="section level3">
<h3><span class="header-section-number">25.3.2</span> Functions</h3>
<p></p>
<p>You can put R functions in an object of type <code>Function</code>. This makes calling an R function from C++ straightforward. The only challenge is that we don’t know what type of output the function will return, so we use the catchall type <code>RObject</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
RObject callWithOne(Function f) {
  <span class="cf">return</span> f(<span class="dv">1</span>);
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">callWithOne</span>(<span class="cf">function</span>(x) x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; [1] 2</span>
<span class="kw">callWithOne</span>(paste)
<span class="co">#&gt; [1] &quot;1&quot;</span></code></pre>
<p>Calling R functions with positional arguments is obvious:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">f(<span class="st">&quot;y&quot;</span>, <span class="dv">1</span>);</code></pre>
<p>But you need a special syntax for named arguments:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">f(_[<span class="st">&quot;x&quot;</span>] = <span class="st">&quot;y&quot;</span>, _[<span class="st">&quot;value&quot;</span>] = <span class="dv">1</span>);</code></pre>
</div>
<div id="attributes-1" class="section level3">
<h3><span class="header-section-number">25.3.3</span> Attributes</h3>
<p></p>
<p>All R objects have attributes, which can be queried and modified with <code>.attr()</code>. Rcpp also provides <code>.names()</code> as an alias for the name attribute. The following code snippet illustrates these methods. Note the use of <code>::create()</code>, a <em>class</em> method. This allows you to create an R vector from C++ scalar values:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
NumericVector attribs() {
  NumericVector out = NumericVector::create(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);

  out.names() = CharacterVector::create(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>);
  out.attr(<span class="st">&quot;my-attr&quot;</span>) = <span class="st">&quot;my-value&quot;</span>;
  out.attr(<span class="st">&quot;class&quot;</span>) = <span class="st">&quot;my-class&quot;</span>;

  <span class="cf">return</span> out;
}</code></pre>
<p>For S4 objects, <code>.slot()</code> plays a similar role to <code>.attr()</code>.</p>
</div>
</div>
<div id="rcpp-na" class="section level2">
<h2><span class="header-section-number">25.4</span> Missing values</h2>

<p>If you’re working with missing values, you need to know two things:</p>
<ul>
<li>How R’s missing values behave in C++’s scalars (e.g., <code>double</code>).</li>
<li>How to get and set missing values in vectors (e.g., <code>NumericVector</code>).</li>
</ul>
<div id="scalars-1" class="section level3">
<h3><span class="header-section-number">25.4.1</span> Scalars</h3>
<p>The following code explores what happens when you take one of R’s missing values, coerce it into a scalar, and then coerce back to an R vector. Note that this kind of experimentation is a useful way to figure out what any operation does.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
List scalar_missings() {
  <span class="dt">int</span> int_s = NA_INTEGER;
  String chr_s = NA_STRING;
  <span class="dt">bool</span> lgl_s = NA_LOGICAL;
  <span class="dt">double</span> num_s = NA_REAL;

  <span class="cf">return</span> List::create(int_s, chr_s, lgl_s, num_s);
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">scalar_missings</span>())
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ : int NA</span>
<span class="co">#&gt;  $ : chr NA</span>
<span class="co">#&gt;  $ : logi TRUE</span>
<span class="co">#&gt;  $ : num NA</span></code></pre>
<p>With the exception of <code>bool</code>, things look pretty good here: all of the missing values have been preserved. However, as we’ll see in the following sections, things are not quite as straightforward as they seem.</p>
<div id="integers" class="section level4">
<h4><span class="header-section-number">25.4.1.1</span> Integers</h4>
<p>With integers, missing values are stored as the smallest integer. If you don’t do anything to them, they’ll be preserved. But, since C++ doesn’t know that the smallest integer has this special behaviour, if you do anything to it you’re likely to get an incorrect value: for example, <code>evalCpp('NA_INTEGER + 1')</code> gives -2147483647.</p>
<p>So if you want to work with missing values in integers, either use a length one <code>IntegerVector</code> or be very careful with your code.</p>
</div>
<div id="doubles" class="section level4">
<h4><span class="header-section-number">25.4.1.2</span> Doubles</h4>
<p>With doubles, you may be able to get away with ignoring missing values and working with NaNs (not a number). This is because R’s NA is a special type of IEEE 754 floating point number NaN. So any logical expression that involves a NaN (or in C++, NAN) always evaluates as FALSE:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">evalCpp</span>(<span class="st">&quot;NAN == 1&quot;</span>)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN &lt; 1&quot;</span>)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN &gt; 1&quot;</span>)
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN == NAN&quot;</span>)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>(Here I’m using <code>evalCpp()</code> which allows you to see the result of running a single C++ expression, making it excellent for this sort of interactive experimentation.)</p>
<p>But be careful when combining them with boolean values:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">evalCpp</span>(<span class="st">&quot;NAN &amp;&amp; TRUE&quot;</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN || FALSE&quot;</span>)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>However, in numeric contexts NaNs will propagate NAs:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">evalCpp</span>(<span class="st">&quot;NAN + 1&quot;</span>)
<span class="co">#&gt; [1] NaN</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN - 1&quot;</span>)
<span class="co">#&gt; [1] NaN</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN / 1&quot;</span>)
<span class="co">#&gt; [1] NaN</span>
<span class="kw">evalCpp</span>(<span class="st">&quot;NAN * 1&quot;</span>)
<span class="co">#&gt; [1] NaN</span></code></pre>
</div>
</div>
<div id="strings" class="section level3">
<h3><span class="header-section-number">25.4.2</span> Strings</h3>
<p><code>String</code> is a scalar string class introduced by Rcpp, so it knows how to deal with missing values.</p>
</div>
<div id="boolean" class="section level3">
<h3><span class="header-section-number">25.4.3</span> Boolean</h3>
<p>While C++’s <code>bool</code> has two possible values (<code>true</code> or <code>false</code>), a logical vector in R has three (<code>TRUE</code>, <code>FALSE</code>, and <code>NA</code>). If you coerce a length 1 logical vector, make sure it doesn’t contain any missing values otherwise they will be converted to TRUE. An easy fix is to use <code>int</code> instead, as this can represent <code>TRUE</code>, <code>FALSE</code>, and <code>NA</code>.</p>
</div>
<div id="vectors-rcpp" class="section level3">
<h3><span class="header-section-number">25.4.4</span> Vectors</h3>
<p>With vectors, you need to use a missing value specific to the type of vector, <code>NA_REAL</code>, <code>NA_INTEGER</code>, <code>NA_LOGICAL</code>, <code>NA_STRING</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
List missing_sampler() {
  <span class="cf">return</span> List::create(
    NumericVector::create(NA_REAL),
    IntegerVector::create(NA_INTEGER),
    LogicalVector::create(NA_LOGICAL),
    CharacterVector::create(NA_STRING)
  );
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">missing_sampler</span>())
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ : num NA</span>
<span class="co">#&gt;  $ : int NA</span>
<span class="co">#&gt;  $ : logi NA</span>
<span class="co">#&gt;  $ : chr NA</span></code></pre>
<p>To check if a value in a vector is missing, use the class method <code>::is_na()</code>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
LogicalVector is_naC(NumericVector x) {
  <span class="dt">int</span> n = x.size();
  LogicalVector out(n);

  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    out[i] = NumericVector::is_na(x[i]);
  }
  <span class="cf">return</span> out;
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is_naC</span>(<span class="kw">c</span>(<span class="ot">NA</span>, <span class="fl">5.4</span>, <span class="fl">3.2</span>, <span class="ot">NA</span>))
<span class="co">#&gt; [1]  TRUE FALSE FALSE  TRUE</span></code></pre>
<p>Another alternative is the sugar function <code>is_na()</code>, which takes a vector and returns a logical vector.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
LogicalVector is_naC2(NumericVector x) {
  <span class="cf">return</span> is_na(x);
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is_naC2</span>(<span class="kw">c</span>(<span class="ot">NA</span>, <span class="fl">5.4</span>, <span class="fl">3.2</span>, <span class="ot">NA</span>))
<span class="co">#&gt; [1]  TRUE FALSE FALSE  TRUE</span></code></pre>
</div>
<div id="exercises-74" class="section level3">
<h3><span class="header-section-number">25.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Rewrite any of the functions from the first exercise to deal with missing
values. If <code>na.rm</code> is true, ignore the missing values. If <code>na.rm</code> is false,
return a missing value if the input contains any missing values. Some
good functions to practice with are <code>min()</code>, <code>max()</code>, <code>range()</code>, <code>mean()</code>,
and <code>var()</code>.</p></li>
<li><p>Rewrite <code>cumsum()</code> and <code>diff()</code> so they can handle missing values. Note that
these functions have slightly more complicated behaviour.</p></li>
</ol>
</div>
</div>
<div id="stl" class="section level2">
<h2><span class="header-section-number">25.5</span> The STL</h2>
<p>The real strength of C++ shows itself when you need to implement more complex algorithms. The standard template library (STL) provides a set of extremely useful data structures and algorithms. This section will explain some of the most important algorithms and data structures and point you in the right direction to learn more. I can’t teach you everything you need to know about the STL, but hopefully the examples will show you the power of the STL, and persuade you that it’s useful to learn more. </p>
<p>If you need an algorithm or data structure that isn’t implemented in STL, a good place to look is boost<span id="fn184" class="footnote" data-pagedown-footnote-number="184" style="white-space: pre-line;"><a href="http://www.boost.org/doc/" class="uri">http://www.boost.org/doc/</a></span>. Installing boost on your computer is beyond the scope of this chapter, but once you have it installed, you can use boost data structures and algorithms by including the appropriate header file with (e.g.) <code>#include &lt;boost/array.hpp&gt;</code>.</p>
<div id="using-iterators" class="section level3">
<h3><span class="header-section-number">25.5.1</span> Using iterators</h3>
<p>Iterators are used extensively in the STL: many functions either accept or return iterators. They are the next step up from basic loops, abstracting away the details of the underlying data structure. Iterators have three main operators: </p>
<ol style="list-style-type: decimal">
<li>Advance with <code>++</code>.</li>
<li>Get the value they refer to, or <strong>dereference</strong>, with <code>*</code>.</li>
<li>Compare with <code>==</code>.</li>
</ol>
<p>For example we could re-write our sum function using iterators:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">double</span> sum3(NumericVector x) {
  <span class="dt">double</span> total = <span class="dv">0</span>;
  
  NumericVector::iterator it;
  <span class="cf">for</span>(it = x.begin(); it != x.end(); ++it) {
    total += *it;
  }
  <span class="cf">return</span> total;
}</code></pre>
<p>The main changes are in the for loop:</p>
<ul>
<li><p>We start at <code>x.begin()</code> and loop until we get to <code>x.end()</code>. A small
optimization is to store the value of the end iterator so we don’t need to
look it up each time. This only saves about 2 ns per iteration, so it’s only
important when the calculations in the loop are very simple.</p></li>
<li><p>Instead of indexing into x, we use the dereference operator to get its
current value: <code>*it</code>.</p></li>
<li><p>Notice the type of the iterator: <code>NumericVector::iterator</code>. Each vector
type has its own iterator type: <code>LogicalVector::iterator</code>,
<code>CharacterVector::iterator</code>, etc.</p></li>
</ul>
<p>This code can be simplified still further through the use of a C++11 feature: range-based for loops. C++11 is widely available, and can easily be activated for use with Rcpp by adding <code>[[Rcpp::plugins(cpp11)]]</code>.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::plugins(cpp11)]]</span>
<span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">double</span> sum4(NumericVector xs) {
  <span class="dt">double</span> total = <span class="dv">0</span>;
  
  <span class="cf">for</span>(<span class="at">const</span> <span class="kw">auto</span> &amp;x : xs) {
    total += x;
  }
  <span class="cf">return</span> total;
}</code></pre>
<p>Iterators also allow us to use the C++ equivalents of the apply family of functions. For example, we could again rewrite <code>sum()</code> to use the <code>accumulate()</code> function, which takes a starting and an ending iterator, and adds up all the values in the vector. The third argument to accumulate gives the initial value: it’s particularly important because this also determines the data type that accumulate uses (so we use <code>0.0</code> and not <code>0</code> so that accumulate uses a <code>double</code>, not an <code>int</code>.). To use <code>accumulate()</code> we need to include the <code>&lt;numeric&gt;</code> header.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span>
<span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
<span class="dt">double</span> sum5(NumericVector x) {
  <span class="cf">return</span> <span class="bu">std::</span>accumulate(x.begin(), x.end(), <span class="fl">0.0</span>);
}</code></pre>
</div>
<div id="algorithms" class="section level3">
<h3><span class="header-section-number">25.5.2</span> Algorithms</h3>
<p>The <code>&lt;algorithm&gt;</code> header provides a large number of algorithms that work with iterators. A good reference is available at <a href="https://en.cppreference.com/w/cpp/algorithm" class="uri">https://en.cppreference.com/w/cpp/algorithm</a>. For example, we could write a basic Rcpp version of <code>findInterval()</code> that takes two arguments a vector of values and a vector of breaks, and locates the bin that each x falls into. This shows off a few more advanced iterator features. Read the code below and see if you can figure out how it works. </p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span>
<span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
IntegerVector findInterval2(NumericVector x, NumericVector breaks) {
  IntegerVector out(x.size());

  NumericVector::iterator it, pos;
  IntegerVector::iterator out_it;

  <span class="cf">for</span>(it = x.begin(), out_it = out.begin(); it != x.end(); 
      ++it, ++out_it) {
    pos = <span class="bu">std::</span>upper_bound(breaks.begin(), breaks.end(), *it);
    *out_it = <span class="bu">std::</span>distance(breaks.begin(), pos);
  }

  <span class="cf">return</span> out;
}</code></pre>
<p>The key points are:</p>
<ul>
<li><p>We step through two iterators (input and output) simultaneously.</p></li>
<li><p>We can assign into an dereferenced iterator (<code>out_it</code>) to change the values
in <code>out</code>.</p></li>
<li><p><code>upper_bound()</code> returns an iterator. If we wanted the value of the
<code>upper_bound()</code> we could dereference it; to figure out its location, we
use the <code>distance()</code> function.</p></li>
<li><p>Small note: if we want this function to be as fast as <code>findInterval()</code> in R
(which uses handwritten C code), we need to compute the calls to <code>.begin()</code>
and <code>.end()</code> once and save the results. This is easy, but it distracts from
this example so it has been omitted. Making this change yields a function
that’s slightly faster than R’s <code>findInterval()</code> function, but is about 1/10
of the code.</p></li>
</ul>
<p>It’s generally better to use algorithms from the STL than hand rolled loops. In <em>Effective STL</em>, Scott Meyers gives three reasons: efficiency, correctness, and maintainability. Algorithms from the STL are written by C++ experts to be extremely efficient, and they have been around for a long time so they are well tested. Using standard algorithms also makes the intent of your code more clear, helping to make it more readable and more maintainable.</p>
</div>
<div id="data-structures-rcpp" class="section level3">
<h3><span class="header-section-number">25.5.3</span> Data structures</h3>
<p>The STL provides a large set of data structures: <code>array</code>, <code>bitset</code>, <code>list</code>, <code>forward_list</code>, <code>map</code>, <code>multimap</code>, <code>multiset</code>, <code>priority_queue</code>, <code>queue</code>, <code>deque</code>, <code>set</code>, <code>stack</code>, <code>unordered_map</code>, <code>unordered_set</code>, <code>unordered_multimap</code>, <code>unordered_multiset</code>, and <code>vector</code>. The most important of these data structures are the <code>vector</code>, the <code>unordered_set</code>, and the <code>unordered_map</code>. We’ll focus on these three in this section, but using the others is similar: they just have different performance trade-offs. For example, the <code>deque</code> (pronounced “deck”) has a very similar interface to vectors but a different underlying implementation that has different performance trade-offs. You may want to try them for your problem. A good reference for STL data structures is <a href="https://en.cppreference.com/w/cpp/container" class="uri">https://en.cppreference.com/w/cpp/container</a> — I recommend you keep it open while working with the STL.</p>
<p>Rcpp knows how to convert from many STL data structures to their R equivalents, so you can return them from your functions without explicitly converting to R data structures.</p>
</div>
<div id="vectors-stl" class="section level3">
<h3><span class="header-section-number">25.5.4</span> Vectors</h3>
<p>An STL vector is very similar to an R vector, except that it grows efficiently. This makes vectors appropriate to use when you don’t know in advance how big the output will be. Vectors are templated, which means that you need to specify the type of object the vector will contain when you create it: <code>vector&lt;int&gt;</code>, <code>vector&lt;bool&gt;</code>, <code>vector&lt;double&gt;</code>, <code>vector&lt;String&gt;</code>. You can access individual elements of a vector using the standard <code>[]</code> notation, and you can add a new element to the end of the vector using <code>.push_back()</code>. If you have some idea in advance how big the vector will be, you can use <code>.reserve()</code> to allocate sufficient storage. </p>
<p>The following code implements run length encoding (<code>rle()</code>). It produces two vectors of output: a vector of values, and a vector <code>lengths</code> giving how many times each element is repeated. It works by looping through the input vector <code>x</code> comparing each value to the previous: if it’s the same, then it increments the last value in <code>lengths</code>; if it’s different, it adds the value to the end of <code>values</code>, and sets the corresponding length to 1.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
List rleC(NumericVector x) {
  <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; lengths;
  <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; values;

  <span class="co">// Initialise first value</span>
  <span class="dt">int</span> i = <span class="dv">0</span>;
  <span class="dt">double</span> prev = x[<span class="dv">0</span>];
  values.push_back(prev);
  lengths.push_back(<span class="dv">1</span>);

  NumericVector::iterator it;
  <span class="cf">for</span>(it = x.begin() + <span class="dv">1</span>; it != x.end(); ++it) {
    <span class="cf">if</span> (prev == *it) {
      lengths[i]++;
    } <span class="cf">else</span> {
      values.push_back(*it);
      lengths.push_back(<span class="dv">1</span>);

      i++;
      prev = *it;
    }
  }

  <span class="cf">return</span> List::create(
    _[<span class="st">&quot;lengths&quot;</span>] = lengths, 
    _[<span class="st">&quot;values&quot;</span>] = values
  );
}</code></pre>
<p>(An alternative implementation would be to replace <code>i</code> with the iterator <code>lengths.rbegin()</code> which always points to the last element of the vector. You might want to try implementing that yourself.)</p>
<p>Other methods of a vector are described at <a href="https://en.cppreference.com/w/cpp/container/vector" class="uri">https://en.cppreference.com/w/cpp/container/vector</a>.</p>
</div>
<div id="sets" class="section level3">
<h3><span class="header-section-number">25.5.5</span> Sets</h3>
<p>Sets maintain a unique set of values, and can efficiently tell if you’ve seen a value before. They are useful for problems that involve duplicates or unique values (like <code>unique</code>, <code>duplicated</code>, or <code>in</code>). C++ provides both ordered (<code>std::set</code>) and unordered sets (<code>std::unordered_set</code>), depending on whether or not order matters for you. Unordered sets tend to be much faster (because they use a hash table internally rather than a tree), so even if you need an ordered set, you should consider using an unordered set and then sorting the output. Like vectors, sets are templated, so you need to request the appropriate type of set for your purpose: <code>unordered_set&lt;int&gt;</code>, <code>unordered_set&lt;bool&gt;</code>, etc. More details are available at <a href="https://en.cppreference.com/w/cpp/container/set" class="uri">https://en.cppreference.com/w/cpp/container/set</a> and <a href="https://en.cppreference.com/w/cpp/container/unordered_set" class="uri">https://en.cppreference.com/w/cpp/container/unordered_set</a>. </p>
<p>The following function uses an unordered set to implement an equivalent to <code>duplicated()</code> for integer vectors. Note the use of <code>seen.insert(x[i]).second</code>. <code>insert()</code> returns a pair, the <code>.first</code> value is an iterator that points to element and the <code>.second</code> value is a boolean that’s true if the value was a new addition to the set.</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::plugins(cpp11)]]</span>
<span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
LogicalVector duplicatedC(IntegerVector x) {
  <span class="bu">std::</span>unordered_set&lt;<span class="dt">int</span>&gt; seen;
  <span class="dt">int</span> n = x.size();
  LogicalVector out(n);

  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    out[i] = !seen.insert(x[i]).second;
  }

  <span class="cf">return</span> out;
}</code></pre>
</div>
<div id="map-1" class="section level3">
<h3><span class="header-section-number">25.5.6</span> Map</h3>
<p></p>
<p>A map is similar to a set, but instead of storing presence or absence, it can store additional data. It’s useful for functions like <code>table()</code> or <code>match()</code> that need to look up a value. As with sets, there are ordered (<code>std::map</code>) and unordered (<code>std::unordered_map</code>) versions. Since maps have a value and a key, you need to specify both types when initialising a map: <code>map&lt;double, int&gt;</code>, <code>unordered_map&lt;int, double&gt;</code>, and so on. The following example shows how you could use a <code>map</code> to implement <code>table()</code> for numeric vectors:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
<span class="bu">std::</span>map&lt;<span class="dt">double</span>, <span class="dt">int</span>&gt; tableC(NumericVector x) {
  <span class="bu">std::</span>map&lt;<span class="dt">double</span>, <span class="dt">int</span>&gt; counts;

  <span class="dt">int</span> n = x.size();
  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {
    counts[x[i]]++;
  }

  <span class="cf">return</span> counts;
}</code></pre>
</div>
<div id="exercises-75" class="section level3">
<h3><span class="header-section-number">25.5.7</span> Exercises</h3>
<p>To practice using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:</p>
<ol style="list-style-type: decimal">
<li><p><code>median.default()</code> using <code>partial_sort</code>.</p></li>
<li><p><code>%in%</code> using <code>unordered_set</code> and the <code>find()</code> or <code>count()</code> methods.</p></li>
<li><p><code>unique()</code> using an <code>unordered_set</code> (challenge: do it in one line!).</p></li>
<li><p><code>min()</code> using <code>std::min()</code>, or <code>max()</code> using <code>std::max()</code>.</p></li>
<li><p><code>which.min()</code> using <code>min_element</code>, or <code>which.max()</code> using <code>max_element</code>.</p></li>
<li><p><code>setdiff()</code>, <code>union()</code>, and <code>intersect()</code> for integers using sorted ranges
and <code>set_union</code>, <code>set_intersection</code> and <code>set_difference</code>.</p></li>
</ol>
</div>
</div>
<div id="rcpp-case-studies" class="section level2">
<h2><span class="header-section-number">25.6</span> Case studies</h2>
<p>The following case studies illustrate some real life uses of C++ to replace slow R code.</p>
<div id="gibbs-sampler" class="section level3">
<h3><span class="header-section-number">25.6.1</span> Gibbs sampler</h3>
<!-- FIXME: needs more context? -->
<p>The following case study updates an example blogged about<span id="fn185" class="footnote" data-pagedown-footnote-number="185" style="white-space: pre-line;"><a href="http://dirk.eddelbuettel.com/blog/2011/07/14/" class="uri">http://dirk.eddelbuettel.com/blog/2011/07/14/</a></span> by Dirk Eddelbuettel, illustrating the conversion of a Gibbs sampler in R to C++. The R and C++ code shown below is very similar (it only took a few minutes to convert the R version to the C++ version), but runs about 20 times faster on my computer. Dirk’s blog post also shows another way to make it even faster: using the faster random number generator functions in GSL (easily accessible from R through the RcppGSL package) can make it another 2–3x faster. </p>
<p>The R code is as follows:</p>
<pre class="sourceCode r"><code class="sourceCode r">gibbs_r &lt;-<span class="st"> </span><span class="cf">function</span>(N, thin) {
  mat &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">nrow =</span> N, <span class="dt">ncol =</span> <span class="dv">2</span>)
  x &lt;-<span class="st"> </span>y &lt;-<span class="st"> </span><span class="dv">0</span>

  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N) {
    <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>thin) {
      x &lt;-<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>, <span class="dv">3</span>, y <span class="op">*</span><span class="st"> </span>y <span class="op">+</span><span class="st"> </span><span class="dv">4</span>)
      y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">1</span> <span class="op">/</span><span class="st"> </span>(x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>), <span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="kw">sqrt</span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>(x <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)))
    }
    mat[i, ] &lt;-<span class="st"> </span><span class="kw">c</span>(x, y)
  }
  mat
}</code></pre>
<p>This is straightforward to convert to C++. We:</p>
<ul>
<li><p>add type declarations to all variables</p></li>
<li><p>use <code>(</code> instead of <code>[</code> to index into the matrix</p></li>
<li><p>subscript the results of <code>rgamma</code> and <code>rnorm</code> to convert from a vector
into a scalar</p></li>
</ul>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="co">// [[Rcpp::export]]</span>
NumericMatrix gibbs_cpp(<span class="dt">int</span> N, <span class="dt">int</span> thin) {
  NumericMatrix mat(N, <span class="dv">2</span>);
  <span class="dt">double</span> x = <span class="dv">0</span>, y = <span class="dv">0</span>;

  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; N; i++) {
    <span class="cf">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; thin; j++) {
      x = rgamma(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span> / (y * y + <span class="dv">4</span>))[<span class="dv">0</span>];
      y = rnorm(<span class="dv">1</span>, <span class="dv">1</span> / (x + <span class="dv">1</span>), <span class="dv">1</span> / sqrt(<span class="dv">2</span> * (x + <span class="dv">1</span>)))[<span class="dv">0</span>];
    }
    mat(i, <span class="dv">0</span>) = x;
    mat(i, <span class="dv">1</span>) = y;
  }

  <span class="cf">return</span>(mat);
}</code></pre>
<p>Benchmarking the two implementations yields:</p>
<pre class="sourceCode r"><code class="sourceCode r">bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="kw">gibbs_r</span>(<span class="dv">100</span>, <span class="dv">10</span>),
  <span class="kw">gibbs_cpp</span>(<span class="dv">100</span>, <span class="dv">10</span>),
  <span class="dt">check =</span> <span class="ot">FALSE</span>
)
<span class="co">#&gt; # A tibble: 2 x 10</span>
<span class="co">#&gt;   expression      min     mean   median    max `itr/sec` mem_alloc  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:&gt;     &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 gibbs_r(1…   5.68ms   5.88ms   5.81ms 6.99ms      170.    4.97MB    16</span>
<span class="co">#&gt; 2 gibbs_cpp…  304.8µs  358.8µs 349.14µs 2.75ms     2787.     4.1KB     8</span>
<span class="co">#&gt; # … with 2 more variables: n_itr &lt;int&gt;, total_time &lt;bch:tm&gt;</span></code></pre>
</div>
<div id="r-vectorisation-vs.c-vectorisation" class="section level3">
<h3><span class="header-section-number">25.6.2</span> R vectorisation vs. C++ vectorisation</h3>
<!-- FIXME: needs more context? -->
<p>This example is adapted from “Rcpp is smoking fast for agent-based models in data frames”<span id="fn186" class="footnote" data-pagedown-footnote-number="186" style="white-space: pre-line;"><a href="https://gweissman.github.io/babelgraph/blog/2017/06/15/rcpp-is-smoking-fast-for-agent-based-models-in-data-frames.html" class="uri">https://gweissman.github.io/babelgraph/blog/2017/06/15/rcpp-is-smoking-fast-for-agent-based-models-in-data-frames.html</a></span>. The challenge is to predict a model response from three inputs. The basic R version of the predictor looks like:</p>
<pre class="sourceCode r"><code class="sourceCode r">vacc1a &lt;-<span class="st"> </span><span class="cf">function</span>(age, female, ily) {
  p &lt;-<span class="st"> </span><span class="fl">0.25</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.3</span> <span class="op">*</span><span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(<span class="fl">0.04</span> <span class="op">*</span><span class="st"> </span>age)) <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span> <span class="op">*</span><span class="st"> </span>ily
  p &lt;-<span class="st"> </span>p <span class="op">*</span><span class="st"> </span><span class="cf">if</span> (female) <span class="fl">1.25</span> <span class="cf">else</span> <span class="fl">0.75</span>
  p &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="dv">0</span>, p)
  p &lt;-<span class="st"> </span><span class="kw">min</span>(<span class="dv">1</span>, p)
  p
}</code></pre>
<p>We want to be able to apply this function to many inputs, so we might write a vector-input version using a for loop.</p>
<pre class="sourceCode r"><code class="sourceCode r">vacc1 &lt;-<span class="st"> </span><span class="cf">function</span>(age, female, ily) {
  n &lt;-<span class="st"> </span><span class="kw">length</span>(age)
  out &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) {
    out[i] &lt;-<span class="st"> </span><span class="kw">vacc1a</span>(age[i], female[i], ily[i])
  }
  out
}</code></pre>
<p>If you’re familiar with R, you’ll have a gut feeling that this will be slow, and indeed it is. There are two ways we could attack this problem. If you have a good R vocabulary, you might immediately see how to vectorise the function (using <code>ifelse()</code>, <code>pmin()</code>, and <code>pmax()</code>). Alternatively, we could rewrite <code>vacc1a()</code> and <code>vacc1()</code> in C++, using our knowledge that loops and function calls have much lower overhead in C++.</p>
<p>Either approach is fairly straightforward. In R:</p>
<pre class="sourceCode r"><code class="sourceCode r">vacc2 &lt;-<span class="st"> </span><span class="cf">function</span>(age, female, ily) {
  p &lt;-<span class="st"> </span><span class="fl">0.25</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.3</span> <span class="op">*</span><span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">exp</span>(<span class="fl">0.04</span> <span class="op">*</span><span class="st"> </span>age)) <span class="op">+</span><span class="st"> </span><span class="fl">0.1</span> <span class="op">*</span><span class="st"> </span>ily
  p &lt;-<span class="st"> </span>p <span class="op">*</span><span class="st"> </span><span class="kw">ifelse</span>(female, <span class="fl">1.25</span>, <span class="fl">0.75</span>)
  p &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="dv">0</span>, p)
  p &lt;-<span class="st"> </span><span class="kw">pmin</span>(<span class="dv">1</span>, p)
  p
}</code></pre>
<p>(If you’ve worked R a lot you might recognise some potential bottlenecks in this code: <code>ifelse</code>, <code>pmin</code>, and <code>pmax</code> are known to be slow, and could be replaced with <code>p * 0.75 + p * 0.5 * female</code>, <code>p[p &lt; 0] &lt;- 0</code>, <code>p[p &gt; 1] &lt;- 1</code>. You might want to try timing those variations yourself.)</p>
<p>Or in C++:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> Rcpp;

<span class="dt">double</span> vacc3a(<span class="dt">double</span> age, <span class="dt">bool</span> female, <span class="dt">bool</span> ily){
  <span class="dt">double</span> p = <span class="fl">0.25</span> + <span class="fl">0.3</span> * <span class="dv">1</span> / (<span class="dv">1</span> - exp(<span class="fl">0.04</span> * age)) + <span class="fl">0.1</span> * ily;
  p = p * (female ? <span class="fl">1.25</span> : <span class="fl">0.75</span>);
  p = <span class="bu">std::</span>max(p, <span class="fl">0.0</span>);
  p = <span class="bu">std::</span>min(p, <span class="fl">1.0</span>);
  <span class="cf">return</span> p;
}

<span class="co">// [[Rcpp::export]]</span>
NumericVector vacc3(NumericVector age, LogicalVector female, 
                    LogicalVector ily) {
  <span class="dt">int</span> n = age.size();
  NumericVector out(n);

  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; ++i) {
    out[i] = vacc3a(age[i], female[i], ily[i]);
  }

  <span class="cf">return</span> out;
}</code></pre>
<p>We next generate some sample data, and check that all three versions return the same values:</p>
<pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="dv">1000</span>
age &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n, <span class="dt">mean =</span> <span class="dv">50</span>, <span class="dt">sd =</span> <span class="dv">10</span>)
female &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(T, F), n, <span class="dt">rep =</span> <span class="ot">TRUE</span>)
ily &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(T, F), n, <span class="dt">prob =</span> <span class="kw">c</span>(<span class="fl">0.8</span>, <span class="fl">0.2</span>), <span class="dt">rep =</span> <span class="ot">TRUE</span>)

<span class="kw">stopifnot</span>(
  <span class="kw">all.equal</span>(<span class="kw">vacc1</span>(age, female, ily), <span class="kw">vacc2</span>(age, female, ily)),
  <span class="kw">all.equal</span>(<span class="kw">vacc1</span>(age, female, ily), <span class="kw">vacc3</span>(age, female, ily))
)</code></pre>
<p>The original blog post forgot to do this, and introduced a bug in the C++ version: it used <code>0.004</code> instead of <code>0.04</code>. Finally, we can benchmark our three approaches:</p>
<pre class="sourceCode r"><code class="sourceCode r">bench<span class="op">::</span><span class="kw">mark</span>(
  <span class="dt">vacc1 =</span> <span class="kw">vacc1</span>(age, female, ily),
  <span class="dt">vacc2 =</span> <span class="kw">vacc2</span>(age, female, ily),
  <span class="dt">vacc3 =</span> <span class="kw">vacc3</span>(age, female, ily)
)
<span class="co">#&gt; # A tibble: 3 x 10</span>
<span class="co">#&gt;   expression      min     mean  median      max `itr/sec` mem_alloc  n_gc</span>
<span class="co">#&gt;   &lt;chr&gt;      &lt;bch:tm&gt; &lt;bch:tm&gt; &lt;bch:t&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 vacc1        1.89ms   2.04ms     2ms   4.18ms      490.    7.86KB     9</span>
<span class="co">#&gt; 2 vacc2      100.75µs 123.03µs 112.3µs 413.22µs     8128.     224KB    17</span>
<span class="co">#&gt; 3 vacc3       29.29µs  32.38µs  30.4µs 199.89µs    30884.   14.48KB     4</span>
<span class="co">#&gt; # … with 2 more variables: n_itr &lt;int&gt;, total_time &lt;bch:tm&gt;</span></code></pre>
<p>Not surprisingly, our original approach with loops is very slow. Vectorising in R gives a huge speedup, and we can eke out even more performance (~10x) with the C++ loop. I was a little surprised that the C++ was so much faster, but it is because the R version has to create 11 vectors to store intermediate results, where the C++ code only needs to create 1.</p>
</div>
</div>
<div id="rcpp-package" class="section level2">
<h2><span class="header-section-number">25.7</span> Using Rcpp in a package</h2>
<p>The same C++ code that is used with <code>sourceCpp()</code> can also be bundled into a package. There are several benefits of moving code from a stand-alone C++ source file to a package: </p>
<ol style="list-style-type: decimal">
<li><p>Your code can be made available to users without C++ development tools.</p></li>
<li><p>Multiple source files and their dependencies are handled automatically by
the R package build system.</p></li>
<li><p>Packages provide additional infrastructure for testing, documentation, and
consistency.</p></li>
</ol>
<p>To add <code>Rcpp</code> to an existing package, you put your C++ files in the <code>src/</code> directory and modify/create the following configuration files:</p>
<ul>
<li><p>In <code>DESCRIPTION</code> add</p>
<pre><code>LinkingTo: Rcpp
Imports: Rcpp</code></pre></li>
<li><p>Make sure your <code>NAMESPACE</code> includes:</p>
<pre><code>useDynLib(mypackage)
importFrom(Rcpp, sourceCpp)</code></pre>
<p>We need to import something (anything) from Rcpp so that internal Rcpp code
is properly loaded. This is a bug in R and hopefully will be fixed in the
future.</p></li>
</ul>
<p>The easiest way to set this up automatically is to call <code>usethis::use_rcpp()</code>.</p>
<p>Before building the package, you’ll need to run <code>Rcpp::compileAttributes()</code>. This function scans the C++ files for <code>Rcpp::export</code> attributes and generates the code required to make the functions available in R. Re-run <code>compileAttributes()</code> whenever functions are added, removed, or have their signatures changed. This is done automatically by the devtools package and by Rstudio.</p>
<p>For more details see the Rcpp package vignette, <code>vignette(&quot;Rcpp-package&quot;)</code>.</p>
</div>
<div id="rcpp-more" class="section level2">
<h2><span class="header-section-number">25.8</span> Learning more</h2>
<p>This chapter has only touched on a small part of Rcpp, giving you the basic tools to rewrite poorly performing R code in C++. As noted, Rcpp has many other capabilities that make it easy to interface R to existing C++ code, including:</p>
<ul>
<li><p>Additional features of attributes including specifying default arguments,
linking in external C++ dependencies, and exporting C++ interfaces from
packages. These features and more are covered in the Rcpp attributes vignette,
<code>vignette(&quot;Rcpp-attributes&quot;)</code>.</p></li>
<li><p>Automatically creating wrappers between C++ data structures and R data
structures, including mapping C++ classes to reference classes. A good
introduction to this topic is Rcpp modules vignette,
<code>vignette(&quot;Rcpp-modules&quot;)</code></p></li>
<li><p>The Rcpp quick reference guide, <code>vignette(&quot;Rcpp-quickref&quot;)</code>, contains a useful
summary of Rcpp classes and common programming idioms.</p></li>
</ul>
<p>I strongly recommend keeping an eye on the Rcpp homepage<span id="fn187" class="footnote" data-pagedown-footnote-number="187" style="white-space: pre-line;"><a href="http://www.rcpp.org" class="uri">http://www.rcpp.org</a></span> and signing up for the Rcpp mailing list<span id="fn188" class="footnote" data-pagedown-footnote-number="188" style="white-space: pre-line;"><a href="http://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/rcpp-devel" class="uri">http://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/rcpp-devel</a></span>.</p>
<p>Other resources I’ve found helpful in learning C++ are:</p>
<ul>
<li><p>“Effective C++” <span class="citation">(Meyers <a href="#ref-effective-cpp">2005</a>)</span> and “Effective STL” <span class="citation">(Meyers <a href="#ref-effective-stl">2001</a>)</span>.</p></li>
<li><p><em>C++ Annotations</em><span id="fn189" class="footnote" data-pagedown-footnote-number="189" style="white-space: pre-line;"><a href="http://www.icce.rug.nl/documents/cplusplus/cplusplus.html" class="uri">http://www.icce.rug.nl/documents/cplusplus/cplusplus.html</a></span>,
aimed at “knowledgeable users of C (or any other language using a C-like
grammar, like Perl or Java) who would like to know more about, or make the
transition to, C++”.</p></li>
<li><p><em>Algorithm Libraries</em><span id="fn190" class="footnote" data-pagedown-footnote-number="190" style="white-space: pre-line;"><a href="http://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/" class="uri">http://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/</a></span>,
which provides a more technical, but still concise, description of
important STL concepts. (Follow the links under notes).</p></li>
</ul>
<p>Writing performance code may also require you to rethink your basic approach: a solid understanding of basic data structures and algorithms is very helpful here. That’s beyond the scope of this book, but I’d suggest the “Algorithm Design Manual” <span class="citation">(Skiena <a href="#ref-alg-design-man">1998</a>)</span>, MIT’s <em>Introduction to Algorithms</em><span id="fn191" class="footnote" data-pagedown-footnote-number="191" style="white-space: pre-line;"><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" class="uri">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/</a></span>, <em>Algorithms</em> by Robert Sedgewick and Kevin Wayne which has a free online textbook<span id="fn192" class="footnote" data-pagedown-footnote-number="192" style="white-space: pre-line;"><a href="http://algs4.cs.princeton.edu/home/" class="uri">http://algs4.cs.princeton.edu/home/</a></span> and a matching Coursera course<span id="fn193" class="footnote" data-pagedown-footnote-number="193" style="white-space: pre-line;"><a href="https://www.coursera.org/learn/algorithms-part1" class="uri">https://www.coursera.org/learn/algorithms-part1</a></span>.</p>
</div>
<div id="acknowledgments" class="section level2">
<h2><span class="header-section-number">25.9</span> Acknowledgments</h2>
<p>I’d like to thank the Rcpp-mailing list for many helpful conversations, particularly Romain Francois and Dirk Eddelbuettel who have not only provided detailed answers to many of my questions, but have been incredibly responsive at improving Rcpp. This chapter would not have been possible without JJ Allaire; he encouraged me to learn C++ and then answered many of my dumb questions along the way.</p>
<!--chapter:end:Rcpp.Rmd-->
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<!--chapter:end:References.Rmd-->
<div id="refs" class="references">
<div id="ref-SICP">
<p>Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996. <em>Structure and Interpretation of Computer Programs</em>. MIT Press.</p>
</div>
<div id="ref-magrittr">
<p>Bache, Stefan Milton, and Hadley Wickham. 2014. <em>Magrittr: A Forward-Pipe Operator for R</em>. <a href="http://magrittr.tidyverse.org/">http://magrittr.tidyverse.org/</a>.</p>
</div>
<div id="ref-errorist">
<p>Balamuta, James. 2018a. <em>Errorist: Automatically Search Errors or Warnings</em>. <a href="https://github.com/coatless/errorist">https://github.com/coatless/errorist</a>.</p>
</div>
<div id="ref-searcher">
<p>———. 2018b. <em>Searcher: Query Search Interfaces</em>. <a href="https://github.com/coatless/searcher">https://github.com/coatless/searcher</a>.</p>
</div>
<div id="ref-Matrix">
<p>Bates, Douglas, and Martin Maechler. 2018. “Matrix: Sparse and Dense Matrix Classes and Methods.” <a href="https://CRAN.R-project.org/package=Matrix">https://CRAN.R-project.org/package=Matrix</a>.</p>
</div>
<div id="ref-bawden-1999">
<p>Bawden, Alan. 1999. “Quasiquotation in Lisp.” In <em>PEPM ’99</em>, 4–12. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.309.227">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.309.227</a>.</p>
</div>
<div id="ref-R.oo">
<p>Bengtsson, Henrik. 2003. “The R.oo Package - Object-Oriented Programming with References Using Standard R Code.” In <em>Proceedings of the 3rd International Workshop on Distributed Statistical Computing (Dsc 2003)</em>, edited by Kurt Hornik, Friedrich Leisch, and Achim Zeileis. Vienna, Austria: https://www.r-project.org/conferences/DSC-2003/Proceedings/. <a href="https://www.r-project.org/conferences/DSC-2003/Proceedings/Bengtsson.pdf">https://www.r-project.org/conferences/DSC-2003/Proceedings/Bengtsson.pdf</a>.</p>
</div>
<div id="ref-hash">
<p>Brown, Christopher. 2013. <em>Hash: Full Feature Implementation of Hash/Associated Arrays/Dictionaries</em>. <a href="https://CRAN.R-project.org/package=hash">https://CRAN.R-project.org/package=hash</a>.</p>
</div>
<div id="ref-mature-opt">
<p>Bueno, Carlos. 2013. <em>Mature Optimization Handbook</em>. <a href="http://carlos.bueno.org/optimization/">http://carlos.bueno.org/optimization/</a>.</p>
</div>
<div id="ref-programming-with-data">
<p>Chambers, John M. 1998. <em>Programming with Data: A Guide to the S Language</em>. Springer.</p>
</div>
<div id="ref-s4da">
<p>———. 2008. <em>Software for Data Analysis: Programming with R</em>. Springer.</p>
</div>
<div id="ref-chambers-2014">
<p>———. 2014. “Object-Oriented Programming, Functional Programming and R.” <em>Statistical Science</em> 29 (2). Institute of Mathematical Statistics: 167–80. <a href="https://projecteuclid.org/download/pdfview_1/euclid.ss/1408368569">https://projecteuclid.org/download/pdfview_1/euclid.ss/1408368569</a>.</p>
</div>
<div id="ref-extending-R">
<p>———. 2016. <em>Extending R</em>. CRC Press.</p>
</div>
<div id="ref-white-book">
<p>Chambers, John M, and Trevor J Hastie. 1992. <em>Statistical Models in S</em>. Wadsworth &amp; Brooks/Cole Advanced Books &amp; Software.</p>
</div>
<div id="ref-R6">
<p>Chang, Winston. 2017. <em>R6: Classes with Reference Semantics</em>. <a href="https://r6.r-lib.org">https://r6.r-lib.org</a>.</p>
</div>
<div id="ref-Rcpp">
<p>Eddelbuettel, Dirk, and Romain François. 2011. “Rcpp: Seamless R and C++ Integration.” <em>Journal of Statistical Software</em> 40 (8): 1–18. <a href="https://doi.org/10.18637/jss.v040.i08">https://doi.org/10.18637/jss.v040.i08</a>.</p>
</div>
<div id="ref-dsls">
<p>Fowler, Martin. 2010. <em>Domain-Specific Languages</em>. Pearson Education. <a href="http://amzn.com/0321712943">http://amzn.com/0321712943</a>.</p>
</div>
<div id="ref-lubridate">
<p>Grolemund, Garrett, and Hadley Wickham. 2011. “Dates and Times Made Easy with lubridate.” <em>Journal of Statistical Software</em> 40 (3): 1–25. <a href="http://www.jstatsoft.org/v40/i03/">http://www.jstatsoft.org/v40/i03/</a>.</p>
</div>
<div id="ref-proto">
<p>Grothendieck, Gabor, Louis Kates, and Thomas Petzoldt. 2016. <em>Proto: Prototype Object-Based Programming</em>. <a href="https://CRAN.R-project.org/package=proto">https://CRAN.R-project.org/package=proto</a>.</p>
</div>
<div id="ref-purrr">
<p>Henry, Lionel, and Hadley Wickham. 2018a. <em>Purrr: Functional Programming Tools</em>. <a href="https://purrr.tidyverse.org">https://purrr.tidyverse.org</a>.</p>
</div>
<div id="ref-rlang">
<p>———. 2018b. <em>Rlang: Tools for Low-Level R Programming</em>. <a href="https://rlang.r-lib.org">https://rlang.r-lib.org</a>.</p>
</div>
<div id="ref-bench">
<p>Hester, Jim. 2018. <em>Bench: High Precision Timing of R Expressions</em>. <a href="http://bench.r-lib.org/">http://bench.r-lib.org/</a>.</p>
</div>
<div id="ref-withr">
<p>Hester, Jim, Kirill Müller, Kevin Ushey, Hadley Wickham, and Winston Chang. 2018. <em>Withr: Run Code with Temporarily Modified Global State</em>. <a href="http://withr.r-lib.org">http://withr.r-lib.org</a>.</p>
</div>
<div id="ref-pragprog">
<p>Hunt, Andrew, and David Thomas. 1990. <em>The Pragmatic Programmer</em>. Addison Wesley.</p>
</div>
<div id="ref-lumley-2001">
<p>Lumley, Thomas. 2001. “Programmer’s Niche: Macros in R.” <em>R News</em> 1 (3): 11–13. <a href="https://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf">https://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf</a>.</p>
</div>
<div id="ref-art-r-prog">
<p>Matloff, Norman. 2011. <em>The Art of R Programming</em>. No Starch Press.</p>
</div>
<div id="ref-parcomp-ds">
<p>———. 2015. <em>Parallel Computing for Data Science</em>. Chapman &amp; Hall/CRC. <a href="http://amzn.com/1466587016">http://amzn.com/1466587016</a>.</p>
</div>
<div id="ref-parallel-r">
<p>McCallum, Q. Ethan, and Steve Weston. 2011. <em>Parallel R</em>. O’Reilly. <a href="http://amzn.com/B005Z29QT4">http://amzn.com/B005Z29QT4</a>.</p>
</div>
<div id="ref-effective-stl">
<p>Meyers, Scott. 2001. <em>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</em>. Pearson Education. <a href="http://amzn.com/0201749629">http://amzn.com/0201749629</a>.</p>
</div>
<div id="ref-effective-cpp">
<p>———. 2005. <em>Effective C++: 55 Specific Ways to Improve Your Programs and Designs</em>. Pearson Education. <a href="http://amzn.com/0321334876">http://amzn.com/0321334876</a>.</p>
</div>
<div id="ref-r-design">
<p>Morandat, Floréal, Brandon Hill, Leo Osvald, and Jan Vitek. 2012. “Evaluating the Design of the R Language.” In <em>European Conference on Object-Oriented Programming</em>, 104–31. Springer. <a href="http://r.cs.purdue.edu/pub/ecoop12.pdf">http://r.cs.purdue.edu/pub/ecoop12.pdf</a>.</p>
</div>
<div id="ref-tibble">
<p>Müller, Kirill, and Hadley Wickham. 2018. <em>Tibble: Simple Data Frames</em>. <a href="http://tibble.tidyverse.org/">http://tibble.tidyverse.org/</a>.</p>
</div>
<div id="ref-r-ints">
<p>R Core Team. 2018a. “R Internals.” <em>R Foundation for Statistical Computing</em>. <a href="https://cran.r-project.org/doc/manuals/r-devel/R-exts.html">https://cran.r-project.org/doc/manuals/r-devel/R-exts.html</a>.</p>
</div>
<div id="ref-r-exts">
<p>———. 2018b. “Writing R Extensions.” <em>R Foundation for Statistical Computing</em>. <a href="https://cran.r-project.org/doc/manuals/r-devel/R-ints.html">https://cran.r-project.org/doc/manuals/r-devel/R-ints.html</a>.</p>
</div>
<div id="ref-alg-design-man">
<p>Skiena, Steven S. 1998. <em>The Algorithm Design Manual</em>. Springer Science &amp; Business Media. <a href="http://amzn.com/0387948600">http://amzn.com/0387948600</a>.</p>
</div>
<div id="ref-zeallot">
<p>Teetor, Nathan. 2018. <em>Zeallot: Multiple, Unpacking, and Destructuring Assignment</em>. <a href="https://CRAN.R-project.org/package=zeallot">https://CRAN.R-project.org/package=zeallot</a>.</p>
</div>
<div id="ref-proftools">
<p>Tierney, Luke, and Riad Jarjour. 2016. <em>Proftools: Profile Output Processing Tools for R</em>. <a href="https://CRAN.R-project.org/package=proftools">https://CRAN.R-project.org/package=proftools</a>.</p>
</div>
<div id="ref-ctmcp">
<p>Van-Roy, Peter, and Seif Haridi. 2004. <em>Concepts, Techniques, and Models of Computer Programming</em>. MIT press.</p>
</div>
<div id="ref-mutatr">
<p>Wickham, Hadley. 2011. “Mutatr: Mutable Objects for R.” <em>Computational Statistics</em> 26 (3): 405–18. <a href="https://doi.org/10.1007/s00180-011-0235-7">https://doi.org/10.1007/s00180-011-0235-7</a>.</p>
</div>
<div id="ref-forcats">
<p>———. 2018. <em>Forcats: Tools for Working with Categorical Variables</em>. <a href="http://forcats.tidyverse.org">http://forcats.tidyverse.org</a>.</p>
</div>
<div id="ref-memoise">
<p>Wickham, Hadley, Jim Hester, Kirill Müller, and Daniel Cook. 2018. <em>Memoise: Memoisation of Functions</em>. <a href="https://github.com/r-lib/memoise">https://github.com/r-lib/memoise</a>.</p>
</div>
<div id="ref-evaluate">
<p>Wickham, Hadley, and Yihui Xie. 2018. <em>Evaluate: Parsing and Evaluation Tools That Provide More Details Than the Default</em>. <a href="https://github.com/r-lib/evaluate">https://github.com/r-lib/evaluate</a>.</p>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
