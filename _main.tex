\documentclass[]{book}
\usepackage{lmodern}
\usepackage{setspace}
\setstretch{1.2}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[b5paper]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={Advanced R},
            pdfauthor={Hadley Wickham},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{Advanced R}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{Hadley Wickham}
    \preauthor{\centering\large\emph}
  \postauthor{\par}
    \date{}
    \predate{}\postdate{}
  
\usepackage{index}
\newcommand{\indexc}[1]{\index{#1@\texttt{#1}}}
\makeindex

% Place links inline
\renewcommand{\href}[2]{#2 (\url{#1})}

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Example}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Exercise}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Solution}
\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{preface}{%
\chapter*{Preface}\label{preface}}
\addcontentsline{toc}{chapter}{Preface}

Welcome to the 2nd edition of Advanced R. I had three main goals for
this edition:

\begin{itemize}
\item
  Improve coverage of important concepts that I fully understood only
  after the publication of the 1st edition.
\item
  Reduce coverage of topics time has shown to be less useful, or that I
  think are really exciting but turn out not to be that practical.
\item
  Generally make the material easier to understand with better text,
  clearer code, and many more diagrams.
\end{itemize}

If you're familiar with the 1st edition, this preface describes the
major changes so that you can focus your reading on the new areas (but I
really do encourage you to skim throughout the book).

If you're reading a printed version of this book you'll notice one big
change very quickly: Advanced R is now in colour! This has considerably
improved the syntax highlighting of code chunks, and made it much easier
to create helpful diagrams. I have taken advantage of this and included
over 100 new diagrams throughout the book.

Another big change in this version is the use of packages, particularly
\href{http://rlang.r-lib.org}{rlang}, which provides a clean interface
to low-level data structures and operations. The 1st edition used base R
functions almost exclusively, which created some pedagogical challenges
because many functions evolved independently over multiple years, making
it hard to see the big underlying ideas hidden amongst the incidental
variations in function names and arguments. I continue to show base
equivalents in sidebars, footnotes, and where needed, in individual
sections, but if you want to see the purest base R expression of the
ideas in this book, I recommend reading the 1st edition, which you can
find online at \url{http://adv-r.had.co.nz}.

The foundations of R have not changed in the five years since the 1st
edition, but my understanding of them certainly has. Thus, the overall
structure of ``Foundations'' has remained roughly the same, but many of
the individual chapters have been considerably improved:

\begin{itemize}
\item
  Chapter \ref{names-values}, ``Names and values'', is a brand new
  chapter that helps you understand the difference between objects and
  names of objects. This helps you more accurately predict when R will
  make a copy of a data structure, and lays important groundwork to
  understand functional programming.
\item
  Chapter \ref{vectors-chap}, ``Vectors'' (previously called data
  structures), and has been rewritten to focus on vector types like
  integers, factors, and data frames. It contains more details of
  important S3 vectors (like dates and date-times), and discusses the
  data frame variation provided by the
  \href{https://tibble.tidyverse.org}{tibble} package.
\item
  Chapter \ref{subsetting}, ``Subsetting'', now distinguishes between
  \texttt{{[}} and \texttt{{[}{[}} by their intention: \texttt{{[}}
  extracts many values and \texttt{{[}{[}} extracts a single value
  (previously they were characterised by whether they ``simplified'' or
  ``preserved''). Section \ref{subset-single} draws the ``train'' to
  help you understand how \texttt{{[}{[}} works with lists, and
  introduces the new \texttt{purrr::pluck()} and \texttt{purrr::chuck()}
  functions that provide more consistent behaviour for out-of-bounds
  indices.
\item
  Chapter \ref{functions}, ``Functions'', has an improved ordering,
  introduces the pipe (\texttt{\%\textgreater{}\%}) as a third way to
  compose functions (Section \ref{function-composition}), and has
  considerably improved coverage of function forms (Section
  \ref{function-forms}).
\item
  Chapter \ref{environments}, ``Environments'', has a reorganised
  treatment of special environments (Section \ref{function-envs}), and a
  much improved discussion of the call stack (Section \ref{call-stack}).
\item
  Chapter \ref{conditions}, ``Conditions'', contains material previously
  in ``Exceptions and debugging'', and much new content on how R's
  condition system works. It also shows you how to create your own
  custom condition classes (Section \ref{custom-conditions}).
\end{itemize}

The chapters following foundations have been re-organised around the
three most important programming paradigms in R: functional programming,
object oriented programming, and metaprogramming.

\begin{itemize}
\item
  Functional programming is now more cleanly divided into the three main
  techniques: ``Functionals'' (Chapter \ref{functionals}), ``Function
  factories'' (Chapter \ref{function-factories}), and ``Function
  operators'' (Chapter \ref{function-operators}). I've focussed in on
  ideas that have practical applications in data science and reduced the
  amount of pure theory.

  These chapters now use functions provided by the purrr package, which
  allow me to focus more on the underlying ideas and less on the
  incidental variations. This also lead to a considerable simplification
  of the function operators chapter since a major use was to work around
  the absence of \texttt{...} in base functionals.
\item
  Object oriented programming (OOP) now forms a major section of the
  book with completely new chapters on base types (Chapter
  \ref{base-types}), S3 (Chapter \ref{s3}), S4 (Chapter \ref{s4}), R6
  (Chapter \ref{r6}), and the tradeoffs between the systems (Chapter
  \ref{oo-tradeoffs}).

  These chapters focus on how the different object systems work, not how
  to use them effectively. This is unfortunate, but necessary, because
  many of the technical details are not described elsewhere, and
  effective use of OOP needs a whole book of its own.
\item
  Metaprogramming (previously called ``computing on the language'')
  describes the suite of tools that you can use to generate code with
  code. Compared to the 1st edition this material has been substantially
  expanded and now focusses on ``tidy evaluation'', a set of ideas and
  theory that that make metaprogramming safe, well-principled, and
  accessible to many more R programmers. Chapter \ref{expressions},
  ``Expressions'', describes the underlying data structures; Chapter
  \ref{quasiquotation}, ``Quasiquotation'', quoting and unquoting;
  Chapter \ref{evaluation}, ``Evaluation'', evaluating code in special
  environments; and Chapter \ref{translation}, ``Translations'', pulls
  all the themes together to show how you might translate from one
  (programming) language to another.
\end{itemize}

The final section of the book collects chapters on programming
techniques, including debugging, profiling, improving performance, and
connecting R and C++.

While the 2nd edition has mostly expanded coverage of existing material,
there were four chapters that have been removed:

\begin{itemize}
\item
  The vocabulary chapter has been removed because it was always a bit of
  an odd duck, and there are more effective ways to present vocabulary
  lists than in a book chapter.
\item
  The style chapter has been replaced with an online style guide,
  \url{http://style.tidyverse.org/}. The style guide is paired with the
  new \href{http://styler.r-lib.org/}{styler} package which can
  automatically apply many of the rules.
\item
  The C chapter has been moved to a new repo,
  \url{https://github.com/hadley/r-internals}, which, over time, will
  provide a guide to writing C code that work's with R's data
  structures.
\item
  The memory chapter has been removed. Much of the material has been
  integrated into Chapter \ref{names-values} and the remainder felt
  excessively technical and not that important to understand.
\end{itemize}

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

I have now been programming in R for over 15 years, and have been doing
it full-time for the last five years. This has given me the luxury of
time to spend on understanding how the language works. This book is my
attempt to pass on what I've learned so that you can understand the
intricacies of R as quickly and painlessly as possible. Reading it will
help you avoid the mistakes I've made and dead ends I've gone down, and
will teach you useful tools, techniques, and idioms that can help you to
attack many types of problems. In the process, I hope to show that,
despite its sometimes frustrating quirks, R is, at its heart, an elegant
and beautiful language, well tailored for data science.

\hypertarget{why-r}{%
\section{Why R?}\label{why-r}}

If you are new to R, you might wonder what makes learning such a quirky
language worthwhile. To me, some of the best features are:

\begin{itemize}
\item
  It's free, open source, and available on every major platform. As a
  result, if you do your analysis in R, anyone can easily replicate it,
  regardless of where they live or how much money they earn.
\item
  R has a diverse and welcoming community, both online (e.g.
  \href{https://twitter.com/search?q=\%23rstats}{the \#rstats twitter
  community}) and in person (like the
  \href{https://www.meetup.com/topics/r-programming-language/}{many R
  meetups}). Two particularly inspiring community groups are the
  \href{https://rweekly.org}{rweekly newsletter} which makes it easy to
  keep up to date with R, and the \href{http://r-ladies.org}{R-Ladies}
  organization which has made a wonderfully welcoming community for
  women and gender minorities.
\item
  A massive set of packages for statistical modelling, machine learning,
  visualisation, and importing and manipulating data. Whatever model or
  graphic you're trying to do, chances are that someone has already
  tried to do it and you can learn from their efforts.
\item
  Powerful tools for communicating your results.
  \href{https://rmarkdown.rstudio.com}{RMarkdown} makes it easy to turn
  your results into R packages into HTML, PDFs, word documents,
  powerpoint presentations, dashboards and more.
  \href{http://shiny.rstudio.com}{Shiny} allows you to make beautiful
  interactive apps without any knowledge of HTML or javascript.
\item
  RStudio, \href{http://www.rstudio.com/ide/}{the IDE}, which is
  tailored to the needs of data science, interactive data analysis, and
  statistical programming.
\item
  Cutting edge tools. Researchers in statistics and machine learning
  will often publish an R package to accompany their articles. This
  means immediate access to the very latest statistical techniques and
  implementations.
\item
  Deep-seated language support for data analysis. This includes features
  like missing values, data frames, and subsetting.
\item
  A strong foundation of functional programming. The ideas of functional
  programming are well suited to the challenges of data science, and the
  R language is functional at heart, and provides many primitives needed
  for effective functional programming.
\item
  RStudio, \href{https://www.rstudio.com}{the company}, which makes
  money by selling professional products to teams of R users, and turns
  around and invests much of that money back into the open source
  community. I work for RStudio because I fundamentally believe in its
  mission.
\item
  Powerful metaprogramming facilities. R's metaprogramming capabilities
  allow you to write magically succinct and concise functions and
  provide an excellent environment for designing domain-specific
  languages like ggplot2, dplyr, data.table, and more.
\item
  The ease with which R can connect to high-performance programming
  languages like C, Fortran, and C++.
\end{itemize}

Of course, R is not perfect. R's biggest challenge (and opportunity!) is
that most R users are not programmers. This means that:

\begin{itemize}
\item
  Much of the R code you'll see in the wild is written in haste to solve
  a pressing problem. As a result, code is not very elegant, fast, or
  easy to understand. Most users do not revise their code to address
  these shortcomings.
\item
  Compared to other programming languages, the R community is more
  focussed on results than processes. Knowledge of software engineering
  best practices is patchy: for instance, not enough R programmers use
  source code control or automated testing.
\item
  Metaprogramming is a double-edged sword. Too many R functions use
  tricks to reduce the amount of typing at the cost of making code that
  is hard to understand and that can fail in unexpected ways.
\item
  Inconsistency is rife across contributed packages, and even within
  base R. You are confronted with over 20 years of evolution every time
  you use R, and this can make learning R tough because there are so
  many special cases to remember.
\item
  R is not a particularly fast programming language, and poorly written
  R code can be terribly slow. R is also a profligate user of memory.
\end{itemize}

Personally, I think these challenges create a great opportunity for
experienced programmers to have a profound positive impact on R and the
R community. R users do care about writing high quality code,
particularly for reproducible research, but they don't yet have the
skills to do so. I hope this book will not only help more R users to
become R programmers, but also encourage programmers from other
languages to contribute to R.

\hypertarget{who-should-read}{%
\section{Who should read this book}\label{who-should-read}}

This book is aimed at two complementary audiences:

\begin{itemize}
\item
  Intermediate R programmers who want to dive deeper into R and learn
  new strategies for solving diverse problems.
\item
  Programmers from other languages who are learning R and want to
  understand why R works the way it does.
\end{itemize}

To get the most out of this book, you'll need to have written a decent
amount of code in R or another programming language. You should be
familiar with the basics of data analysis (i.e.~data import,
manipulation, and visualisation), have written a number of functions,
and be familiar with the installation and use of CRAN packages.

This book works the narrow line between being a reference book
(primarily used for lookup), and being linearly readable. This involves
some tradeoffs, because it's difficult to linearise material while still
keeping related materials together, whereas some concepts are much
easier to explain if you're already familiar with specific technical
vocabulary. I've tried to use footnotes and cross-references to make
sure you can still make sense even if you just dip your toes in the
occasional chapter.

\hypertarget{what-you-will-get}{%
\section{What you will get out of this book}\label{what-you-will-get}}

This book delivers the knowledge that I think an advanced R programmer
should possess: a deep understanding of the fundamentals coupled with a
broad vocabulary that means that you can tactically learn more about a
topic when needed.

After reading this book, you will:

\begin{itemize}
\item
  Be familiar with the fundamentals of R. You will understand complex
  data types and the best ways to perform operations on them. You will
  have a deep understanding of how functions work, and be able to
  recognise and use the four object systems in R.
\item
  Understand what functional programming means, and why it is a useful
  tool for data science. You'll be able to quickly learn how to use
  existing tools, and have the knowledge to create your own functional
  tools when needed.
\item
  Appreciate the double-edged sword of metaprogramming. You'll be able
  to create functions that use tidy evaluation, saving typing and
  creating elegant code to express important operations. You'll also
  understand the dangers and when to avoid it.
\item
  Have a good intuition for which operations in R are slow or use a lot
  of memory. You'll know how to use profiling to pinpoint performance
  bottlenecks, and you'll know enough C++ to convert slow R functions to
  fast C++ equivalents.
\item
  Be comfortable reading and understanding the majority of R code.
  You'll recognise common idioms (even if you wouldn't use them
  yourself) and be able to critique others' code.
\end{itemize}

\hypertarget{what-you-will-not-learn}{%
\section{What you will not learn}\label{what-you-will-not-learn}}

This book is about R the programming language, not R the data analysis
tool. If you are looking to improve your data science skills, I instead
recommend that you learn about the
\href{https://www.tidyverse.org/}{tidyverse}, a collection of consistent
packages developed by me and my colleagues. In this book you'll learn
the techniques used to develop the tidyverse package; if you want to
instead learn how to use them, I recommend
\href{http://r4ds.had.co.nz/}{``R for Data Science''}.

If you want to share your R code with others, you will need to make an R
package. This allows you to bundle code along with documentation and
unit tests, and easily distribute it via CRAN. In my opinion, the
easiest way to develop packages is with
\href{http://devtools.r-lib.org}{devtools},
\href{http://klutometis.github.io/roxygen/}{roxygen2},
\href{http://testthat.r-lib.org}{testthat}, and
\href{http://usethis.r-lib.org}{usethis}. You can learn about using them
to make your own package in \href{http://r-pkgs.had.co.nz/}{``R
packages''}.

\hypertarget{meta-techniques}{%
\section{Meta-techniques}\label{meta-techniques}}

There are two meta-techniques that are tremendously helpful for
improving your skills as an R programmer: reading source code and
adopting a scientific mindset.

Reading source code is important because it will help you write better
code. A great place to start developing this skill is to look at the
source code of the functions and packages you use most often. You'll
find things that are worth emulating in your own code and you'll develop
a sense of taste for what makes good R code. You will also see things
that you don't like, either because its virtues are not obvious or it
offends your sensibilities. Such code is nonetheless valuable, because
it helps make concrete your opinions on good and bad code.

A scientific mindset is extremely helpful when learning R. If you don't
understand how something works, develop a hypothesis, design some
experiments, run them, and record the results. This exercise is
extremely useful since if you can't figure something out and need to get
help, you can easily show others what you tried. Also, when you learn
the right answer, you'll be mentally prepared to update your world view.

\hypertarget{recommended-reading}{%
\section{Recommended reading}\label{recommended-reading}}

Because the R community mostly consists of data scientists, not computer
scientists, there are relatively few books that go deep in the technical
underpinnings of R. In my personal journey to understand R, I've found
it particularly helpful to use resources from other programming
languages. R has aspects of both functional and object-oriented (OO)
programming languages. Learning how these concepts are expressed in R
will help you leverage your existing knowledge of other programming
languages, and will help you identify areas where you can improve.

To understand why R's object systems work the way they do, I found ``The
Structure and Interpretation of Computer Programs''\footnote{You can
  read it online for free at
  \url{https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html}}
(Abelson, Sussman, and Sussman \protect\hyperlink{ref-SICP}{1996})
(SICP) by Harold Abelson and Gerald Jay Sussman, to be particularly
helpful. It's a concise but deep book, and after reading it, I felt for
the first time that I could actually design my own object-oriented
system. The book was my first introduction to the encapsulated paradigm
of object oriented programming found in R, and it helped me understand
the strengths and weaknesses of this system. SICP also teaches the
functional mindset where you create functions that are simple
individually, and which become powerful when composed together.

To understand the trade-offs that R has made compared to other
programming languages, I found ``Concepts, Techniques and Models of
Computer Programming'' (Van-Roy and Haridi
\protect\hyperlink{ref-ctmcp}{2004}) extremely helpful. It helped me
understand that R's copy-on-modify semantics make it substantially
easier to reason about code, and that while its current implementation
is not particularly efficient, it is a solvable problem.

If you want to learn to be a better programmer, there's no place better
to turn than ``The Pragmatic Programmer'' (Hunt and Thomas
\protect\hyperlink{ref-pragprog}{1990}) by Andrew Hunt and David Thomas.
This book is language agnostic, and provides great advice for how to be
a better programmer.

\hypertarget{getting-help}{%
\section{Getting help}\label{getting-help}}

Currently, there are three main venues to get help when you're stuck and
can't figure out what's causing the problem:
\href{https://community.rstudio.com/}{RStudio Community},
\href{http://stackoverflow.com}{stackoverflow} and the
\href{https://stat.ethz.ch/mailman/listinfo/r-help}{R-help mailing
list}. You can get fantastic help in each venue, but they do have their
own cultures and expectations. It's usually a good idea to spend a
little time lurking, learning about community expectations, before you
put up your first post. \index{help}

Some good general advice:

\begin{itemize}
\item
  Make sure you have the latest version of R and of the package (or
  packages) you are having problems with. It may be that your problem is
  the result of a recently fixed bug.
\item
  Spend some time creating a \textbf{repr}oducible \textbf{ex}ample, or
  reprex. This will help others help you, and often leads to a solution
  without asking others, because in the course of making the problem
  reproducible you often figure out the root cause. I highly recommend
  learning and using the \href{https://reprex.tidyverse.org/}{reprex}
  package.
\end{itemize}

\hypertarget{intro-ack}{%
\section{Acknowledgments}\label{intro-ack}}

I would like to thank the many contributors to R-devel and R-help and,
more recently, Stack Overflow and RStudio Community. There are too many
to name individually, but I'd particularly like to thank Luke Tierney,
John Chambers, Dirk Eddelbuettel, JJ Allaire, and Brian Ripley for
generously giving their time and correcting my countless
misunderstandings.

This book was \href{https://github.com/hadley/adv-r/}{written in the
open}, and chapters were advertised on
\href{https://twitter.com/hadleywickham}{twitter} when complete. It is
truly a community effort: many people read drafts, fixed typos,
suggested improvements, and contributed content. Without those
contributors, the book wouldn't be nearly as good as it is, and I'm
deeply grateful for their help. Special thanks go to Peter Li, who read
the book from cover-to-cover and provided many fixes. Other consistently
helpful contributors were Aaron Schumacher, @crtahlin, Lingbing Feng,
@juancentro, @johnbaums, and Jeff Hammerbacher. \index{contributors}

Thanks go to all contributors in alphabetical order: Aaron Wolen
(@aaronwolen), @absolutelyNoWarranty, Adam Hunt (@adamphunt),
@agrabovsky, Alexander Grueneberg (@agrueneberg), Anthony Damico
(@ajdamico), James Manton (@ajdm), Aaron Schumacher (@ajschumacher),
Alan Dipert (@alandipert), Alex Brown (@alexbbrown), @alexperrone, Alex
Whitworth (@alexWhitworth), Alexandros Kokkalis (@alko989), @amarchin,
Amelia McNamara (@AmeliaMN), Bryce Mecum (@amoeba), Andrew Laucius
(@andrewla), Andrew Bray (@andrewpbray), Andrie de Vries (@andrie),
@aranlunzer, Ari Lamstein (@arilamstein), @asnr, Andy Teucher
(@ateucher), Albert Vilella (@avilella), baptiste (@baptiste), Brian G.
Barkley (@BarkleyBG), Mara Averick (@batpigandme), Barbara Borges
Ribeiro (@bborgesr), Brandon Greenwell (@bgreenwell), Brandon Hurr
(@bhive01), Jason Knight (@binarybana), Brett Klamer (@bklamer), Jesse
Anderson (@blindjesse), Brian Mayer (@blmayer), Benjamin L. Moore
(@blmoore), Brian Diggs (@BrianDiggs), Brian S. Yandell (@byandell),
@carey1024, Chip Hogg (@chiphogg), Chris Muir (@ChrisMuir), Christopher
Gandrud (@christophergandrud), Clay Ford (@clayford), Colin Fay
(@ColinFay), @cortinah, Cameron Plouffe (@cplouffe), Carson Sievert
(@cpsievert), Craig Citro (@craigcitro), Craig Grabowski
(@craiggrabowski), Christopher Roach (@croach), Peter Meilstrup
(@crowding), Crt Ahlin (@crtahlin), Carlos Scheidegger (@cscheid), Colin
Gillespie (@csgillespie), Christopher Brown (@ctbrown), Davor Cubranic
(@cubranic), Darren Cusanovich (@cusanovich), Christian G. Warden
(@cwarden), Charlotte Wickham (@cwickham), Dean Attali (@daattali), Dan
Sullivan (@dan87134), Daniel Barnett (@daniel-barnett), Kenny Darrell
(@darrkj), Tracy Nance (@datapixie), Dave Childers (@davechilders),
David Rubinger (@davidrubinger), David Chudzicki (@dchudz), Daisuke
ICHIKAWA (@dichika), david kahle (@dkahle), David LeBauer (@dlebauer),
David Schweizer (@dlschweizer), David Montaner (@dmontaner), Zhuoer Dong
(@dongzhuoer), Doug Mitarotonda (@dougmitarotonda), Jonathan Hill
(@Dripdrop12), Julian During (@duju211), @duncanwadsworth, @eaurele,
Dirk Eddelbuettel (@eddelbuettel), @EdFineOKL, Edwin Thoen (@EdwinTh),
Ethan Heinzen (@eheinzen), @eijoac, Joel Schwartz (@eipi10), Eric Ronald
Legrand (@elegrand), Ellis Valentiner (@ellisvalentiner), Emil Hvitfeldt
(@EmilHvitfeldt), Emil Rehnberg (@EmilRehnberg), Daniel Lee (@erget),
Eric C. Anderson (@eriqande), Enrico Spinielli (@espinielli), @etb,
David Hajage (@eusebe), Fabian Scheipl (@fabian-s), @flammy0530,
François Michonneau (@fmichonneau), Francois Pepin (@fpepin), Frank
Farach (@frankfarach), @freezby, Frans van Dunné (@FvD), @fyears,
@gagnagaman, Garrett Grolemund (@garrettgman), Gavin Simpson
(@gavinsimpson), @gezakiss7, @gggtest, Gökçen Eraslan (@gokceneraslan),
Georg Russ (@gr650), @grasshoppermouse, Gregor Thomas (@gregorp),
Garrett See (@gsee), Ari Friedman (@gsk3), Gunnlaugur Thor Briem
(@gthb), Hadley Wickham (@hadley), Hamed (@hamedbh), Harley Day
(@harleyday), @hassaad85, @helmingstay, Henning (@henningsway), Henrik
Bengtsson (@HenrikBengtsson), Ching Boon (@hoscb), Iain Dillingham
(@iaindillingham), @IanKopacka, Ian Lyttle (@ijlyttle), Ilan Man
(@ilanman), Imanuel Costigan (@imanuelcostigan), Thomas Bürli
(@initdch), Os Keyes (@Ironholds), @irudnyts, i (@isomorphisms), Irene
Steves (@isteves), Jan Gleixner (@jan-glx), Jason Asher (@jasonasher),
Jason Davies (@jasondavies), Chris (@jastingo), jcborras (@jcborras),
John Blischak (@jdblischak), @jeharmse, Lukas Burk (@jemus42), Jennifer
(Jenny) Bryan (@jennybc), Justin Jent (@jentjr), Jeston (@JestonBlu),
Jim Hester (@jimhester), @JimInNashville, @jimmyliu2017, Jim Vine
(@jimvine), Jinlong Yang (@jinlong25), J.J. Allaire (@jjallaire),
@JMHay, Jochen Van de Velde (@jochenvdv), Johann Hibschman (@johannh),
John Baumgartner (@johnbaums), John Horton (@johnjosephhorton),
@johnthomas12, Jon Calder (@jonmcalder), Jon Harmon (@jonthegeek), Julia
Gustavsen (@jooolia), JorneBiccler (@JorneBiccler), Jeffrey Arnold
(@jrnold), Joyce Robbins (@jtr13), Juan Manuel Truppia (@juancentro),
Kevin Markham (@justmarkham), john verzani (@jverzani), Michael Kane
(@kaneplusplus), Bart Kastermans (@kasterma), Kevin D'Auria (@kdauria),
Karandeep Singh (@kdpsingh), Ken Williams (@kenahoo), Kendon Bell
(@kendonB), Kent Johnson (@kent37), Kevin Ushey (@kevinushey), 电线杆
(@kfeng123), Karl Forner (@kforner), Kirill Sevastyanenko (@kirillseva),
Brian Knaus (@knausb), Kirill Müller (@krlmlr), Kriti Sen Sharma
(@ksens), Kevin Wright (@kwstat),
\href{mailto:suo.lawrence.liu@gmail.com}{\nolinkurl{suo.lawrence.liu@gmail.com}}
(@Lawrence-Liu), @ldfmrails, Rachel Severson (@leighseverson), Laurent
Gatto (@lgatto), C. Jason Liang (@liangcj), Steve Lianoglou (@lianos),
@lindbrook, Lingbing Feng (@Lingbing), Marcel Ramos (@LiNk-NY),
Zhongpeng Lin (@linzhp), Lionel Henry (@lionel-), myq (@lrcg), Luke W
Johnston (@lwjohnst86), Kevin Lynagh (@lynaghk), Malcolm Barrett
(@malcolmbarrett), @mannyishere, Matt (@mattbaggott), Matthew Grogan
(@mattgrogan), @matthewhillary, Matthieu Gomez (@matthieugomez), Matt
Malin (@mattmalin), Mauro Lepore (@maurolepore), Max Ghenis
(@MaxGhenis), Maximilian Held (@maxheld83), Michal Bojanowski (@mbojan),
Mark Rosenstein (@mbrmbr), Michael Sumner (@mdsumner), Jun Mei
(@meijun), merkliopas (@merkliopas), mfrasco (@mfrasco), Michael Bach
(@michaelbach), Michael Bishop (@MichaelMBishop), Michael Buckley
(@michaelmikebuckley), Michael Quinn (@michaelquinn32), @miguelmorin,
Michael (@mikekaminsky), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel),
@mjsduncan, Mamoun Benghezal (@MoBeng), Matt Pettis (@mpettis), Martin
Morgan (@mtmorgan), Guy Dawson (@Mullefa), Nacho Caballero (@nachocab),
Natalya Rapstine (@natalya-patrikeeva), Nick Carchedi (@ncarchedi), Noah
Greifer (@ngreifer), Nicholas Vasile (@nickv9), Nikos Ignatiadis
(@nignatiadis), Xavier Laviron (@norival), Nick Pullen (@nstjhp), Oge
Nnadi (@ogennadi), Oliver Paisley (@oliverpaisley), Pariksheet Nanda
(@omsai), Øystein Sørensen (@osorensen), Paul (@otepoti), Otho
Mantegazza (@othomantegazza), Dewey Dunnington (@paleolimbot), Parker
Abercrombie (@parkerabercrombie), Patrick Hausmann (@patperu), Patrick
Miller (@patr1ckm), Patrick Werkmeister (@Patrick01), @paulponcet,
@pdb61, Tom Crockett (@pelotom), @pengyu, Jeremiah (@perryjer1), Peter
Hickey (@PeteHaitch), Phil Chalmers (@philchalmers), Jose Antonio Magaña
Mesa (@picarus), Pierre Casadebaig (@picasa), Antonio Piccolboni
(@piccolbo), Pierre Roudier (@pierreroudier), Poor Yorick (@pooryorick),
Marie-Helene Burle (@prosoitos), Peter Schulam (@pschulam), John
(@quantbo), Quyu Kong (@qykong), Ramiro Magno (@ramiromagno), Ramnath
Vaidyanathan (@ramnathv), Kun Ren (@renkun-ken), Richard Reeve
(@richardreeve), Richard Cotton (@richierocks), Robert M Flight
(@rmflight), R. Mark Sharp (@rmsharp), Robert Krzyzanowski (@robertzk),
@robiRagan, Romain François (@romainfrancois), Ross Holmberg
(@rossholmberg), Ricardo Pietrobon (@rpietro), @rrunner, Ryan Walker
(@rtwalker), @rubenfcasal, Rob Weyant (@rweyant), Rumen Zarev (@rzarev),
Nan Wang (@sailingwave), @sbgraves237, Scott Kostyshak (@scottkosty),
Scott Leishman (@scttl), Sean Hughes (@seaaan), Sean Anderson
(@seananderson), Sean Carmody (@seancarmody), Sebastian (@sebastian-c),
Matthew Sedaghatfar (@sedaghatfar), @see24, Sven E. Templer
(@setempler), @sflippl, @shabbybanks, Steven Pav (@shabbychef), Shannon
Rush (@shannonrush), S'busiso Mkhondwane (@sibusiso16), Sigfried Gold
(@Sigfried), Simon O'Hanlon (@simonohanlon101), Simon Potter (@sjp),
Steve (@SplashDance), Scott Ritchie (@sritchie73), Tim Cole (@statist7),
@ste-fan, @stephens999, Steve Walker (@stevencarlislewalker), Stefan
Widgren (@stewid), Homer Strong (@strongh), Dirk (@surmann), Sebastien
Vigneau (@svigneau), Scott Warchal (@Swarchal), Steven Nydick
(@swnydick), Taekyun Kim (@taekyunk), Tal Galili (@talgalili), @Tazinho,
Tom B (@tbuckl), @tdenes, @thomasherbig, Thomas (@thomaskern), Thomas
Lin Pedersen (@thomasp85), Thomas Zumbrunn (@thomaszumbrunn), Tim
Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Anton Antonov
(@tonytonov), Ben Torvaney (@Torvaney), Jeff Allen (@trestletech),
Terence Teo (@tteo), Tim Triche, Jr. (@ttriche), @tyhenkaline, Tyler
Ritchie (@tylerritchie), Varun Agrawal (@varun729), Vijay Barve
(@vijaybarve), Victor (@vkryukov), Vaidotas Zemlys-Balevičius
(@vzemlys), Winston Chang (@wch), Linda Chin (@wchi144), Welliton Souza
(@Welliton309), Gregg Whitworth (@whitwort), Will Beasley (@wibeasley),
William R Bauer (@WilCrofter), William Doane (@WilDoane), Sean Wilkinson
(@wilkinson), Christof Winter (@winterschlaefer), Bill Carver (@wmc3),
Wolfgang Huber (@wolfganghuber), Krishna Sankar (@xsankar), Yihui Xie
(@yihui), yang (@yiluheihei), Yoni Ben-Meshulam (@yoni), @yuchouchen,
@zachcp, @zackham, Edward Cho (@zerokarmaleft), Albert Zhao (@zxzb).

\hypertarget{conventions}{%
\section{Conventions}\label{conventions}}

\index{website}

Throughout this book I use \texttt{f()} to refer to functions,
\texttt{g} to refer to variables and function parameters, and
\texttt{h/} to paths.

Larger code blocks intermingle input and output. Output is commented so
that if you have an electronic version of the book, e.g.,
\url{https://adv-r.hadley.nz/}, you can easily copy and paste examples
into R. Output comments look like \texttt{\#\textgreater{}} to
distinguish them from regular comments.

Many examples use random numbers. These are made reproducible by
\texttt{set.seed(1014)}, which is executed automatically at the start of
each chapter.

\hypertarget{colophon}{%
\section{Colophon}\label{colophon}}

This book was written in \href{http://bookdown.org/}{bookdown} inside
\href{http://www.rstudio.com/ide/}{RStudio}. The
\href{https://adv-r.hadley.nz/}{website} is hosted with
\href{http://netlify.com/}{netlify}, and automatically updated after
every commit by \href{https://travis-ci.org/}{travis-ci}. The complete
source is available from \href{https://github.com/hadley/adv-r}{github}.
Code in the printed book is set in
\href{http://levien.com/type/myfonts/inconsolata.html}{inconsolata}.
Emoji come from the open-licensed
\href{https://github.com/twitter/twemoji}{Twitter Emoji}.

This version of the book was built with the following version of R and
packages.

\begin{longtable}[]{@{}ll@{}}
\toprule
setting & value\tabularnewline
\midrule
\endhead
version & R version 3.5.1 (2017-01-27)\tabularnewline
os & Ubuntu 14.04.5 LTS\tabularnewline
system & x86\_64, linux-gnu\tabularnewline
ui & X11\tabularnewline
language & (EN)\tabularnewline
collate & en\_US.UTF-8\tabularnewline
ctype & en\_US.UTF-8\tabularnewline
tz & UTC\tabularnewline
date & 2018-11-19\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}lll@{}}
\toprule
package & version & source\tabularnewline
\midrule
\endhead
assertthat & 0.2.0 & CRAN (R 3.5.1)\tabularnewline
backports & 1.1.2 & CRAN (R 3.5.1)\tabularnewline
base64enc & 0.1-3 & CRAN (R 3.5.1)\tabularnewline
bench & 1.0.1 & CRAN (R 3.5.1)\tabularnewline
BH & 1.66.0-1 & CRAN (R 3.5.1)\tabularnewline
bindr & 0.1.1 & CRAN (R 3.5.1)\tabularnewline
bindrcpp & 0.2.2 & CRAN (R 3.5.1)\tabularnewline
bit & 1.1-14 & CRAN (R 3.5.1)\tabularnewline
bit64 & 0.9-7 & CRAN (R 3.5.1)\tabularnewline
blob & 1.1.1 & CRAN (R 3.5.1)\tabularnewline
bookdown & 0.7 & CRAN (R 3.5.1)\tabularnewline
cli & 1.0.1 & CRAN (R 3.5.1)\tabularnewline
codetools & 0.2-15 & CRAN (R 3.5.1)\tabularnewline
colorspace & 1.3-2 & CRAN (R 3.5.1)\tabularnewline
crayon & 1.3.4 & CRAN (R 3.5.1)\tabularnewline
DBI & 1.0.0 & CRAN (R 3.5.1)\tabularnewline
dbplyr & 1.2.2 & CRAN (R 3.5.1)\tabularnewline
desc & 1.2.0 & CRAN (R 3.5.1)\tabularnewline
digest & 0.6.18 & CRAN (R 3.5.1)\tabularnewline
dplyr & 0.7.8 & CRAN (R 3.5.1)\tabularnewline
emo & 0.0.0.9000 & Github (hadley/emo@02a5206)\tabularnewline
evaluate & 0.12 & CRAN (R 3.5.1)\tabularnewline
fansi & 0.4.0 & CRAN (R 3.5.1)\tabularnewline
furrr & 0.1.0 & CRAN (R 3.5.1)\tabularnewline
future & 1.10.0 & CRAN (R 3.5.1)\tabularnewline
ggplot2 & 3.1.0 & CRAN (R 3.5.1)\tabularnewline
globals & 0.12.4 & CRAN (R 3.5.1)\tabularnewline
glue & 1.3.0 & Github (tidyverse/glue@35c61e9)\tabularnewline
gtable & 0.2.0 & CRAN (R 3.5.1)\tabularnewline
highr & 0.7 & CRAN (R 3.5.1)\tabularnewline
hms & 0.4.2 & CRAN (R 3.5.1)\tabularnewline
htmltools & 0.3.6 & CRAN (R 3.5.1)\tabularnewline
httpuv & 1.4.5 & CRAN (R 3.5.1)\tabularnewline
inline & 0.3.15 & CRAN (R 3.5.1)\tabularnewline
jsonlite & 1.5 & CRAN (R 3.5.1)\tabularnewline
knitr & 1.20 & CRAN (R 3.5.1)\tabularnewline
labeling & 0.3 & CRAN (R 3.5.1)\tabularnewline
later & 0.7.5 & CRAN (R 3.5.1)\tabularnewline
lattice & 0.20-35 & CRAN (R 3.5.1)\tabularnewline
lazyeval & 0.2.1 & CRAN (R 3.5.1)\tabularnewline
lineprof & 0.1.9001 & Github (hadley/lineprof@972e71d)\tabularnewline
listenv & 0.7.0 & CRAN (R 3.5.1)\tabularnewline
lobstr & 0.0.0.9000 & Github (r-lib/lobstr@2ab73e8)\tabularnewline
lubridate & 1.7.4 & CRAN (R 3.5.1)\tabularnewline
magrittr & 1.5 & CRAN (R 3.5.1)\tabularnewline
markdown & 0.8 & CRAN (R 3.5.1)\tabularnewline
MASS & 7.3-50 & CRAN (R 3.5.1)\tabularnewline
Matrix & 1.2-14 & CRAN (R 3.5.1)\tabularnewline
memoise & 1.1.0 & CRAN (R 3.5.1)\tabularnewline
mgcv & 1.8-24 & CRAN (R 3.5.1)\tabularnewline
microbenchmark & 1.4-6 & CRAN (R 3.5.1)\tabularnewline
mime & 0.6 & CRAN (R 3.5.1)\tabularnewline
munsell & 0.5.0 & CRAN (R 3.5.1)\tabularnewline
nlme & 3.1-137 & CRAN (R 3.5.1)\tabularnewline
pillar & 1.3.0 & CRAN (R 3.5.1)\tabularnewline
pkgconfig & 2.0.2 & CRAN (R 3.5.1)\tabularnewline
plogr & 0.2.0 & CRAN (R 3.5.1)\tabularnewline
plyr & 1.8.4 & CRAN (R 3.5.1)\tabularnewline
png & 0.1-7 & CRAN (R 3.5.1)\tabularnewline
praise & 1.0.0 & CRAN (R 3.5.1)\tabularnewline
prettyunits & 1.0.2 & CRAN (R 3.5.1)\tabularnewline
profmem & 0.5.0 & CRAN (R 3.5.1)\tabularnewline
promises & 1.0.1 & CRAN (R 3.5.1)\tabularnewline
pryr & 0.1.4 & CRAN (R 3.5.1)\tabularnewline
purrr & 0.2.5 & CRAN (R 3.5.1)\tabularnewline
R6 & 2.3.0 & CRAN (R 3.5.1)\tabularnewline
RColorBrewer & 1.1-2 & CRAN (R 3.5.1)\tabularnewline
Rcpp & 1.0.0 & CRAN (R 3.5.1)\tabularnewline
readr & 1.1.1 & CRAN (R 3.5.1)\tabularnewline
reshape2 & 1.4.3 & CRAN (R 3.5.1)\tabularnewline
rlang & 0.3.0.1 & CRAN (R 3.5.1)\tabularnewline
rmarkdown & 1.10 & CRAN (R 3.5.1)\tabularnewline
rprojroot & 1.3-2 & CRAN (R 3.5.1)\tabularnewline
RSQLite & 2.1.1 & CRAN (R 3.5.1)\tabularnewline
scales & 1.0.0 & CRAN (R 3.5.1)\tabularnewline
sessioninfo & 1.1.1 & CRAN (R 3.5.1)\tabularnewline
shiny & 1.2.0 & CRAN (R 3.5.1)\tabularnewline
sloop & 1.0.0 & CRAN (R 3.5.1)\tabularnewline
sourcetools & 0.1.7 & CRAN (R 3.5.1)\tabularnewline
stringi & 1.2.4 & CRAN (R 3.5.1)\tabularnewline
stringr & 1.3.1 & CRAN (R 3.5.1)\tabularnewline
testthat & 2.0.1 & CRAN (R 3.5.1)\tabularnewline
tibble & 1.4.2 & CRAN (R 3.5.1)\tabularnewline
tidyselect & 0.2.5 & CRAN (R 3.5.1)\tabularnewline
tinytex & 0.9 & CRAN (R 3.5.1)\tabularnewline
utf8 & 1.1.4 & CRAN (R 3.5.1)\tabularnewline
vctrs & 0.0.0.9000 & Github (r-lib/vctrs@688707c)\tabularnewline
viridisLite & 0.3.0 & CRAN (R 3.5.1)\tabularnewline
withr & 2.1.2 & CRAN (R 3.5.1)\tabularnewline
xfun & 0.4 & CRAN (R 3.5.1)\tabularnewline
xtable & 1.8-3 & CRAN (R 3.5.1)\tabularnewline
yaml & 2.2.0 & CRAN (R 3.5.1)\tabularnewline
zeallot & 0.1.0 & CRAN (R 3.5.1)\tabularnewline
\bottomrule
\end{longtable}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ruler}\NormalTok{()}
\CommentTok{#> ----+----1----+----2----+----3----+----4----+----5----+----6----+----}
\CommentTok{#> 123456789012345678901234567890123456789012345678901234567890123456789}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-foundations}{%
\part{Foundations}\label{part-foundations}}

\hypertarget{foundations-intro}{%
\chapter*{Introduction}\label{foundations-intro}}
\addcontentsline{toc}{chapter}{Introduction}

To start your journey in mastering R, the following six chapters will
help you learn what I consider to be the foundational components of R. I
expect that you've already seen many of these pieces before, but you
probably have not studied them deeply. To help check your existing
knowledge, each chapter starts with a quiz; if you get all the questions
right, feel free to skip to the next chapter!

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In Chapter \ref{names-values}, you'll learn about one of the most
  important distinctions you haven't previously needed to grapple with:
  the difference between an object and its name. Improving your mental
  model here will help you make better predictions about when R copies
  data and hence which basic operations are cheap and which are
  expensive.
\item
  Every day you've used R, you've used vectors, so Chapter
  \ref{vectors-chap} will dive into the details, helping you learn how
  the different types of vector fit together. You'll also learn about
  attributes, which allow you to store arbitrary metadata, and form the
  basis for two of R's object oriented programming toolkits
\item
  To write concise and performant R code it is important to fully
  appreciate the power of subsetting with \texttt{{[}}, \texttt{{[}{[}}
  and \texttt{\$}, as described in Chapter \ref{subsetting}.
  Understanding the fundamental components of subsetting will allow you
  to solve new problems by combining the building blocks in novel ways.
\item
  Functions are the most important building block of R code, and in
  Chapter \ref{functions}, you'll learn exactly how they work, including
  the \textbf{scoping} rules, which govern how R looks up values from
  names. You'll also learn more of the details behind R's lazy
  evaluation, and how you can control what happens when you exit a
  function.
\item
  In Chapter \ref{environments}, you'll learn about a data structure
  that is crucial for understanding how R works, but quite unimportant
  for data analysis: the environment. Environments are the data
  structure that binds names to values, and they power tools like
  package namespaces. Unlike most programming languages, environments in
  R are ``first class'' which means that you can manipulate them just
  like other objects.
\item
  Chapter \ref{conditions} concludes this section of the book with a
  discussion of ``conditions'', the umbrella term used to describe
  errors, warnings, and messages. You've certainly encountered these
  before, so in this chapter you learn how to signal them appropriately
  in your own functions, and how to handle them when signalled
  elsewhere.
\end{enumerate}

\hypertarget{names-values}{%
\chapter{Names and values}\label{names-values}}

\hypertarget{introduction-1}{%
\section{Introduction}\label{introduction-1}}

In R, it is important to understand the distinction between an object
and its name. Doing so will help you:

\begin{itemize}
\tightlist
\item
  More accurately predict the performance and memory usage of your code.
\item
  Write faster code by avoiding accidental copies, a major source of
  slow code.
\item
  Better understand R's functional programming tools.
\end{itemize}

The goal of this chapter is to help you understand the distinction
between names and values, and when R will copy an object.

\hypertarget{quiz}{%
\subsection*{Quiz}\label{quiz}}
\addcontentsline{toc}{subsection}{Quiz}

Answer the following questions to see if you can safely skip this
chapter. You can find the answers at the end of the chapter in Section
\ref{names-values-answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Given the following data frame, how do I create a new column called
  ``3'' that contains the sum of \texttt{1} and \texttt{2}? You may only
  use \texttt{\$}, not \texttt{{[}{[}}. What makes \texttt{1},
  \texttt{2}, and \texttt{3} challenging as variable names?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{), }\KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\KeywordTok{names}\NormalTok{(df) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  In the following code, how much memory does \texttt{y} occupy?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(x, x, x)}
\end{Highlighting}
\end{Shaded}
\item
  On which line does \texttt{a} get copied in the following example?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\NormalTok{a}
\NormalTok{b[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{outline}{%
\subsection*{Outline}\label{outline}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{binding-basics} introduces you to the distinction between
  names and values, and discusses how \texttt{\textless{}-} creates a
  binding, or reference, between a name and a value.
\item
  Section \ref{copy-on-modify} describes when R makes a copy: whenever
  you modify a vector, you're almost certainly creating a new, modified
  vector. You'll learn how to use \texttt{tracemem()} to figure out when
  a copy actually occurs. Then you'll explore the implications as they
  apply to function calls, lists, data frames, and character vectors.
\item
  Section \ref{object-size} explores the implications of the previous
  two sections on how much memory an object occupies. Since your
  intuition may be profoundly wrong and since
  \texttt{utils::object.size()} is unfortunately inaccurate, you'll
  learn how to use \texttt{lobstr::obj\_size()}.
\item
  Section \ref{modify-in-place} describes the two important exceptions
  to copy-on-modify: with environments and values with a single name,
  objects are actually modified in place.
\item
  Section \ref{gc} concludes the chapter with a discussion of the
  garbage collector, which frees up the memory used by objects no longer
  referenced by a name.
\end{itemize}

\hypertarget{prerequisites}{%
\subsection*{Prerequisites}\label{prerequisites}}
\addcontentsline{toc}{subsection}{Prerequisites}

We'll use the development version of
\href{https://github.com/r-lib/lobstr}{lobstr} to dig into the internal
representation of R objects.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# devtools::install_github("r-lib/lobstr")}
\KeywordTok{library}\NormalTok{(lobstr)}
\end{Highlighting}
\end{Shaded}

\hypertarget{sources}{%
\subsection*{Sources}\label{sources}}
\addcontentsline{toc}{subsection}{Sources}

The details of R's memory management are not documented in a single
place. Much of the information in this chapter was gleaned from a close
reading of the documentation (particularly \texttt{?Memory} and
\texttt{?gc}), the
\href{http://cran.r-project.org/doc/manuals/R-exts.html\#Profiling-R-code-for-memory-use}{memory
profiling} section of ``Writing R extensions'' (R Core Team
\protect\hyperlink{ref-r-exts}{2018}\protect\hyperlink{ref-r-exts}{b}),
and the
\href{http://cran.r-project.org/doc/manuals/R-ints.html\#SEXPs}{SEXPs}
section of ``R internals'' (R Core Team
\protect\hyperlink{ref-r-ints}{2018}\protect\hyperlink{ref-r-ints}{a}).
The rest I figured out by reading the C source code, performing small
experiments, and asking questions on R-devel. Any mistakes are entirely
mine.

\hypertarget{binding-basics}{%
\section{Binding basics}\label{binding-basics}}

\index{bindings} \index{assignment}

Consider this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It's easy to read it as: ``create an object named `x', containing the
values 1, 2, and 3''. Unfortunately, that's a simplification that will
lead to inaccurate predictions about what R is actually doing behind the
scenes. It's more accurate to say that this code is doing two things:

\begin{itemize}
\tightlist
\item
  It's creating an object, a vector of values, \texttt{c(1,\ 2,\ 3)}.
\item
  And it's binding that object to a name, \texttt{x}.
\end{itemize}

In other words, the object, or value, doesn't have a name; it's actually
the name that has a value.

To further clarify this distinction, I'll draw diagrams like this:

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/binding-1} \end{center}

The name, \texttt{x}, is drawn with a rounded rectangle. It has an arrow
that points to (or binds or references) the value, the vector
\texttt{1:3}. Note that the arrow points in opposite direction to the
assignment arrow: \texttt{\textless{}-} creates a binding from the name
on the left-hand side to the object on the right-hand side.

Thus, you can think of a name as a reference to a value. For example, if
you run this code, you don't get another copy of the value \texttt{1:3},
you get another binding to the existing object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.77in]{diagrams/name-value/binding-2} \end{center}

You might have noticed that the value \texttt{1:3} has a label:
\texttt{0x74b}. While the vector doesn't have a name, I'll occasionally
need to refer to an object independent of its bindings. To make that
possible, I'll label values with a unique identifier. These identifiers
have a special form that looks like the object's memory ``address'',
i.e.~the location in memory where the object is stored. But because the
actual memory addresses changes every time the code is run, we use these
identifiers instead.

You can access an object's identifier with \texttt{lobstr::obj\_addr()}.
Doing so allows you to see that both \texttt{x} and \texttt{y} point to
the same identifier:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_addr}\NormalTok{(x)}
\CommentTok{#> [1] "0x43f7f68"}
\KeywordTok{obj_addr}\NormalTok{(y)}
\CommentTok{#> [1] "0x43f7f68"}
\end{Highlighting}
\end{Shaded}

These identifiers are long, and change every time you restart R.

It can take some time to get your head around the distinction between
names and values, but understanding this is really helpful in functional
programming where functions can have different names in different
contexts.

\hypertarget{non-syntactic}{%
\subsection{Non-syntactic names}\label{non-syntactic}}

\index{reserved names} \indexc{`} \index{non-syntactic names}

R has strict rules about what constitutes a valid name. A
\textbf{syntactic} name must consist of letters\footnote{Surprisingly,
  what constitutes a letter is determined by your current locale. That
  means that the syntax of R code can actually differ from computer to
  computer, and that it's possible for a file that works on one computer
  to not even parse on another!}, digits, \texttt{.} and \texttt{\_} but
can't begin with \texttt{\_} or a digit. Additionally, you can't use any
of the \textbf{reserved words} like \texttt{TRUE}, \texttt{NULL},
\texttt{if}, and \texttt{function} (see the complete list in
\texttt{?Reserved}). A name that doesn't follow these rules is a
\textbf{non-syntactic} name; if you try to use them, you'll get an
error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{_abc <-}\StringTok{ }\DecValTok{1}
\CommentTok{#> Error: unexpected input in "_"}

\ControlFlowTok{if}\NormalTok{ <-}\StringTok{ }\DecValTok{10}
\CommentTok{#> Error: unexpected assignment in "if <-"}
\end{Highlighting}
\end{Shaded}

It's possible to override these rules and use any name, i.e., any
sequence of characters, by surrounding it with backticks:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{_abc}\StringTok{`}\NormalTok{ <-}\StringTok{ }\DecValTok{1}
\StringTok{`}\DataTypeTok{_abc}\StringTok{`}
\CommentTok{#> [1] 1}

\StringTok{`}\DataTypeTok{if}\StringTok{`}\NormalTok{ <-}\StringTok{ }\DecValTok{10}
\StringTok{`}\DataTypeTok{if}\StringTok{`}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

While it's unlikely you'd deliberately create such crazy names, you need
to understand how these crazy names work because you'll come across
them, most commonly when you load data that has been created outside of
R.

You \emph{can} also create non-syntactic bindings using single or double
quotes (e.g. \texttt{"\_abc"\ \textless{}-\ 1}) instead of backticks,
but you shouldn't, because you'll have to use a different syntax to
retrieve the values. The ability to use strings on the left hand side of
the assignment arrow is an historical artefact, used before R supported
backticks.

\hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Explain the relationship between \texttt{a}, \texttt{b}, \texttt{c}
  and \texttt{d} in the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{b <-}\StringTok{ }\NormalTok{a}
\NormalTok{c <-}\StringTok{ }\NormalTok{b}
\NormalTok{d <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}
\item
  The following code accesses the mean function in multiple ways. Do
  they all point to the same underlying function object? Verify this
  with \texttt{lobstr::obj\_addr()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean}
\NormalTok{base}\OperatorTok{::}\NormalTok{mean}
\KeywordTok{get}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\KeywordTok{evalq}\NormalTok{(mean)}
\KeywordTok{match.fun}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  By default, base R data import functions, like \texttt{read.csv()},
  will automatically convert non-syntactic names to syntactic ones. Why
  might this be problematic? What option allows you to suppress this
  behaviour
\item
  What rules does \texttt{make.names()} use to convert non-syntactic
  names into syntactic ones?
\item
  I slightly simplified the rules that govern syntactic names. Why is
  \texttt{.123e1} not a syntactic name? Read \texttt{?make.names} for
  the full details.
\end{enumerate}

\hypertarget{copy-on-modify}{%
\section{Copy-on-modify}\label{copy-on-modify}}

Consider the following code. It binds \texttt{x} and \texttt{y} to the
same underlying value, then modifies \texttt{y}.\footnote{You may be
  surprised to see \texttt{{[}{[}} used with a numeric vector. We'll
  come back to this in Section \ref{subset-single}, but in brief, I
  think you should always use \texttt{{[}{[}} when you are getting or
  setting a single element.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\NormalTok{x}

\NormalTok{y[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\NormalTok{x}
\CommentTok{#> [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

Modifying \texttt{y} clearly didn't modify \texttt{x}. So what happened
to the shared binding? While the value associated with \texttt{y}
changed, the original object did not. Instead, R created a new object,
\texttt{0xcd2}, a copy of \texttt{0x74b} with one value changed, then
rebinded \texttt{y} to that object.

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/binding-3} \end{center}

This behaviour is called \textbf{copy-on-modify}. Understanding it will
radically improve your intuition about the performance of R code. A
related way to describe this behaviour is to say that R objects are
unchangeable, or \textbf{immutable}. However, I'll generally avoid that
term because there are a couple of important exceptions to
copy-on-modify that you'll learn about in Section \ref{modify-in-place}.

\hypertarget{tracemem}{%
\subsection{\texorpdfstring{\texttt{tracemem()}}{tracemem()}}\label{tracemem}}

You can see when an object gets copied with the help of
\texttt{base::tracemem()}. Once you call that function with an object,
you'll get the object's current address:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{cat}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(x), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{#> <0x7f80c0e0ffc8> }
\end{Highlighting}
\end{Shaded}

From then on, whenever that object is copied, \texttt{tracemem()} will
print a message telling you which object was copied, its new address,
and the sequence of calls that led to the copy:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{x}
\NormalTok{y[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\NormalTok{4L}
\CommentTok{#> tracemem[0x7f80c0e0ffc8 -> 0x7f80c4427f40]: }
\end{Highlighting}
\end{Shaded}

Note that if you modify \texttt{y} again, it won't get copied. That's
because the new object now only has a single name bound to it, so R
applies modify-in-place optimisation. We'll come back to this shortly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\NormalTok{5L}

\KeywordTok{untracemem}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\texttt{untracemem()} is the opposite of \texttt{tracemem()}; it turns
tracing off.

\hypertarget{function-calls}{%
\subsection{Function calls}\label{function-calls}}

The same rules for copying also apply to function calls. Take this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a) \{}
\NormalTok{  a}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\KeywordTok{cat}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(x), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{#> <0x38bae48>}

\NormalTok{z <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x)}
\CommentTok{# there's no copy here!}

\KeywordTok{untracemem}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

While \texttt{f()} is running, the \texttt{a} inside the function points
to the same value as the \texttt{x} does outside the function:

\begin{center}\includegraphics[width=2.6in]{diagrams/name-value/binding-f1} \end{center}

(You'll learn more about the conventions used in this diagram in
\protect\hyperlink{execution-environments}{Execution environments}.)

Once \texttt{f()} completes, \texttt{x} and \texttt{z} will point to the
same object. \texttt{0x74b} never gets copied because it never gets
modified. If \texttt{f()} did modify \texttt{x}, R would create a new
copy, and then \texttt{z} would bind that object.

\begin{center}\includegraphics[width=1.77in]{diagrams/name-value/binding-f2} \end{center}

\hypertarget{list-references}{%
\subsection{Lists}\label{list-references}}

It's not just names (i.e.~variables) that point to values; elements of
lists do too. Take this list, which is superficially very similar to the
vector above:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l1 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The internal representation of a list is actually quite different from
that of a vector. A list is really a vector of references:

\begin{center}\includegraphics[width=1.97in]{diagrams/name-value/list} \end{center}

This is particularly important when we modify a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l2 <-}\StringTok{ }\NormalTok{l1}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.97in]{diagrams/name-value/l-modify-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l2[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.31in]{diagrams/name-value/l-modify-2} \end{center}

Like vectors, lists use copy-on-modify behaviour; the original list is
left unchanged, and R creates a modified copy. This, however, is a
\textbf{shallow} copy: the list object and its bindings are copied, but
the values pointed to by the bindings are not. The opposite of a shallow
copy is a deep copy where the contents of every reference are copied.
Prior to R 3.1.0, copies were always deep copies.

To see values that are shared across lists, use \texttt{lobstr::ref()}.
\texttt{ref()} prints the memory address of each object, along with a
local ID so that you can easily cross-reference shared components.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ref}\NormalTok{(l1, l2)}
\CommentTok{#> █ [1:0x6ec3878] <list> }
\CommentTok{#> ├─[2:0x6d21298] <dbl> }
\CommentTok{#> ├─[3:0x6d21260] <dbl> }
\CommentTok{#> └─[4:0x6d21228] <dbl> }
\CommentTok{#>  }
\CommentTok{#> █ [5:0x7914778] <list> }
\CommentTok{#> ├─[2:0x6d21298] }
\CommentTok{#> ├─[3:0x6d21260] }
\CommentTok{#> └─[6:0x781c148] <dbl>}
\end{Highlighting}
\end{Shaded}

\hypertarget{df-modify}{%
\subsection{Data frames}\label{df-modify}}

Data frames are lists of vectors, so copy-on-modify has important
consequences when you modify a data frame. Take this data frame as an
example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d1 <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.72in]{diagrams/name-value/dataframe} \end{center}

If you modify a column, only \emph{that} column needs to be modified;
the others will still point to their original references:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d2 <-}\StringTok{ }\NormalTok{d1}
\NormalTok{d2[, }\DecValTok{2}\NormalTok{] <-}\StringTok{ }\NormalTok{d2[, }\DecValTok{2}\NormalTok{] }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.21in]{diagrams/name-value/d-modify-c} \end{center}

However, if you modify a row, there is no way to share data with the
previous version of the data frame: every column must be
copied-and-modified.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d3 <-}\StringTok{ }\NormalTok{d1}
\NormalTok{d3[}\DecValTok{1}\NormalTok{, ] <-}\StringTok{ }\NormalTok{d3[}\DecValTok{1}\NormalTok{, ] }\OperatorTok{*}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.39in]{diagrams/name-value/d-modify-r} \end{center}

\hypertarget{character-vectors}{%
\subsection{Character vectors}\label{character-vectors}}

\index{string pool}

The final place that R uses references is with character vectors. I
usually draw character vectors like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"abc"}\NormalTok{, }\StringTok{"d"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.51in]{diagrams/name-value/character} \end{center}

But this is a polite fiction. R actually uses a \textbf{global string
pool} where each element of a character vector is a pointer to a unique
string in the pool:

\begin{center}\includegraphics[width=2.6in]{diagrams/name-value/character-2} \end{center}

You can request that \texttt{ref()} show these references by setting the
\texttt{character} argument to \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ref}\NormalTok{(x, }\DataTypeTok{character =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> █ [1:0x42963e8] <chr> }
\CommentTok{#> ├─[2:0x13d5788] <string: "a"> }
\CommentTok{#> ├─[2:0x13d5788] }
\CommentTok{#> ├─[3:0x29a91f0] <string: "abc"> }
\CommentTok{#> └─[4:0x188bb28] <string: "d">}
\end{Highlighting}
\end{Shaded}

This has a profound impact on the amount of memory a character vector
uses but is otherwise generally unimportant, so elsewhere in the book
I'll draw character vectors as if the strings lived inside a vector.

\hypertarget{exercises-1}{%
\subsection{Exercises}\label{exercises-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Why is \texttt{tracemem(1:10)} not useful?
\item
  Explain why \texttt{tracemem()} shows two copies when you run this
  code. Hint: carefully look at the difference between this code and the
  code shown earlier in the section.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{tracemem}\NormalTok{(x)}

\NormalTok{x[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}
\item
  Sketch out the relationship between the following objects:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{b <-}\StringTok{ }\KeywordTok{list}\NormalTok{(a, a)}
\NormalTok{c <-}\StringTok{ }\KeywordTok{list}\NormalTok{(b, a, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  What happens when you run this code?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\NormalTok{x[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\NormalTok{x}
\end{Highlighting}
\end{Shaded}

  Draw a picture.
\end{enumerate}

\hypertarget{object-size}{%
\section{Object size}\label{object-size}}

\indexc{object\_size} 
\indexc{obj\_size}

You can find out how much memory an object takes with
\texttt{lobstr::obj\_size()}\footnote{Beware of the
  \texttt{utils::object.size()} function. It does not correctly account
  for shared references and will return sizes that are too large.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(letters)}
\CommentTok{#> 1,712 B}
\KeywordTok{obj_size}\NormalTok{(ggplot2}\OperatorTok{::}\NormalTok{diamonds)}
\CommentTok{#> 3,456,344 B}
\end{Highlighting}
\end{Shaded}

Since the elements of lists are references to values, the size of a list
might be much smaller than you expect:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\KeywordTok{obj_size}\NormalTok{(x)}
\CommentTok{#> 8,000,048 B}

\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(x, x, x)}
\KeywordTok{obj_size}\NormalTok{(y)}
\CommentTok{#> 8,000,128 B}
\end{Highlighting}
\end{Shaded}

\texttt{y} is only 80 bytes\footnote{If you're running the 32-bit
  version of R you'll see slightly different sizes.} bigger than
\texttt{x}. That's the size of an empty list with three elements:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\OtherTok{NULL}\NormalTok{, }\OtherTok{NULL}\NormalTok{))}
\CommentTok{#> 80 B}
\end{Highlighting}
\end{Shaded}

Similarly, because R uses a global string pool character vectors take up
less memory than you might expect: repeating a string 1000 times does
not make it take up 1000 times as much memory.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{banana <-}\StringTok{ "bananas bananas bananas"}
\KeywordTok{obj_size}\NormalTok{(banana)}
\CommentTok{#> 136 B}
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{rep}\NormalTok{(banana, }\DecValTok{100}\NormalTok{))}
\CommentTok{#> 928 B}
\end{Highlighting}
\end{Shaded}

References also make it challenging to think about the size of
individual objects. \texttt{obj\_size(x)\ +\ obj\_size(y)} will only
equal \texttt{obj\_size(x,\ y)} if there are no shared values. Here, the
combined size of \texttt{x} and \texttt{y} is the same as the size of
\texttt{y}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(x, y)}
\CommentTok{#> 8,000,128 B}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-2}{%
\subsection{Exercises}\label{exercises-2}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the following example, why are \texttt{object.size(y)} and
  \texttt{obj\_size(y)} so radically different? Consult the
  documentation of \texttt{object.size()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\FloatTok{1e4}\NormalTok{)), }\DecValTok{100}\NormalTok{)}

\KeywordTok{object.size}\NormalTok{(y)}
\CommentTok{#> 8005648 bytes}
\KeywordTok{obj_size}\NormalTok{(y)}
\CommentTok{#> 80,896 B}
\end{Highlighting}
\end{Shaded}
\item
  Take the following list. Why is its size somewhat misleading?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(mean, sd, var)}
\KeywordTok{obj_size}\NormalTok{(x)}
\CommentTok{#> 17,664 B}
\end{Highlighting}
\end{Shaded}
\item
  Predict the output of the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\KeywordTok{obj_size}\NormalTok{(x)}

\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(x, x)}
\KeywordTok{obj_size}\NormalTok{(y)}
\KeywordTok{obj_size}\NormalTok{(x, y)}

\NormalTok{y[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\KeywordTok{obj_size}\NormalTok{(y)}
\KeywordTok{obj_size}\NormalTok{(x, y)}

\NormalTok{y[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\KeywordTok{obj_size}\NormalTok{(y)}
\KeywordTok{obj_size}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{modify-in-place}{%
\section{Modify-in-place}\label{modify-in-place}}

As we've seen above, modifying an R object usually creates a copy. There
are two exceptions:

\begin{itemize}
\item
  Objects with a single binding get a special performance optimisation.
\item
  Environments, a special type of object, are always modified in place.
\end{itemize}

\hypertarget{single-binding}{%
\subsection{Objects with a single binding}\label{single-binding}}

If an object has a single name bound to it, R will modify it in place:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/v-inplace-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/v-inplace-2} \end{center}

(Note the object IDs here: \texttt{v} continues to bind to the same
object, \texttt{0x207}.)

Two complications make predicting exactly when R applies this
optimisation challenging:

\begin{itemize}
\item
  When it comes to bindings, R can currently\footnote{By the time you
    read this, this may have changed, as plans are afoot to improve
    reference counting:
    \url{https://developer.r-project.org/Refcnt.html}} only count 0, 1,
  or many. That means that if an object has two bindings, and one goes
  away, the reference count does not go back to 1: one less than many is
  still many.
\item
  Whenever you call any regular function, it makes a reference to the
  object. The only exception are specially written C functions. These
  occur mostly in the base package.
\end{itemize}

Together, these two complications make it hard to predict whether or not
a copy will occur. Instead, it's better to determine it empirically with
\texttt{tracemem()}.

Let's explore the subtleties with a case study using for loops. For
loops have a reputation for being slow in R, but often that slowness is
caused by every iteration of the loop creating a copy. Consider the
following code. It subtracts the median from each column of a large data
frame: \index{loops!avoiding copies}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{5} \OperatorTok{*}\StringTok{ }\FloatTok{1e4}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{))}
\NormalTok{medians <-}\StringTok{ }\KeywordTok{vapply}\NormalTok{(x, median, }\KeywordTok{numeric}\NormalTok{(}\DecValTok{1}\NormalTok{))}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(medians)) \{}
\NormalTok{  x[[i]] <-}\StringTok{ }\NormalTok{x[[i]] }\OperatorTok{-}\StringTok{ }\NormalTok{medians[[i]]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This loop is surprisingly slow because each iteration of the loop copies
the data frame. You can see this by using \texttt{tracemem()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(x), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{#> <0x7f80c429e020> }

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{) \{}
\NormalTok{  x[[i]] <-}\StringTok{ }\NormalTok{x[[i]] }\OperatorTok{-}\StringTok{ }\NormalTok{medians[[i]]}
\NormalTok{\}}
\CommentTok{#> tracemem[0x7f80c429e020 -> 0x7f80c0c144d8]: }
\CommentTok{#> tracemem[0x7f80c0c144d8 -> 0x7f80c0c14540]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c14540 -> 0x7f80c0c145a8]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c145a8 -> 0x7f80c0c14610]: }
\CommentTok{#> tracemem[0x7f80c0c14610 -> 0x7f80c0c14678]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c14678 -> 0x7f80c0c146e0]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c146e0 -> 0x7f80c0c14748]: }
\CommentTok{#> tracemem[0x7f80c0c14748 -> 0x7f80c0c147b0]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c147b0 -> 0x7f80c0c14818]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c14818 -> 0x7f80c0c14880]: }
\CommentTok{#> tracemem[0x7f80c0c14880 -> 0x7f80c0c148e8]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c148e8 -> 0x7f80c0c14950]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c14950 -> 0x7f80c0c149b8]: }
\CommentTok{#> tracemem[0x7f80c0c149b8 -> 0x7f80c0c14a20]: [[<-.data.frame [[<- }
\CommentTok{#> tracemem[0x7f80c0c14a20 -> 0x7f80c0c14a88]: [[<-.data.frame [[<- }

\KeywordTok{untracemem}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

In fact, each iteration copies the data frame not once, not twice, but
three times! Two copies are made by \texttt{{[}{[}.data.frame}, and a
further copy\footnote{Note that these copies are shallow: they only copy
  the reference to each individual column, not the contents of the
  columns. This means the performance isn't terrible, but it's obviously
  not as good as it could be.} is made because
\texttt{{[}{[}.data.frame} is a regular function that increments the
reference count of \texttt{x}.

We can reduce the number of copies by using a list instead of a data
frame. Modifying a list uses internal C code, so the refs are not
incremented and only a single copy is made:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)}
\KeywordTok{cat}\NormalTok{(}\KeywordTok{tracemem}\NormalTok{(y), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{#> <0x7f80c5c3de20>}
  
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{) \{}
\NormalTok{  y[[i]] <-}\StringTok{ }\NormalTok{y[[i]] }\OperatorTok{-}\StringTok{ }\NormalTok{medians[[i]]}
\NormalTok{\}}
\CommentTok{#> tracemem[0x7f80c5c3de20 -> 0x7f80c48de210]: }
\end{Highlighting}
\end{Shaded}

While it's not hard to determine when a copy is made, it is hard to
prevent it. If you find yourself resorting to exotic tricks to avoid
copies, it may be time to rewrite your function in C++, as described in
Chapter \ref{rcpp}.

\hypertarget{env-modify}{%
\subsection{Environments}\label{env-modify}}

You'll learn more about environments in Chapter \ref{environments}, but
it's important to mention them here because their behavior is different
from that of other objects: environments are always modified in place.
This property is sometimes described as \textbf{reference semantics}
because when you modify an environment all existing bindings to that
environment continue to have the same reference.

Take this environment, which we bind to \texttt{e1} and \texttt{e2}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1 <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{env}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}
\NormalTok{e2 <-}\StringTok{ }\NormalTok{e1}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.92in]{diagrams/name-value/e-modify-1} \end{center}

If we change a binding, the environment is modified in place:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1}\OperatorTok{$}\NormalTok{c <-}\StringTok{ }\DecValTok{4}
\NormalTok{e2}\OperatorTok{$}\NormalTok{c}
\CommentTok{#> [1] 4}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.92in]{diagrams/name-value/e-modify-2} \end{center}

This basic idea can be used to create functions that ``remember'' their
previous state. See Section \ref{stateful-funs} for more details. This
property is also used to implement the R6 object oriented programming
system, the topic of Chapter \ref{r6}.

One consequence of this is that environments can contain themselves:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{env}\NormalTok{()}
\NormalTok{e}\OperatorTok{$}\NormalTok{self <-}\StringTok{ }\NormalTok{e}

\KeywordTok{ref}\NormalTok{(e)}
\CommentTok{#> █ [1:0x24a0368] <env> }
\CommentTok{#> └─self = [1:0x24a0368]}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.48in]{diagrams/name-value/e-self} \end{center}

This is a unique property of environments!

\hypertarget{exercises-3}{%
\subsection{Exercises}\label{exercises-3}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Wrap the two methods for subtracting medians into two functions, then
  use the `bench' package (Hester \protect\hyperlink{ref-bench}{2018})
  to carefully compare their speeds. How does performance change as the
  number of columns increase?
\item
  What happens if you attempt to use \texttt{tracemem()} on an
  environment?
\end{enumerate}

\hypertarget{gc}{%
\section{Unbinding and the garbage collector}\label{gc}}

\index{garbage collector} \indexc{rm()} \indexc{gc()}

Consider this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/unbinding-1} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}\OperatorTok{:}\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/unbinding-2} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rm}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.67in]{diagrams/name-value/unbinding-3} \end{center}

We create two objects, but by the end of code neither object is bound to
a name. How do these objects get deleted? That's the job of the
\textbf{garbage collector}, or GC, for short. The GC creates more memory
by deleting R objects that are no longer used, and if needed, requesting
more memory from the operating system.

R uses a \textbf{tracing} GC. That means it traces every object
reachable from the global\footnote{And every environment on the current
  call stack.} environment, and all the objects reachable from those
objects (i.e.~the references in lists and environments are searched
recursively). The garbage collector does not use the reference count
used for the modify-in-place optimisation described above. The two ideas
are closely related but the internal data structures have been optimised
for different use cases.

The garbage collector (GC) is run automatically whenever R needs more
memory to create a new object. From the outside, it's basically
impossible to predict when the GC will run, and indeed, you shouldn't
try. Instead, if you want to find out when the GC runs, call
\texttt{gcinfo(TRUE)}: then the GC will print a message to the console
every time it runs.

You can force the garbage collector to run by calling \texttt{gc()}.
Despite what you might have read elsewhere, there's never any
\emph{need} to call \texttt{gc()} yourself. You may \emph{want} to call
\texttt{gc()} to ask R to return memory to your operating system, or for
its side-effect of telling you how much memory is currently being used:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{gc}\NormalTok{() }
\CommentTok{#>           used (Mb) gc trigger (Mb) max used (Mb)}
\CommentTok{#> Ncells  677000 36.2    1242705 66.4  1242705 66.4}
\CommentTok{#> Vcells 3681827 28.1   11775668 89.9 11774445 89.9}
\end{Highlighting}
\end{Shaded}

\texttt{lobstr::mem\_used()} is a wrapper around \texttt{gc()} that just
prints the total number of bytes used:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mem_used}\NormalTok{()}
\CommentTok{#> 67,371,136 B}
\end{Highlighting}
\end{Shaded}

This number won't agree with the amount of memory reported by your
operating system for three reasons:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  It only includes objects created by R, not the R interpreter itself.
\item
  Both R and the operating system are lazy: they won't reclaim memory
  until it's actually needed. R might be holding on to memory because
  the OS hasn't yet asked for it back.
\item
  R counts the memory occupied by objects but there may be gaps due to
  deleted objects. This problem is known as memory fragmentation.
\end{enumerate}

\hypertarget{names-values-answers}{%
\section{Answers}\label{names-values-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You must surround non-syntactic names in \texttt{\textasciigrave{}}.
  The variables \texttt{1}, \texttt{2}, and \texttt{3} have
  non-syntactic names, so must always be quoted with backticks.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{), }\KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\KeywordTok{names}\NormalTok{(df) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}

\NormalTok{df}\OperatorTok{$}\StringTok{`}\DataTypeTok{3}\StringTok{`}\NormalTok{ <-}\StringTok{ }\NormalTok{df}\OperatorTok{$}\StringTok{`}\DataTypeTok{1}\StringTok{`} \OperatorTok{+}\StringTok{ }\NormalTok{df}\OperatorTok{$}\StringTok{`}\DataTypeTok{2}\StringTok{`}
\end{Highlighting}
\end{Shaded}
\item
  It occupies about 8 MB.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(x, x, x)}
\KeywordTok{obj_size}\NormalTok{(y)}
\CommentTok{#> 8,000,128 B}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{a} is copied when \texttt{b} is modified,
  \texttt{b{[}{[}1{]}{]}\ \textless{}-\ 10}.
\end{enumerate}

\hypertarget{vectors-chap}{%
\chapter{Vectors}\label{vectors-chap}}

\hypertarget{introduction-2}{%
\section{Introduction}\label{introduction-2}}

This chapter discusses the most important family of data types in base
R: the vector types\footnote{Collectively, all other data types are
  known as the ``node'' data types, and include things like functions
  and environments. This is a highly technical term used in only a few
  places. The place where you're most likely to encounter it is the
  output of \texttt{gc()}: the ``N'' in \texttt{Ncells} stands for
  nodes, and the ``V'' in \texttt{Vcells} stands for vectors.}. You've
probably used many (if not all) of the vectors before, but you may not
have thought deeply about how they are interrelated. In this chapter, I
won't cover individual vectors types in too much depth. Instead, I'll
show you how they fit together as a whole. If you need more details, you
can find them in R's documentation.

Vectors come in two flavours: atomic vectors and lists\footnote{A few
  places in R's documentation call lists generic vectors to emphasise
  their difference from atomic vectors.}. They differ in the types of
their elements: all elements of an atomic vector must be the same type,
whereas the elements of a list can have different types. Closely related
to vectors is \texttt{NULL}; \texttt{NULL} is not a vector, but often
serves the role of a generic 0-length vector. Throughout this chapter
we'll expand on this diagram:

\begin{center}\includegraphics[width=2.07in]{diagrams/vectors/summary-tree} \end{center}

Every vector can also have \textbf{attributes}, which you can think of
as a named list containing arbitrary metadata. Two attributes are
particularly important because they create important vector variants.
The \textbf{dim}ension attribute turns vectors into matrices and arrays.
The \textbf{class} attribute powers the S3 object system. You'll learn
how to use S3 in Chapter \ref{s3}, but here, you'll learn about a
handful of the most important S3 vectors: factors, date/times, data
frames, and tibbles. Matrices and data frames are not necessarily what
you think of as vectors, so you'll learn why these 2d structures are
considered to be vectors in R.

\hypertarget{quiz-1}{%
\subsection*{Quiz}\label{quiz-1}}
\addcontentsline{toc}{subsection}{Quiz}

Take this short quiz to determine if you need to read this chapter. If
the answers quickly come to mind, you can comfortably skip this chapter.
You can check your answers in
\protect\hyperlink{data-structure-answers}{answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What are the four common types of atomic vectors? What are the two
  rare types?
\item
  What are attributes? How do you get them and set them?
\item
  How is a list different from an atomic vector? How is a matrix
  different from a data frame?
\item
  Can you have a list that is a matrix? Can a data frame have a column
  that is a matrix?
\item
  How do tibbles behave differently from data frames?
\end{enumerate}

\hypertarget{outline-1}{%
\subsection*{Outline}\label{outline-1}}
\addcontentsline{toc}{subsection}{Outline}

\hypertarget{atomic-vectors}{%
\section{Atomic vectors}\label{atomic-vectors}}

\index{atomic vectors} \index{vectors!atomic|see{atomic vectors}}
\indexc{NA} \indexc{c()}

There are four common types of atomic vectors: logical, integer, double,
and character. Collectively integer and double vectors are known as
numeric vectors\footnote{This is a slight simplification as R does not
  use ``numeric'' consistently, which we'll come back to in Section
  \ref{numeric-type}.}. There are two rare types that I won't discuss
further: complex and raw. Complex numbers are rarely needed for
statistics, and raw vectors are a special type only needed when handling
binary data.

\begin{center}\includegraphics[width=3in]{diagrams/vectors/summary-tree-atomic} \end{center}

\hypertarget{scalars}{%
\subsection{Scalars}\label{scalars}}

\index{scalars}

Each of the four primary atomic vectors has special syntax to create an
individual value, aka a \textbf{scalar}\footnote{Technically, the R
  language does not possess scalars, and everything that looks like a
  scalar is actually a vector of length one. This however, is mainly a
  theoretical distinction, and blurring the distinction between scalar
  and length-1 vector is unlikely to harm your code.}, and its own
missing value.:

\begin{itemize}
\tightlist
\item
  Strings are surrounded by \texttt{"} (\texttt{"hi"}) or
  \texttt{\textquotesingle{}}
  (\texttt{\textquotesingle{}bye\textquotesingle{}}). The string missing
  value is \texttt{NA\_character\_}. Special characters are escaped with
  \texttt{\textbackslash{}\textbackslash{}}; see \texttt{?Quotes} for
  full details.
\end{itemize}

\begin{itemize}
\item
  Doubles can be specified in decimal (\texttt{0.1234}), scientific
  (\texttt{1.23e4}), or hexadecimal (\texttt{0xcafe}) forms. There are
  three special values unique to doubles: \texttt{Inf}, \texttt{-Inf},
  and \texttt{NaN}. The double missing value is \texttt{NA\_real\_}.
\item
  Integers are written similarly to doubles but must be followed by
  \texttt{L}\footnote{\texttt{L} is not intuitive, and you might wonder
    where it comes from. At the time \texttt{L} was added to R, R's
    integer type was equivalent to a long integer in C, and C code could
    use a suffix of \texttt{l} or \texttt{L} to force a number to be a
    long integer. It was decided that \texttt{l} was too visually
    similar to \texttt{i} (used for complex numbers in R), leaving
    \texttt{L}.} (\texttt{1234L}, \texttt{1e4L}, or \texttt{0xcafeL}),
  and can not include decimals. The integer missing value is
  \texttt{NA\_integer\_}.
\item
  Logicals can be spelled out (\texttt{TRUE} or \texttt{FALSE}), or
  abbreviated (\texttt{T} or \texttt{F}). The logical missing value is
  \texttt{NA}.
\end{itemize}

\hypertarget{atomic-constructing}{%
\subsection{\texorpdfstring{Making longer vectors with
\texttt{c()}}{Making longer vectors with c()}}\label{atomic-constructing}}

\indexc{typeof()}

To create longer vectors from shorter ones, use \texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dbl_var <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\FloatTok{2.5}\NormalTok{, }\FloatTok{4.5}\NormalTok{)}
\NormalTok{int_var <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 6L, 10L)}
\NormalTok{lgl_var <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\NormalTok{chr_var <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"these are"}\NormalTok{, }\StringTok{"some strings"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In diagrams, I'll depict vectors as connected rectangles, so the above
code could be drawn as follows:

\begin{center}\includegraphics[width=3.64in]{diagrams/vectors/atomic} \end{center}

You can determine the type of a vector with \texttt{typeof()} and its
length with \texttt{length()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(dbl_var)}
\CommentTok{#> [1] "double"}
\KeywordTok{typeof}\NormalTok{(int_var)}
\CommentTok{#> [1] "integer"}
\KeywordTok{typeof}\NormalTok{(lgl_var)}
\CommentTok{#> [1] "logical"}
\KeywordTok{typeof}\NormalTok{(chr_var)}
\CommentTok{#> [1] "character"}
\end{Highlighting}
\end{Shaded}

\hypertarget{testing-and-coercing}{%
\subsection{Testing and coercing}\label{testing-and-coercing}}

\index{coercion}

Generally, you can \textbf{test} if a vector is of a given type with an
\texttt{is.} function, but they need to be used with care.
\texttt{is.character()}, \texttt{is.double()}, \texttt{is.integer()},
and \texttt{is.logical()} do what you might expect: they test if a
vector is a character, double, integer, or logical. Beware
\texttt{is.vector()}, \texttt{is.atomic()}, and \texttt{is.numeric()}:
they don't test if you have a vector, atomic vector, or numeric vector,
and you'll need to carefully read the docs to figure out what they do
do.

The type is a property of the entire atomic vector, so all elements of
an atomic must be the same type. When you attempt to combine different
types they will be \textbf{coerced} to the most flexible one (character
\textgreater{}\textgreater{} double \textgreater{}\textgreater{} integer
\textgreater{}\textgreater{} logical). For example, combining a
character and an integer yields a character:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\CommentTok{#>  chr [1:2] "a" "1"}
\end{Highlighting}
\end{Shaded}

Coercion often happens automatically. Most mathematical functions
(\texttt{+}, \texttt{log}, \texttt{abs}, etc.) will coerce to numeric.
This coercion is particularly useful for logical vectors because
\texttt{TRUE} becomes 1 and \texttt{FALSE} becomes 0.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{as.numeric}\NormalTok{(x)}
\CommentTok{#> [1] 0 0 1}

\CommentTok{# Total number of TRUEs}
\KeywordTok{sum}\NormalTok{(x)}
\CommentTok{#> [1] 1}

\CommentTok{# Proportion that are TRUE}
\KeywordTok{mean}\NormalTok{(x)}
\CommentTok{#> [1] 0.333}
\end{Highlighting}
\end{Shaded}

Vectorised logical operations (\texttt{\&}, \texttt{\textbar{}},
\texttt{any}, etc) will coerce to a logical, but since this might lose
information, it's always accompanied by a warning.

Generally, you can deliberately coerce by using an \texttt{as.}
function, like \texttt{as.character()}, \texttt{as.double()},
\texttt{as.integer()}, or \texttt{as.logical()}. Failed coercions from
strings generate a warning and a missing value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.integer}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"1.5"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\CommentTok{#> Warning: NAs introduced by coercion}
\CommentTok{#> [1]  1  1 NA}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-4}{%
\subsection{Exercises}\label{exercises-4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How do you create scalars of type raw and complex? (See \texttt{?raw}
  and \texttt{?complex})
\item
  Test your knowledge of vector coercion rules by predicting the output
  of the following uses of \texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, 1L)}
\end{Highlighting}
\end{Shaded}
\item
  Why is \texttt{1\ ==\ "1"} true? Why is
  \texttt{-1\ \textless{}\ FALSE} true? Why is
  \texttt{"one"\ \textless{}\ 2} false?
\item
  Why is the default missing value, \texttt{NA}, a logical vector?
  What's special about logical vectors? (Hint: think about
  \texttt{c(FALSE,\ NA\_character\_)}.)
\item
  Precisely what do \texttt{is.atomic()}, \texttt{is.numeric()}, and
  \texttt{is.vector()} test for?
\end{enumerate}

\hypertarget{attributes}{%
\section{Attributes}\label{attributes}}

\index{attributes}

You might have noticed that the set of atomic vectors does not include a
number of important data structures like matrices and arrays, factors
and date/times. These types are built on top of atomic vectors by adding
attributes. In this section, you'll learn the basics of attributes, and
how the dim attribute makes matrices and arrays. In the next section
you'll learn how the class attribute is used to create S3 vectors,
including factors, dates, and date-times.

\hypertarget{getting-and-setting}{%
\subsection{Getting and setting}\label{getting-and-setting}}

\indexc{attr()}
\indexc{attributes()}
\indexc{structure()}

You can think of attributes as a named list\footnote{The reality is a
  little more complicated: attributes are actually stored in pairlists.
  Pairlists are functionally indistinguishable from lists, but are
  profoundly different under the hood, and you'll learn more about them
  in Section \ref{pairlists}.} used to attach metadata to an object.
Individual attributes can be retrieved and modified with
\texttt{attr()}, or retrieved en masse with \texttt{attributes()}, and
set en masse with \texttt{structure()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}
\KeywordTok{attr}\NormalTok{(a, }\StringTok{"x"}\NormalTok{) <-}\StringTok{ "abcdef"}
\KeywordTok{attr}\NormalTok{(a, }\StringTok{"x"}\NormalTok{)}
\CommentTok{#> [1] "abcdef"}

\KeywordTok{attr}\NormalTok{(a, }\StringTok{"y"}\NormalTok{) <-}\StringTok{ }\DecValTok{4}\OperatorTok{:}\DecValTok{6}
\KeywordTok{str}\NormalTok{(}\KeywordTok{attributes}\NormalTok{(a))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ x: chr "abcdef"}
\CommentTok{#>  $ y: int [1:3] 4 5 6}

\CommentTok{# Or equivalently}
\NormalTok{a <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}
  \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }
  \DataTypeTok{x =} \StringTok{"abcdef"}\NormalTok{,}
  \DataTypeTok{y =} \DecValTok{4}\OperatorTok{:}\DecValTok{6}
\NormalTok{)}
\KeywordTok{str}\NormalTok{(}\KeywordTok{attributes}\NormalTok{(a))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ x: chr "abcdef"}
\CommentTok{#>  $ y: int [1:3] 4 5 6}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.02in]{diagrams/vectors/attr} \end{center}

Attributes should generally be thought of as ephemeral. For example,
most attributes are lost by most operations:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attributes}\NormalTok{(a[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> NULL}
\KeywordTok{attributes}\NormalTok{(}\KeywordTok{sum}\NormalTok{(a))}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

There are only two attributes that are routinely preserved:

\begin{itemize}
\tightlist
\item
  \textbf{names}, a character vector giving each element a name.
\item
  \textbf{dim}, short for dimensions, an integer vector, used to turn
  vectors into matrices and arrays.
\end{itemize}

To preserve additional attributes, you'll need to create your own S3
class, the topic of Chapter \ref{s3}.

\hypertarget{attr-names}{%
\subsection{Names}\label{attr-names}}

\index{attributes!names} \indexc{names()} \indexc{setNames()}

You can name a vector in three ways:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# When creating it: }
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}

\CommentTok{# By assigning names() to an existing vector:}
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}
\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{)}

\CommentTok{# Inline, with setNames():}
\NormalTok{x <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Avoid using \texttt{attr(x,\ "names")} as it requires more typing and is
less readable than \texttt{names(x)}. You can remove names from a vector
by using \texttt{unname(x)} or \texttt{names(x)\ \textless{}-\ NULL}.

To be technically correct, when drawing the named vector \texttt{x}, I
should draw it like so:

\begin{center}\includegraphics[width=2.56in]{diagrams/vectors/attr-names-1} \end{center}

However, names are so special and so important, that unless I'm trying
specifically to draw attention to the attributes data structure, I'll
use them to label the vector directly:

\begin{center}\includegraphics[width=1.08in]{diagrams/vectors/attr-names-2} \end{center}

To be maximally useful for character subsetting (e.g.~Section
\ref{lookup-tables}) names should be unique, and non-missing, but this
is not enforced by R. Depending on how the names are set, missing names
may be either \texttt{""} or \texttt{NA\_character\_}. If all names are
missing, \texttt{names()} will return \texttt{NULL}.

\hypertarget{attr-dims}{%
\subsection{Dimensions}\label{attr-dims}}

\index{arrays} \index{matrices|see{arrays}}

Adding a \texttt{dim} attribute to a vector allows it to behave like a
2-dimensional \textbf{matrix} or multi-dimensional \textbf{array}.
Matrices and arrays are primarily a mathematical/statistical tool, not a
programming tool, so will be used infrequently in this book, and only
covered briefly. Their most important feature is multidimensional
subsetting, which is covered in Section \ref{matrix-subsetting}.

You can create matrices and arrays with \texttt{matrix()} and
\texttt{array()}, or by using the assignment form of \texttt{dim()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Two scalar arguments specify row and column sizes}
\NormalTok{a <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{a}
\CommentTok{#>      [,1] [,2] [,3]}
\CommentTok{#> [1,]    1    3    5}
\CommentTok{#> [2,]    2    4    6}

\CommentTok{# One vector argument to describe all dimensions}
\NormalTok{b <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\NormalTok{b}
\CommentTok{#> , , 1}
\CommentTok{#> }
\CommentTok{#>      [,1] [,2] [,3]}
\CommentTok{#> [1,]    1    3    5}
\CommentTok{#> [2,]    2    4    6}
\CommentTok{#> }
\CommentTok{#> , , 2}
\CommentTok{#> }
\CommentTok{#>      [,1] [,2] [,3]}
\CommentTok{#> [1,]    7    9   11}
\CommentTok{#> [2,]    8   10   12}

\CommentTok{# You can also modify an object in place by setting dim()}
\NormalTok{c <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{6}
\KeywordTok{dim}\NormalTok{(c) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{c}
\CommentTok{#>      [,1] [,2]}
\CommentTok{#> [1,]    1    4}
\CommentTok{#> [2,]    2    5}
\CommentTok{#> [3,]    3    6}
\end{Highlighting}
\end{Shaded}

Many of the functions for working with vectors have generalisations for
matrices and arrays:

\begin{longtable}[]{@{}lll@{}}
\toprule
Vector & Matrix & Array\tabularnewline
\midrule
\endhead
\texttt{names()} & \texttt{rownames()}, \texttt{colnames()} &
\texttt{dimnames()}\tabularnewline
\texttt{length()} & \texttt{nrow()}, \texttt{ncol()} &
\texttt{dim()}\tabularnewline
\texttt{c()} & \texttt{rbind()}, \texttt{cbind()} &
\texttt{abind::abind()}\tabularnewline
--- & \texttt{t()} & \texttt{aperm()}\tabularnewline
\texttt{is.null(dim(x))} & \texttt{is.matrix()} &
\texttt{is.array()}\tabularnewline
\bottomrule
\end{longtable}

A vector without a \texttt{dim} attribute set is often thought of as
1-dimensional, but actually has \texttt{NULL} dimensions. You also can
have matrices with a single row or single column, or arrays with a
single dimension. They may print similarly, but will behave differently.
The differences aren't too important, but it's useful to know they exist
in case you get strange output from a function (\texttt{tapply()} is a
frequent offender). As always, use \texttt{str()} to reveal the
differences.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)                   }\CommentTok{# 1d vector}
\CommentTok{#>  int [1:3] 1 2 3}
\KeywordTok{str}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{1}\NormalTok{)) }\CommentTok{# column vector}
\CommentTok{#>  int [1:3, 1] 1 2 3}
\KeywordTok{str}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{1}\NormalTok{)) }\CommentTok{# row vector}
\CommentTok{#>  int [1, 1:3] 1 2 3}
\KeywordTok{str}\NormalTok{(}\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{))         }\CommentTok{# "array" vector}
\CommentTok{#>  int [1:3(1d)] 1 2 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-5}{%
\subsection{Exercises}\label{exercises-5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How is \texttt{setNames()} implemented? How is \texttt{unname()}
  implemented? Read the source code.
\item
  What does \texttt{dim()} return when applied to a 1d vector? When
  might you use \texttt{NROW()} or \texttt{NCOL()}?
\item
  How would you describe the following three objects? What makes them
  different to \texttt{1:5}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\NormalTok{x3 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  An early draft used this code to illustrate \texttt{structure()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{comment =} \StringTok{"my attribute"}\NormalTok{)}
\CommentTok{#> [1] 1 2 3 4 5}
\end{Highlighting}
\end{Shaded}

  But when you print that object you don't see the comment attribute.
  Why? Is the attribute missing, or is there something else special
  about it? (Hint: try using help.)
\end{enumerate}

\hypertarget{s3-atomic-vectors}{%
\section{S3 atomic vectors}\label{s3-atomic-vectors}}

\index{attributes!names} \index{S3!vectors}

One of the most important attributes is \texttt{class}, which defines
the S3 object system. Having a class attribute makes an object an
\textbf{S3 object}, which means that it will behave differently when
passed to a \textbf{generic} function. Every S3 object is built on top
of a base type, and often stores additional information in other
attributes. You'll learn the details of the S3 object system, and how to
create your own S3 classes, in Chapter \ref{s3}.

In this section, we'll discuss three important S3 vectors used in base
R:

\begin{itemize}
\item
  Categorical data, where values can only come from a fixed set of
  levels, are recorded in \textbf{factor} vectors.
\item
  Dates (with day resolution) are recorded in \textbf{Date} vectors.
\item
  Date-times (with second or sub-second resolution) are stored in
  \textbf{POSIXct} vectors.
\end{itemize}

\begin{center}\includegraphics[width=3.1in]{diagrams/vectors/summary-tree-s3-1} \end{center}

\hypertarget{factors}{%
\subsection{Factors}\label{factors}}

\index{factors} \indexc{stringsAsFactors}

A factor is a vector that can contain only predefined values, and is
used to store categorical data. Factors are built on top of integer
vectors with two attributes: the \texttt{class}, ``factor'', which makes
them behave differently from regular integer vectors, and the
\texttt{levels}, which defines the set of allowed values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> [1] a b b a}
\CommentTok{#> Levels: a b}

\KeywordTok{typeof}\NormalTok{(x)}
\CommentTok{#> [1] "integer"}
\KeywordTok{attributes}\NormalTok{(x)}
\CommentTok{#> $levels}
\CommentTok{#> [1] "a" "b"}
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "factor"}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.56in]{diagrams/vectors/factor} \end{center}

Factors are useful when you know the set of possible values, even if you
don't see them all in a given dataset. Compared to a character vector,
this means that tabulating a factor can yield counts of 0:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sex_char <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"m"}\NormalTok{, }\StringTok{"m"}\NormalTok{)}
\NormalTok{sex_factor <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(sex_char, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"f"}\NormalTok{))}

\KeywordTok{table}\NormalTok{(sex_char)}
\CommentTok{#> sex_char}
\CommentTok{#> m }
\CommentTok{#> 3}
\KeywordTok{table}\NormalTok{(sex_factor)}
\CommentTok{#> sex_factor}
\CommentTok{#> m f }
\CommentTok{#> 3 0}
\end{Highlighting}
\end{Shaded}

A minor variation of factors is \textbf{ordered} factors, which
generally behave similarly, but declare that the order of the levels is
meaningful (a fact which is used automatically in some models and
visualisations).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grade <-}\StringTok{ }\KeywordTok{ordered}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\NormalTok{grade}
\CommentTok{#> [1] b b a c}
\CommentTok{#> Levels: c < b < a}
\end{Highlighting}
\end{Shaded}

With base R\footnote{The tidyverse never automatically coerce characters
  to factor, and provides the forcats (Wickham
  \protect\hyperlink{ref-forcats}{2018}) package specifically for
  working with factors.} you tend to encounter factors very frequently,
because many base R functions (like \texttt{read.csv()} and
\texttt{data.frame()}) automatically convert character vectors to
factors. This is suboptimal, because there's no way for those functions
to know the set of all possible levels or their optimal order: the
levels are a property of the experimental design, not the data. Instead,
use the argument \texttt{stringsAsFactors\ =\ FALSE} to suppress this
behaviour, and then manually convert character vectors to factors using
your knowledge of the data. To learn about the historical context of
this behaviour, I recommend
\href{http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/}{\emph{stringsAsFactors:
An unauthorized biography}} by Roger Peng, and
\href{http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh}{\emph{stringsAsFactors
= \textless{}sigh\textgreater{}}} by Thomas Lumley.

While factors look like (and often behave like) character vectors, they
are built on top of integers. Be careful when treating them like
strings. Some string methods (like \texttt{gsub()} and \texttt{grepl()})
will coerce factors to strings automatically, while others (like
\texttt{nchar()}) will throw an error, and still others (like
\texttt{c()}) will use the underlying integer values. For this reason,
it's usually best to explicitly convert factors to character vectors if
you need string-like behaviour.

\hypertarget{dates}{%
\subsection{Dates}\label{dates}}

Date vectors are built on top of double vectors. They have class
``Date'' and no other attributes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{today <-}\StringTok{ }\KeywordTok{Sys.Date}\NormalTok{()}

\KeywordTok{typeof}\NormalTok{(today)}
\CommentTok{#> [1] "double"}
\KeywordTok{attributes}\NormalTok{(today)}
\CommentTok{#> $class}
\CommentTok{#> [1] "Date"}
\end{Highlighting}
\end{Shaded}

The value of the double (which can be seen by stripping the class),
represents the number of days since 1970-01-01:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"1970-02-01"}\NormalTok{)}
\KeywordTok{unclass}\NormalTok{(date)}
\CommentTok{#> [1] 31}
\end{Highlighting}
\end{Shaded}

\hypertarget{date-times}{%
\subsection{Date-times}\label{date-times}}

Base R\footnote{The tidyverse provides the lubridate (Grolemund and
  Wickham \protect\hyperlink{ref-lubridate}{2011}) package for working
  with date-times. It provides a number of convenient helpers which work
  with the base POSIXct type.} provides two ways of storing date-time
information, POSIXct, and POSIXlt. These are admittedly odd names:
``POSIX'' is short for Portable Operating System Interface which is a
family of cross-platform standards. ``ct'' standards for calendar time
(the \texttt{time\_t} type in C), and ``lt'' for local time (the
\texttt{struct\ tm} type in C). Here we'll focus on \texttt{POSIXct},
because it's the simplest, is built on top of an atomic vector, and is
most appropriate for use in data frames. POSIXct vectors are built on
top of double vectors, where the value represents the number of seconds
since 1970-01-01.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{now_ct <-}\StringTok{ }\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"2018-08-01 22:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"UTC"}\NormalTok{)}
\NormalTok{now_ct}
\CommentTok{#> [1] "2018-08-01 22:00:00 UTC"}

\KeywordTok{typeof}\NormalTok{(now_ct)}
\CommentTok{#> [1] "double"}
\KeywordTok{attributes}\NormalTok{(now_ct)}
\CommentTok{#> $class}
\CommentTok{#> [1] "POSIXct" "POSIXt" }
\CommentTok{#> }
\CommentTok{#> $tzone}
\CommentTok{#> [1] "UTC"}
\end{Highlighting}
\end{Shaded}

The \texttt{tzone} attribute controls how the date-time is formatted,
not the instant of time represented by the vector. Note that the time is
not printed if it is midnight.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{structure}\NormalTok{(now_ct, }\DataTypeTok{tzone =} \StringTok{"Asia/Tokyo"}\NormalTok{)}
\CommentTok{#> [1] "2018-08-02 07:00:00 JST"}
\KeywordTok{structure}\NormalTok{(now_ct, }\DataTypeTok{tzone =} \StringTok{"America/New_York"}\NormalTok{)}
\CommentTok{#> [1] "2018-08-01 18:00:00 EDT"}
\KeywordTok{structure}\NormalTok{(now_ct, }\DataTypeTok{tzone =} \StringTok{"Australia/Lord_Howe"}\NormalTok{)}
\CommentTok{#> [1] "2018-08-02 08:30:00 +1030"}
\KeywordTok{structure}\NormalTok{(now_ct, }\DataTypeTok{tzone =} \StringTok{"Europe/Paris"}\NormalTok{)}
\CommentTok{#> [1] "2018-08-02 CEST"}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-6}{%
\subsection{Exercises}\label{exercises-6}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What sort of object does \texttt{table()} return? What is its type?
  What attributes does it have? How does the dimensionality change as
  you tabulate more variables?
\item
  What happens to a factor when you modify its levels?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(letters)}
\KeywordTok{levels}\NormalTok{(f1) <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{levels}\NormalTok{(f1))}
\end{Highlighting}
\end{Shaded}
\item
  What does this code do? How do \texttt{f2} and \texttt{f3} differ from
  \texttt{f1}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{factor}\NormalTok{(letters))}

\NormalTok{f3 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(letters, }\DataTypeTok{levels =} \KeywordTok{rev}\NormalTok{(letters))}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{lists}{%
\section{Lists}\label{lists}}

\index{lists} \index{vectors!lists|see{lists}}

Lists are a step up in complexity from atomic vectors because an element
of a list can be any type (not just vectors). An element of a list can
even be another list!

\hypertarget{list-creating}{%
\subsection{Creating}\label{list-creating}}

Construct lists with \texttt{list()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l1 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }
  \StringTok{"a"}\NormalTok{, }
  \KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }
  \KeywordTok{c}\NormalTok{(}\FloatTok{2.3}\NormalTok{, }\FloatTok{5.9}\NormalTok{)}
\NormalTok{)}

\KeywordTok{typeof}\NormalTok{(l1)}
\CommentTok{#> [1] "list"}

\KeywordTok{str}\NormalTok{(l1)}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : int [1:3] 1 2 3}
\CommentTok{#>  $ : chr "a"}
\CommentTok{#>  $ : logi [1:3] TRUE FALSE TRUE}
\CommentTok{#>  $ : num [1:2] 2.3 5.9}
\end{Highlighting}
\end{Shaded}

As described in Section \ref{list-references}, the elements of a list
are references. Creating a list does not copy the components in, so the
total size of a list might be smaller than you expect.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(mtcars)}
\CommentTok{#> 7,792 B}

\NormalTok{l2 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(mtcars, mtcars, mtcars, mtcars)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(l2)}
\CommentTok{#> 7,872 B}
\end{Highlighting}
\end{Shaded}

Lists can contain complex objects so it's not possible to pick one
visual style that works for every list. Generally I'll draw lists like
vectors, using colour to remind you of the hierarchy.

\begin{center}\includegraphics[width=4.67in]{diagrams/vectors/list} \end{center}

Lists are sometimes called \textbf{recursive} vectors, because a list
can contain other lists. This makes them fundamentally different from
atomic vectors.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l3 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
\KeywordTok{str}\NormalTok{(l3)}
\CommentTok{#> List of 1}
\CommentTok{#>  $ :List of 1}
\CommentTok{#>   ..$ :List of 1}
\CommentTok{#>   .. ..$ : num 1}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.08in]{diagrams/vectors/list-recursive} \end{center}

\texttt{c()} will combine several lists into one. If given a combination
of atomic vectors and lists, \texttt{c()} will coerce the vectors to
lists before combining them. Compare the results of \texttt{list()} and
\texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l4 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\NormalTok{l5 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\KeywordTok{str}\NormalTok{(l4)}
\CommentTok{#> List of 2}
\CommentTok{#>  $ :List of 2}
\CommentTok{#>   ..$ : num 1}
\CommentTok{#>   ..$ : num 2}
\CommentTok{#>  $ : num [1:2] 3 4}
\KeywordTok{str}\NormalTok{(l5)}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : num 1}
\CommentTok{#>  $ : num 2}
\CommentTok{#>  $ : num 3}
\CommentTok{#>  $ : num 4}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.51in]{diagrams/vectors/list-c} \end{center}

\hypertarget{list-types}{%
\subsection{Testing and coercing}\label{list-types}}

The \texttt{typeof()} a list is \texttt{list}. You can test for a list
with \texttt{is.list()}, and coerce to a list with \texttt{as.list()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 1 2 3}
\KeywordTok{as.list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 2}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

You can turn a list into an atomic vector with \texttt{unlist()}. The
rules for the resulting type are complex, not well documented, and not
always equivalent to \texttt{c()}.

\hypertarget{list-array}{%
\subsection{Matrices and arrays}\label{list-array}}

\index{list-arrays} \index{arrays!list-arrays}

While atomic vectors are most commonly turned into matrices, the
dimension attribute can also be set on lists to make list-matrices or
list-arrays:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\FloatTok{1.0}\NormalTok{)}
\KeywordTok{dim}\NormalTok{(l) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{l}
\CommentTok{#>      [,1]      [,2]}
\CommentTok{#> [1,] Integer,3 TRUE}
\CommentTok{#> [2,] "a"       1}

\NormalTok{l[[}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{]]}
\CommentTok{#> [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

These are relatively esoteric data structures, but can be useful if you
want to arrange objects into a grid-like structure. For example, if
you're running models on a spatio-temporal grid, it might be natural to
preserve the grid structure by storing the models in a 3d array.

\hypertarget{exercises-7}{%
\subsection{Exercises}\label{exercises-7}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  List all the ways that a list differs from an atomic vector.
\item
  Why do you need to use \texttt{unlist()} to convert a list to an
  atomic vector? Why doesn't \texttt{as.vector()} work?
\item
  Compare and contrast \texttt{c()} and \texttt{unlist()} when combining
  a date and date-time into a single vector.
\end{enumerate}

\hypertarget{tibble}{%
\section{Data frames and tibbles}\label{tibble}}

\index{data frames} \index{tibbles}

There are two important S3 vectors that are built on top of lists: data
frames and tibbles.

\begin{center}\includegraphics[width=1.67in]{diagrams/vectors/summary-tree-s3-2} \end{center}

A data frame is the most common way of storing data in R, and is crucial
for effective data analysis. A data frame is a named list of
equal-length vectors. It has attributes providing the (column)
\texttt{names}, \texttt{row.names}\footnote{Row names are one of the
  most surprisingly complex data structures in R, because they've been a
  persistent performance issue over many years. The most straightforward
  representations are character or integer vectors, with one element for
  each row. There's also a compact representation for ``automatic'' row
  names (consecutive integers), created by \texttt{.set\_row\_names()}.
  R 3.5 has a special way of deferring integer to character conversions
  specifically to speed up \texttt{lm()}; see
  \url{https://svn.r-project.org/R/branches/ALTREP/ALTREP.html\#deferred_string_conversions}
  for details.}, and a class of ``data.frame'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1 <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\KeywordTok{typeof}\NormalTok{(df1)}
\CommentTok{#> [1] "list"}

\KeywordTok{attributes}\NormalTok{(df1)}
\CommentTok{#> $names}
\CommentTok{#> [1] "x" "y"}
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "data.frame"}
\CommentTok{#> }
\CommentTok{#> $row.names}
\CommentTok{#> [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

Because each element of the list has the same length, data frames have a
rectangular structure, and hence shares properties of both the matrix
and the list:

\begin{itemize}
\item
  A data frame has 1d \texttt{names()}, and 2d \texttt{colnames()} and
  \texttt{rownames()}\footnote{Technically, you are encouraged to use
    \texttt{row.names()}, not \texttt{rownames()} with data frames, but
    this distinction is rarely important.}. The \texttt{names()} and
  \texttt{colnames()} are identical.
\item
  A data frame has 1d \texttt{length()}, and 2d \texttt{ncol()} and
  \texttt{nrow()}. The \texttt{length()} is the number of columns.
\end{itemize}

Data frames are one of the biggest and most important ideas in R, and
one of the things that makes R different from other programming
languages. However, in the over 20 years since their creation, the ways
people use R have changed, and some of the design decisions that made
sense at the time data frames were created now cause frustration.

This frustration lead to the creation of the tibble (Müller and Wickham
\protect\hyperlink{ref-tibble}{2018}), a modern reimagining of the data
frame. Tibbles are designed to be (as much as possible) drop-in
replacements for data frames, while still fixing the greatest
frustrations. A concise, and fun, way to summarise the main differences
is that tibbles are lazy and surly: they tend to do less and complain
more. You'll see what that means as you work through this section.

Tibbles are provided by the tibble package and share the same structure
as data frames. The only difference is that the class vector is longer,
and includes \texttt{tbl\_df}. This allows tibbles to behave differently
in the key ways which we'll discuss below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tibble)}

\NormalTok{df2 <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\KeywordTok{typeof}\NormalTok{(df2)}
\CommentTok{#> [1] "list"}

\KeywordTok{attributes}\NormalTok{(df2)}
\CommentTok{#> $names}
\CommentTok{#> [1] "x" "y"}
\CommentTok{#> }
\CommentTok{#> $row.names}
\CommentTok{#> [1] 1 2 3}
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "tbl_df"     "tbl"        "data.frame"}
\end{Highlighting}
\end{Shaded}

\hypertarget{df-create}{%
\subsection{Creating}\label{df-create}}

\indexc{stringsAsFactors}
\indexc{data.frame()}
\indexc{tibble()}

You create a data frame by supplying name-vector pairs to
\texttt{data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }
  \DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{)}
\NormalTok{)}
\KeywordTok{str}\NormalTok{(df)}
\CommentTok{#> 'data.frame':    3 obs. of  2 variables:}
\CommentTok{#>  $ x: int  1 2 3}
\CommentTok{#>  $ y: Factor w/ 3 levels "a","b","c": 1 2 3}
\end{Highlighting}
\end{Shaded}

Beware the default conversion of strings to factors. Use
\texttt{stringsAsFactors\ =\ FALSE} to suppress it and keep character
vectors as character vectors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1 <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{),}
  \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}
\NormalTok{)}
\KeywordTok{str}\NormalTok{(df1)}
\CommentTok{#> 'data.frame':    3 obs. of  2 variables:}
\CommentTok{#>  $ x: int  1 2 3}
\CommentTok{#>  $ y: chr  "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

Creating a tibble is similar, but tibbles never coerce their input (this
is one feature that makes them lazy):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df2 <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }
  \DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{)}
\NormalTok{)}
\KeywordTok{str}\NormalTok{(df2)}
\CommentTok{#> Classes 'tbl_df', 'tbl' and 'data.frame':    3 obs. of  2 variables:}
\CommentTok{#>  $ x: int  1 2 3}
\CommentTok{#>  $ y: chr  "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

Additionally, while data frames automatically transform non-syntactic
names (unless \texttt{check.names\ =\ FALSE}), tibbles do not (although
they do print non-syntactic names surrounded by
\texttt{\textasciigrave{}}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(}\KeywordTok{data.frame}\NormalTok{(}\StringTok{`}\DataTypeTok{1}\StringTok{`}\NormalTok{ =}\StringTok{ }\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] "X1"}

\KeywordTok{names}\NormalTok{(}\KeywordTok{tibble}\NormalTok{(}\StringTok{`}\DataTypeTok{1}\StringTok{`}\NormalTok{ =}\StringTok{ }\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] "1"}
\end{Highlighting}
\end{Shaded}

While every element of a data frame (or tibble) must have the same
length, both \texttt{data.frame()} and \texttt{tibble()} can recycle
shorter inputs. Data frames automatically recycle columns that are an
integer multiple of the longest column; tibbles only ever recycle
vectors of length 1.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 1}
\CommentTok{#> 2 2 2}
\CommentTok{#> 3 3 1}
\CommentTok{#> 4 4 2}
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> Error in data.frame(x = 1:4, y = 1:3):}
\CommentTok{#>   arguments imply differing number of rows: 4, 3}

\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> # A tibble: 4 x 2}
\CommentTok{#>       x     y}
\CommentTok{#>   <int> <dbl>}
\CommentTok{#> 1     1     1}
\CommentTok{#> 2     2     1}
\CommentTok{#> 3     3     1}
\CommentTok{#> 4     4     1}
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)}
\CommentTok{#> Error: Column `y` must be length 1 or 4, not 2}
\end{Highlighting}
\end{Shaded}

There is one final difference: \texttt{tibble()} allows you to refer to
newly created variables:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{y =}\NormalTok{ x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{)}
\CommentTok{#> # A tibble: 3 x 2}
\CommentTok{#>       x     y}
\CommentTok{#>   <int> <dbl>}
\CommentTok{#> 1     1     2}
\CommentTok{#> 2     2     4}
\CommentTok{#> 3     3     6}
\end{Highlighting}
\end{Shaded}

When drawing data frames and tibbles, rather than focussing on the
implementation details, i.e.~the attributes:

\begin{center}\includegraphics[width=2.65in]{diagrams/vectors/data-frame-1} \end{center}

I'll draw them in the same way as a named list, but arranged to
emphasise their columnar structure.

\begin{center}\includegraphics[width=1.08in]{diagrams/vectors/data-frame-2} \end{center}

\hypertarget{rownames}{%
\subsection{Row names}\label{rownames}}

Data frames allow you to label each row with a ``name'', a character
vector containing only unique values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df3 <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{age =} \KeywordTok{c}\NormalTok{(}\DecValTok{35}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{18}\NormalTok{),}
  \DataTypeTok{hair =} \KeywordTok{c}\NormalTok{(}\StringTok{"blond"}\NormalTok{, }\StringTok{"brown"}\NormalTok{, }\StringTok{"black"}\NormalTok{),}
  \DataTypeTok{row.names =} \KeywordTok{c}\NormalTok{(}\StringTok{"Bob"}\NormalTok{, }\StringTok{"Susan"}\NormalTok{, }\StringTok{"Sam"}\NormalTok{)}
\NormalTok{)}
\NormalTok{df3}
\CommentTok{#>       age  hair}
\CommentTok{#> Bob    35 blond}
\CommentTok{#> Susan  27 brown}
\CommentTok{#> Sam    18 black}
\end{Highlighting}
\end{Shaded}

You can get and set row names with \texttt{rownames()}, and you can use
them to subset rows:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rownames}\NormalTok{(df3)}
\CommentTok{#> [1] "Bob"   "Susan" "Sam"}

\NormalTok{df3[}\StringTok{"Bob"}\NormalTok{, ]}
\CommentTok{#>     age  hair}
\CommentTok{#> Bob  35 blond}
\end{Highlighting}
\end{Shaded}

Row names arise naturally if you think of data frames as 2d structures
like matrices: the columns (variables) have names so the rows
(observations) should too. Most matrices are numeric, so having a place
to store character labels is important. But this analogy to matrices is
misleading because matrices possess an important property that data
frames do not: they are transposable. In matrices the rows and columns
are interchangeable, and transposing a matrix gives you another matrix
(and transposing again gives you back the original matrix). With data
frames, however, the rows and columns are not interchangeable, and the
transpose of a data frame is not a data frame.

There are three reasons that row names are suboptimal:

\begin{itemize}
\item
  Metadata is data, so storing it in a different way to the rest of the
  data is fundamentally a bad idea. It also means that you need to learn
  a new set of tools to work with row names; you can't use what you
  already know about manipulating columns.
\item
  Row names are poor abstraction for labelling rows because they only
  work when a row can be identified by a single string. This fails in
  many cases, for example when you want to identify a row by a
  non-character vector (e.g.~a time point), or with multiple vectors
  (e.g.~position, encoded by latitude and longitude).
\item
  Row names must be unique, so any replication of rows (e.g.~from
  bootstrapping) will create new row names. If you want to match rows
  from before and after the transformation you'll need to perform
  complicated string surgery.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df3[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), ]}
\CommentTok{#>       age  hair}
\CommentTok{#> Bob    35 blond}
\CommentTok{#> Bob.1  35 blond}
\CommentTok{#> Bob.2  35 blond}
\end{Highlighting}
\end{Shaded}
\end{itemize}

For these reasons, tibbles do not support row names. Instead the tibble
package provides tools to easily convert row names into a regular column
with either \texttt{rownames\_to\_column()}, or the \texttt{rownames}
argument to \texttt{as\_tibble()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_tibble}\NormalTok{(df3, }\DataTypeTok{rownames =} \StringTok{"name"}\NormalTok{)}
\CommentTok{#> # A tibble: 3 x 3}
\CommentTok{#>   name    age hair }
\CommentTok{#>   <chr> <dbl> <fct>}
\CommentTok{#> 1 Bob      35 blond}
\CommentTok{#> 2 Susan    27 brown}
\CommentTok{#> 3 Sam      18 black}
\end{Highlighting}
\end{Shaded}

\hypertarget{printing}{%
\subsection{Printing}\label{printing}}

One of the most obvious differences between tibbles and data frames is
how they are printed. I assume that you're already familiar with how
data frames are printed, so here I'll highlight some of the biggest
differences using an example dataset included in the dplyr package:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\OperatorTok{::}\NormalTok{starwars}
\CommentTok{#> # A tibble: 87 x 13}
\CommentTok{#>    name  height  mass hair_color skin_color eye_color birth_year}
\CommentTok{#>    <chr>  <int> <dbl> <chr>      <chr>      <chr>          <dbl>}
\CommentTok{#>  1 Luke~    172    77 blond      fair       blue            19  }
\CommentTok{#>  2 C-3PO    167    75 <NA>       gold       yellow         112  }
\CommentTok{#>  3 R2-D2     96    32 <NA>       white, bl~ red             33  }
\CommentTok{#>  4 Dart~    202   136 none       white      yellow          41.9}
\CommentTok{#>  5 Leia~    150    49 brown      light      brown           19  }
\CommentTok{#>  6 Owen~    178   120 brown, gr~ light      blue            52  }
\CommentTok{#>  7 Beru~    165    75 brown      light      blue            47  }
\CommentTok{#>  8 R5-D4     97    32 <NA>       white, red red             NA  }
\CommentTok{#>  9 Bigg~    183    84 black      light      brown           24  }
\CommentTok{#> 10 Obi-~    182    77 auburn, w~ fair       blue-gray       57  }
\CommentTok{#> # ... with 77 more rows, and 6 more variables: gender <chr>,}
\CommentTok{#> #   homeworld <chr>, species <chr>, films <list>, vehicles <list>,}
\CommentTok{#> #   starships <list>}
\end{Highlighting}
\end{Shaded}

Tibbles:

\begin{itemize}
\item
  Only show the first 10 rows and all the columns that will fit on
  screen. Additional columns are shown at the bottom.
\item
  Each column is labelled with its type, abbreviated to three or four
  letters.
\item
  Wide columns are truncated to avoid a single long string occupying an
  entire row. (This is still a work in progress: it's tricky to get the
  tradeoff right between showing as many columns as possible and showing
  a single wide column fully.)
\item
  When used in console environments that support it, colour is used
  judiciously to highlight important information, and de-emphasise
  supplemental details.
\end{itemize}

\hypertarget{safe-subsetting}{%
\subsection{Subsetting}\label{safe-subsetting}}

As you will learn in Chapter \ref{subsetting}, you can subset a data
frame or a tibble like a 1d structure (where it behaves like a list), or
a 2d structure (where it behaves like a matrix).

In my opinion, data frames have two suboptimal subsetting behaviours:

\begin{itemize}
\item
  When you subset columns with \texttt{df{[},\ vars{]}}, you will get a
  vector if \texttt{vars} selects one variable, otherwise you'll get a
  data frame. This is a frequent source of bugs when using \texttt{{[}}
  in a function, unless you always remember to do
  \texttt{df{[},\ vars,\ drop\ =\ FALSE{]}}.
\item
  When you attempt to extract a single column with \texttt{df\$x} and
  there is no column \texttt{x}, a data frame will instead select any
  variable that starts with \texttt{x}. If no variable starts with
  \texttt{x}, \texttt{df\$x} will return \texttt{NULL}. This makes it
  easy to select the wrong variable or to select a variable that doesn't
  exist.
\end{itemize}

Tibbles tweak these behaviours so that \texttt{{[}} always returns a
tibble, and \texttt{\$} doesn't partial match, and warns if it can't
find a variable (this is what makes tibbles surly).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1 <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{xyz =} \StringTok{"a"}\NormalTok{)}
\NormalTok{df2 <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{xyz =} \StringTok{"a"}\NormalTok{)}

\KeywordTok{str}\NormalTok{(df1}\OperatorTok{$}\NormalTok{x)}
\CommentTok{#>  Factor w/ 1 level "a": 1}
\KeywordTok{str}\NormalTok{(df2}\OperatorTok{$}\NormalTok{x)}
\CommentTok{#> Warning: Unknown or uninitialised column: 'x'.}
\CommentTok{#>  NULL}
\end{Highlighting}
\end{Shaded}

A tibble's insistence on returning a data frame from \texttt{{[}} can
cause problems with legacy code, which often uses
\texttt{df{[},\ "col"{]}} to extract a single column. To fix this, use
\texttt{df{[}{[}"col"{]}{]}} instead; this is more expressive (since
\texttt{{[}{[}} always extracts a single element) and works with both
data frames and tibbles.

\hypertarget{df-test-coerce}{%
\subsection{Testing and coercing}\label{df-test-coerce}}

\indexc{is.data.frame()}
\indexc{is\_tibble()}
\indexc{as.data.frame()}
\indexc{as\_tibble()}

To check if an object is a data frame or tibble, use
\texttt{is.data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.data.frame}\NormalTok{(df1)}
\CommentTok{#> [1] TRUE}
\KeywordTok{is.data.frame}\NormalTok{(df2)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

Typically, it should not matter if you have a tibble or data frame, but
if you do need to distinguish, use \texttt{is\_tibble()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_tibble}\NormalTok{(df1)}
\CommentTok{#> [1] FALSE}
\KeywordTok{is_tibble}\NormalTok{(df2)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

You can coerce an object to a data frame with \texttt{as.data.frame()}
or to as tibble with \texttt{as\_tibble()}.

\hypertarget{list-columns}{%
\subsection{List columns}\label{list-columns}}

\index{data frames!list-column} \indexc{I()}

Since a data frame is a list of vectors, it is possible for a data frame
to have a column that is a list. This is very useful because a list can
contain any other object, which means that you can put any object in a
data frame. This allows you to keep related objects together in a row,
no matter how complex the individual objects are. You can see an
application of this in the ``Many Models'' chapter of ``R for Data
Science'', \url{http://r4ds.had.co.nz/many-models.html}.

List-columns are allowed in data frames but you have to do a little
extra work, either adding the list-column after creation, or wrapping
the list in \texttt{I()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\NormalTok{df}\OperatorTok{$}\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}

\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }
  \DataTypeTok{y =} \KeywordTok{I}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{))}
\NormalTok{)}
\CommentTok{#>   x          y}
\CommentTok{#> 1 1       1, 2}
\CommentTok{#> 2 2    1, 2, 3}
\CommentTok{#> 3 3 1, 2, 3, 4}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.97in]{diagrams/vectors/data-frame-list} \end{center}

List columns are easier to use with tibbles because you can provide them
inside \texttt{tibble()}, and they are handled specially when printing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }
  \DataTypeTok{y =} \KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> # A tibble: 3 x 2}
\CommentTok{#>       x y        }
\CommentTok{#>   <int> <list>   }
\CommentTok{#> 1     1 <int [2]>}
\CommentTok{#> 2     2 <int [3]>}
\CommentTok{#> 3     3 <int [4]>}
\end{Highlighting}
\end{Shaded}

\hypertarget{matrix-and-data-frame-columns}{%
\subsection{Matrix and data frame
columns}\label{matrix-and-data-frame-columns}}

\index{data frames!matrix-column}

It's also possible to have a column of a data frame that's a matrix or
array, as long as the number of rows matches the data frame. (This
requires a slight extension to our definition of a data frame: it's not
the \texttt{length()} of each column that must be equal, but the
\texttt{NROW()}.) Like with list-columns, you must either add after
creation, or wrap in \texttt{I()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dfm <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3} \OperatorTok{*}\StringTok{ }\DecValTok{10}
\NormalTok{)}
\NormalTok{dfm}\OperatorTok{$}\NormalTok{y <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}
\NormalTok{dfm}\OperatorTok{$}\NormalTok{z <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{b =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{], }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}

\KeywordTok{str}\NormalTok{(dfm)}
\CommentTok{#> 'data.frame':    3 obs. of  3 variables:}
\CommentTok{#>  $ x: num  10 20 30}
\CommentTok{#>  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9}
\CommentTok{#>  $ z:'data.frame':   3 obs. of  2 variables:}
\CommentTok{#>   ..$ a: int  3 2 1}
\CommentTok{#>   ..$ b: chr  "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.6in]{diagrams/vectors/data-frame-matrix} \end{center}

Matrix and data frame columns require a little caution. Many functions
that work with data frames assume that all columns are vectors, and the
printed display can be confusing.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dfm[}\DecValTok{1}\NormalTok{, ]}
\CommentTok{#>    x y.1 y.2 y.3 z.a z.b}
\CommentTok{#> 1 10   1   4   7   3   a}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-8}{%
\subsection{Exercises}\label{exercises-8}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Can you have a data frame with 0 rows? What about 0 columns?
\item
  What happens if you attempt to set rownames that are not unique?
\item
  If \texttt{df} is a data frame, what can you say about \texttt{t(df)},
  and \texttt{t(t(df))}? Perform some experiments, making sure to try
  different column types.
\item
  What does \texttt{as.matrix()} do when applied to a data frame with
  columns of different types? How does it differ from
  \texttt{data.matrix()}?
\end{enumerate}

\hypertarget{null}{%
\section{\texorpdfstring{\texttt{NULL}}{NULL}}\label{null}}

To finish up the chapter, I wanted to talk about a final important data
structure that's closely related to vectors: \texttt{NULL}.
\texttt{NULL} is special because it has a unique type, is always length
0, and can't have any attributes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> [1] "NULL"}

\KeywordTok{length}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> [1] 0}

\NormalTok{x <-}\StringTok{ }\OtherTok{NULL}
\KeywordTok{attr}\NormalTok{(x, }\StringTok{"y"}\NormalTok{) <-}\StringTok{ }\DecValTok{1}
\CommentTok{#> Error in attr(x, "y") <- 1:}
\CommentTok{#>   attempt to set an attribute on NULL}
\end{Highlighting}
\end{Shaded}

You can test for \texttt{NULL}s with \texttt{is.null()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.null}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

There are two common uses of \texttt{NULL}:

\begin{itemize}
\item
  To represent an empty vector (a vector of length 0) of arbitrary type.
  For example, if you use \texttt{c()} but don't include any arguments,
  you get \texttt{NULL}, and concatenating \texttt{NULL} to a vector
  leaves it unchanged\footnote{Algebraically, this makes \texttt{NULL}
    the identity element under vector concatenation.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{()}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}
\item
  To represent an absent vector. For example, \texttt{NULL} is often
  used as a default function argument, when the argument is optional but
  the default value requires some computation (see Section
  \ref{missing-arguments} for more on this idea). Contrast this with
  \texttt{NA} which is used to indicate that an \emph{element} of a
  vector is absent.
\end{itemize}

If you're familiar with SQL, you know about relational \texttt{NULL} and
might expect it to be the same as R's. However, the database
\texttt{NULL} is actually equivalent to \texttt{NA}.

\hypertarget{data-structure-answers}{%
\section{Answers}\label{data-structure-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The four common types of atomic vector are logical, integer, double
  and character. The two rarer types are complex and raw.
\item
  Attributes allow you to associate arbitrary additional metadata to any
  object. You can get and set individual attributes with
  \texttt{attr(x,\ "y")} and
  \texttt{attr(x,\ "y")\ \textless{}-\ value}; or get and set all
  attributes at once with \texttt{attributes()}.
\item
  The elements of a list can be any type (even a list); the elements of
  an atomic vector are all of the same type. Similarly, every element of
  a matrix must be the same type; in a data frame, the different columns
  can have different types.
\item
  You can make ``list-array'' by assigning dimensions to a list. You can
  make a matrix a column of a data frame with
  \texttt{df\$x\ \textless{}-\ matrix()}, or using \texttt{I()} when
  creating a new data frame \texttt{data.frame(x\ =\ I(matrix()))}.
\item
  Tibbles have an enhanced print method, never coerce strings to
  factors, and provide stricter subsetting methods.
\end{enumerate}

\hypertarget{subsetting}{%
\chapter{Subsetting}\label{subsetting}}

\hypertarget{introduction-3}{%
\section{Introduction}\label{introduction-3}}

\index{subsetting}

R's subsetting operators are powerful and fast. Mastery of subsetting
allows you to succinctly express complex operations in a way that few
other languages can match. Subsetting is easy to learn but hard to
master because you need to internalise a number of interrelated
concepts:

\begin{itemize}
\item
  The six types of thing that you can subset with.
\item
  The three subsetting operators, \texttt{{[}{[}}, \texttt{{[}}, and
  \texttt{\$}.
\item
  How the subsetting operators interact with vector types (e.g., atomic
  vectors, lists, factors, matrices, and data frames).
\item
  The use of subsetting together with assignment.
\end{itemize}

This chapter helps you master subsetting by starting with the simplest
type of subsetting: subsetting an atomic vector with \texttt{{[}}. It
then gradually extends your knowledge, first to more complicated data
types (like arrays and lists), and then to the other subsetting
operators, \texttt{{[}{[}} and \texttt{\$}. You'll then learn how
subsetting and assignment can be combined to modify parts of an object,
and, finally, you'll see a large number of useful applications.

Subsetting is a natural complement to \texttt{str()}. \texttt{str()}
shows you the structure of any object, and subsetting allows you to pull
out the pieces that you're interested in. For large, complex objects, I
also highly recommend the interactive RStudio Viewer, which you can
activate with \texttt{View(my\_object)}.

\hypertarget{quiz-2}{%
\subsection*{Quiz}\label{quiz-2}}
\addcontentsline{toc}{subsection}{Quiz}

Take this short quiz to determine if you need to read this chapter. If
the answers quickly come to mind, you can comfortably skip this chapter.
Check your answers in Section \ref{subsetting-answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What is the result of subsetting a vector with positive integers,
  negative integers, a logical vector, or a character vector?
\item
  What's the difference between \texttt{{[}}, \texttt{{[}{[}}, and
  \texttt{\$} when applied to a list?
\item
  When should you use \texttt{drop\ =\ FALSE}?
\item
  If \texttt{x} is a matrix, what does \texttt{x{[}{]}\ \textless{}-\ 0}
  do? How is it different to \texttt{x\ \textless{}-\ 0}?
\item
  How can you use a named vector to relabel categorical variables?
\end{enumerate}

\hypertarget{outline-2}{%
\subsection*{Outline}\label{outline-2}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{subset-multiple} starts by teaching you about
  \texttt{{[}}. You'll start by learning the six types of data that you
  can use to subset atomic vectors. You'll then learn how those six data
  types act when used to subset lists, matrices, and data frames.
\item
  Section \ref{subset-single} expands your knowledge of subsetting
  operators to include \texttt{{[}{[}} and \texttt{\$}, focussing on the
  important principles of simplifying vs.~preserving.
\item
  In Section \ref{subassignment} you'll learn the art of subassignment,
  combining subsetting and assignment to modify parts of an object.
\item
  Section \ref{applications} leads you through eight important, but not
  obvious, applications of subsetting to solve problems that you often
  encounter in a data analysis.
\end{itemize}

\hypertarget{subset-multiple}{%
\section{Selecting multiple elements}\label{subset-multiple}}

It's easiest to learn how subsetting works for atomic vectors, and then
how it generalises to higher dimensions and other more complicated
objects. We'll start with \texttt{{[}}, the most commonly used operator
which allows you to extract any number of elements. Section
\ref{subset-single} will cover \texttt{{[}{[}} and \texttt{\$}, used to
extract a single element from a data structure.

\hypertarget{atomic-vectors-1}{%
\subsection{Atomic vectors}\label{atomic-vectors-1}}

\index{subsetting!atomic vectors} \index{atomic vectors!subsetting}
\indexc{[}

Let's explore the different types of subsetting with a simple vector,
\texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{2.1}\NormalTok{, }\FloatTok{4.2}\NormalTok{, }\FloatTok{3.3}\NormalTok{, }\FloatTok{5.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note that the number after the decimal point gives the original position
in the vector.

There are six things that you can use to subset a vector:

\begin{itemize}
\item
  \textbf{Positive integers} return elements at the specified positions:
  \index{subsetting!with positive integers}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\CommentTok{#> [1] 3.3 2.1}
\NormalTok{x[}\KeywordTok{order}\NormalTok{(x)]}
\CommentTok{#> [1] 2.1 3.3 4.2 5.4}

\CommentTok{# Duplicated indices yield duplicated values}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\CommentTok{#> [1] 2.1 2.1}

\CommentTok{# Real numbers are silently truncated to integers}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\FloatTok{2.1}\NormalTok{, }\FloatTok{2.9}\NormalTok{)]}
\CommentTok{#> [1] 4.2 4.2}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Negative integers} omit elements at the specified positions:
  \index{subsetting!with negative integers}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\CommentTok{#> [1] 4.2 5.4}
\end{Highlighting}
\end{Shaded}

  You can't mix positive and negative integers in a single subset:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\CommentTok{#> Error in x[c(-1, 2)]:}
\CommentTok{#>   only 0's may be mixed with negative subscripts}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Logical vectors} select elements where the corresponding
  logical value is \texttt{TRUE}. This is probably the most useful type
  of subsetting because you can write an expression that creates the
  logical vector: \index{subsetting!with logical vectors}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 4.2}
\NormalTok{x[x }\OperatorTok{>}\StringTok{ }\DecValTok{3}\NormalTok{]}
\CommentTok{#> [1] 4.2 3.3 5.4}
\end{Highlighting}
\end{Shaded}

  If the logical vector is shorter than the vector being subsetted, it
  will be silently \textbf{recycled} to be the same length.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 3.3}
\CommentTok{# Equivalent to}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 3.3}
\end{Highlighting}
\end{Shaded}

  A missing value in the index always yields a missing value in the
  output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\CommentTok{#> [1] 2.1 4.2  NA}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Nothing} returns the original vector. This is not useful for
  1d vectors, but as you'll see shortly, is very useful for matrices,
  data frames, and arrays. It can also be useful in conjunction with
  assignment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[]}
\CommentTok{#> [1] 2.1 4.2 3.3 5.4}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{Zero} returns a zero-length vector. This is not something you
  usually do on purpose, but it can be helpful for generating test data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\DecValTok{0}\NormalTok{]}
\CommentTok{#> numeric(0)}
\end{Highlighting}
\end{Shaded}
\item
  If the vector is named, you can also use \textbf{character vectors} to
  return elements with matching names.
  \index{subsetting!with character vectors}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(y <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(x, letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{]))}
\CommentTok{#>   a   b   c   d }
\CommentTok{#> 2.1 4.2 3.3 5.4}
\NormalTok{y[}\KeywordTok{c}\NormalTok{(}\StringTok{"d"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{)]}
\CommentTok{#>   d   c   a }
\CommentTok{#> 5.4 3.3 2.1}

\CommentTok{# Like integer indices, you can repeat indices}
\NormalTok{y[}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{)]}
\CommentTok{#>   a   a   a }
\CommentTok{#> 2.1 2.1 2.1}

\CommentTok{# When subsetting with [, names are always matched exactly}
\NormalTok{z <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{abc =} \DecValTok{1}\NormalTok{, }\DataTypeTok{def =} \DecValTok{2}\NormalTok{)}
\NormalTok{z[}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"d"}\NormalTok{)]}
\CommentTok{#> <NA> <NA> }
\CommentTok{#>   NA   NA}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{lists-1}{%
\subsection{Lists}\label{lists-1}}

\index{lists!subsetting} \index{subsetting!lists}

Subsetting a list works in the same way as subsetting an atomic vector.
Using \texttt{{[}} will always return a list; \texttt{{[}{[}} and
\texttt{\$}, as described in Section \ref{subset-single}, let you pull
out the components of the list.

\hypertarget{matrix-subsetting}{%
\subsection{Matrices and arrays}\label{matrix-subsetting}}

\index{subsetting!arrays} \index{arrays!subsetting}

You can subset higher-dimensional structures in three ways:

\begin{itemize}
\tightlist
\item
  With multiple vectors.
\item
  With a single vector.
\item
  With a matrix.
\end{itemize}

The most common way of subsetting matrices (2d) and arrays
(\textgreater{}2d) is a simple generalisation of 1d subsetting: you
supply a 1d index for each dimension, separated by a comma. Blank
subsetting is now useful because it lets you keep all rows or all
columns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{)}
\KeywordTok{colnames}\NormalTok{(a) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{)}
\NormalTok{a[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, ]}
\CommentTok{#>      A B C}
\CommentTok{#> [1,] 1 4 7}
\CommentTok{#> [2,] 2 5 8}
\NormalTok{a[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"A"}\NormalTok{)]}
\CommentTok{#>      B A}
\CommentTok{#> [1,] 4 1}
\CommentTok{#> [2,] 6 3}
\NormalTok{a[}\DecValTok{0}\NormalTok{, }\DecValTok{-2}\NormalTok{]}
\CommentTok{#>      A C}
\end{Highlighting}
\end{Shaded}

By default, \texttt{{[}} will simplify the results to the lowest
possible dimensionality. You'll learn how to avoid this in Section
\ref{simplify-preserve}.

Because matrices and arrays are just vectors with special attributes,
you can subset them with a single vector, as if they were a 1d vector.
Arrays in R are stored in column-major order:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vals <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"paste"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{","}\NormalTok{)}
\NormalTok{vals}
\CommentTok{#>      [,1]  [,2]  [,3]  [,4]  [,5] }
\CommentTok{#> [1,] "1,1" "1,2" "1,3" "1,4" "1,5"}
\CommentTok{#> [2,] "2,1" "2,2" "2,3" "2,4" "2,5"}
\CommentTok{#> [3,] "3,1" "3,2" "3,3" "3,4" "3,5"}
\CommentTok{#> [4,] "4,1" "4,2" "4,3" "4,4" "4,5"}
\CommentTok{#> [5,] "5,1" "5,2" "5,3" "5,4" "5,5"}

\NormalTok{vals[}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{15}\NormalTok{)]}
\CommentTok{#> [1] "4,1" "5,3"}
\end{Highlighting}
\end{Shaded}

You can also subset higher-dimensional data structures with an integer
matrix (or, if named, a character matrix). Each row in the matrix
specifies the location of one value, and each column corresponds to a
dimension in the array being subsetted. This means that you can use a 2
column matrix to subset a matrix, a 3 column matrix to subset a 3d
array, and so on. The result is a vector of values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{select <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(}
  \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{)}
\NormalTok{vals[select]}
\CommentTok{#> [1] "1,1" "3,1" "2,4"}
\end{Highlighting}
\end{Shaded}

\hypertarget{df-subsetting}{%
\subsection{Data frames and tibbles}\label{df-subsetting}}

\index{subsetting!data frames} \index{data frames!subsetting}

Data frames possess the characteristics of both lists and matrices: if
you subset with a single vector, they behave like lists; if you subset
with two vectors, they behave like matrices.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}

\NormalTok{df[df}\OperatorTok{$}\NormalTok{x }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{, ]}
\CommentTok{#>   x y z}
\CommentTok{#> 2 2 2 b}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{), ]}
\CommentTok{#>   x y z}
\CommentTok{#> 1 1 3 a}
\CommentTok{#> 3 3 1 c}

\CommentTok{# There are two ways to select columns from a data frame}
\CommentTok{# Like a list, which}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"z"}\NormalTok{)]}
\CommentTok{#>   x z}
\CommentTok{#> 1 1 a}
\CommentTok{#> 2 2 b}
\CommentTok{#> 3 3 c}
\CommentTok{# Like a matrix}
\NormalTok{df[, }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"z"}\NormalTok{)]}
\CommentTok{#>   x z}
\CommentTok{#> 1 1 a}
\CommentTok{#> 2 2 b}
\CommentTok{#> 3 3 c}

\CommentTok{# There's an important difference if you select a single }
\CommentTok{# column: matrix subsetting simplifies by default, list }
\CommentTok{# subsetting does not.}
\KeywordTok{str}\NormalTok{(df[}\StringTok{"x"}\NormalTok{])}
\CommentTok{#> 'data.frame':    3 obs. of  1 variable:}
\CommentTok{#>  $ x: int  1 2 3}
\KeywordTok{str}\NormalTok{(df[, }\StringTok{"x"}\NormalTok{])}
\CommentTok{#>  int [1:3] 1 2 3}
\end{Highlighting}
\end{Shaded}

Subsetting a tibble with \texttt{{[}} always returns a tibble:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}

\KeywordTok{str}\NormalTok{(df[}\StringTok{"x"}\NormalTok{])}
\CommentTok{#> Classes 'tbl_df', 'tbl' and 'data.frame':    3 obs. of  1 variable:}
\CommentTok{#>  $ x: int  1 2 3}
\KeywordTok{str}\NormalTok{(df[, }\StringTok{"x"}\NormalTok{])}
\CommentTok{#> Classes 'tbl_df', 'tbl' and 'data.frame':    3 obs. of  1 variable:}
\CommentTok{#>  $ x: int  1 2 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{simplify-preserve}{%
\subsection{Preserving dimensionality}\label{simplify-preserve}}

\indexc{drop = FALSE}

\index{subsetting!simplifying} \index{subsetting!preserving}

By default, subsetting a 2d data structures with a single number, single
name, or a logical vector containing a single \texttt{TRUE} will
simplify the returned output, i.e.~it will return an object with lower
dimensionality. To preserve the original dimensionality, you must use
\texttt{drop\ =\ FALSE}

\begin{itemize}
\item
  For matrices and arrays, any dimensions with length 1 will be dropped:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{)}
\KeywordTok{str}\NormalTok{(a[}\DecValTok{1}\NormalTok{, ])}
\CommentTok{#>  int [1:2] 1 3}

\KeywordTok{str}\NormalTok{(a[}\DecValTok{1}\NormalTok{, , }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{])}
\CommentTok{#>  int [1, 1:2] 1 3}
\end{Highlighting}
\end{Shaded}
\item
  Data frames with a single column will return just that column:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)}
\KeywordTok{str}\NormalTok{(df[, }\StringTok{"a"}\NormalTok{])}
\CommentTok{#>  int [1:2] 1 2}

\KeywordTok{str}\NormalTok{(df[, }\StringTok{"a"}\NormalTok{, }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{])}
\CommentTok{#> 'data.frame':    2 obs. of  1 variable:}
\CommentTok{#>  $ a: int  1 2}
\end{Highlighting}
\end{Shaded}
\item
  Tibbles default to \texttt{drop\ =\ FALSE}, and \texttt{{[}} will
  never return a single vector.
\end{itemize}

The default \texttt{drop\ =\ TRUE} behaviour is a common source of bugs
in functions: you check your code with a data frame or matrix with
multiple columns, and it works. Six months later you (or someone else)
uses it with a single column data frame and it fails with a mystifying
error. When writing functions, get in the habit of always using
\texttt{drop\ =\ FALSE} when subsetting a 2d object.

Factor subsetting also has a \texttt{drop} argument, but the meaning is
rather different. It controls whether or not levels are preserved (not
the dimensionality), and it defaults to \texttt{FALSE} (levels are
preserved, not simplified by default). If you find you are using
\texttt{drop\ =\ TRUE} a lot it's often a sign that you should be using
a character vector instead of a factor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\NormalTok{z[}\DecValTok{1}\NormalTok{]}
\CommentTok{#> [1] a}
\CommentTok{#> Levels: a b}
\NormalTok{z[}\DecValTok{1}\NormalTok{, drop =}\StringTok{ }\OtherTok{TRUE}\NormalTok{]}
\CommentTok{#> [1] a}
\CommentTok{#> Levels: a}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-9}{%
\subsection{Exercises}\label{exercises-9}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Fix each of the following common data frame subsetting errors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{cyl =}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\NormalTok{mtcars[}\OperatorTok{-}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, ]}
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{<=}\StringTok{ }\DecValTok{5}\NormalTok{]}
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4} \OperatorTok{|}\StringTok{ }\DecValTok{6}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}
\item
  Why does the following code yield five missing values? (Hint: why is
  it different from \texttt{x{[}NA\_real\_{]}}?)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\NormalTok{x[}\OtherTok{NA}\NormalTok{]}
\CommentTok{#> [1] NA NA NA NA NA}
\end{Highlighting}
\end{Shaded}
\item
  What does \texttt{upper.tri()} return? How does subsetting a matrix
  with it work? Do we need any additional subsetting rules to describe
  its behaviour?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"*"}\NormalTok{)}
\NormalTok{x[}\KeywordTok{upper.tri}\NormalTok{(x)]}
\end{Highlighting}
\end{Shaded}
\item
  Why does \texttt{mtcars{[}1:20{]}} return an error? How does it differ
  from the similar \texttt{mtcars{[}1:20,\ {]}}?
\item
  Implement your own function that extracts the diagonal entries from a
  matrix (it should behave like \texttt{diag(x)} where \texttt{x} is a
  matrix).
\item
  What does \texttt{df{[}is.na(df){]}\ \textless{}-\ 0} do? How does it
  work?
\end{enumerate}

\hypertarget{subset-single}{%
\section{Selecting a single element}\label{subset-single}}

\index{subsetting!lists} \index{lists!subsetting}

There are two other subsetting operators: \texttt{{[}{[}} and
\texttt{\$}. \texttt{{[}{[}} is used for extracting single items, and
\texttt{x\$y} is a useful shorthand for \texttt{x{[}{[}"y"{]}{]}}.

\hypertarget{section}{%
\subsection{\texorpdfstring{\texttt{{[}{[}}}{{[}{[}}}\label{section}}

\indexc{[[}

\texttt{{[}{[}} is most important working with lists because subsetting
a list with \texttt{{[}} always returns a smaller list. To help make
this easier to understand we can use a metaphor:

\begin{quote}
``If list \texttt{x} is a train carrying objects, then
\texttt{x{[}{[}5{]}{]}} is the object in car 5; \texttt{x{[}4:6{]}} is a
train of cars 4-6.''

\hspace*{\fill} --- @RLangTip,
\url{https://twitter.com/RLangTip/status/268375867468681216}
\end{quote}

Let's make a simple list and draw it as a train:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\DecValTok{4}\OperatorTok{:}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.62in]{diagrams/subsetting/train} \end{center}

When extracting a single element, you have two options: you can create a
smaller train, or you can extract the contents of a carriage. This is
the difference between \texttt{{[}} and \texttt{{[}{[}}:

\begin{center}\includegraphics[width=4.62in]{diagrams/subsetting/train-single} \end{center}

When extracting multiple elements (or zero!), you have to make a smaller
train:

\begin{center}\includegraphics[width=4.62in]{diagrams/subsetting/train-multiple} \end{center}

Because it can return only a single item, you must use \texttt{{[}{[}}
with either a single positive integer or a string. If you use a vector
with \texttt{{[}{[}}, it will subset recursively:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{b =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{c =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{d =} \DecValTok{1}\NormalTok{))))}
\NormalTok{b[[}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{)]]}
\CommentTok{#> [1] 1}

\CommentTok{# Equivalent to}
\NormalTok{b[[}\StringTok{"a"}\NormalTok{]][[}\StringTok{"b"}\NormalTok{]][[}\StringTok{"c"}\NormalTok{]][[}\StringTok{"d"}\NormalTok{]]}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\texttt{{[}{[}} is crucial for working with lists, but I recommend using
it whenever you want your code to clearly express that it's working with
a single item. That frequently arises in for loops, e.g., instead of
writing:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\NormalTok{  out[i] <-}\StringTok{ }\KeywordTok{fun}\NormalTok{(x[i], out[i }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It's better to write:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\NormalTok{  out[[i]] <-}\StringTok{ }\KeywordTok{fun}\NormalTok{(x[[i]], out[[i }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{]])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That reinforces to the reader that you expect to get and set individual
values.

\hypertarget{section-1}{%
\subsection{\texorpdfstring{\texttt{\$}}{\$}}\label{section-1}}

\indexc{\$}

\texttt{\$} is a shorthand operator: \texttt{x\$y} is roughly equivalent
to \texttt{x{[}{[}"y"{]}{]}}. It's often used to access variables in a
data frame, as in \texttt{mtcars\$cyl} or \texttt{diamonds\$carat}. One
common mistake with \texttt{\$} is to use it when you have the name of a
column stored in a variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ "cyl"}
\CommentTok{# Doesn't work - mtcars$var translated to mtcars[["var"]]}
\NormalTok{mtcars}\OperatorTok{$}\NormalTok{var}
\CommentTok{#> NULL}

\CommentTok{# Instead use [[}
\NormalTok{mtcars[[var]]}
\CommentTok{#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4}
\end{Highlighting}
\end{Shaded}

There's one important difference between \texttt{\$} and
\texttt{{[}{[}}. \texttt{\$} does partial matching:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{abc =} \DecValTok{1}\NormalTok{)}
\NormalTok{x}\OperatorTok{$}\NormalTok{a}
\CommentTok{#> [1] 1}
\NormalTok{x[[}\StringTok{"a"}\NormalTok{]]}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

To help avoid this behaviour I highly recommend setting the global
option \texttt{warnPartialMatchDollar} to \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{options}\NormalTok{(}\DataTypeTok{warnPartialMatchDollar =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{x}\OperatorTok{$}\NormalTok{a}
\CommentTok{#> Warning in x$a: partial match of 'a' to 'abc'}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

(For data frames, you can also avoid this problem by using tibbles
instead: they never do partial matching.)

\hypertarget{missingout-of-bounds-indices}{%
\subsection{Missing/out of bounds
indices}\label{missingout-of-bounds-indices}}

\index{subsetting!with NA \& NULL} \index{subsetting!out of bounds}

It's useful to understand what happens with \texttt{{[}{[}} when you use
an ``invalid'' index. The following tables summarise what happens when
you subset a logical vector, list, and \texttt{NULL} with an
out-of-bounds value (OOB), a missing value (e.g.
\texttt{NA\_integer\_}), and a zero-length object (like \texttt{NULL} or
\texttt{logical()}) with \texttt{{[}{[}} . Each cell shows the result of
subsetting the data structure named in the row by the type of index
described in the column. I've only shown the results for logical
vectors, but other atomic vectors behave similarly, returning elements
of the same type.

\begin{longtable}[]{@{}lllll@{}}
\toprule
\texttt{row{[}{[}col{]}{]}} & Zero-length & OOB (int) & OOB (chr) &
Missing\tabularnewline
\midrule
\endhead
\texttt{NULL} & \texttt{NULL} & \texttt{NULL} & \texttt{NULL} &
\texttt{NULL}\tabularnewline
Atomic & Error & Error & Error & Error\tabularnewline
List & Error & Error & \texttt{NULL} & \texttt{NULL}\tabularnewline
\bottomrule
\end{longtable}

If the input vector is named, then the names of OOB, missing, or
\texttt{NULL} components will be \texttt{"\textless{}NA\textgreater{}"}.

The inconsistency of the \texttt{{[}{[}} table above lead to the
development of \texttt{purrr::pluck()} and \texttt{purrr::chuck()}.
\texttt{pluck()} always returns \texttt{NULL} (or the value of the
\texttt{.default} argument) when the element is missing;
\texttt{chuck()} always throws an error:

\begin{longtable}[]{@{}lllll@{}}
\toprule
\texttt{pluck(row,\ col)} & Zero-length & OOB (int) & OOB (chr) &
Missing\tabularnewline
\midrule
\endhead
\texttt{NULL} & \texttt{NULL} & \texttt{NULL} & \texttt{NULL} &
\texttt{NULL}\tabularnewline
Atomic & \texttt{NULL} & \texttt{NULL} & \texttt{NULL} &
\texttt{NULL}\tabularnewline
List & \texttt{NULL} & \texttt{NULL} & \texttt{NULL} &
\texttt{NULL}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}lllll@{}}
\toprule
\texttt{chuck(row,\ col)} & Zero-length & OOB (int) & OOB (chr) &
Missing\tabularnewline
\midrule
\endhead
\texttt{NULL} & Error & Error & Error & Error\tabularnewline
Atomic & Error & Error & Error & Error\tabularnewline
List & Error & Error & Error & Error\tabularnewline
\bottomrule
\end{longtable}

The behaviour of \texttt{pluck()} makes it well suited for indexing into
deeply nested data structures where the component you want does not
always exist (as is common when working with JSON data from web APIs).
\texttt{pluck()} also allows you to mingle integer and character
indexes, and to provide an alternative default value if the item does
not exist:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{),}
  \DataTypeTok{b =} \KeywordTok{list}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\NormalTok{)}

\NormalTok{purrr}\OperatorTok{::}\KeywordTok{pluck}\NormalTok{(x, }\StringTok{"a"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 1}

\NormalTok{purrr}\OperatorTok{::}\KeywordTok{pluck}\NormalTok{(x, }\StringTok{"c"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{#> NULL}

\NormalTok{purrr}\OperatorTok{::}\KeywordTok{pluck}\NormalTok{(x, }\StringTok{"c"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DataTypeTok{.default =} \OtherTok{NA}\NormalTok{)}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}

\hypertarget{and-slot}{%
\subsection{\texorpdfstring{\texttt{@} and
\texttt{slot()}}{@ and slot()}}\label{and-slot}}

\index{subsetting!S4} \index{S4!subsetting}

There are also two additional subsetting operators that are needed for
S4 objects: \texttt{@} (equivalent to \texttt{\$}), and \texttt{slot()}
(equivalent to \texttt{{[}{[}}). \texttt{@} is more restrictive than
\texttt{\$} in that it will return an error if the slot does not exist.
These are described in more detail in \protect\hyperlink{s4}{S4}.

\hypertarget{exercises-10}{%
\subsection{Exercises}\label{exercises-10}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Brainstorm as many ways as possible to extract the third value from
  the \texttt{cyl} variable in the \texttt{mtcars} dataset.
\item
  Given a linear model, e.g.,
  \texttt{mod\ \textless{}-\ lm(mpg\ \textasciitilde{}\ wt,\ data\ =\ mtcars)},
  extract the residual degrees of freedom. Extract the R squared from
  the model summary (\texttt{summary(mod)})
\end{enumerate}

\hypertarget{subassignment}{%
\section{Subsetting and assignment}\label{subassignment}}

\index{subsetting!subassignment} \index{assignment!subassignment}

All subsetting operators can be combined with assignment to modify
selected values of the input vector, so called subassignment. The basic
form is \texttt{x{[}i{]}\ \textless{}-\ value}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\NormalTok{x[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{101}\NormalTok{, }\DecValTok{102}\NormalTok{)}
\NormalTok{x}
\CommentTok{#> [1] 101 102   3   4   5}
\end{Highlighting}
\end{Shaded}

I recommend ensuring that \texttt{length(value)} and
\texttt{length(x{[}i{]})} are equal, and that \texttt{i} is unique. R
does recycle if needed, but the rules are complex (particularly if
\texttt{i} contains missing or duplicated values).

With lists, you can use \texttt{x{[}{[}i{]}{]}\ \textless{}-\ NULL} to
remove a component. To add a literal \texttt{NULL}, use
\texttt{x{[}i{]}\ \textless{}-\ list(NULL)}:
\index{lists!removing an element}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{x[[}\StringTok{"b"}\NormalTok{]] <-}\StringTok{ }\OtherTok{NULL}
\KeywordTok{str}\NormalTok{(x)}
\CommentTok{#> List of 1}
\CommentTok{#>  $ a: num 1}

\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{y[}\StringTok{"b"}\NormalTok{] <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\KeywordTok{str}\NormalTok{(y)}
\CommentTok{#> List of 2}
\CommentTok{#>  $ a: num 1}
\CommentTok{#>  $ b: NULL}
\end{Highlighting}
\end{Shaded}

Subsetting with nothing can be useful in conjunction with assignment
because it will preserve the structure of the original object. Compare
the following two expressions. In the first, \texttt{mtcars} will remain
as a data frame. In the second, \texttt{mtcars} will become a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[] <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(mtcars, as.integer)}
\KeywordTok{is.data.frame}\NormalTok{(mtcars)}
\CommentTok{#> [1] TRUE}

\NormalTok{mtcars <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(mtcars, as.integer)}
\KeywordTok{is.data.frame}\NormalTok{(mtcars)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{applications}{%
\section{Applications}\label{applications}}

The basic principles described above give rise to a wide variety of
useful applications. Some of the most important are described below.
Many of these basic techniques are wrapped up into more concise
functions (e.g., \texttt{subset()}, \texttt{merge()},
\texttt{dplyr::arrange()}), but it is useful to understand how they are
implemented with basic subsetting. This will allow you to adapt to new
situations not handled by existing functions.

\hypertarget{lookup-tables}{%
\subsection{Lookup tables (character subsetting)}\label{lookup-tables}}

\index{lookup tables}

Character matching provides a powerful way to make lookup tables. Say
you want to convert abbreviations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"u"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"m"}\NormalTok{, }\StringTok{"m"}\NormalTok{)}
\NormalTok{lookup <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{m =} \StringTok{"Male"}\NormalTok{, }\DataTypeTok{f =} \StringTok{"Female"}\NormalTok{, }\DataTypeTok{u =} \OtherTok{NA}\NormalTok{)}
\NormalTok{lookup[x]}
\CommentTok{#>        m        f        u        f        f        m        m }
\CommentTok{#>   "Male" "Female"       NA "Female" "Female"   "Male"   "Male"}

\KeywordTok{unname}\NormalTok{(lookup[x])}
\CommentTok{#> [1] "Male"   "Female" NA       "Female" "Female" "Male"   "Male"}
\end{Highlighting}
\end{Shaded}

If you don't want names in the result, use \texttt{unname()} to remove
them.

\hypertarget{matching-merging}{%
\subsection{Matching and merging by hand (integer
subsetting)}\label{matching-merging}}

\index{matching \& merging} \indexc{match()}

You may have a more complicated lookup table which has multiple columns
of information. Suppose we have a vector of integer grades, and a table
that describes their properties:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{grades <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}

\NormalTok{info <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{grade =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{,}
  \DataTypeTok{desc =} \KeywordTok{c}\NormalTok{(}\StringTok{"Excellent"}\NormalTok{, }\StringTok{"Good"}\NormalTok{, }\StringTok{"Poor"}\NormalTok{),}
  \DataTypeTok{fail =} \KeywordTok{c}\NormalTok{(F, F, T)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We want to duplicate the \texttt{info} table so that we have a row for
each value in \texttt{grades}. An elegant way to do this is by combining
\texttt{match()} and integer subsetting:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{id <-}\StringTok{ }\KeywordTok{match}\NormalTok{(grades, info}\OperatorTok{$}\NormalTok{grade)}
\NormalTok{info[id, ]}
\CommentTok{#>     grade      desc  fail}
\CommentTok{#> 3       1      Poor  TRUE}
\CommentTok{#> 2       2      Good FALSE}
\CommentTok{#> 2.1     2      Good FALSE}
\CommentTok{#> 1       3 Excellent FALSE}
\CommentTok{#> 3.1     1      Poor  TRUE}
\end{Highlighting}
\end{Shaded}

If you have multiple columns to match on, you'll need to first collapse
them to a single column (with e.g. \texttt{interaction()}), but
typically you are better off switching to a function designed
specifically for joining multiple tables like \texttt{merge()}, or
\texttt{dplyr::left\_join()}.

\hypertarget{random-samplesbootstraps-integer-subsetting}{%
\subsection{Random samples/bootstraps (integer
subsetting)}\label{random-samplesbootstraps-integer-subsetting}}

\indexc{sample()}

\index{sampling} \index{bootstrapping}

You can use integer indices to perform random sampling or bootstrapping
of a vector or data frame. \texttt{sample()} generates a vector of
indices, then subsetting accesses the values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\DataTypeTok{y =} \DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{])}

\CommentTok{# Randomly reorder}
\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df)), ]}
\CommentTok{#>   x y z}
\CommentTok{#> 1 1 5 a}
\CommentTok{#> 4 1 2 d}
\CommentTok{#> 2 2 4 b}
\CommentTok{#> 5 2 1 e}
\CommentTok{#> 3 3 3 c}

\CommentTok{# Select 3 random rows}
\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), }\DecValTok{3}\NormalTok{), ]}
\CommentTok{#>   x y z}
\CommentTok{#> 3 3 3 c}
\CommentTok{#> 2 2 4 b}
\CommentTok{#> 1 1 5 a}

\CommentTok{# Select 6 bootstrap replicates}
\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), }\DecValTok{6}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), ]}
\CommentTok{#>     x y z}
\CommentTok{#> 4   1 2 d}
\CommentTok{#> 4.1 1 2 d}
\CommentTok{#> 5   2 1 e}
\CommentTok{#> 1   1 5 a}
\CommentTok{#> 1.1 1 5 a}
\CommentTok{#> 2   2 4 b}
\end{Highlighting}
\end{Shaded}

The arguments of \texttt{sample()} control the number of samples to
extract, and whether sampling is performed with or without replacement.

\hypertarget{ordering-integer-subsetting}{%
\subsection{Ordering (integer
subsetting)}\label{ordering-integer-subsetting}}

\texttt{order()} takes a vector as input and returns an integer vector
describing how the subsetted vector should be ordered: \indexc{order()}
\index{sorting}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\KeywordTok{order}\NormalTok{(x)}
\CommentTok{#> [1] 3 1 2}
\NormalTok{x[}\KeywordTok{order}\NormalTok{(x)]}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

To break ties, you can supply additional variables to \texttt{order()},
and you can change from ascending to descending order using
\texttt{decreasing\ =\ TRUE}. By default, any missing values will be put
at the end of the vector; however, you can remove them with
\texttt{na.last\ =\ NA} or put at the front with
\texttt{na.last\ =\ FALSE}.

For two or more dimensions, \texttt{order()} and integer subsetting
makes it easy to order either the rows or columns of an object:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Randomly reorder df}
\NormalTok{df2 <-}\StringTok{ }\NormalTok{df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df)), }\DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{]}
\NormalTok{df2}
\CommentTok{#>   z y x}
\CommentTok{#> 3 c 3 3}
\CommentTok{#> 1 a 5 1}
\CommentTok{#> 2 b 4 2}
\CommentTok{#> 4 d 2 1}
\CommentTok{#> 5 e 1 2}

\NormalTok{df2[}\KeywordTok{order}\NormalTok{(df2}\OperatorTok{$}\NormalTok{x), ]}
\CommentTok{#>   z y x}
\CommentTok{#> 1 a 5 1}
\CommentTok{#> 4 d 2 1}
\CommentTok{#> 2 b 4 2}
\CommentTok{#> 5 e 1 2}
\CommentTok{#> 3 c 3 3}
\NormalTok{df2[, }\KeywordTok{order}\NormalTok{(}\KeywordTok{names}\NormalTok{(df2))]}
\CommentTok{#>   x y z}
\CommentTok{#> 3 3 3 c}
\CommentTok{#> 1 1 5 a}
\CommentTok{#> 2 2 4 b}
\CommentTok{#> 4 1 2 d}
\CommentTok{#> 5 2 1 e}
\end{Highlighting}
\end{Shaded}

You can sort vectors directly with \texttt{sort()}, or use
\texttt{dplyr::arrange()} or similar to sort a data frame.

\hypertarget{expanding-aggregated-counts-integer-subsetting}{%
\subsection{Expanding aggregated counts (integer
subsetting)}\label{expanding-aggregated-counts-integer-subsetting}}

Sometimes you get a data frame where identical rows have been collapsed
into one and a count column has been added. \texttt{rep()} and integer
subsetting make it easy to uncollapse the data by subsetting with a
repeated row index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DataTypeTok{n =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(df), df}\OperatorTok{$}\NormalTok{n)}
\CommentTok{#> [1] 1 1 1 2 2 2 2 2 3}

\NormalTok{df[}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(df), df}\OperatorTok{$}\NormalTok{n), ]}
\CommentTok{#>     x  y n}
\CommentTok{#> 1   2  9 3}
\CommentTok{#> 1.1 2  9 3}
\CommentTok{#> 1.2 2  9 3}
\CommentTok{#> 2   4 11 5}
\CommentTok{#> 2.1 4 11 5}
\CommentTok{#> 2.2 4 11 5}
\CommentTok{#> 2.3 4 11 5}
\CommentTok{#> 2.4 4 11 5}
\CommentTok{#> 3   1  6 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{removing-columns-from-data-frames-character-subsetting}{%
\subsection{Removing columns from data frames (character
subsetting)}\label{removing-columns-from-data-frames-character-subsetting}}

\index{data frames!remove columns}

There are two ways to remove columns from a data frame. You can set
individual columns to \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\NormalTok{df}\OperatorTok{$}\NormalTok{z <-}\StringTok{ }\OtherTok{NULL}
\end{Highlighting}
\end{Shaded}

Or you can subset to return only the columns you want:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{)]}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 3}
\CommentTok{#> 2 2 2}
\CommentTok{#> 3 3 1}
\end{Highlighting}
\end{Shaded}

If you only know the columns you don't want, use set operations to work
out which columns to keep:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\KeywordTok{setdiff}\NormalTok{(}\KeywordTok{names}\NormalTok{(df), }\StringTok{"z"}\NormalTok{)]}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 3}
\CommentTok{#> 2 2 2}
\CommentTok{#> 3 3 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{selecting-rows-based-on-a-condition-logical-subsetting}{%
\subsection{Selecting rows based on a condition (logical
subsetting)}\label{selecting-rows-based-on-a-condition-logical-subsetting}}

\index{subsetting!with logical vectors} \indexc{subset()}

Because logical subsetting allows you to easily combine conditions from
multiple columns, it is probably the most commonly used technique for
extracting rows out of a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{gear }\OperatorTok{==}\StringTok{ }\DecValTok{5}\NormalTok{, ]}
\CommentTok{#>     mpg cyl  disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> 27 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2}
\CommentTok{#> 28 30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2}
\CommentTok{#> 29 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4}
\CommentTok{#> 30 19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6}
\CommentTok{#> 31 15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8}

\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{gear }\OperatorTok{==}\StringTok{ }\DecValTok{5} \OperatorTok{&}\StringTok{ }\NormalTok{mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\CommentTok{#>     mpg cyl  disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> 27 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2}
\CommentTok{#> 28 30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2}
\end{Highlighting}
\end{Shaded}

Remember to use the vector boolean operators \texttt{\&} and
\texttt{\textbar{}}, not the short-circuiting scalar operators
\texttt{\&\&} and \texttt{\textbar{}\textbar{}} which are more useful
inside if statements. Don't forget
\href{http://en.wikipedia.org/wiki/De_Morgan's_laws}{De Morgan's laws},
which can be useful to simplify negations:

\begin{itemize}
\tightlist
\item
  \texttt{!(X\ \&\ Y)} is the same as \texttt{!X\ \textbar{}\ !Y}
\item
  \texttt{!(X\ \textbar{}\ Y)} is the same as \texttt{!X\ \&\ !Y}
\end{itemize}

For example, \texttt{!(X\ \&\ !(Y\ \textbar{}\ Z))} simplifies to
\texttt{!X\ \textbar{}\ !!(Y\textbar{}Z)}, and then to
\texttt{!X\ \textbar{}\ Y\ \textbar{}\ Z}.

\hypertarget{boolean-algebra-vs.sets-logical-integer-subsetting}{%
\subsection{Boolean algebra vs.~sets (logical \& integer
subsetting)}\label{boolean-algebra-vs.sets-logical-integer-subsetting}}

\index{Boolean algebra} \index{set algebra} \indexc{which()}

It's useful to be aware of the natural equivalence between set
operations (integer subsetting) and boolean algebra (logical
subsetting). Using set operations is more effective when:

\begin{itemize}
\item
  You want to find the first (or last) \texttt{TRUE}.
\item
  You have very few \texttt{TRUE}s and very many \texttt{FALSE}s; a set
  representation may be faster and require less storage.
\end{itemize}

\texttt{which()} allows you to convert a boolean representation to an
integer representation. There's no reverse operation in base R but we
can easily create one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{10}\NormalTok{) }\OperatorTok{<}\StringTok{ }\DecValTok{4}
\KeywordTok{which}\NormalTok{(x)}
\CommentTok{#> [1] 2 5 8}

\NormalTok{unwhich <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, n) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{rep_len}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, n)}
\NormalTok{  out[x] <-}\StringTok{ }\OtherTok{TRUE}
\NormalTok{  out}
\NormalTok{\}}
\KeywordTok{unwhich}\NormalTok{(}\KeywordTok{which}\NormalTok{(x), }\DecValTok{10}\NormalTok{)}
\CommentTok{#>  [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Let's create two logical vectors and their integer equivalents and then
explore the relationship between boolean and set operations.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%%}\StringTok{ }\DecValTok{2} \OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE}
\NormalTok{(x2 <-}\StringTok{ }\KeywordTok{which}\NormalTok{(x1))}
\CommentTok{#> [1]  2  4  6  8 10}
\NormalTok{(y1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%%}\StringTok{ }\DecValTok{5} \OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE}
\NormalTok{(y2 <-}\StringTok{ }\KeywordTok{which}\NormalTok{(y1))}
\CommentTok{#> [1]  5 10}

\CommentTok{# X & Y <-> intersect(x, y)}
\NormalTok{x1 }\OperatorTok{&}\StringTok{ }\NormalTok{y1}
\CommentTok{#>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE}
\KeywordTok{intersect}\NormalTok{(x2, y2)}
\CommentTok{#> [1] 10}

\CommentTok{# X | Y <-> union(x, y)}
\NormalTok{x1 }\OperatorTok{|}\StringTok{ }\NormalTok{y1}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE}
\KeywordTok{union}\NormalTok{(x2, y2)}
\CommentTok{#> [1]  2  4  6  8 10  5}

\CommentTok{# X & !Y <-> setdiff(x, y)}
\NormalTok{x1 }\OperatorTok{&}\StringTok{ }\OperatorTok{!}\NormalTok{y1}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE}
\KeywordTok{setdiff}\NormalTok{(x2, y2)}
\CommentTok{#> [1] 2 4 6 8}

\CommentTok{# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))}
\KeywordTok{xor}\NormalTok{(x1, y1)}
\CommentTok{#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE}
\KeywordTok{setdiff}\NormalTok{(}\KeywordTok{union}\NormalTok{(x2, y2), }\KeywordTok{intersect}\NormalTok{(x2, y2))}
\CommentTok{#> [1] 2 4 6 8 5}
\end{Highlighting}
\end{Shaded}

When first learning subsetting, a common mistake is to use
\texttt{x{[}which(y){]}} instead of \texttt{x{[}y{]}}. Here the
\texttt{which()} achieves nothing: it switches from logical to integer
subsetting but the result will be exactly the same. In more general
cases, there are two important differences.

\begin{itemize}
\tightlist
\item
  When the logical vector contains \texttt{NA}, logical subsetting
  replaces these values by \texttt{NA} while \texttt{which()} drops
  these values. It's not uncommon to use \texttt{which()} for this
  side-effect, but that's
\end{itemize}

\begin{itemize}
\tightlist
\item
  \texttt{x{[}-which(y){]}} is \textbf{not} equivalent to
  \texttt{x{[}!y{]}}: if \texttt{y} is all FALSE, \texttt{which(y)} will
  be \texttt{integer(0)} and \texttt{-integer(0)} is still
  \texttt{integer(0)}, so you'll get no values, instead of all values.
\end{itemize}

In general, avoid switching from logical to integer subsetting unless
you want, for example, the first or last \texttt{TRUE} value.

\hypertarget{exercises-11}{%
\subsection{Exercises}\label{exercises-11}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How would you randomly permute the columns of a data frame? (This is
  an important technique in random forests.) Can you simultaneously
  permute the rows and columns in one step?
\item
  How would you select a random sample of \texttt{m} rows from a data
  frame? What if the sample had to be contiguous (i.e., with an initial
  row, a final row, and every row in between)?
\item
  How could you put the columns in a data frame in alphabetical order?
\end{enumerate}

\hypertarget{subsetting-answers}{%
\section{Answers}\label{subsetting-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Positive integers select elements at specific positions, negative
  integers drop elements; logical vectors keep elements at positions
  corresponding to \texttt{TRUE}; character vectors select elements with
  matching names.
\item
  \texttt{{[}} selects sub-lists. It always returns a list; if you use
  it with a single positive integer, it returns a list of length one.
  \texttt{{[}{[}} selects an element within a list. \texttt{\$} is a
  convenient shorthand: \texttt{x\$y} is equivalent to
  \texttt{x{[}{[}"y"{]}{]}}.
\item
  Use \texttt{drop\ =\ FALSE} if you are subsetting a matrix, array, or
  data frame and you want to preserve the original dimensions. You
  should almost always use it when subsetting inside a function.
\item
  If \texttt{x} is a matrix, \texttt{x{[}{]}\ \textless{}-\ 0} will
  replace every element with 0, keeping the same number of rows and
  columns. \texttt{x\ \textless{}-\ 0} completely replaces the matrix
  with the value 0.
\item
  A named character vector can act as a simple lookup table:
  \texttt{c(x\ =\ 1,\ y\ =\ 2,\ z\ =\ 3){[}c("y",\ "z",\ "x"){]}}
\end{enumerate}

\hypertarget{functions}{%
\chapter{Functions}\label{functions}}

\hypertarget{introduction-4}{%
\section{Introduction}\label{introduction-4}}

\index{functions}

If you're reading this book, you've probably already created many R
functions and know how to use them to reduce duplication in your code.
In this chapter, you'll learn how to turn that informal, working
knowledge into more rigorous, theoretical understanding. And while
you'll see some interesting tricks and techniques along the way, keep in
mind that what you'll learn here will be important for understanding the
more advanced topics discussed later in the book.

\hypertarget{quiz-3}{%
\subsection*{Quiz}\label{quiz-3}}
\addcontentsline{toc}{subsection}{Quiz}

Answer the following questions to see if you can safely skip this
chapter. You can find the answers in Section \ref{function-answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What are the three components of a function?
\item
  What does the following code return?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    x }\OperatorTok{+}\StringTok{ }\DecValTok{10}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(}\DecValTok{1}\NormalTok{)()}
\end{Highlighting}
\end{Shaded}
\item
  How would you usually write this code?

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  How could you make this call easier to read?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(, }\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  Does the following code throw an error when executed? Why/why not?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
\NormalTok{  a }\OperatorTok{*}\StringTok{ }\DecValTok{10}
\NormalTok{\}}
\KeywordTok{f2}\NormalTok{(}\DecValTok{10}\NormalTok{, }\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  What is an infix function? How do you write it? What's a replacement
  function? How do you write it?
\item
  How do you ensure that cleanup action occurs regardless of how a
  function exits?
\end{enumerate}

\hypertarget{outline-3}{%
\subsection*{Outline}\label{outline-3}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{function-fundamentals} describes the basics of creating a
  function, the three main components of a function, and the exception
  to many function rules: primitive functions (which are implemented in
  C, not R).
\item
  Section \ref{function-composition} discusses the strengths and
  weaknesses of the three forms of function composition commonly used in
  R code.
\item
  Section \ref{lexical-scoping} shows you how R finds the value
  associated with a given name, i.e.~the rules of lexical scoping.
\item
  Section \ref{lazy-evaluation} is devoted to an important property of
  function arguments: they are only evaluated when used for the first
  time.
\item
  Section \ref{fun-dot-dot-dot} discusses the special \texttt{...}
  argument, which allows you to pass on extra arguments to another
  function.
\item
  Section \ref{exiting-a-function} discusses the two primary ways that a
  function can exit, and how to define an exit handler, code that is run
  on exit, regardless of what triggers it.
\item
  Section \ref{function-forms} shows you the various ways in which R
  disguises ordinary function calls, and how you can use the standard
  prefix form to better understand what's going on.
\end{itemize}

\hypertarget{function-fundamentals}{%
\section{Function fundamentals}\label{function-fundamentals}}

To understand functions in R you need to internalise two important
ideas:

\begin{itemize}
\item
  Functions are objects, just as vectors are objects.
\item
  Functions can be broken down into three components: arguments, body,
  and environment.
\end{itemize}

There are exceptions to every rule, and in this case, there is a small
selection of ``primitive'' base functions that are implemented purely in
C.

\hypertarget{first-class-functions}{%
\subsection{First-class functions}\label{first-class-functions}}

The most important thing to understand about R is that functions are
objects in their own right, a language property often called
``first-class functions''. Unlike in many other languages, there is no
special syntax for defining and naming a function: you simply create a
function object (with \texttt{function}) and bind it to a name with
\texttt{\textless{}-}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{sin}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{x }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.62in]{diagrams/functions/first-class} \end{center}

\index{functions!anonymous} \index{anoynmous functions}

While you almost always create a function and then bind it to a name,
the binding step is not compulsory. If you choose not to give a function
a name, you get an \textbf{anonymous function}. This is useful when it's
not worth the effort to figure out a name:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(mtcars, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(x)))}
\KeywordTok{Filter}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\OperatorTok{!}\KeywordTok{is.numeric}\NormalTok{(x), mtcars)}
\KeywordTok{integrate}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sin}\NormalTok{(x) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, pi)}
\end{Highlighting}
\end{Shaded}

A final option is to put functions in a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{half =} \ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{,}
  \DataTypeTok{double =} \ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{)}

\NormalTok{funs}\OperatorTok{$}\KeywordTok{double}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

In R, you'll often see functions called \textbf{closures}. This name
reflects the fact that R functions capture, or \textbf{enclose}, their
environments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(f01)}
\CommentTok{#> [1] "closure"}
\end{Highlighting}
\end{Shaded}

\hypertarget{function-components}{%
\subsection{Function components}\label{function-components}}

\index{functions!body} \indexc{body()} \index{functions!formals}
\indexc{formals()} \index{functions!environment}
\index{environments!of a function}

A function has three parts:

\begin{itemize}
\item
  The \texttt{formals()}, the list of arguments that control how you
  call the function.
\item
  The \texttt{body()}, the code inside the function.
\item
  The \texttt{environment()}, the data structure that determines how the
  function finds the values associated with the names.
\end{itemize}

I'll draw functions as in the following diagram. The black dot on the
left is the environment. The two blocks to the right are the function
arguments. I won't draw the body, because it's usually large, and
doesn't help you understand the ``shape'' of the function.

\begin{center}\includegraphics[width=1.23in]{diagrams/functions/components} \end{center}

While the formals and body are specified explicitly when you create a
function, the environment is specified implicitly, based on \emph{where}
you defined the function. The function environment always exists, but it
is only printed when the function isn't defined in the global
environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f02 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \CommentTok{# A comment}
\NormalTok{  x }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{\}}

\KeywordTok{formals}\NormalTok{(f02)}
\CommentTok{#> $x}

\KeywordTok{body}\NormalTok{(f02)}
\CommentTok{#> \{}
\CommentTok{#>     x^2}
\CommentTok{#> \}}

\KeywordTok{environment}\NormalTok{(f02)}
\CommentTok{#> <environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

Like all objects in R, functions can also possess any number of
additional \texttt{attributes()}. One attribute used by base R is
``srcref'', short for source reference. It points to the source code
used to create the function. The srcref is used for printing because,
unlike \texttt{body()}, it contains code comments and other formatting.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attr}\NormalTok{(f02, }\StringTok{"srcref"}\NormalTok{)}
\CommentTok{#> function(x) \{}
\CommentTok{#>   # A comment}
\CommentTok{#>   x ^ 2}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

\hypertarget{primitive-functions}{%
\subsection{Primitive functions}\label{primitive-functions}}

\index{primitive functions}
\index{functions!primitive|see{primitive functions}} \indexc{.Primitive}

There is one exception to the rule that a function has three components.
Primitive functions, like \texttt{sum()} and \texttt{{[}}, call C code
directly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum}
\CommentTok{#> function (..., na.rm = FALSE)  .Primitive("sum")}
\StringTok{`}\DataTypeTok{[}\StringTok{`}
\CommentTok{#> .Primitive("[")}
\end{Highlighting}
\end{Shaded}

They have type ``builtin'' or ``special'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(sum)}
\CommentTok{#> [1] "builtin"}
\KeywordTok{typeof}\NormalTok{(}\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] "special"}
\end{Highlighting}
\end{Shaded}

These functions exist primarily in C, not R, so their
\texttt{formals()}, \texttt{body()}, and \texttt{environment()} are all
\texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{formals}\NormalTok{(sum)}
\CommentTok{#> NULL}
\KeywordTok{body}\NormalTok{(sum)}
\CommentTok{#> NULL}
\KeywordTok{environment}\NormalTok{(sum)}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

Primitive functions are only found in the base package. While they have
certain performance advantages, this benefit comes at a price: they are
harder to write. For this reason, R-core generally avoids creating them
unless there is no other option.

\hypertarget{exercises-12}{%
\subsection{Exercises}\label{exercises-12}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Given a function, like \texttt{"mean"}, \texttt{match.fun()} lets you
  find a function. Given a function, can you find its name? Why doesn't
  that make sense in R?
\end{enumerate}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  It's possible (although typically not useful) to call an anonymous
  function. Which of the two approaches below is correct? Why?

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{function}\NormalTok{(x) }\DecValTok{3}\NormalTok{()}
\CommentTok{#> function(x) 3()}
\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\DecValTok{3}\NormalTok{)()}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}
\item
  A good rule of thumb is that an anonymous function should fit on one
  line and shouldn't need to use \texttt{\{\}}. Review your code. Where
  could you have used an anonymous function instead of a named function?
  Where should you have used a named function instead of an anonymous
  function?
\item
  What function allows you to tell if an object is a function? What
  function allows you to tell if a function is a primitive function?
\item
  This code makes a list of all functions in the base package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objs <-}\StringTok{ }\KeywordTok{mget}\NormalTok{(}\KeywordTok{ls}\NormalTok{(}\StringTok{"package:base"}\NormalTok{), }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{funs <-}\StringTok{ }\KeywordTok{Filter}\NormalTok{(is.function, objs)}
\end{Highlighting}
\end{Shaded}

  Use it to answer the following questions:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Which base function has the most arguments?
  \item
    How many base functions have no arguments? What's special about
    those functions?
  \item
    How could you adapt the code to find all primitive functions?
  \end{enumerate}
\item
  What are the three important components of a function?
\item
  When does printing a function not show the environment it was created
  in?
\end{enumerate}

\hypertarget{function-composition}{%
\section{Function composition}\label{function-composition}}

Base R provides two ways to compose multiple function calls. For
example, imagine you want to compute the population standard deviation
using \texttt{sqrt()} and \texttt{mean()} as building blocks:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{square <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{^}\DecValTok{2}
\NormalTok{deviation <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

You either nest the function calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}

\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\KeywordTok{square}\NormalTok{(}\KeywordTok{deviation}\NormalTok{(x))))}
\CommentTok{#> [1] 0.274}
\end{Highlighting}
\end{Shaded}

Or you save the intermediate results as variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out <-}\StringTok{ }\KeywordTok{deviation}\NormalTok{(x)}
\NormalTok{out <-}\StringTok{ }\KeywordTok{square}\NormalTok{(out)}
\NormalTok{out <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(out)}
\NormalTok{out <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(out)}
\NormalTok{out}
\CommentTok{#> [1] 0.274}
\end{Highlighting}
\end{Shaded}

The magrittr package (Bache and Wickham
\protect\hyperlink{ref-magrittr}{2014}) provides a third option: the
binary operator \texttt{\%\textgreater{}\%}, which is called the pipe
and is pronounced as ``and then''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(magrittr)}

\NormalTok{x }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{deviation}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{square}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mean}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{sqrt}\NormalTok{()}
\CommentTok{#> [1] 0.274}
\end{Highlighting}
\end{Shaded}

\texttt{x\ \%\textgreater{}\%\ f()} is equivalent to \texttt{f(x)};
\texttt{x\ \%\textgreater{}\%\ f(y)} is equivalent to \texttt{f(x,\ y)}.
The pipe is related to \textbf{tacit} or \textbf{point-free
programming}\footnote{Point-free programming is related to point-free
  topology. It's just a coincidence that many forms of point-free
  programming use \texttt{.} extensively. Point-free programming is
  sometimes humorously called pointless programming.}. In this style of
programming, you don't explicitly refer to variables. Instead, you focus
on the high-level composition of functions rather than the low-level
flow of data; the focus is on what's being done (the verbs), rather that
on what's being modified (the nouns). This style is common in Haskell
and F\#, the main inspiration for magrittr, and is the default style in
stack based programming languages like Forth and Factor.
\index{point-free programming} \index{tacit programming}

Each of the three options has its own strengths and weaknesses:

\begin{itemize}
\item
  Nesting, \texttt{f(g(x))}, is concise, and well suited for short
  sequences. But longer sequences are hard to read because they are read
  inside out and right to left. As a result, arguments can get spread
  out over long distances creating the
  ``\href{https://en.wikipedia.org/wiki/Dagwood_sandwich}{Dagwood
  sandwich}'' problem.
\item
  Intermediate objects, \texttt{y\ \textless{}-\ f(x);\ g(y)}, requires
  you to name intermediate objects. This is a strength when objects are
  important, but a weakness when values are truly intermediate.
\item
  Piping, \texttt{x\ \%\textgreater{}\%\ f()\ \%\textgreater{}\%\ g()},
  allows you to read code in straightforward left-to-right fashion and
  doesn't require you to name intermediate objects. But you can only use
  it with linear sequences of transformations of a single object. It
  also requires an additional third party package and assumes that the
  reader understands piping.
\end{itemize}

Most code will use a combination of all three styles. Piping is more
common in data analysis code, as much of an analysis consists of a
sequence of transformations of an object (like a data frame or plot). I
tend to use piping infrequently in packages; not because it is a bad
idea, but because it's often a less natural fit.

\hypertarget{lexical-scoping}{%
\section{Lexical scoping}\label{lexical-scoping}}

\index{scoping!lexical|see{lexical scoping}} \index{lexical scoping}

In \protect\hyperlink{names-values}{Names and values}, we discussed
assignment, the act of binding a name to a value. Here we'll discuss
\textbf{scoping}, the act of finding the value associated with a name.

The basic rules of scoping are quite intuitive, and you've probably
already internalised them, even if you never explicitly studied them.
For example, what will the following code return, 10 or 20?\footnote{I'll
  ``hide'' the answers to these challenges in the footnotes. Try solving
  them before looking at the answer; this will help you to better
  remember the correct answer. In this case, \texttt{g01()} will return
  \texttt{20}.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{g01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{20}
\NormalTok{  x}
\NormalTok{\}}

\KeywordTok{g01}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

In this section, you'll learn the formal rules of scoping as well as
some of its more subtle details. A deeper understanding of scoping will
help you to use more advanced functional programming tools, and
eventually, even to write tools that translate R code into other
languages.

R uses \textbf{lexical scoping}\footnote{Functions that automatically
  quote one or more arguments (sometimes called NSE functions) can
  override the default scoping rules to implement other varieties of
  scoping. You'll learn more about that in
  \protect\hyperlink{meta}{metaprogramming}.}: it looks up the values of
names based on how a function is defined, not how it is called.
``Lexical'' here is not the English adjective ``relating to words or a
vocabulary''. It's a technical CS term that tells us that the scoping
rules use a parse-time, rather than a run-time structure.

R's lexical scoping follows four primary rules:

\begin{itemize}
\tightlist
\item
  Name masking
\item
  Functions vs.~variables
\item
  A fresh start
\item
  Dynamic lookup
\end{itemize}

\hypertarget{name-masking}{%
\subsection{Name masking}\label{name-masking}}

The basic principle of lexical scoping is that names defined inside a
function mask names defined outside a function. This is illustrated in
the following example.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{y <-}\StringTok{ }\DecValTok{20}
\NormalTok{g02 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{1}
\NormalTok{  y <-}\StringTok{ }\DecValTok{2}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{g02}\NormalTok{()}
\CommentTok{#> [1] 1 2}
\end{Highlighting}
\end{Shaded}

If a name isn't defined inside a function, R looks one level up.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\NormalTok{g03 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  y <-}\StringTok{ }\DecValTok{1}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{g03}\NormalTok{()}
\CommentTok{#> [1] 2 1}
\end{Highlighting}
\end{Shaded}

The same rules apply if a function is defined inside another function.
First, R looks inside the current function. Then, it looks where that
function was defined (and so on, all the way up to the global
environment). Finally, it looks in other loaded packages.

Run the following code in your head, then confirm the result by running
the code.\footnote{\texttt{g04()} returns \texttt{c(1,\ 2,\ 3)}.}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{g04 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  y <-}\StringTok{ }\DecValTok{2}
\NormalTok{  i <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    z <-}\StringTok{ }\DecValTok{3}
    \KeywordTok{c}\NormalTok{(x, y, z)}
\NormalTok{  \}}
  \KeywordTok{i}\NormalTok{()}
\NormalTok{\}}
\KeywordTok{g04}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The same rules also apply to functions created by other functions, which
I call manufactured functions, and are the topic of Chapter
\ref{function-factories}. Here I'll focus on how they interact with
scoping. The following function, \texttt{g05()}, returns a function.
What do you think this function will return when it's called?\footnote{\texttt{g06()}
  returns \texttt{c(10,\ 2)}. \index{closures!scoping}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{y <-}\StringTok{ }\DecValTok{20}

\NormalTok{g05 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  y <-}\StringTok{ }\DecValTok{2}
  \ControlFlowTok{function}\NormalTok{() \{}
    \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{g06 <-}\StringTok{ }\KeywordTok{g05}\NormalTok{()}
\KeywordTok{g06}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

This seems a little magical: how does R know what the value of
\texttt{y} is after \texttt{g05()} is returned? R knows because
\texttt{g06()} preserves the environment where it was defined and that
environment includes the value of \texttt{y}. You'll learn more about
how environments work in Chapter \ref{environments}.

\hypertarget{functions-vs.variables}{%
\subsection{Functions vs.~variables}\label{functions-vs.variables}}

In R, functions are ordinary objects. This means the scoping rules
described above also apply to functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g07 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{g08 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  g07 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{100}
  \KeywordTok{g07}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{g08}\NormalTok{()}
\CommentTok{#> [1] 110}
\end{Highlighting}
\end{Shaded}

However, when a function and a non-function share the same name (they
must, of course, reside in different environments), applying these rules
gets a little more complicated. When you use a name in a function call,
R ignores non-function objects when looking for that value. For example,
in the code below, \texttt{g09} takes on two different values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g09 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{100}
\NormalTok{g10 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  g09 <-}\StringTok{ }\DecValTok{10}
  \KeywordTok{g09}\NormalTok{(g09)}
\NormalTok{\}}
\KeywordTok{g10}\NormalTok{()}
\CommentTok{#> [1] 110}
\end{Highlighting}
\end{Shaded}

Note that for the record, using the same name for two different things
makes for confusing code, and is something best avoided!

\hypertarget{fresh-start}{%
\subsection{A fresh start}\label{fresh-start}}

What happens to values between invocations of a function? Consider the
example below. What will happen the first time you run this function?
What will happen the second time?\footnote{\texttt{g11()} returns
  \texttt{1} every time it's called.} (If you haven't seen
\texttt{exists()} before, it returns \texttt{TRUE} if there's a variable
with that name and returns \texttt{FALSE} if not.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g11 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{exists}\NormalTok{(}\StringTok{"a"}\NormalTok{)) \{}
\NormalTok{    a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    a <-}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
\NormalTok{  a}
\NormalTok{\}}

\KeywordTok{g11}\NormalTok{()}
\KeywordTok{g11}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

You might be surprised that \texttt{g11()} always returns the same
value. This happens because every time a function is called a new
environment is created to host its execution. This means that a function
has no way to tell what happened the last time it was run; each
invocation is completely independent. (We'll see some ways to get around
this in Section \ref{stateful-funs})

\hypertarget{dynamic-lookup}{%
\subsection{Dynamic lookup}\label{dynamic-lookup}}

Lexical scoping determines where, but not when to look for values. R
looks for values when the function is run, not when the function is
created. Together, these two properties tell us that the output of a
function can differ depending on the objects outside the function's
environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g12 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{x <-}\StringTok{ }\DecValTok{15}
\KeywordTok{g12}\NormalTok{()}
\CommentTok{#> [1] 16}

\NormalTok{x <-}\StringTok{ }\DecValTok{20}
\KeywordTok{g12}\NormalTok{()}
\CommentTok{#> [1] 21}
\end{Highlighting}
\end{Shaded}

This behaviour can be quite annoying. If you make a spelling mistake in
your code, you won't get an error message when you create the function.
And depending on the variables defined in the global environment, you
might not even get an error message when you run the function.

\indexc{findGlobals()}

To detect this problem, use \texttt{codetools::findGlobals()}. This
function lists all the external dependencies (unbound symbols) within a
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{codetools}\OperatorTok{::}\KeywordTok{findGlobals}\NormalTok{(g12)}
\CommentTok{#> [1] "+" "x"}
\end{Highlighting}
\end{Shaded}

To solve this problem, you can manually change the function's
environment to the \texttt{emptyenv()}, an environment which contains
nothing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{environment}\NormalTok{(g12) <-}\StringTok{ }\KeywordTok{emptyenv}\NormalTok{()}
\KeywordTok{g12}\NormalTok{()}
\CommentTok{#> Error in x + 1:}
\CommentTok{#>   could not find function "+"}
\end{Highlighting}
\end{Shaded}

The problem and its solution reveal why this seemingly undesirable
behaviour exists: R relies on lexical scoping to find \emph{everything},
from the obvious, like \texttt{mean()}, to the less obvious, like
\texttt{+} or even \texttt{\{}. This gives R's scoping rules a rather
beautiful simplicity.

\hypertarget{exercises-13}{%
\subsection{Exercises}\label{exercises-13}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What does the following code return? Why? Describe how each of the
  three \texttt{c}'s is interpreted.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\DecValTok{10}
\KeywordTok{c}\NormalTok{(}\DataTypeTok{c =}\NormalTok{ c)}
\end{Highlighting}
\end{Shaded}
\item
  What are the four principles that govern how R looks for values?
\item
  What does the following function return? Make a prediction before
  running the code yourself.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{      x }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{    \}}
    \KeywordTok{f}\NormalTok{() }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
  \KeywordTok{f}\NormalTok{(x) }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{lazy-evaluation}{%
\section{Lazy evaluation}\label{lazy-evaluation}}

\index{lazy evaluation} \index{functions!lazy evaluation}

In R, function arguments are \textbf{lazily evaluated}: they're only
evaluated if accessed. For example, this code doesn't generate an error
because \texttt{x} is never used:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \DecValTok{10}
\NormalTok{\}}
\KeywordTok{h01}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{))}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

This is an important feature because it allows you to do things like
include potentially expensive computations in function arguments that
will only be evaluated if needed.

\hypertarget{forcing-evaluation}{%
\subsection{Forcing evaluation}\label{forcing-evaluation}}

\indexc{force()}

To \textbf{compel} the evaluation of an argument, use \texttt{force()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h02 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{force}\NormalTok{(x)}
  \DecValTok{10}
\NormalTok{\}}
\KeywordTok{h02}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{))}
\CommentTok{#> Error in force(x):}
\CommentTok{#>   This is an error!}
\end{Highlighting}
\end{Shaded}

It's usually not necessary to force evaluation. However, it is important
for certain functional programming techniques, like the one we'll cover
in detail in \protect\hyperlink{function-operators}{function operators}.
Here, I'm just going to show you what the basic issue is.

Consider this small but surprisingly tricky function. It takes a single
argument \texttt{x}, and returns a function that returns \texttt{x} when
called.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    x}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The subtlety here is that the value of \texttt{x} will be captured not
when you call \texttt{capture1()}, but when you call the function that
\texttt{capture1()} returns:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{h03 <-}\StringTok{ }\KeywordTok{capture1}\NormalTok{(x)}
\NormalTok{h04 <-}\StringTok{ }\KeywordTok{capture1}\NormalTok{(x)}

\KeywordTok{h03}\NormalTok{()}
\CommentTok{#> [1] 10}

\NormalTok{x <-}\StringTok{ }\DecValTok{20}
\KeywordTok{h04}\NormalTok{()}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

Even more confusingly this only happens once: the value is locked in
after you have called \texttt{h03()}/\texttt{h04()} for the first time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{30}
\KeywordTok{h03}\NormalTok{()}
\CommentTok{#> [1] 10}
\KeywordTok{h04}\NormalTok{()}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

This behaviour is a consequence of lazy evaluation. The \texttt{x}
argument is evaluated once \texttt{h03()}/\texttt{h04()} is called, and
then its value is cached. We can avoid the confusion by forcing
\texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{force}\NormalTok{(x)}
  
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    x}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{h05 <-}\StringTok{ }\KeywordTok{capture2}\NormalTok{(x)}

\NormalTok{x <-}\StringTok{ }\DecValTok{20}
\KeywordTok{h05}\NormalTok{()}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

\hypertarget{promises}{%
\subsection{Promises}\label{promises}}

\index{promises} \index{thunks|see{promises}}

Lazy evaluation is powered by a data structure called a
\textbf{promise}, or (less commonly) a thunk. It's one of the features
that makes R such an interesting programming language (we'll return to
promises again in \protect\hyperlink{meta}{metaprogramming}).

A promise has three components:

\begin{itemize}
\item
  The expression, like \texttt{x\ +\ y} which gives rise to the delayed
  computation.
\item
  The environment where the expression should be evaluated.
\item
  The value, which is computed and cached the first time a promise is
  accessed when the expression is evaluated in the specified
  environment.
\end{itemize}

The value cache ensures that the promise always returns the same value,
even when it's accessed multiple times. For example, you can see in the
following code that \texttt{runif(1)} is only evaluated once:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h06 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{ }
  \KeywordTok{c}\NormalTok{(x, x, x)  }
\NormalTok{\}}

\KeywordTok{h06}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] 0.806 0.806 0.806}
\end{Highlighting}
\end{Shaded}

You can also create promises ``by hand'' using \texttt{delayedAssign()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{delayedAssign}\NormalTok{(}\StringTok{"x"}\NormalTok{, \{}\KeywordTok{print}\NormalTok{(}\StringTok{"Executing code"}\NormalTok{); }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)\})}
\NormalTok{x}
\CommentTok{#> [1] "Executing code"}
\CommentTok{#> [1] 0.814}
\NormalTok{x}
\CommentTok{#> [1] 0.814}
\end{Highlighting}
\end{Shaded}

You'll see this idea again in
\protect\hyperlink{advanced-bindings}{advanced bindings}.

You cannot manipulate promises with R code. Promises are like a quantum
state: any attempt to inspect them with R code will force an immediate
evaluation, making the promise disappear. Later, in Section
\ref{quosures}, you'll learn about quosures, which reify promises into
an R object where you can easily inspect the expression and the
environment.

\hypertarget{default-arguments}{%
\subsection{Default arguments}\label{default-arguments}}

\index{functions!default values}

Thanks to lazy evaluation, default values can be defined in terms of
other arguments, or even in terms of variables defined later in the
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h07 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ a }\OperatorTok{+}\StringTok{ }\NormalTok{b) \{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{10}
\NormalTok{  b <-}\StringTok{ }\DecValTok{100}
  
  \KeywordTok{c}\NormalTok{(x, y, z)}
\NormalTok{\}}

\KeywordTok{h07}\NormalTok{()}
\CommentTok{#> [1]   1   2 110}
\end{Highlighting}
\end{Shaded}

Many base R functions use this technique, but I don't recommend it. It
makes the code harder to understand: to predict \emph{what} will be
returned, you need to know the exact order in which default arguments
are evaluated.

The evaluation environment is slightly different for default and user
supplied arguments, as default arguments are evaluated inside the
function. This means that seemingly identical calls can yield different
results. It's easiest to see this with an extreme example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h08 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{ls}\NormalTok{()) \{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  x}
\NormalTok{\}}

\CommentTok{# ls() evaluated inside f:}
\KeywordTok{h08}\NormalTok{()}
\CommentTok{#> [1] "a" "x"}

\CommentTok{# ls() evaluated in global environment:}
\KeywordTok{h08}\NormalTok{(}\KeywordTok{ls}\NormalTok{())}
\CommentTok{#> [1] "f"}
\end{Highlighting}
\end{Shaded}

\hypertarget{missing-arguments}{%
\subsection{Missing arguments}\label{missing-arguments}}

\indexc{missing()}

To determine if an argument's value comes from the user or from a
default, you can use \texttt{missing()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h09 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{) \{}
  \KeywordTok{list}\NormalTok{(}\KeywordTok{missing}\NormalTok{(x), x)}
\NormalTok{\}}
\KeywordTok{str}\NormalTok{(}\KeywordTok{h09}\NormalTok{())}
\CommentTok{#> List of 2}
\CommentTok{#>  $ : logi TRUE}
\CommentTok{#>  $ : num 10}
\KeywordTok{str}\NormalTok{(}\KeywordTok{h09}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ : logi FALSE}
\CommentTok{#>  $ : num 10}
\end{Highlighting}
\end{Shaded}

\texttt{missing()} is best used sparingly, however. Take
\texttt{sample()}, for example. How many arguments are required?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{args}\NormalTok{(sample)}
\CommentTok{#> function (x, size, replace = FALSE, prob = NULL) }
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

It looks like both \texttt{x} and \texttt{size} are required, but in
fact if it's not supplied, \texttt{sample()} uses \texttt{missing()} to
provide a default for \texttt{size}. If I were to rewrite sample, I'd
use an explicit \texttt{NULL} to indicate that \texttt{size} is not
required but can be supplied:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sample <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{size =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{prob =} \OtherTok{NULL}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(size)) \{}
\NormalTok{    size <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{  \}}
  
\NormalTok{  x[}\KeywordTok{sample.int}\NormalTok{(}\KeywordTok{length}\NormalTok{(x), size, }\DataTypeTok{replace =}\NormalTok{ replace, }\DataTypeTok{prob =}\NormalTok{ prob)]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

With the binary pattern created by the \texttt{\%\textbar{}\textbar{}\%}
infix function, which uses the LHS if it's not \texttt{NULL} and the RHS
otherwise, we can further simplify \texttt{sample()}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%||%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lhs, rhs) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(lhs)) \{}
\NormalTok{    lhs}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    rhs}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{sample <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{size =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{prob =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  size <-}\StringTok{ }\NormalTok{size }\OperatorTok{%||%}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{  x[}\KeywordTok{sample.int}\NormalTok{(}\KeywordTok{length}\NormalTok{(x), size, }\DataTypeTok{replace =}\NormalTok{ replace, }\DataTypeTok{prob =}\NormalTok{ prob)]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Because of lazy evaluation, you don't need to worry about unnecessary
computation: the RHS of \texttt{\%\textbar{}\textbar{}\%} will only be
evaluated if the LHS is \texttt{NULL}.

\hypertarget{exercises-14}{%
\subsection{Exercises}\label{exercises-14}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What important property of \texttt{\&\&} makes \texttt{x\_ok()} work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_ok <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \OperatorTok{!}\KeywordTok{is.null}\NormalTok{(x) }\OperatorTok{&&}\StringTok{ }\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{&&}\StringTok{ }\NormalTok{x }\OperatorTok{>}\StringTok{ }\DecValTok{0}
\NormalTok{\}}

\KeywordTok{x_ok}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

  What is different with this code? Why is this behaviour undesirable
  here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_ok <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \OperatorTok{!}\KeywordTok{is.null}\NormalTok{(x) }\OperatorTok{&}\StringTok{ }\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{&}\StringTok{ }\NormalTok{x }\OperatorTok{>}\StringTok{ }\DecValTok{0}
\NormalTok{\}}

\KeywordTok{x_ok}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> logical(0)}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}
\item
  The definition of \texttt{force()} is simple:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{force}
\CommentTok{#> function (x) }
\CommentTok{#> x}
\CommentTok{#> <bytecode: 0x1a65cd8>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

  Why is it better to \texttt{force(x)} instead of just \texttt{x}?
\item
  What does this function return? Why? Which principle does it
  illustrate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ z) \{}
\NormalTok{  z <-}\StringTok{ }\DecValTok{100}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{f2}\NormalTok{()}
\end{Highlighting}
\end{Shaded}
\item
  What does this function return? Why? Which principle does it
  illustrate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{10}
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{()}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}
\item
  In \texttt{hist()}, the default value of \texttt{xlim} is
  \texttt{range(breaks)}, the default value for \texttt{breaks} is
  \texttt{"Sturges"}, and

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{range}\NormalTok{(}\StringTok{"Sturges"}\NormalTok{)}
\CommentTok{#> [1] "Sturges" "Sturges"}
\end{Highlighting}
\end{Shaded}

  Explain how \texttt{hist()} works to get a correct \texttt{xlim}
  value.
\item
  Explain why this function works. Why is it confusing?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_time <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{stop}\NormalTok{(}\StringTok{"Error!"}\NormalTok{)) \{}
\NormalTok{  stop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{Sys.time}\NormalTok{()}
  \KeywordTok{print}\NormalTok{(x)}
\NormalTok{\}}
\KeywordTok{show_time}\NormalTok{()}
\CommentTok{#> [1] "2018-09-28 10:19:00 UTC"}
\end{Highlighting}
\end{Shaded}
\item
  How many arguments are required when calling \texttt{library()}?
\end{enumerate}

\hypertarget{fun-dot-dot-dot}{%
\section{\texorpdfstring{\texttt{...}
(dot-dot-dot)}{... (dot-dot-dot)}}\label{fun-dot-dot-dot}}

\indexc{...}

\index{varargs} \index{function!variadic} \index{ellipsis}
\index{dot-dot-dot}

Functions can have a special argument \texttt{...} (pronounced
dot-dot-dot). With it, a function can take any number of additional
arguments. In other programming languages, this type of argument is
often called a varargs, and a function that uses it is said to be
variadic.

You can also use \texttt{...} to pass those additional arguments on to
another function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(y, z) \{}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{y =}\NormalTok{ y, }\DataTypeTok{z =}\NormalTok{ z)}
\NormalTok{\}}

\NormalTok{i02 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{i01}\NormalTok{(...)}
\NormalTok{\}}

\KeywordTok{str}\NormalTok{(}\KeywordTok{i02}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{, }\DataTypeTok{z =} \DecValTok{3}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ y: num 2}
\CommentTok{#>  $ z: num 3}
\end{Highlighting}
\end{Shaded}

Using a special syntax, it's possible (but rarely useful) to refer to
elements of \texttt{...} by position:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i03 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{first =}\NormalTok{ ..}\DecValTok{1}\NormalTok{, }\DataTypeTok{third =}\NormalTok{ ..}\DecValTok{3}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{str}\NormalTok{(}\KeywordTok{i03}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ first: num 1}
\CommentTok{#>  $ third: num 3}
\end{Highlighting}
\end{Shaded}

More useful is \texttt{list(...)}, which evaluates the arguments and
stores them in a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i04 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{list}\NormalTok{(...)}
\NormalTok{\}}
\KeywordTok{str}\NormalTok{(}\KeywordTok{i04}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ a: num 1}
\CommentTok{#>  $ b: num 2}
\end{Highlighting}
\end{Shaded}

(See also \texttt{rlang::list2()} to support splicing and to silently
ignore trailing commas, and \texttt{rlang::enquos()} to capture
unevaluated arguments, the topic of
\protect\hyperlink{quasiquotation}{quasiquotation}.)

There are two primary uses of \texttt{...}, both of which we'll come
back to later in the book:

\begin{itemize}
\item
  If your function takes a function as an argument, you want some way to
  pass additional arguments to that function. In this example,
  \texttt{lapply()} uses \texttt{...} to pass \texttt{na.rm} on to
  \texttt{mean()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\KeywordTok{str}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ : num 2}
\CommentTok{#>  $ : num 5}
\end{Highlighting}
\end{Shaded}

  We'll come back to this technique in Section \ref{passing-arguments}.
\item
  If your function is an S3 generic, you need some way to allow methods
  to take arbitrary extra arguments. For example, take the
  \texttt{print()} function. Because there are different options for
  printing depending on the type of object, there's no way to
  pre-specify every possible argument. \texttt{...} is what allow
  individual methods to have different arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{print}\NormalTok{(}\KeywordTok{factor}\NormalTok{(letters), }\DataTypeTok{max.levels =} \DecValTok{4}\NormalTok{)}

\KeywordTok{print}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x, }\DataTypeTok{showEnv =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  We'll come back to this use of \texttt{...} in Section
  \ref{s3-arguments}.
\end{itemize}

Using \texttt{...} comes with two downsides:

\begin{itemize}
\item
  When you use it to pass arguments to another function, you have to
  carefully explain to the user where those arguments go. This makes it
  hard to understand what you can do with functions like
  \texttt{lapply()} and \texttt{plot()}.
\item
  A misspelled argument will not raise an error. This makes it easy for
  typos to go unnoticed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DataTypeTok{na_rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\texttt{...} is a powerful tool, but be aware of the downsides.

\hypertarget{exercises-15}{%
\subsection{Exercises}\label{exercises-15}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Explain the following results:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 6}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 1}

\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{na.omit =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 7}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{na.omit =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}
\item
  In the following call, explain how to find the documentation for the
  named arguments in the following function call:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{20}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"x"}\NormalTok{, }\DataTypeTok{col.lab =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{center}\includegraphics[width=0.7\linewidth]{Functions_files/figure-latex/unnamed-chunk-63-1} \end{center}
\item
  Why does \texttt{plot(1:10,\ col\ =\ "red")} only colour the points,
  not the axes or labels? Read the source code of
  \texttt{plot.default()} to find out.
\end{enumerate}

\hypertarget{exiting-a-function}{%
\section{Exiting a function}\label{exiting-a-function}}

Most functions exit in one of two ways\footnote{Functions can exit in
  other more esoteric ways like signalling a condition that is caught by
  an exit handler, invoking a restart, or pressing ``Q'' in an
  interactive browser.}: they either return a value, indicating success,
or they throw an error, indicating failure. This section describes
return values (implicit vs.~explicit; visible vs.~invisible), briefly
discusses errors, and introduces exit handlers, which allow you to run
code when a function exits.

\hypertarget{implicit-vs.explicit-returns}{%
\subsection{Implicit vs.~explicit
returns}\label{implicit-vs.explicit-returns}}

\index{functions!return value} \indexc{return()}

There are two ways that a function can return a value:

\begin{itemize}
\item
  Implicitly, where the last evaluated expression is the return value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{<}\StringTok{ }\DecValTok{10}\NormalTok{) \{}
    \DecValTok{0}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \DecValTok{10}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{j01}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{#> [1] 0}
\KeywordTok{j01}\NormalTok{(}\DecValTok{15}\NormalTok{)}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}
\item
  Explicitly, by calling \texttt{return()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j02 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{<}\StringTok{ }\DecValTok{10}\NormalTok{) \{}
    \KeywordTok{return}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{return}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{invisible}{%
\subsection{Invisible values}\label{invisible}}

\indexc{invisible()}

\index{functions!invisible results}

Most functions return visibly: calling the function in an interactive
context prints the result.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j03 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\DecValTok{1}
\KeywordTok{j03}\NormalTok{()}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

However, you can prevent automatic printing by applying
\texttt{invisible()} to the last value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j04 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{invisible}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\KeywordTok{j04}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

To verify that this value does indeed exist, you can explicitly print it
or wrap it in parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{print}\NormalTok{(}\KeywordTok{j04}\NormalTok{())}
\CommentTok{#> [1] 1}

\NormalTok{(}\KeywordTok{j04}\NormalTok{())}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

Alternatively, you can use \texttt{withVisible()} to return the value
and a visibility flag:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{withVisible}\NormalTok{(}\KeywordTok{j04}\NormalTok{()))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ value  : num 1}
\CommentTok{#>  $ visible: logi FALSE}
\end{Highlighting}
\end{Shaded}

\index{assignment} The most common function that returns invisibly is
\texttt{\textless{}-}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{(a <-}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

This is what makes it possible to chain assignments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\NormalTok{b <-}\StringTok{ }\NormalTok{c <-}\StringTok{ }\NormalTok{d <-}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

In general, any function called primarily for a side effect (like
\texttt{\textless{}-}, \texttt{print()}, or \texttt{plot()}) should
return an invisible value (typically the value of the first argument).

\hypertarget{errors}{%
\subsection{Errors}\label{errors}}

If a function cannot complete its assigned task, it should throw an
error with \texttt{stop()}, which immediately terminates the execution
of the function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j05 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{stop}\NormalTok{(}\StringTok{"I'm an error"}\NormalTok{)}
  \KeywordTok{return}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{j05}\NormalTok{()}
\CommentTok{#> Error in j05():}
\CommentTok{#>   I'm an error}
\end{Highlighting}
\end{Shaded}

An error indicates that something has gone wrong, and forces the user to
deal with the problem. Some languages (like C, Go, and Rust) rely on
special return values to indicate problems, but in R you should always
throw an error. You'll learn more about errors, and how to handle them,
in \protect\hyperlink{conditions}{Conditions}.

\hypertarget{on-exit}{%
\subsection{Exit handlers}\label{on-exit}}

\indexc{on.exit()}

\index{handler!exit}

Sometimes a function needs to make temporary changes to the global
state. But having to cleanup those changes can be painful (what happens
if there's an error?). To ensure that your changes are undone and that
the global state is restored when the function completes, set up an
\textbf{exit handler} . You do so by calling \texttt{on.exit()} with the
code to be run. When the function exits, this code executes regardless
of whether the function returns a value or throws an error.

To setup an exit handler:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j06 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"Hello}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{cat}\NormalTok{(}\StringTok{"Goodbye!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
  
  \ControlFlowTok{if}\NormalTok{ (x) \{}
    \KeywordTok{return}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Error"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{j06}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> Hello}
\CommentTok{#> Goodbye!}
\CommentTok{#> [1] 10}

\KeywordTok{j06}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\CommentTok{#> Hello}
\CommentTok{#> Error in j06(FALSE):}
\CommentTok{#>   Error}
\CommentTok{#> Goodbye!}
\end{Highlighting}
\end{Shaded}

Always set \texttt{add\ =\ TRUE} when using \texttt{on.exit()}. If you
don't, each call to \texttt{on.exit()} will overwrite the previous exit
handler. Even when only registering a single handler, it's good practice
to set \texttt{add\ =\ TRUE} so that you won't get any unpleasant
surprises if you later add more exit handlers

\texttt{on.exit()} is important because it allows you to place clean-up
actions next to other actions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cleanup <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(dir, code) \{}
\NormalTok{  old_dir <-}\StringTok{ }\KeywordTok{setwd}\NormalTok{(dir)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{setwd}\NormalTok{(old_dir), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
  
\NormalTok{  old_opt <-}\StringTok{ }\KeywordTok{options}\NormalTok{(}\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{options}\NormalTok{(old_opt), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Coupled with lazy evaluation, this creates a very useful pattern for
running a block of code in an altered environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with_dir <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(dir, code) \{}
\NormalTok{  old <-}\StringTok{ }\KeywordTok{setwd}\NormalTok{(dir)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{setwd}\NormalTok{(old), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{force}\NormalTok{(code)}
\NormalTok{\}}

\KeywordTok{getwd}\NormalTok{()}
\CommentTok{#> [1] "/home/travis/build/liao961120/adv-r"}
\KeywordTok{with_dir}\NormalTok{(}\StringTok{"~"}\NormalTok{, }\KeywordTok{getwd}\NormalTok{())}
\CommentTok{#> [1] "/home/travis"}
\end{Highlighting}
\end{Shaded}

See the \href{http://withr.r-lib.org}{withr package} for a collection of
functions of this nature.

In R 3.4 and earlier, \texttt{on.exit()} expressions are always run in
order of creation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"a"}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"b"}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> a}
\CommentTok{#> b}
\end{Highlighting}
\end{Shaded}

This can make cleanup a little tricky if some actions need to happen in
a specific order; typically you want the most recent added expression to
be run first. In R 3.5 and later, you can control this by setting
\texttt{after\ =\ FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"a"}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{after =} \OtherTok{FALSE}\NormalTok{)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{message}\NormalTok{(}\StringTok{"b"}\NormalTok{), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{after =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> b}
\CommentTok{#> a}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-16}{%
\subsection{Exercises}\label{exercises-16}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What does \texttt{load()} return? Why don't you normally see these
  values?
\item
  What does \texttt{write.table()} return? What would be more useful?
\item
  How does the \texttt{chdir} parameter of \texttt{source()} compare to
  \texttt{in\_dir()}? Why might you prefer one to the other?
\item
  Write a function that opens a graphics device, runs the supplied code,
  and closes the graphics device (always, regardless of whether or not
  the plotting code works).
\item
  We can use \texttt{on.exit()} to implement a simple version of
  \texttt{capture.output()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture.output2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  temp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{file.remove}\NormalTok{(temp), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{after =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{sink}\NormalTok{(temp)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{sink}\NormalTok{(), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{after =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{force}\NormalTok{(code)}
  \KeywordTok{readLines}\NormalTok{(temp)}
\NormalTok{\}}
\KeywordTok{capture.output2}\NormalTok{(}\KeywordTok{cat}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

  Compare \texttt{capture.output()} to \texttt{capture.output2()}. How
  do the functions differ? What features have I removed to make the key
  ideas easier to see? How have I rewritten the key ideas so they're
  easier to understand?
\end{enumerate}

\hypertarget{function-forms}{%
\section{Function forms}\label{function-forms}}

\begin{quote}
``To understand computations in R, two slogans are helpful:

\begin{itemize}
\tightlist
\item
  Everything that exists is an object.
\item
  Everything that happens is a function call."
\end{itemize}

\hspace*{\fill} --- John Chambers
\end{quote}

While everything that happens in R is a result of a function call, not
all calls look the same. Function calls come in four varieties:

\begin{itemize}
\item
  \textbf{prefix}: the function name comes before its arguments, like
  \texttt{foofy(a,\ b,\ c)}. These constitute of the majority of
  function calls in R.
\item
  \textbf{infix}: the function name comes in between its arguments, like
  \texttt{x\ +\ y}. Infix forms are used for many mathematical
  operators, and for user-defined functions that begin and end with
  \texttt{\%}.
\item
  \textbf{replacement}: functions that replace values by assignment,
  like \texttt{names(df)\ \textless{}-\ c("a",\ "b",\ "c")}. They
  actually look like prefix functions.
\item
  \textbf{special}: functions like \texttt{{[}{[}}, \texttt{if}, and
  \texttt{for}. While they don't have a consistent structure, they play
  important roles in R's syntax.
\end{itemize}

While there are four forms, you actually only need one because any call
can be written in prefix form. I'll demonstrate this property, and then
you'll learn about each of the forms in turn.

\hypertarget{prefix-transform}{%
\subsection{Rewriting to prefix form}\label{prefix-transform}}

\indexc{`}

\index{backticks|see{\texttt{`}}}

An interesting property of R is that every infix, replacement, or
special form can be rewritten in prefix form. Doing so is useful because
it helps you better understand the structure of the language, it gives
you the real name of every function, and it allows you to modify those
functions for fun and profit.

The following example shows three pairs of equivalent calls, rewriting
an infix form, replacement form, and a special form into prefix form.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(x, y)}

\KeywordTok{names}\NormalTok{(df) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{)}
\StringTok{`}\DataTypeTok{names<-}\StringTok{`}\NormalTok{(df, }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{))}

\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) }\KeywordTok{print}\NormalTok{(i)}
\StringTok{`}\DataTypeTok{for}\StringTok{`}\NormalTok{(i, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\KeywordTok{print}\NormalTok{(i))}
\end{Highlighting}
\end{Shaded}

Knowing the function name of a non-prefix function allows you to
override its behaviour. For example, if you're ever feeling particularly
evil, run the following code while a friend is away from their computer.
It will introduce a fun bug: 10\% of the time, it will add 1 to any
numeric calculation inside the parentheses.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(e1) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.numeric}\NormalTok{(e1) }\OperatorTok{&&}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) }\OperatorTok{<}\StringTok{ }\FloatTok{0.1}\NormalTok{) \{}
\NormalTok{    e1 }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    e1}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{replicate}\NormalTok{(}\DecValTok{50}\NormalTok{, (}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{))}
\CommentTok{#>  [1] 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3}
\CommentTok{#> [33] 3 3 3 3 4 3 4 3 3 3 3 4 3 3 3 3 3 3}
\KeywordTok{rm}\NormalTok{(}\StringTok{"("}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Of course, overriding built-in functions like this is a bad idea, but,
as you'll learn in \protect\hyperlink{meta}{metaprogramming}, it's
possible to apply it only to selected code blocks. This provides a clean
and elegant approach to writing domain specific languages and
translators to other languages.

A more useful application comes up when using functional programming
tools. For example, you could use \texttt{sapply()} to add 3 to every
element of a list by first defining a function \texttt{add()}:
\indexc{sapply()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\KeywordTok{sapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, add, }\DecValTok{3}\NormalTok{)}
\CommentTok{#>  [1]  4  5  6  7  8  9 10 11 12 13}
\end{Highlighting}
\end{Shaded}

But we can also get the same result simply by relying on the existing
\texttt{+} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 4 5 6 7 8}
\end{Highlighting}
\end{Shaded}

We'll explore this idea in detail in
\protect\hyperlink{functionals}{functionals}.

\hypertarget{prefix-form}{%
\subsection{Prefix form}\label{prefix-form}}

\index{functions!arguments}

The prefix form is the most common form in R code, and indeed in the
majority of programming languages. Prefix calls in R are a little
special because you can specify arguments in three ways:

\begin{itemize}
\tightlist
\item
  By position, like \texttt{help(mean)}.
\item
  Using partial matching, like \texttt{help(to\ =\ mean)}. 
\item
  By name, like \texttt{help(topic\ =\ mean)}.
\end{itemize}

As illustrated by the following chunk, arguments are matched by exact
name, then with unique prefixes, and finally by position.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{k01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(abcdef, bcde1, bcde2) \{}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{a =}\NormalTok{ abcdef, }\DataTypeTok{b1 =}\NormalTok{ bcde1, }\DataTypeTok{b2 =}\NormalTok{ bcde2)}
\NormalTok{\}}
\KeywordTok{str}\NormalTok{(}\KeywordTok{k01}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ a : num 1}
\CommentTok{#>  $ b1: num 2}
\CommentTok{#>  $ b2: num 3}
\KeywordTok{str}\NormalTok{(}\KeywordTok{k01}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{abcdef =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ a : num 1}
\CommentTok{#>  $ b1: num 2}
\CommentTok{#>  $ b2: num 3}

\CommentTok{# Can abbreviate long argument names:}
\KeywordTok{str}\NormalTok{(}\KeywordTok{k01}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{a =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ a : num 1}
\CommentTok{#>  $ b1: num 2}
\CommentTok{#>  $ b2: num 3}

\CommentTok{# But this doesn't work because abbreviation is ambiguous}
\KeywordTok{str}\NormalTok{(}\KeywordTok{k01}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> Error in k01(1, 3, b = 1):}
\CommentTok{#>   argument 3 matches multiple formal arguments}
\end{Highlighting}
\end{Shaded}

Generally, only use positional matching for the first one or two
arguments; they will be the most commonly used, and most readers will
know what they are. Avoid using positional matching for less commonly
used arguments, and never use partial matching. See the tidyverse style
guide, \url{http://style.tidyverse.org/syntax.html\#argument-names}, for
more advice.

\hypertarget{infix-functions}{%
\subsection{Infix functions}\label{infix-functions}}

\index{functions!infix} \index{infix functions} \indexc{\%\%}

Infix functions are so called because the function name comes
\textbf{in}between its arguments, and hence infix functions have two
arguments. R comes with a number of built-in infix operators:
\texttt{:}, \texttt{::}, \texttt{:::}, \texttt{\$}, \texttt{@},
\texttt{\^{}}, \texttt{*}, \texttt{/}, \texttt{+}, \texttt{-},
\texttt{\textgreater{}}, \texttt{\textgreater{}=}, \texttt{\textless{}},
\texttt{\textless{}=}, \texttt{==}, \texttt{!=}, \texttt{!},
\texttt{\&}, \texttt{\&\&}, \texttt{\textbar{}},
\texttt{\textbar{}\textbar{}}, \texttt{\textasciitilde{}},
\texttt{\textless{}-}, and \texttt{\textless{}\textless{}-}. You can
also create your own infix functions that start and end with
\texttt{\%}, and base R uses this to additionally define \texttt{\%\%},
\texttt{\%*\%}, \texttt{\%/\%}, \texttt{\%in\%}, \texttt{\%o\%}, and
\texttt{\%x\%}.

Defining your own infix function is simple. You create a two argument
function and bind it to a name that starts and ends with \texttt{\%}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%+%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\KeywordTok{paste0}\NormalTok{(a, b)}
\StringTok{"new "} \OperatorTok{%+%}\StringTok{ "string"}
\CommentTok{#> [1] "new string"}
\end{Highlighting}
\end{Shaded}

The names of infix functions are more flexible than regular R functions:
they can contain any sequence of characters except ``\%''. You will need
to escape any special characters in the string used to define the
function, but not when you call it:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{% %}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\KeywordTok{paste}\NormalTok{(a, b)}
\StringTok{`}\DataTypeTok{%/}\CharTok{\textbackslash{}\textbackslash{}}\DataTypeTok{%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\KeywordTok{paste}\NormalTok{(a, b)}

\StringTok{"a"} \OperatorTok{% %}\StringTok{ "b"}
\CommentTok{#> [1] "a b"}
\StringTok{"a"} \OperatorTok{%/\textbackslash{}%}\StringTok{ "b"}
\CommentTok{#> [1] "a b"}
\end{Highlighting}
\end{Shaded}

R's default precedence rules mean that infix operators are composed from
left to right:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%-%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"("}\NormalTok{, a, }\StringTok{" %-% "}\NormalTok{, b, }\StringTok{")"}\NormalTok{)}
\StringTok{"a"} \OperatorTok{%-%}\StringTok{ "b"} \OperatorTok{%-%}\StringTok{ "c"}
\CommentTok{#> [1] "((a %-% b) %-% c)"}
\end{Highlighting}
\end{Shaded}

There are two special infix functions that can be called with a single
argument: \texttt{+} and \texttt{-}.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{-1}
\CommentTok{#> [1] -1}
\OperatorTok{+}\DecValTok{10}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

\hypertarget{replacement-functions}{%
\subsection{Replacement functions}\label{replacement-functions}}

\index{replacement functions} \index{functions!replacement}
\index{assignment!replacement functions}

Replacement functions act like they modify their arguments in place, and
have the special name \texttt{xxx\textless{}-}. They must have arguments
named \texttt{x} and \texttt{value}, and must return the modified
object. For example, the following function allows you to modify the
second element of a vector:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{second<-}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, value) \{}
\NormalTok{  x[}\DecValTok{2}\NormalTok{] <-}\StringTok{ }\NormalTok{value}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Replacement functions are used by placing the function call on the LHS
of \texttt{\textless{}-}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\KeywordTok{second}\NormalTok{(x) <-}\StringTok{ }\NormalTok{5L}
\NormalTok{x}
\CommentTok{#>  [1]  1  5  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

I say they ``act'' like they modify their arguments in place, because,
as discussed in \protect\hyperlink{modify-in-place}{Modify-in-place},
they actually create a modified copy. We can see that by using
\texttt{tracemem()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\KeywordTok{tracemem}\NormalTok{(x)}
\CommentTok{#> <0x7ffae71bd880>}

\KeywordTok{second}\NormalTok{(x) <-}\StringTok{ }\NormalTok{6L}
\CommentTok{#> tracemem[0x7ffae71bd880 -> 0x7ffae61b5480]: }
\CommentTok{#> tracemem[0x7ffae61b5480 -> 0x7ffae73f0408]: second<- }
\end{Highlighting}
\end{Shaded}

If you want to supply additional arguments, they go in between
\texttt{x} and \texttt{value}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, position, value) \{}
\NormalTok{  x[position] <-}\StringTok{ }\NormalTok{value}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{modify}\NormalTok{(x, }\DecValTok{1}\NormalTok{) <-}\StringTok{ }\DecValTok{10}
\NormalTok{x}
\CommentTok{#>  [1] 10  5  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

When you write \texttt{modify(x,\ 1)\ \textless{}-\ 10}, behind the
scenes R turns it into:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ `}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Combining replacement with other functions requires more complex
translation. For example, this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}
\KeywordTok{names}\NormalTok{(x)}
\CommentTok{#> [1] "a" "b" "c"}

\KeywordTok{names}\NormalTok{(x)[}\DecValTok{2}\NormalTok{] <-}\StringTok{ "two"}
\KeywordTok{names}\NormalTok{(x)}
\CommentTok{#> [1] "a"   "two" "c"}
\end{Highlighting}
\end{Shaded}

Is translated into:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{ <-}\StringTok{ }\NormalTok{x}
\NormalTok{x <-}\StringTok{ `}\DataTypeTok{names<-}\StringTok{`}\NormalTok{(}\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{, }\StringTok{`}\DataTypeTok{[<-}\StringTok{`}\NormalTok{(}\KeywordTok{names}\NormalTok{(}\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{), }\DecValTok{2}\NormalTok{, }\StringTok{"two"}\NormalTok{))}
\KeywordTok{rm}\NormalTok{(}\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

(Yes, it really does create a local variable named \emph{tmp}, which is
removed afterwards.)

\hypertarget{special-forms}{%
\subsection{Special forms}\label{special-forms}}

Finally, there are a bunch of language features that are usually written
in special ways, but also have prefix forms. These include parentheses:

\begin{itemize}
\tightlist
\item
  \texttt{(x)} (\texttt{\textasciigrave{}(\textasciigrave{}(x)})
\item
  \texttt{\{x\}} (\texttt{\textasciigrave{}\{\textasciigrave{}(x)}).
\end{itemize}

The subsetting operators:

\begin{itemize}
\tightlist
\item
  \texttt{x{[}i{]}}
  (\texttt{\textasciigrave{}{[}\textasciigrave{}(x,\ i)})
\item
  \texttt{x{[}{[}i{]}{]}}
  (\texttt{\textasciigrave{}{[}{[}\textasciigrave{}(x,\ i)})
\end{itemize}

And the tools of control flow:

\begin{itemize}
\tightlist
\item
  \texttt{if\ (cond)\ true}
  (\texttt{\textasciigrave{}if\textasciigrave{}(cond,\ true)})
\item
  \texttt{if\ (cond)\ true\ else\ false}
  (\texttt{\textasciigrave{}if\textasciigrave{}(cond,\ true,\ false)})
\item
  \texttt{for(var\ in\ seq)\ action}
  (\texttt{\textasciigrave{}for\textasciigrave{}(var,\ seq,\ action)})
\item
  \texttt{while(cond)\ action}
  (\texttt{\textasciigrave{}while\textasciigrave{}(cond,\ action)})
\item
  \texttt{repeat\ expr}
  (\texttt{\textasciigrave{}repeat\textasciigrave{}(expr)})
\item
  \texttt{next} (\texttt{\textasciigrave{}next\textasciigrave{}()})
\item
  \texttt{break} (\texttt{\textasciigrave{}break\textasciigrave{}()})
\end{itemize}

Finally, the most complex is the ``function'' function:

\begin{itemize}
\tightlist
\item
  \texttt{function(arg1,\ arg2)\ \{body\}}
  (\texttt{\textasciigrave{}function\textasciigrave{}(alist(arg1,\ arg2),\ body,\ env)})
\end{itemize}

Knowing the name of the function that underlies the special form is
useful for getting documentation. \texttt{?(} is a syntax error;
\texttt{?\textasciigrave{}(\textasciigrave{}} will give you the
documentation for parentheses.

Note that all special forms are implemented as primitive functions
(i.e.~in C); that means printing these functions is not informative:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{for}\StringTok{`}
\CommentTok{#> .Primitive("for")}
\end{Highlighting}
\end{Shaded}

\hypertarget{invoking-a-function}{%
\section{Invoking a function}\label{invoking-a-function}}

\indexc{do.call()}

Suppose you had a list of function arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

How could you then send that list to \texttt{mean()}? In base R, you
need \texttt{do.call()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{do.call}\NormalTok{(mean, args)}
\CommentTok{#> [1] 5.5}
\CommentTok{# Equivalent to}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 5.5}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-17}{%
\subsection{Exercises}\label{exercises-17}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Rewrite the following code snippets into prefix form:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}

\DecValTok{1} \OperatorTok{+}\StringTok{ }\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{<=}\StringTok{ }\DecValTok{5}\NormalTok{) x[[}\DecValTok{5}\NormalTok{]] }\ControlFlowTok{else}\NormalTok{ x[[n]]}
\end{Highlighting}
\end{Shaded}
\item
  Clarify the following list of odd function calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\NormalTok{y <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\KeywordTok{cor}\NormalTok{(}\DataTypeTok{m =} \StringTok{"k"}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ y, }\DataTypeTok{u =} \StringTok{"p"}\NormalTok{, }\DataTypeTok{x =}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}
\item
  Explain why the following code fails:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{modify}\NormalTok{(}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{) <-}\StringTok{ }\DecValTok{10}
\CommentTok{#> Error: target of assignment expands to non-language object}
\end{Highlighting}
\end{Shaded}
\item
  Create a replacement function that modifies a random location in a
  vector.
\item
  Write your own version of \texttt{+} that will paste its inputs
  together if they are character vectors but behaves as usual otherwise.
  In other words, make this code work:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\CommentTok{#> [1] 3}

\StringTok{"a"} \OperatorTok{+}\StringTok{ "b"}
\CommentTok{#> [1] "ab"}
\end{Highlighting}
\end{Shaded}
\item
  Create a list of all the replacement functions found in the base
  package. Which ones are primitive functions? (Hint: use
  \texttt{apropros()})
\item
  What are valid names for user-created infix functions?
\item
  Create an infix \texttt{xor()} operator.
\item
  Create infix versions of the set functions \texttt{intersect()},
  \texttt{union()}, and \texttt{setdiff()}. You might call them
  \texttt{\%n\%}, \texttt{\%u\%}, and \texttt{\%/\%} to match
  conventions from mathematics.
\end{enumerate}

\hypertarget{function-answers}{%
\section{Quiz answers}\label{function-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The three components of a function are its body, arguments, and
  environment.
\item
  \texttt{f1(1)()} returns 11.
\item
  You'd normally write it in infix style: \texttt{1\ +\ (2\ *\ 3)}.
\item
  Rewriting the call to \texttt{mean(c(1:10,\ NA),\ na.rm\ =\ TRUE)} is
  easier to understand.
\item
  No, it does not throw an error because the second argument is never
  used so it's never evaluated.
\item
  See \protect\hyperlink{infix-functions}{infix} and
  \protect\hyperlink{replacement-functions}{replacement functions}.
\item
  You use \texttt{on.exit()}; see \protect\hyperlink{on-exit}{on exit}
  for details.
\end{enumerate}

\hypertarget{environments}{%
\chapter{Environments}\label{environments}}

\index{environments}

\hypertarget{introduction-5}{%
\section{Introduction}\label{introduction-5}}

The environment is the data structure that powers scoping. This chapter
dives deep into environments, describing their structure in depth, and
using them to improve your understanding of the four scoping rules
described in \protect\hyperlink{lexical-scoping}{lexical scoping}.
Understanding environments is not necessary for day-to-day use of R. But
they are important to understand because they power many important R
features like lexical scoping, namespaces, and R6 classes, and interact
with evaluation to give you powerful tools for making domain specific
languages, like dplyr and ggplot2.

\hypertarget{quiz-4}{%
\subsection*{Quiz}\label{quiz-4}}
\addcontentsline{toc}{subsection}{Quiz}

If you can answer the following questions correctly, you already know
the most important topics in this chapter. You can find the answers at
the end of the chapter in \protect\hyperlink{env-answers}{answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  List at least three ways that an environment is different to a list.
\item
  What is the parent of the global environment? What is the only
  environment that doesn't have a parent?
\item
  What is the enclosing environment of a function? Why is it important?
\item
  How do you determine the environment from which a function was called?
\item
  How are \texttt{\textless{}-} and \texttt{\textless{}\textless{}-}
  different?
\end{enumerate}

\hypertarget{outline-4}{%
\subsection*{Outline}\label{outline-4}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  \protect\hyperlink{env-basics}{Environment basics} introduces you to
  the basic properties of an environment and shows you how to create
  your own.
\item
  \protect\hyperlink{env-recursion}{Recursing over environments}
  provides a function template for computing with environments,
  illustrating the idea with a useful function.
\item
  \protect\hyperlink{explicit-envs}{Explicit environments} briefly
  discusses three places where environments are useful data structures
  for solving other problems.
\end{itemize}

\hypertarget{prerequisites-1}{%
\subsection*{Prerequisites}\label{prerequisites-1}}
\addcontentsline{toc}{subsection}{Prerequisites}

This chapter will use rlang functions for working with environments,
because it allows us to focus on the essence of environments, rather
than the incidental details.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}

\CommentTok{# Some API changes that haven't made it in rlang yet}
\NormalTok{search_envs <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  rlang}\OperatorTok{:::}\KeywordTok{new_environments}\NormalTok{(}\KeywordTok{c}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}\KeywordTok{global_env}\NormalTok{()),}
    \KeywordTok{head}\NormalTok{(}\KeywordTok{env_parents}\NormalTok{(}\KeywordTok{global_env}\NormalTok{()), }\DecValTok{-1}\NormalTok{)}
\NormalTok{  ))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{env\_} functions in rlang are designed to work
with the pipe: all take an environment as the first argument, and many
also return an environment. I won't use the pipe in this chapter in the
interest of keeping the code as simple as possible, but you should
consider it for your own code.

\hypertarget{env-basics}{%
\section{Environment basics}\label{env-basics}}

Generally, an environment is similar to a named list, with four
important exceptions:

\begin{itemize}
\item
  Every name must be unique.
\item
  The names in an environment are not ordered (i.e.~it doesn't make
  sense to ask what the first element of an environment is).
\item
  An environment has a parent.
\item
  Environments are not copied when modified.
\end{itemize}

Let's explore these ideas with code and pictures.

\hypertarget{basics}{%
\subsection{Basics}\label{basics}}

\index{environments!creating}

To create an environment, use \texttt{rlang::env()}. It works like
\texttt{list()}, taking a set of name-value pairs:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1 <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}
  \DataTypeTok{a =} \OtherTok{FALSE}\NormalTok{,}
  \DataTypeTok{b =} \StringTok{"a"}\NormalTok{,}
  \DataTypeTok{c =} \FloatTok{2.3}\NormalTok{,}
  \DataTypeTok{d =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Use \texttt{new.env()} to create a new environment. Ignore the
\texttt{hash} and \texttt{size} parameters; they are not needed. Note
that you cannot simultaneously create and define values; use
\texttt{\$\textless{}-}, as shown below.

The job of an environment is to associate, or \textbf{bind}, a set of
names to a set of values. You can think of an environment as a bag of
names, with no implied order (i.e.~it doesn't make sense to ask which is
the first element in an environment). For that reason, we'll draw the
environment as so:

\begin{center}\includegraphics[width=3.05in]{diagrams/environments/bindings} \end{center}

As discussed in \protect\hyperlink{env-modify}{names and values},
environments have reference semantics: unlike most R objects, when you
modify them, you modify them in place, and don't create a copy. One
important implication is that environments can contain themselves. This
means that environments go one step further in their level of recursion
than lists: an environment can contain any object, including itself!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1}\OperatorTok{$}\NormalTok{d <-}\StringTok{ }\NormalTok{e1}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.05in]{diagrams/environments/loop} \end{center}

Printing an environment just displays its memory address, which is not
terribly useful:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1}
\CommentTok{#> <environment: 0x28a7be8>}
\end{Highlighting}
\end{Shaded}

Instead, we'll use \texttt{env\_print()} which gives us a little more
information:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_print}\NormalTok{(e1)}
\CommentTok{#> <environment: 0x28a7be8>}
\CommentTok{#>   parent: <environment: global>}
\CommentTok{#>   bindings:}
\CommentTok{#>    * a: <lgl>}
\CommentTok{#>    * b: <chr>}
\CommentTok{#>    * c: <dbl>}
\CommentTok{#>    * d: <env>}
\end{Highlighting}
\end{Shaded}

You can use \texttt{env\_names()} to get a character vector giving the
current bindings

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_names}\NormalTok{(e1)}
\CommentTok{#> [1] "a" "b" "c" "d"}
\end{Highlighting}
\end{Shaded}

In R 3.2.0 and greater, use \texttt{names()} to list the bindings in an
environment. If your code needs to work with R 3.1.0 or earlier, use
\texttt{ls()}, but note that the default value of \texttt{all.names} is
\texttt{FALSE} so you don't see any bindings that start with \texttt{.}.

\hypertarget{important-environments}{%
\subsection{Important environments}\label{important-environments}}

We'll talk in detail about special environments in
\protect\hyperlink{function-envs}{Special environments}, but for now we
need to mention two. The current environment, or \texttt{current\_env()}
is the environment in which code is currently executing. When you're
experimenting interactively, that's usually the global environment, or
\texttt{global\_env()}. The global environment is sometimes called your
``workspace'', as it's where all interactive (i.e.~outside of a
function) computation takes place.

Note that to compare environments, you need to use \texttt{identical()}
and not \texttt{==}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}\KeywordTok{global_env}\NormalTok{(), }\KeywordTok{current_env}\NormalTok{())}
\CommentTok{#> [1] TRUE}

\KeywordTok{global_env}\NormalTok{() }\OperatorTok{==}\StringTok{ }\KeywordTok{current_env}\NormalTok{()}
\CommentTok{#> Error in global_env() == current_env():}
\CommentTok{#>   comparison (1) is possible only for atomic and list types}
\end{Highlighting}
\end{Shaded}

Access the global environment with \texttt{globalenv()} and the current
environment with \texttt{environment()}. The global environment is
printed as \texttt{Rf\_GlobalEnv} and \texttt{.GlobalEnv}.

\hypertarget{parents}{%
\subsection{Parents}\label{parents}}

Every environment has a \textbf{parent}, another environment. In
diagrams, the parent is shown as a small pale blue circle and arrow that
points to another environment. The parent is what's used to implement
lexical scoping: if a name is not found in an environment, then R will
look in its parent (and so on). You can set the parent environment by
supplying an unnamed argument to \texttt{env()}. If you don't supply it,
it defaults to the current environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e2a <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\DataTypeTok{d =} \DecValTok{4}\NormalTok{, }\DataTypeTok{e =} \DecValTok{5}\NormalTok{)}
\NormalTok{e2b <-}\StringTok{ }\KeywordTok{env}\NormalTok{(e2a, }\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.74in]{diagrams/environments/parents} \end{center}

We use the metaphor of a family to name environments relative to one
another. The grandparent of an environment is the parent's parent, and
the ancestors include all parent environments up to the empty
environment. To save space, I typically won't draw all the ancestors;
just remember whenever you see a pale blue circle, there's a parent
environment somewhere.

You can find the parent of an environment with \texttt{env\_parent()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_parent}\NormalTok{(e2b)}
\CommentTok{#> <environment: 0x5406938>}
\KeywordTok{env_parent}\NormalTok{(e2a)}
\CommentTok{#> <environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

\index{environments!empty} Only one environment doesn't have a parent:
the \textbf{empty} environment. I draw the empty environment with a
hollow parent environment, and where space allows I'll label it with
\texttt{R\_EmptyEnv}, the name R uses.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e2c <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\KeywordTok{empty_env}\NormalTok{(), }\DataTypeTok{d =} \DecValTok{4}\NormalTok{, }\DataTypeTok{e =} \DecValTok{5}\NormalTok{)}
\NormalTok{e2d <-}\StringTok{ }\KeywordTok{env}\NormalTok{(e2c, }\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.74in]{diagrams/environments/parents-empty} \end{center}

You'll get an error if you try to find the parent of the empty
environment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_parent}\NormalTok{(}\KeywordTok{empty_env}\NormalTok{())}
\CommentTok{#> Error: The empty environment has no parent}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\end{Highlighting}
\end{Shaded}

You can list all ancestors of an environment with
\texttt{env\_parents()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_parents}\NormalTok{(e2b)}
\CommentTok{#> [[1]]   <env: 0x5406938>}
\CommentTok{#> [[2]] $ <env: global>}

\KeywordTok{env_parents}\NormalTok{(e2d)}
\CommentTok{#> [[1]]   <env: 0x5e88690>}
\CommentTok{#> [[2]] $ <env: empty>}
\end{Highlighting}
\end{Shaded}

By default, \texttt{env\_parents()} continues until it hits either the
global environment or the empty environment. You can control this
behaviour with the \texttt{last} environment.

Use \texttt{parent.env()} to find the parent of an environment. No base
function returns all ancestors.

\hypertarget{super-assigment--}{%
\subsection{\texorpdfstring{Super assigment,
\texttt{\textless{}\textless{}-}}{Super assigment, \textless{}\textless{}-}}\label{super-assigment--}}

The ancestors of an environment have an important relationship to
\texttt{\textless{}\textless{}-}. Regular assignment,
\texttt{\textless{}-}, always creates a variable in the current
environment. Super assignment, \texttt{\textless{}\textless{}-}, never
creates a variable in the current environment, but instead modifies an
existing variable found in a parent environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{0}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  x <<-}\StringTok{ }\DecValTok{1}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\NormalTok{x}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

If \texttt{\textless{}\textless{}-} doesn't find an existing variable,
it will create one in the global environment. This is usually
undesirable, because global variables introduce non-obvious dependencies
between functions. \texttt{\textless{}\textless{}-} is most often used
in conjunction with a function factory, as described in Section
\ref{stateful-funs}.

\hypertarget{getting-and-setting-1}{%
\subsection{Getting and setting}\label{getting-and-setting-1}}

You can get and set elements of an environment with \texttt{\$} and
\texttt{{[}{[}} in the same way as a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e3 <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\NormalTok{e3}\OperatorTok{$}\NormalTok{x}
\CommentTok{#> [1] 1}
\NormalTok{e3}\OperatorTok{$}\NormalTok{z <-}\StringTok{ }\DecValTok{3}
\NormalTok{e3[[}\StringTok{"z"}\NormalTok{]]}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

But you can't use \texttt{{[}{[}} with numeric indices, and you can't
use \texttt{{[}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e3[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> Error in e3[[1]]:}
\CommentTok{#>   wrong arguments for subsetting an environment}

\NormalTok{e3[}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{)]}
\CommentTok{#> Error in e3[c("x", "y")]:}
\CommentTok{#>   object of type 'environment' is not subsettable}
\end{Highlighting}
\end{Shaded}

\texttt{\$} and \texttt{{[}{[}} will return \texttt{NULL} if the binding
doesn't exist. Use \texttt{env\_get()} if you want an error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e3}\OperatorTok{$}\NormalTok{xyz}
\CommentTok{#> NULL}

\KeywordTok{env_get}\NormalTok{(e3, }\StringTok{"xyz"}\NormalTok{)}
\CommentTok{#> Error in env_get(e3, "xyz"):}
\CommentTok{#>   object 'xyz' not found}
\end{Highlighting}
\end{Shaded}

If you want to use a default value if the binding doesn't exist, you can
use the \texttt{default} argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_get}\NormalTok{(e3, }\StringTok{"xyz"}\NormalTok{, }\DataTypeTok{default =} \OtherTok{NA}\NormalTok{)}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}

There are two other ways to add bindings to an environment:

\begin{itemize}
\item
  \texttt{env\_poke()}\footnote{You might wonder why rlang has
    \texttt{env\_poke()} instead of \texttt{env\_set()}. This is for
    consistency: \texttt{\_set()} functions return a modified copy;
    \texttt{\_poke()} functions modify in place.} takes a name (as
  string) and a value:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_poke}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{e3}\OperatorTok{$}\NormalTok{a}
\CommentTok{#> [1] 100}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{env\_bind()} allows you to bind multiple values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_bind}\NormalTok{(e3, }\DataTypeTok{a =} \DecValTok{10}\NormalTok{, }\DataTypeTok{b =} \DecValTok{20}\NormalTok{)}
\KeywordTok{env_names}\NormalTok{(e3)}
\CommentTok{#> [1] "x" "y" "z" "a" "b"}
\end{Highlighting}
\end{Shaded}
\end{itemize}

You can determine if an environment has a binding with
\texttt{env\_has()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_has}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{)}
\CommentTok{#>    a }
\CommentTok{#> TRUE}
\end{Highlighting}
\end{Shaded}

Unlike lists, setting an element to \texttt{NULL} does not remove it.
Instead, use \texttt{env\_unbind()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e3}\OperatorTok{$}\NormalTok{a <-}\StringTok{ }\OtherTok{NULL}
\KeywordTok{env_has}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{)}
\CommentTok{#>    a }
\CommentTok{#> TRUE}

\KeywordTok{env_unbind}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{)}
\KeywordTok{env_has}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{)}
\CommentTok{#>     a }
\CommentTok{#> FALSE}
\end{Highlighting}
\end{Shaded}

Unbinding a name doesn't delete the object. That's the job of the
garbage collector, which automatically removes objects with no names
binding to them. This process is described in more detail in
\protect\hyperlink{gc}{GC}.

\indexc{rm()}\indexc{assign()}\indexc{get()}\indexc{exists()}

See \texttt{get()}, \texttt{assign()}, \texttt{exists()}, and
\texttt{rm()}. These are designed interactively for use with the current
environment, so working with other environments is a little clunky. Also
beware the \texttt{inherits} argument: it defaults to \texttt{TRUE}
meaning that the base equivalents will inspect the supplied environment
and all its ancestors.

\hypertarget{finalisers}{%
\subsection{Finalisers}\label{finalisers}}

{Add something once rlang has an API. Also mention in data structures
below}

\hypertarget{advanced-bindings}{%
\subsection{Advanced bindings}\label{advanced-bindings}}

\index{bindings!delayed} \index{bindings!active}

There are two more exotic variants of \texttt{env\_bind()}:

\begin{itemize}
\item
  \texttt{env\_bind\_exprs()} creates \textbf{delayed bindings}, which
  are evaluated the first time they are accessed. Behind the scenes,
  delayed bindings create promises, so behave in the same way as
  function arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_bind_exprs}\NormalTok{(}\KeywordTok{current_env}\NormalTok{(), }\DataTypeTok{b =}\NormalTok{ \{}\KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{1}\NormalTok{); }\DecValTok{1}\NormalTok{\})}
\CommentTok{#> Warning: `env_bind_exprs()` is soft-deprecated as of rlang 0.3.0.}
\CommentTok{#> Please use `env_bind_lazy()` instead.}
\CommentTok{#> This warning is displayed once per session.}

\KeywordTok{system.time}\NormalTok{(}\KeywordTok{print}\NormalTok{(b))}
\CommentTok{#> [1] 1}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>       0       0       1}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{print}\NormalTok{(b))}
\CommentTok{#> [1] 1}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>       0       0       0}
\end{Highlighting}
\end{Shaded}

  Delayed bindings are used to implement \texttt{autoload()}, which
  makes R behave as if the package data is in memory, even though it's
  only loaded from disk when you ask for it.
\item
  \texttt{env\_bind\_fns()} creates \textbf{active bindings} which are
  re-computed every time they're accessed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_bind_fns}\NormalTok{(}\KeywordTok{current_env}\NormalTok{(), }\DataTypeTok{z1 =} \ControlFlowTok{function}\NormalTok{(val) }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> Warning: `env_bind_fns()` is soft-deprecated as of rlang 0.3.0.}
\CommentTok{#> Please use `env_bind_active()` instead.}
\CommentTok{#> This warning is displayed once per session.}

\NormalTok{z1}
\CommentTok{#> [1] 0.0808}
\NormalTok{z1}
\CommentTok{#> [1] 0.834}
\end{Highlighting}
\end{Shaded}

  The argument to the function allows you to also override behaviour
  when the variable is set:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_bind_fns}\NormalTok{(}\KeywordTok{current_env}\NormalTok{(), }\DataTypeTok{z2 =} \ControlFlowTok{function}\NormalTok{(val) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(val)) \{}
    \DecValTok{2}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
     \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't touch z2!"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\})}

\NormalTok{z2}
\CommentTok{#> [1] 2}
\NormalTok{z2 <-}\StringTok{ }\DecValTok{3}
\CommentTok{#> Error: Don't touch z2!}
\end{Highlighting}
\end{Shaded}
\end{itemize}

See \texttt{?delayedAssign()} and \texttt{?makeActiveBinding()}.

\hypertarget{exercises-18}{%
\subsection{Exercises}\label{exercises-18}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  List three ways in which an environment differs from a list.
\item
  Create an environment as illustrated by this picture.

  \begin{center}\includegraphics[width=1.48in]{diagrams/environments/recursive-1} \end{center}
\item
  Create a pair of environments as illustrated by this picture.

  \begin{center}\includegraphics[width=2.56in]{diagrams/environments/recursive-2} \end{center}
\item
  Explain why \texttt{e{[}{[}1{]}{]}} and \texttt{e{[}c("a",\ "b"){]}}
  don't make sense when \texttt{e} is an environment.
\item
  Create a version of \texttt{env\_poke()} that will only bind new
  names, never re-bind old names. Some programming languages only do
  this, and are known as
  \href{http://en.wikipedia.org/wiki/Assignment_(computer_science)\#Single_assignment}{single
  assignment languages}.
\item
  What does this function do? How does it differ from
  \texttt{\textless{}\textless{}-} and why might you prefer it?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rebind <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, value, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't find `"}\NormalTok{, name, }\StringTok{"`"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
    \KeywordTok{env_poke}\NormalTok{(env, name, value)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{rebind}\NormalTok{(name, value, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{rebind}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error: Can't find `a`}
\NormalTok{a <-}\StringTok{ }\DecValTok{5}
\KeywordTok{rebind}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{a}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{env-recursion}{%
\section{Recursing over environments}\label{env-recursion}}

\index{recursion!over environments}

If you want to operate on every ancestor of an environment, it's often
convenient to write a recursive function. This section shows you how,
applying your new knowledge of environments to write a function that
given a name, finds the environment \texttt{where()} that name is
defined, using R's regular scoping rules.

The definition of \texttt{where()} is straightforward. It has two
arguments: the name to look for (as a string), and the environment in
which to start the search. (We'll learn why \texttt{caller\_env()} is a
good default in \protect\hyperlink{calling-environments}{calling
environments}.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{where <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \CommentTok{# Base case}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't find "}\NormalTok{, name, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
    \CommentTok{# Success case}
\NormalTok{    env}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{# Recursive case}
    \KeywordTok{where}\NormalTok{(name, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are three cases:

\begin{itemize}
\item
  The base case: we've reached the empty environment and haven't found
  the binding. We can't go any further, so we throw an error.
\item
  The successful case: the name exists in this environment, so we return
  the environment.
\item
  The recursive case: the name was not found in this environment, so try
  the parent.
\end{itemize}

These three cases are illustrated with these three examples:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{where}\NormalTok{(}\StringTok{"yyy"}\NormalTok{)}
\CommentTok{#> Error: Can't find yyy}

\NormalTok{x <-}\StringTok{ }\DecValTok{5}
\KeywordTok{where}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> <environment: R_GlobalEnv>}

\KeywordTok{where}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\CommentTok{#> <environment: base>}
\end{Highlighting}
\end{Shaded}

It might help to see a picture. Imagine you have two environments, as in
the following code and diagram:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e4a <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\KeywordTok{empty_env}\NormalTok{(), }\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{e4b <-}\StringTok{ }\KeywordTok{env}\NormalTok{(e4a, }\DataTypeTok{x =} \DecValTok{10}\NormalTok{, }\DataTypeTok{a =} \DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.69in]{diagrams/environments/where-ex} \end{center}

\begin{itemize}
\item
  \texttt{where("a",\ e4b)} will find \texttt{a} in \texttt{e4b}.
\item
  \texttt{where("b",\ e4b)} doesn't find \texttt{b} in \texttt{e4b}, so
  it looks in its parent, \texttt{e4a}, and finds it there.
\item
  \texttt{where("c",\ e4b)} looks in \texttt{e4b}, then \texttt{e4a},
  then hits the empty environment and throws an error.
\end{itemize}

It's natural to work with environments recursively, so \texttt{where()}
provides a useful template. Removing the specifics of \texttt{where()}
shows the structure more clearly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \CommentTok{# base case}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (success) \{}
    \CommentTok{# success case}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{# recursive case}
    \KeywordTok{f}\NormalTok{(..., }\DataTypeTok{env =} \KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{iteration-vs-recursion}{%
\subsection*{Iteration vs recursion}\label{iteration-vs-recursion}}
\addcontentsline{toc}{subsection}{Iteration vs recursion}

It's possible to use a loop instead of recursion. I think it's harder to
understand than the recursive version, but I include it because you
might find it easier to see what's happening if you haven't written many
recursive functions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{while}\NormalTok{ (}\OperatorTok{!}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \ControlFlowTok{if}\NormalTok{ (success) \{}
      \CommentTok{# success case}
      \KeywordTok{return}\NormalTok{()}
\NormalTok{    \}}
    \CommentTok{# inspect parent}
\NormalTok{    env <-}\StringTok{ }\KeywordTok{env_parent}\NormalTok{(env)}
\NormalTok{  \}}

  \CommentTok{# base case}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-19}{%
\subsection{Exercises}\label{exercises-19}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Modify \texttt{where()} to return \emph{all} environments that contain
  a binding for \texttt{name}. Carefully think through what type of
  object the function will need to return.
\item
  Write a function called \texttt{fget()} that finds only function
  objects. It should have two arguments, \texttt{name} and \texttt{env},
  and should obey the regular scoping rules for functions: if there's an
  object with a matching name that's not a function, look in the parent.
  For an added challenge, also add an \texttt{inherits} argument which
  controls whether the function recurses up the parents or only looks in
  one environment.
\end{enumerate}

\hypertarget{function-envs}{%
\section{Special environments}\label{function-envs}}

\index{functions!environments}

Most environments are not created by you (e.g.~with \texttt{env()}) but
are instead created by R. In this section, you'll learn about the most
important environments, starting with the package environments. You'll
then learn about the function environment bound to the function when it
is created, and the (usually) ephemeral execution environment created
every time the function is called. Finally, you'll see how the package
and function environments interact to support namespaces, which ensure
that a package always behaves the same way, regardless of what other
packages the user has loaded.

\hypertarget{package-environments-and-the-search-path}{%
\subsection{Package environments and the search
path}\label{package-environments-and-the-search-path}}

\indexc{search()} \index{search path}

Each package attached by \texttt{library()} or \texttt{require()}
becomes one of the parents of the global environment. The immediate
parent of the global environment is the last package you
attached\footnote{Note the difference between attached and loaded. A
  package is loaded automatically if you access one of its functions
  using \texttt{::}; it is only \textbf{attached} to the search path by
  \texttt{library()} or \texttt{require()}.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_parent}\NormalTok{(}\KeywordTok{global_env}\NormalTok{())}
\CommentTok{#> <environment: package:rlang>}
\CommentTok{#> attr(,"name")}
\CommentTok{#> [1] "package:rlang"}
\CommentTok{#> attr(,"path")}
\CommentTok{#> [1] "/home/travis/R/Library/rlang"}
\end{Highlighting}
\end{Shaded}

And the parent of that package is the second to last package you
attached:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_parent}\NormalTok{(}\KeywordTok{env_parent}\NormalTok{(}\KeywordTok{global_env}\NormalTok{()))}
\CommentTok{#> <environment: package:stats>}
\CommentTok{#> attr(,"name")}
\CommentTok{#> [1] "package:stats"}
\CommentTok{#> attr(,"path")}
\CommentTok{#> [1] "/home/travis/R-bin/lib/R/library/stats"}
\end{Highlighting}
\end{Shaded}

If you follow all the parents back, you see the order in which every
package has been attached. This is known as the \textbf{search path}
because all objects in these environments can be found from the
top-level interactive workspace.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{search_envs}\NormalTok{()}
\CommentTok{#>  [[1]] $ <env: global>}
\CommentTok{#>  [[2]] $ <env: package:rlang>}
\CommentTok{#>  [[3]] $ <env: package:stats>}
\CommentTok{#>  [[4]] $ <env: package:graphics>}
\CommentTok{#>  [[5]] $ <env: package:grDevices>}
\CommentTok{#>  [[6]] $ <env: package:utils>}
\CommentTok{#>  [[7]] $ <env: package:datasets>}
\CommentTok{#>  [[8]] $ <env: package:methods>}
\CommentTok{#>  [[9]] $ <env: Autoloads>}
\CommentTok{#> [[10]] $ <env: package:base>}
\end{Highlighting}
\end{Shaded}

You can access the names of the environments on the search path with
\texttt{search()}

The last two environments on the search path are always the same:

\begin{itemize}
\item
  The \texttt{Autoloads} environment uses delayed bindings to save
  memory by only loading package objects (like big datasets) when
  needed.
\item
  The base environment, \texttt{package:base} or sometimes just
  \texttt{base}, is the environment of the base package. It is special
  because it has to be able to bootstrap the loading of all other
  packages. You can access it directly with \texttt{base\_env()}.
\end{itemize}

Graphically, the search path looks like this:

\begin{center}\includegraphics[width=4.33in]{diagrams/environments/search-path} \end{center}

When you attach another package with \texttt{library()}, the parent
environment of the global environment changes:

\begin{center}\includegraphics[width=4.33in]{diagrams/environments/search-path-2} \end{center}

\hypertarget{the-function-environment}{%
\subsection{The function environment}\label{the-function-environment}}

\index{environments!function}

A function binds the current environment when it is created. This is
called the \textbf{function environment}, and is used for lexical
scoping. Across computer languages, functions that capture their
environments are called \textbf{closures}, which is why this term is
often used interchangeably with function in R's documentation.

You can get the function environment with \texttt{fn\_env()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{1}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\KeywordTok{fn_env}\NormalTok{(f)}
\CommentTok{#> <environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

Use \texttt{environment(f)} to access the environment of function
\texttt{f}.

In diagrams, I'll depict functions as rectangles with a rounded end that
binds an environment.

\begin{center}\includegraphics[width=2.16in]{diagrams/environments/binding} \end{center}

In this case, \texttt{f()} binds the environment that binds the name
\texttt{f} to the function. But that's not always the case: in the
following example \texttt{g} is bound in a new environment \texttt{e},
but \texttt{g()} binds the global environment. The distinction between
binding and being bound by is subtle but important; the difference is
how we find \texttt{g} vs.~how \texttt{g} finds its variables.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e <-}\StringTok{ }\KeywordTok{env}\NormalTok{()}
\NormalTok{e}\OperatorTok{$}\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.36in]{diagrams/environments/binding-2} \end{center}

\hypertarget{namespaces}{%
\subsection{Namespaces}\label{namespaces}}

\index{namespaces}

In the diagram above, you saw that the parent environment of a package
varies based on what other packages have been loaded. This seems
worrying: doesn't that mean that the package will find different
functions if packages are loaded in a different order? The goal of
\textbf{namespaces} is to make sure that this does not happen, and that
every package works the same way regardless of what packages are
attached by the user.

For example, take \texttt{sd()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sd}
\CommentTok{#> function (x, na.rm = FALSE) }
\CommentTok{#> sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), }
\CommentTok{#>     na.rm = na.rm))}
\CommentTok{#> <bytecode: 0x4a5cf30>}
\CommentTok{#> <environment: namespace:stats>}
\end{Highlighting}
\end{Shaded}

\texttt{sd()} is defined in terms of \texttt{var()}, so you might worry
that the result of \texttt{sd()} would be affected by any function
called \texttt{var()} either in the global environment, or in one of the
other attached packages. R avoids this problem by taking advantage of
the function vs.~binding environment described above. Every function in
a package is associated with a pair of environments: the package
environment, which you learned about earlier, and the \textbf{namespace}
environment.

\begin{itemize}
\item
  The package environment is the external interface to the package. It's
  how you, the R user, find a function in an attached package or with
  \texttt{::}. Its parent is determined by search path, i.e.~the order
  in which packages have been attached.
\item
  The namespace environment is the internal interface to the package.
  The package environment controls how we find the function; the
  namespace controls how the function finds its variables.
\end{itemize}

Every binding in the package environment is also found in the namespace
environment; this ensures every function can use every other function in
the package. But some bindings only occur in the namespace environment.
These are known as internal or non-exported objects, which make it
possible to hide internal implementation details from the user.

\begin{center}\includegraphics[width=2.36in]{diagrams/environments/namespace-bind} \end{center}

Every namespace environment has the same set of ancestors:

\begin{itemize}
\item
  Each namespace has an \textbf{imports} environment that contains
  bindings to all the functions used by the package. The imports
  environment is controlled by the package developer with the
  \texttt{NAMESPACE} file.
\item
  Explicitly importing every base function would be tiresome, so the
  parent of the imports environment is the base \textbf{namespace}. The
  base namespace contains the same bindings as the base environment, but
  it has a different parent.
\item
  The parent of the base namespace is the global environment. This means
  that if a binding isn't defined in the imports environment the package
  will look for it in the usual way. This is usually a bad idea (because
  it makes code depend on other loaded packages), so
  \texttt{R\ CMD\ check} automatically warns about such code. It is
  needed primarily for historical reasons, particularly due to how S3
  method dispatch works.
\end{itemize}

\begin{center}\includegraphics[width=5.12in]{diagrams/environments/namespace-env} \end{center}

Putting all these diagrams together we get:

\begin{center}\includegraphics[width=5.9in]{diagrams/environments/namespace} \end{center}

So when \texttt{sd()} looks for the value of \texttt{var} it always
finds it in a sequence of environments determined by the package
developer, but not by the package user. This ensures that package code
always works the same way regardless of what packages have been attached
by the user.

Note that there's no direct link between the package and namespace
environments; the link is defined by the function environments.

\hypertarget{execution-environments}{%
\subsection{Execution environments}\label{execution-environments}}

The last important topic we need to cover is the \textbf{execution}
environment. What will the following function return the first time it's
run? What about the second? \index{environments!execution}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{env_has}\NormalTok{(}\KeywordTok{current_env}\NormalTok{(), }\StringTok{"a"}\NormalTok{)) \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Defining a"}\NormalTok{)}
\NormalTok{    a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    a <-}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
\NormalTok{  a}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Think about it for a moment before you read on.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{g}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> Defining a}
\CommentTok{#> [1] 1}
\KeywordTok{g}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> Defining a}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

This function returns the same value every time because of the fresh
start principle, described in \protect\hyperlink{fresh-start}{a fresh
start}. Each time a function is called, a new environment is created to
host execution. This is called the execution environment, and its parent
is the function environment. Let's illustrate that process with a
simpler function. I'll draw execution environments with an indirect
parent; the parent environment is found via the function environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \CommentTok{# 1.}
\NormalTok{  a <-}\StringTok{ }\DecValTok{2} \CommentTok{# 2.}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\NormalTok{a}
\NormalTok{\}}
\NormalTok{y <-}\StringTok{ }\KeywordTok{h}\NormalTok{(}\DecValTok{1}\NormalTok{) }\CommentTok{# 3.}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.15in]{diagrams/environments/execution} \end{center}

An execution environment is usually ephemeral; once the function has
completed, the environment will be GC'd. There are several ways to make
it stay around for longer. The first is to explicitly return it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  a <-}\StringTok{ }\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
  \KeywordTok{current_env}\NormalTok{()}
\NormalTok{\}}

\NormalTok{e <-}\StringTok{ }\KeywordTok{h2}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{)}
\KeywordTok{env_print}\NormalTok{(e)}
\CommentTok{#> <environment: 0x482ab40>}
\CommentTok{#>   parent: <environment: global>}
\CommentTok{#>   bindings:}
\CommentTok{#>    * a: <dbl>}
\CommentTok{#>    * x: <dbl>}
\KeywordTok{fn_env}\NormalTok{(h2)}
\CommentTok{#> <environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

\index{closures!environment}

Another way to capture it is to return an object with a binding to that
environment, like a function. The following example illustrates that
idea with a function factory, \texttt{plus()}. We use that factory to
create a function called \texttt{plus\_one()}.

There's a lot going on in the diagram because the enclosing environment
of \texttt{plus\_one()} is the execution environment of \texttt{plus()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plus <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{function}\NormalTok{(y) x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\NormalTok{\}}

\NormalTok{plus_one <-}\StringTok{ }\KeywordTok{plus}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{plus_one}
\CommentTok{#> function(y) x + y}
\CommentTok{#> <environment: 0x3202d60>}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.97in]{diagrams/environments/closure} \end{center}

What happens when we call \texttt{plus\_one()}? Its execution
environment will have the captured execution environment of
\texttt{plus()} as its parent:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plus_one}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=1.97in]{diagrams/environments/closure-call} \end{center}

You'll learn more about function factories in
\protect\hyperlink{functional-programming}{functional programming}.

\hypertarget{exercises-20}{%
\subsection{Exercises}\label{exercises-20}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How is \texttt{search\_envs()} different to
  \texttt{env\_parents(global\_env())}?
\item
  Draw a diagram that shows the enclosing environments of this function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1) \{}
\NormalTok{  f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x2) \{}
\NormalTok{    f3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x3) \{}
\NormalTok{      x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2 }\OperatorTok{+}\StringTok{ }\NormalTok{x3}
\NormalTok{    \}}
    \KeywordTok{f3}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{f2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Write an enhanced version of \texttt{str()} that provides more
  information about functions. Show where the function was found and
  what environment it was defined in.
\end{enumerate}

\hypertarget{call-stack}{%
\section{The call stack}\label{call-stack}}

\index{environments!calling} \index{scoping!dynamic}
\index{dynamic scoping}

There is one last environment we need to explain, the \textbf{caller}
environment, accessed with \texttt{rlang::caller\_env()}. This provides
the environment from which the function was called, and hence varies
based on how the function is called, not how the function was created.
As we saw above this is a useful default whenever you write a function
that takes an environment as an argument.

\texttt{parent.frame()} is equivalent to \texttt{caller\_env()}; just
note that it returns an environment, not a frame.

To fully understand the caller environment we need to discuss two
related concepts: the \textbf{call stack}, which is made up of
\textbf{frames}. Executing a function creates two types of context.
You've learned about one already: the execution environment is a child
of the function environment, which is determined by where the function
was created. There's another type of context created by where the
function was called: this is called the call stack.

\hypertarget{simple-call-stacks}{%
\subsection{Simple call stacks}\label{simple-call-stacks}}

Let's illustrate this with a simple sequence of calls: \texttt{f()}
calls \texttt{g()} calls \texttt{h()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{g}\NormalTok{(}\DataTypeTok{x =} \DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{h}\NormalTok{(}\DataTypeTok{x =} \DecValTok{3}\NormalTok{)}
\NormalTok{\}}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{stop}\NormalTok{()}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The way you most commonly see a call stack in R is by looking at the
\texttt{traceback()} after an error has occurred:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> Error:}
\KeywordTok{traceback}\NormalTok{()}
\CommentTok{#> 4: stop()}
\CommentTok{#> 3: h(x = 3) }
\CommentTok{#> 2: g(x = 2)}
\CommentTok{#> 1: f(x = 1)}
\end{Highlighting}
\end{Shaded}

Instead of \texttt{stop()} + \texttt{traceback()} to understand the call
stack, we're going to use \texttt{lobstr::cst()} to print out the
\textbf{c}all \textbf{s}tack \textbf{t}ree:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  lobstr}\OperatorTok{::}\KeywordTok{cst}\NormalTok{()}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> █}
\CommentTok{#> └─f(x = 1)}
\CommentTok{#>   └─g(x = 2)}
\CommentTok{#>     └─h(x = 3)}
\CommentTok{#>       └─lobstr::cst()}
\end{Highlighting}
\end{Shaded}

This shows us that \texttt{cst()} was called from \texttt{h()}, which
was called from \texttt{g()}, which was called from \texttt{f()}. Note
that the order is the opposite from \texttt{traceback()}. As the call
stacks get more complicated, I think it's easier to understand the
sequence of calls if you start from the beginning, rather than the end
(i.e. \texttt{f()} calls \texttt{g()}; rather than \texttt{g()} was
called by \texttt{f()}).

\hypertarget{lazy-evaluation-1}{%
\subsection{Lazy evaluation}\label{lazy-evaluation-1}}

The call stack above is simple - while you get a hint that there's some
tree-like structure involved, everything happens on a single branch.
This is typical of a call stack when all arguments are eagerly
evaluated.

Let's create a more complicated example that involves some lazy
evaluation. We'll create a sequence of functions, \texttt{a()},
\texttt{b()}, \texttt{c()}, that pass along an argument \texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{b}\NormalTok{(x)}
\NormalTok{b <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{c}\NormalTok{(x)}
\NormalTok{c <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}

\KeywordTok{a}\NormalTok{(}\KeywordTok{f}\NormalTok{())}
\CommentTok{#> █}
\CommentTok{#> ├─a(f())}
\CommentTok{#> │ └─b(x)}
\CommentTok{#> │   └─c(x)}
\CommentTok{#> └─f()}
\CommentTok{#>   └─g(x = 2)}
\CommentTok{#>     └─h(x = 3)}
\CommentTok{#>       └─lobstr::cst()}
\end{Highlighting}
\end{Shaded}

\texttt{x} is lazily evaluated so this tree gets two branches. In the
first branch \texttt{a()} calls \texttt{b()}, then \texttt{b()} calls
\texttt{c()}. The second branch starts when \texttt{c()} evaluates its
argument \texttt{x}. This argument is evaluated in a new branch because
the environment in which it is evaluated is the global environment, not
the environment of \texttt{c()}.

\hypertarget{frames}{%
\subsection{Frames}\label{frames}}

Each element of the call stack is a \textbf{frame}\footnote{NB:
  \texttt{?environment} uses frame in a different sense: ``Environments
  consist of a \emph{frame}, or collection of named objects, and a
  pointer to an enclosing environment.''. We avoid this sense of frame,
  which comes from S, because it's very specific and not widely used in
  base R. For example, the ``frame'' in \texttt{parent.frame()} is an
  execution context, not a collection of named objects.}, also known as
an evaluation context. The frame is an extremely important internal data
structure, and R code can only access a small part of the data structure
because it's so critical. A frame has three main components that are
accessible from R:

\begin{itemize}
\item
  An expression (labelled with \texttt{expr}) giving the function call.
  This is what \texttt{traceback()} prints out.
\item
  An environment (labelled with \texttt{env}), which is typically the
  execution environment of a function. There are two main exceptions:
  the environment of the global frame is the global environment, and
  calling \texttt{eval()} also generates frames, where the environment
  can be anything.
\item
  A parent, the previous call in the call stack (shown by a grey arrow).
\end{itemize}

\begin{center}\includegraphics[width=3.94in]{diagrams/environments/calling} \end{center}

(To focus on the calling environments, I have omitted the bindings in
the global environment from \texttt{f}, \texttt{g}, and \texttt{h} to
the respective function objects.)

The frame also holds exit handlers created with \texttt{on.exit()},
restarts and handlers for the condition system, and which context to
\texttt{return()} to when a function completes. These are important for
the internal operation of R, but are not directly accessible.

\hypertarget{dynamic-scope}{%
\subsection{Dynamic scope}\label{dynamic-scope}}

Looking up variables in the calling stack rather than in the enclosing
environment is called \textbf{dynamic scoping}. Few languages implement
dynamic scoping (Emacs Lisp is a
\href{http://www.gnu.org/software/emacs/emacs-paper.html\#SEC15}{notable
exception}.) This is because dynamic scoping makes it much harder to
reason about how a function operates: not only do you need to know how
it was defined, you also need to know the context in which it was
called. Dynamic scoping is primarily useful for developing functions
that aid interactive data analysis. It is one of the topics discussed in
\protect\hyperlink{nse}{non-standard evaluation}.

\hypertarget{exercises-21}{%
\subsection{Exercises}\label{exercises-21}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function that lists all the variables defined in the
  environment in which it was called. It should return the same results
  as \texttt{ls()}.
\end{enumerate}

\hypertarget{explicit-envs}{%
\section{As data structures}\label{explicit-envs}}

As well as powering scoping, environments are also useful data
structures in their own right because they have reference semantics.
There are three common problems that they can help solve:

\begin{itemize}
\tightlist
\item
  \textbf{Avoiding copies of large data}. Since environments have
  reference semantics, you'll never accidentally create a copy. This
  makes it a useful vessel for large objects. Bare environments are not
  that pleasant to work with; I recommend using R6 objects instead.
  Learn more in \protect\hyperlink{r6}{R6}.
\end{itemize}

\begin{itemize}
\item
  \textbf{Managing state within a package}. Explicit environments are
  useful in packages because they allow you to maintain state across
  function calls. Normally, objects in a package are locked, so you
  can't modify them directly. Instead, you can do something like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_env <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{(}\DataTypeTok{parent =} \KeywordTok{emptyenv}\NormalTok{())}
\NormalTok{my_env}\OperatorTok{$}\NormalTok{a <-}\StringTok{ }\DecValTok{1}

\NormalTok{get_a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  my_env}\OperatorTok{$}\NormalTok{a}
\NormalTok{\}}
\NormalTok{set_a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(value) \{}
\NormalTok{  old <-}\StringTok{ }\NormalTok{my_env}\OperatorTok{$}\NormalTok{a}
\NormalTok{  my_env}\OperatorTok{$}\NormalTok{a <-}\StringTok{ }\NormalTok{value}
  \KeywordTok{invisible}\NormalTok{(old)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

  Returning the old value from setter functions is a good pattern
  because it makes it easier to reset the previous value in conjunction
  with \texttt{on.exit()} (see more in \protect\hyperlink{on-exit}{on
  exit}).
\item
  \textbf{As a hashmap}. A hashmap is a data structure that takes
  constant, O(1), time to find an object based on its name. Environments
  provide this behaviour by default, so can be used to simulate a
  hashmap. See the CRAN package hash for a complete development of this
  idea. \index{hashmaps} \index{dictionaries}
\end{itemize}

\hypertarget{env-answers}{%
\section{Quiz answers}\label{env-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  There are four ways: every object in an environment must have a name;
  order doesn't matter; environments have parents; environments have
  reference semantics.
\item
  The parent of the global environment is the last package that you
  loaded. The only environment that doesn't have a parent is the empty
  environment.
\item
  The enclosing environment of a function is the environment where it
  was created. It determines where a function looks for variables.
\item
  Use \texttt{caller\_env()} or \texttt{parent.frame()}.
\item
  \texttt{\textless{}-} always creates a binding in the current
  environment; \texttt{\textless{}\textless{}-} rebinds an existing name
  in a parent of the current environment.
\end{enumerate}

\hypertarget{conditions}{%
\chapter{Conditions}\label{conditions}}

\hypertarget{introduction-6}{%
\section{Introduction}\label{introduction-6}}

The \textbf{condition} system provides a paired set of tools that allow
the author of a function to indicate that something unusual is
happening, and the user of that function to deal with it. The function
author \textbf{signals} conditions with functions like \texttt{stop()}
(for errors), \texttt{warning()} (for warnings), and \texttt{message()}
(for messages), then the function user can handle them with functions
like \texttt{tryCatch()} and \texttt{withCallingHandlers()}.
Understanding the condition system is important because you'll often
need to play both roles: signalling conditions from the functions you
create, and handle conditions signalled by the functions you call.

R offers a very powerful condition system based on ideas from Common
Lisp. Like R's approach to object oriented programming, it is rather
different to currently popular programming languages so it is easy to
misunderstand, and there has been relatively little written about how to
use it effectively. Historically, this has led to few people (including
me!) taking full advantage of its power. The goal of this chapter is to
remedy that situation. Here you will learn about the big ideas of R's
condition system, as well as learning a bunch of practical tools that
will make your code stronger.

I found two resources particularly useful when writing this chapter. You
may also want to read them if you want to learn more about the
inspirations and motivations for the system:

\begin{itemize}
\item
  \href{http://homepage.stat.uiowa.edu/~luke/R/exceptions/simpcond.html}{\emph{A
  prototype of a condition system for R}} by Robert Gentleman and Luke
  Tierney. This describes an early version of R's condition system.
  While the implementation has changed somewhat since this document was
  written, it provides a good overview of how the pieces fit together,
  and some motivation for its design.
\item
  \href{http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html}{\emph{Beyond
  exception handling: conditions and restarts}} by Peter Seibel. This
  describes exception handling in Lisp, which happens to be very similar
  to R's approach. It provides useful motivation and more sophisticated
  examples. I have provided an R translation of the chapter at
  \url{http://adv-r.had.co.nz/beyond-exception-handling.html}.
\end{itemize}

I also found it helpful to work through the underlying C code that
implements these ideas. If you're interested in understanding how it all
works, you might find
\href{https://gist.github.com/hadley/4278d0a6d3a10e42533d59905fbed0ac}{my
notes} to be useful.

\hypertarget{quiz-5}{%
\subsection*{Quiz}\label{quiz-5}}
\addcontentsline{toc}{subsection}{Quiz}

Want to skip this chapter? Go for it, if you can answer the questions
below. Find the answers at the end of the chapter in
\protect\hyperlink{conditions-answers}{answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What are the three most important types of condition?
\item
  What function do you use to ignore errors in block of code?
\item
  What's the main difference between \texttt{tryCatch()} and
  \texttt{withCallingHandlers()}?
\item
  Why might you want to create a custom error object?
\end{enumerate}

\hypertarget{overview}{%
\subsection*{Overview}\label{overview}}
\addcontentsline{toc}{subsection}{Overview}

\begin{itemize}
\item
  \protect\hyperlink{signalling-conditions}{Signalling conditions}
  introduces the basic tools for signalling conditions, and discusses
  when it is appropriate to use each type.
\item
  \protect\hyperlink{ignoring-conditions}{Ignoring conditions} teaches
  you about the simplest tools for handling conditions: functions like
  \texttt{try()} and \texttt{supressMessages()} that swallow conditions
  and prevent them from getting to the top level.
\item
  \protect\hyperlink{handling-conditions}{Handling conditions}
  introduces the condition \textbf{object}, and the two fundamental
  tools of condition handling: \texttt{tryCatch()} for error conditions,
  and \texttt{withCallingHandlers()} for everything else.
\item
  \protect\hyperlink{custom-conditions}{Custom conditions} shows you how
  to extend the built-in condition objects to store useful data that
  condition handlers can use to make more informed decisions.
\item
  \protect\hyperlink{condition-applications}{Applications} closes out
  the chapter with a grab bag of practical applications based on the
  low-level tools found in earlier sections.
\end{itemize}

\hypertarget{prerequisites-2}{%
\subsection{Prerequisites}\label{prerequisites-2}}

As well as base R functions, this chapter uses condition signalling and
handling functions from rlang.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\end{Highlighting}
\end{Shaded}

\hypertarget{signalling-conditions}{%
\section{Signalling conditions}\label{signalling-conditions}}

\index{errors!throwing} \index{conditions!signalling}

There are three conditions that you can signal in code: errors,
warnings, and messages.

\begin{itemize}
\item
  Errors are the most severe; they indicate that there is no way for a
  function to continue and execution must stop.
\item
  Warnings fall somewhat in between errors and warnings, and typically
  indicate that something has gone wrong but the function has been able
  to at least partially recover.
\item
  Messages are the mildest; they are way of informing the user that some
  action has been performed on their behalf.
\end{itemize}

There is a final condition that can only be generated interactively: an
interrupt, which indicates that the user has ``interrupted'' execution
by pressing Escape, Ctrl + Break, or Ctrl + C (depending on the
platform).

Conditions are usually displayed prominently, in a bold font or coloured
red, depending on the R interface. You can tell them apart because
errors always start with ``Error'', warnings with ``Warning message'',
and messages with nothing.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stop}\NormalTok{(}\StringTok{"This is what an error looks like"}\NormalTok{)}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   This is what an error looks like}

\KeywordTok{warning}\NormalTok{(}\StringTok{"This is what a warning looks like"}\NormalTok{)}
\CommentTok{#> Warning: This is what a warning looks like}

\KeywordTok{message}\NormalTok{(}\StringTok{"This is what a message looks like"}\NormalTok{)}
\CommentTok{#> This is what a message looks like}
\end{Highlighting}
\end{Shaded}

The following three sections describe errors, warnings, and message in
more detail.

\hypertarget{errors-1}{%
\subsection{Errors}\label{errors-1}}

In base R, errors are signalled, or \textbf{thrown}, by \texttt{stop()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{g}\NormalTok{()}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{h}\NormalTok{()}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{)}

\KeywordTok{f}\NormalTok{()}
\CommentTok{#> Error in h():}
\CommentTok{#>   This is an error!}
\end{Highlighting}
\end{Shaded}

By default, the error message includes the call, but this is typically
not useful (and recapitulates information that you can easily get from
\texttt{traceback()}), so I think it's good practice to use
\texttt{call.\ =\ FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> Error: This is an error!}
\end{Highlighting}
\end{Shaded}

The rlang equivalent to \texttt{stop()}, \texttt{rlang::abort()}, does
this automatically. We'll use \texttt{abort()} throughout this chapter,
but we won't get to its most compelling feature, the ability to add
additional metadata to the condition object, until we're near the end of
the chapter.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{abort}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{)}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> Error: This is an error!}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\end{Highlighting}
\end{Shaded}

(Note that \texttt{stop()} pastes together multiple inputs, while
\texttt{abort()} does not. To create complex error messages with abort,
I recommend using \texttt{glue::glue()}. This allows us to use other
arguments to \texttt{abort()} for useful features that you'll learn
about in \protect\hyperlink{custom-conditions}{custom conditions}.)

The best error messages tell you what is wrong and point you in the
right direction to fix the problem. Writing good error messages is hard
because errors usually occur when the user has a flawed mental model of
the function. As a developer, it's hard to imagine how the user might be
thinking incorrectly about your function, and thus it's hard to write a
message that will steer the user in the correct direction. That said,
the tidyverse style guide discusses a few general principles that we
have found useful: \url{http://style.tidyverse.org/error-messages.html}.

\hypertarget{warnings}{%
\subsection{Warnings}\label{warnings}}

Warnings, signalled by \texttt{warning()}, are weaker than errors: they
signal that something has gone wrong, but the code has been able to
recover and continue. Unlike errors, you can have multiple warnings from
a single function call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fw <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"W1"}\NormalTok{)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"2}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"W2"}\NormalTok{)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"3}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"W3"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By default, warnings are cached and printed only when control returns to
the top level:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fw}\NormalTok{()}
\CommentTok{#> 1}
\CommentTok{#> 2}
\CommentTok{#> 3}
\CommentTok{#> Warning messages:}
\CommentTok{#> 1: In f() : W1}
\CommentTok{#> 2: In f() : W2}
\CommentTok{#> 3: In f() : W3}
\end{Highlighting}
\end{Shaded}

You can control this behaviour with the \texttt{warn} option:

\begin{itemize}
\item
  To make warnings appear immediately, set \texttt{options(warn\ =\ 1)}.
\item
  To turn warnings into errors, set \texttt{options(warn\ =\ 2)}. This
  is usually the easiest way to debug a warning, as once it's an error
  you can use tools like \texttt{traceback()} to find the source.
\item
  Restore the default behaviour with \texttt{option(warn\ =\ 0)}.
\end{itemize}

Like \texttt{stop()}, \texttt{warning()} also has a call argument. It is
slightly more useful (since warnings are often more distant from their
source), but I still generally suppress it with
\texttt{call.\ =\ FALSE}. Like \texttt{rlang::abort()}, the rlang
equivalent of \texttt{warning()}, \texttt{rlang::warn()}, also
suppresses the \texttt{call.} by default.

Warnings occupy a somewhat challenging place between messages (``you
should know about this'') and errors (``you must fix this!''), and it's
hard to give precise advice on when to use them. Generally, be
restrained, as warnings are easy to miss if there's a lot of other
output, and you don't want your function to recover too easily from
clearly invalid input. In my opinion, base R tends to overuse warnings,
and many warnings in base R would be better off as errors. For example,
I think these warnings would be more helpful as errors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{formals}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> Warning in formals(fun): argument is not a function}
\CommentTok{#> NULL}

\KeywordTok{file.remove}\NormalTok{(}\StringTok{"this-file-doesn't-exist"}\NormalTok{)}
\CommentTok{#> Warning in file.remove("this-file-doesn't-exist"): cannot remove file}
\CommentTok{#> 'this-file-doesn't-exist', reason 'No such file or directory'}
\CommentTok{#> [1] FALSE}

\KeywordTok{lag}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{k =} \FloatTok{1.5}\NormalTok{)}
\CommentTok{#> Warning in lag.default(1:3, k = 1.5): 'k' is not an integer}
\CommentTok{#> [1] 1 2 3}
\CommentTok{#> attr(,"tsp")}
\CommentTok{#> [1] -1  1  1}
\end{Highlighting}
\end{Shaded}

There only a couple of cases where using a warning is clearly
appropriate:

\begin{itemize}
\item
  When you \textbf{deprecate} a function you want to allow older code to
  continue to work (so ignoring the warning is OK) but you want to
  encourage the user to switch to a new function.
\item
  When you are reasonably certain you can recover from a problem: If you
  were 100\% certain that you could fix the problem, you wouldn't need
  any message; if you were more uncertain that you could correctly fix
  the issue, you'd throw an error.
\end{itemize}

Otherwise use warnings with restraint, and carefully consider if an
error would be more appropriate.

\hypertarget{messages}{%
\subsection{Messages}\label{messages}}

Messages, signalled by \texttt{message()}, are informational; use them
to tell the user that you've done something on their behalf. Good
messages are a balancing act: you want to provide just enough
information so the user knows what's going on, but not so much that
they're overwhelmed.

\texttt{messages()} are displayed immediately and do not have a
\texttt{call.} argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fm <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{message}\NormalTok{(}\StringTok{"M1"}\NormalTok{)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"2}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{message}\NormalTok{(}\StringTok{"M2"}\NormalTok{)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"3}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
  \KeywordTok{message}\NormalTok{(}\StringTok{"M3"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{fm}\NormalTok{()}
\CommentTok{#> 1}
\CommentTok{#> M1}
\CommentTok{#> 2}
\CommentTok{#> M2}
\CommentTok{#> 3}
\CommentTok{#> M3}
\end{Highlighting}
\end{Shaded}

Good places to use a message are:

\begin{itemize}
\item
  When a default argument requries some non-trivial amount of
  computation and you want to tell the user what value was used. For
  example, ggplot2 reports the number of bins used if you don't supply a
  \texttt{binwidth}.
\item
  In functions that are called primarily for their side-effects which
  would otherwise be silent. For example, when writing files to disk,
  calling a web API, or writing to a database, it's useful provide
  regular status messages telling the user what's happening.
\item
  When you're about to start a long running process with no intermediate
  output. A progress bar (e.g.~with
  \href{https://github.com/r-lib/progress}{progress}) is better, but a
  message is a good place start.
\item
  When writing a package, you sometimes want to display a message when
  your package is loaded (i.e.~in \texttt{.onAttach()}); here you must
  use \texttt{packageStartupMessage()}.
\end{itemize}

Generally any function that produces a message should have some way to
suppress it, like a \texttt{quiet\ =\ TRUE} argument. It is possible to
suppress all messages with \texttt{suppressMessages()}, as you'll learn
shortly, but it is nice to also give finer grained control.

It's important to compare \texttt{message()} to the closely related
\texttt{cat()}. In terms of usage and result, they appear quite
similar\footnote{But note that \texttt{cat()} requires an explicit
  trailing \texttt{"\textbackslash{}n"} to print a new line.}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\StringTok{"Hi!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\CommentTok{#> Hi!}

\KeywordTok{message}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{)}
\CommentTok{#> Hi!}
\end{Highlighting}
\end{Shaded}

However, the \emph{purposes} of \texttt{cat()} and \texttt{message()}
are different. Use \texttt{cat()} when the primary role of the function
is to print to the console, like \texttt{print()} or \texttt{str()}
methods. Use \texttt{message()} as a side-channel to print to the
console when the primary purpose of the function is something else. In
other words, \texttt{cat()} is for when the user \emph{asks} for
something to be printed and \texttt{message()} is for when the developer
\emph{elects} to print something.

\hypertarget{exercises-22}{%
\subsection{Exercises}\label{exercises-22}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a wrapper around \texttt{file.remove()} that throws an error if
  the file to be deleted does not exist.
\item
  What does the \texttt{appendLF} argument to \texttt{message()} do? How
  is it related to \texttt{cat()}?
\item
  What does \texttt{options(error\ =\ recover)} do? Why might you use
  it?
\item
  What does
  \texttt{options(error\ =\ quote(dump.frames(to.file\ =\ TRUE)))} do?
  Why might you use it?
\end{enumerate}

\hypertarget{ignoring-conditions}{%
\section{Ignoring conditions}\label{ignoring-conditions}}

\indexc{try()} \indexc{suppressWarnings()} \indexc{suppressMessages()}

The simplest way of handling conditions in R is to simply ignore them:

\begin{itemize}
\tightlist
\item
  Ignore errors with \texttt{try()}.
\item
  Ignore warnings with \texttt{suppressWarnings()}.
\item
  Ignore messages with \texttt{suppressMessages()}.
\end{itemize}

These functions are heavy handed as you can't use them to suppress a
single type of condition that you know about, while allowing everything
else to pass through. We'll come back to that challenge later in the
chapter.

\texttt{try()} allows execution to continue even after an error has
occurred. Normally if you run a function that throws an error, it
terminates immediately and doesn't return a value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{log}\NormalTok{(x)}
  \DecValTok{10}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> Error in log(x):}
\CommentTok{#>   non-numeric argument to mathematical function}
\end{Highlighting}
\end{Shaded}

However, if you wrap the statement that creates the error in
\texttt{try()}, the error message will be displayed\footnote{You can
  suppress the message with \texttt{try(...,\ silent\ =\ TRUE)}.} but
execution will continue:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{try}\NormalTok{(}\KeywordTok{log}\NormalTok{(x))}
  \DecValTok{10}
\NormalTok{\}}
\KeywordTok{f2}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\CommentTok{#> Error in log(x) : non-numeric argument to mathematical function}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

It is possible, but not recommended, to save the result of
\texttt{try()} and perform different actions based on whether or not the
code succeeded or failed\footnote{You can tell if the expression failed
  because the result will have class \texttt{try-error}.}. Instead, it
is better to use \texttt{tryCatch()} or a higher-level helper; you'll
learn about those shortly.

A simple, but useful, pattern is to do assignment inside the call: this
lets you define a default value to be used if the code does not succeed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{default <-}\StringTok{ }\OtherTok{NULL}
\KeywordTok{try}\NormalTok{(default <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"possibly-bad-input.csv"}\NormalTok{), }\DataTypeTok{silent =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{suppressWarnings()} and \texttt{suppressMessages()} suppress all
warnings and messages. Unlike errors, messages and warnings don't
terminate execution, so there may be multiple signalled in a single
block.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{suppressWarnings}\NormalTok{(\{}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"Uhoh!"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"Another warning"}\NormalTok{)}
  \DecValTok{1}
\NormalTok{\})}
\CommentTok{#> [1] 1}

\KeywordTok{suppressMessages}\NormalTok{(\{}
  \KeywordTok{message}\NormalTok{(}\StringTok{"Hello there"}\NormalTok{)}
  \DecValTok{2}
\NormalTok{\})}
\CommentTok{#> [1] 2}

\KeywordTok{suppressWarnings}\NormalTok{(\{}
  \KeywordTok{message}\NormalTok{(}\StringTok{"You can still see me"}\NormalTok{)}
  \DecValTok{3}
\NormalTok{\})}
\CommentTok{#> You can still see me}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{handling-conditions}{%
\section{Handling conditions}\label{handling-conditions}}

\index{errors!catching} \index{conditions!handling}

Every condition has default behaviour: errors stop execution and return
to the top level, warnings are captured and displayed in aggregate, and
messages are immediately displayed. Condition \textbf{handlers} allow us
to temporarily override or supplement the default behaviour.

Two functions, \texttt{tryCatch()} and \texttt{withCallingHandlers()},
allow us to register handlers, functions that take the signalled
condition as their single argument. The registration functions have the
same basic form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
    \CommentTok{# code to run when error is thrown}
\NormalTok{  \},}
\NormalTok{  code_to_run_while_handlers_are_active}
\NormalTok{)}

\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
    \CommentTok{# code to run when warning is signalled}
\NormalTok{  \},}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
    \CommentTok{# code to run when message is signalled}
\NormalTok{  \},}
\NormalTok{  code_to_run_while_handlers_are_active}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

They differ in the type of handlers that they create:

\begin{itemize}
\item
  \texttt{tryCatch()} defines \textbf{exiting} handlers; after the
  condition is handled, control returns to the context where
  \texttt{tryCatch()} was called. This makes \texttt{tryCatch()} most
  suitable for working with errors and interrupts, as these have to exit
  anyway.
\item
  \texttt{withCallingHandlers()} defines \textbf{calling} handlers;
  after the condition is captured control returns to the context where
  the condition was signalled. This makes it most suitable for working
  with non-error conditions.
\end{itemize}

But before we can learn about and use these handlers, we need to talk a
little bit about condition \textbf{objects}. These are created
implicitly whenever you signal a condition, but become explicit inside
the handler.

\hypertarget{condition-objects}{%
\subsection{Condition objects}\label{condition-objects}}

\index{conditions!objects}

So far we've just signalled conditions, and not looked at the objects
that are created behind the scenes. The easiest way to see a condition
object is to catch one from a signalled condition. That's the job of
\texttt{rlang::catch\_cnd()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cnd <-}\StringTok{ }\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{abort}\NormalTok{(}\StringTok{"An error"}\NormalTok{))}
\KeywordTok{str}\NormalTok{(cnd)}
\CommentTok{#> List of 4}
\CommentTok{#>  $ message: chr "An error"}
\CommentTok{#>  $ call   : NULL}
\CommentTok{#>  $ trace  :List of 3}
\CommentTok{#>   ..$ calls  :List of 31}
\CommentTok{#>   .. ..$ : language local(\{     args = commandArgs(TRUE) ...}
\CommentTok{#>   .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))}
\CommentTok{#>   .. ..$ : language eval(expr, p)}
\CommentTok{#>   .. ..$ : language eval(expr, p)}
\CommentTok{#>   .. ..$ : language eval(quote(\{     args = commandArgs(TRUE) ...}
\CommentTok{#>   .. ..$ : language eval(quote(\{     args = commandArgs(TRUE) ...}
\CommentTok{#>   .. ..$ : language do.call(rmarkdown::render, c(args[1], readRDS("..}
\CommentTok{#>   .. ..$ : language (function (input, output_format = NULL, output_..}
\CommentTok{#>   .. ..$ : language knitr::knit(knit_input, knit_output, envir = en..}
\CommentTok{#>   .. ..$ : language process_file(text, output)}
\CommentTok{#>   .. ..$ : language withCallingHandlers(if (tangle) process_tangle(..}
\CommentTok{#>   .. ..$ : language process_group(group)}
\CommentTok{#>   .. ..$ : language process_group.block(group)}
\CommentTok{#>   .. ..$ : language call_block(x)}
\CommentTok{#>   .. ..$ : language block_exec(params)}
\CommentTok{#>   .. ..$ : language in_dir(input_dir(), evaluate(code, envir = env,..}
\CommentTok{#>   .. ..$ : language evaluate(code, envir = env, new_device = FALSE,..}
\CommentTok{#>   .. ..$ : language evaluate::evaluate(...)}
\CommentTok{#>   .. ..$ : language evaluate_call(expr, parsed$src[[i]], envir = en..}
\CommentTok{#>   .. ..$ : language timing_fn(handle(ev <- withCallingHandlers(with..}
\CommentTok{#>   .. ..$ : language handle(ev <- withCallingHandlers(withVisible(ev..}
\CommentTok{#>   .. ..$ : language withCallingHandlers(withVisible(eval(expr, envi..}
\CommentTok{#>   .. ..$ : language withVisible(eval(expr, envir, enclos))}
\CommentTok{#>   .. ..$ : language eval(expr, envir, enclos)}
\CommentTok{#>   .. ..$ : language eval(expr, envir, enclos)}
\CommentTok{#>   .. ..$ : language catch_cnd(abort("An error"))}
\CommentTok{#>   .. ..$ : language tryCatch(condition = identity, \{     force(expr..}
\CommentTok{#>   .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)}
\CommentTok{#>   .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1..}
\CommentTok{#>   .. ..$ : language doTryCatch(return(expr), name, parentenv, handl..}
\CommentTok{#>   .. ..$ : language force(expr)}
\CommentTok{#>   ..$ parents: int [1:31] 0 1 2 3 0 5 6 6 8 9 ...}
\CommentTok{#>   ..$ envs   :List of 31}
\CommentTok{#>   .. ..$ : chr "0x3e725e0"}
\CommentTok{#>   .. ..$ : chr "0x3e72490"}
\CommentTok{#>   .. ..$ : chr "0x3e72148"}
\CommentTok{#>   .. ..$ : chr "global"}
\CommentTok{#>   .. ..$ : chr "0x3e71ab8"}
\CommentTok{#>   .. ..$ : chr "0x3e71620"}
\CommentTok{#>   .. ..$ : chr "0x3e73818"}
\CommentTok{#>   .. ..$ : chr "0x3fdf588"}
\CommentTok{#>   .. ..$ : chr "0x2cf9638"}
\CommentTok{#>   .. ..$ : chr "0x2b3b390"}
\CommentTok{#>   .. ..$ : chr "0x786e328"}
\CommentTok{#>   .. ..$ : chr "0x786de20"}
\CommentTok{#>   .. ..$ : chr "0x786db80"}
\CommentTok{#>   .. ..$ : chr "0x786daa0"}
\CommentTok{#>   .. ..$ : chr "0x7855608"}
\CommentTok{#>   .. ..$ : chr "0x78d0828"}
\CommentTok{#>   .. ..$ : chr "0x78d3190"}
\CommentTok{#>   .. ..$ : chr "0x78d57b0"}
\CommentTok{#>   .. ..$ : chr "0x7964180"}
\CommentTok{#>   .. ..$ : chr "0x79845a8"}
\CommentTok{#>   .. ..$ : chr "0x79844c8"}
\CommentTok{#>   .. ..$ : chr "0x79841b8"}
\CommentTok{#>   .. ..$ : chr "0x7983c08"}
\CommentTok{#>   .. ..$ : chr "0x79839d8"}
\CommentTok{#>   .. ..$ : chr "global"}
\CommentTok{#>   .. ..$ : chr "0x79875a8"}
\CommentTok{#>   .. ..$ : chr "0x79873b0"}
\CommentTok{#>   .. ..$ : chr "0x7986d20"}
\CommentTok{#>   .. ..$ : chr "0x79869d8"}
\CommentTok{#>   .. ..$ : chr "0x7986690"}
\CommentTok{#>   .. ..$ : chr "0x7986348"}
\CommentTok{#>   ..- attr(*, "class")= chr "rlang_trace"}
\CommentTok{#>  $ parent : NULL}
\CommentTok{#>  - attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"}
\end{Highlighting}
\end{Shaded}

Built-in conditions are lists with two elements:

\begin{itemize}
\item
  \texttt{message}, a length-1 character vector containing the text to
  display to a user. To extract the message, use
  \texttt{conditionMessage(cnd)}.
\item
  \texttt{call}, the call which triggered the condition. As described
  above, we don't use the call, so it will often be \texttt{NULL}. To
  extract it, use \texttt{conditionCall(cnd)}.
\end{itemize}

Custom conditions may contain other components, which we'll discuss in
\protect\hyperlink{custom-conditions}{custom conditions}.

Conditions also have a \texttt{class} attribute, which makes them S3
objects. We won't disucss S3 until \protect\hyperlink{s3}{S3}, but
fortunately, even if you don't know about S3, condition objects are
quite simple. The most important thing to know is that the
\texttt{class} attribute is a character vector, and it determines which
handlers will match the condition.

\hypertarget{exiting-handlers}{%
\subsection{Exiting handlers}\label{exiting-handlers}}

\indexc{tryCatch()} \index{handlers!exiting}

\texttt{tryCatch()} registers exiting handlers, and is typically used to
handle error conditions. It allows you to override the default error
behaviour. For example, the following code will return \texttt{10}
instead of display an error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\DecValTok{10}\NormalTok{,}
  \KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

If no conditions are signalled, or the class of the signalled condition
does not match the handler name, the code executes normally:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\DecValTok{10}\NormalTok{,}
  \DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{)}
\CommentTok{#> [1] 2}

\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\DecValTok{10}\NormalTok{,}
\NormalTok{  \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{)}
    \DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> Hi!}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

The handlers set up by \texttt{tryCatch()} are called \textbf{exiting}
handlers because after the condition is signalled, control passes to the
handler and never returns to the original code, effectively meaning that
the code ``exits'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"There"}\NormalTok{,}
\NormalTok{  \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Here"}\NormalTok{)}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"This code is never run!"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> [1] "There"}
\end{Highlighting}
\end{Shaded}

Note that the code is evaluated in the environment of
\texttt{tryCatch()}, but the handler code is not, because the handlers
are functions. This is important to remember if you're trying to modify
objects in the parent environment.

The handler functions are called with a single argument, the condition
object. I call this argument \texttt{cnd}, by convention. This value is
only moderately useful for the base conditions because they contain
relatively little data. It's more useful when you make your own custom
conditions, as you'll see shortly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
    \KeywordTok{paste0}\NormalTok{(}\StringTok{"--"}\NormalTok{, }\KeywordTok{conditionMessage}\NormalTok{(cnd), }\StringTok{"--"}\NormalTok{)}
\NormalTok{  \},}
  \KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> [1] "--This is an error--"}
\end{Highlighting}
\end{Shaded}

\texttt{tryCatch()} has one other argument: \texttt{finally}. It
specifies a block of code (not a function) to run regardless of whether
the initial expression succeeds or fails. This can be useful for clean
up, like deleting files, or closing connections. This is functionally
equivalent to using \texttt{on.exit()} (and indeed that's how it's
implemented) but it can wrap smaller chunks of code than an entire
function. \indexc{on.exit()}

\hypertarget{calling-handlers}{%
\subsection{Calling handlers}\label{calling-handlers}}

\index{handlers!calling}

The handlers set up by \texttt{tryCatch()} are called exiting handlers,
because they cause code to exit once the condition has been caught. By
contrast, \texttt{withCallingHandler()} sets up \textbf{calling}
handlers: code execution continues normally once the handler returns.
This tends to make \texttt{withCallingHandlers()} a more natural pairing
with the non-error conditions.

Compare the results of \texttt{tryCatch()} and
\texttt{withCallingHandlers()} in the example below. The messages are
not printed in the first case, because the code is terminated once the
exiting handler completes. They are printed in the second case, because
a calling handler does not exit.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Caught a message!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }
\NormalTok{  \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Someone there?"}\NormalTok{)}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Why, yes!"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> Caught a message!}

\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(c) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Caught a message!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }
\NormalTok{  \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Someone there?"}\NormalTok{)}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Why, yes!"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> Caught a message!}
\CommentTok{#> Someone there?}
\CommentTok{#> Caught a message!}
\CommentTok{#> Why, yes!}
\end{Highlighting}
\end{Shaded}

Handlers are applied in order, so you don't need to worry getting caught
in an infinite loop:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"Second message"}\NormalTok{),}
  \KeywordTok{message}\NormalTok{(}\StringTok{"First message"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> Second message}
\CommentTok{#> First message}
\end{Highlighting}
\end{Shaded}

(But beware if you have multiple handlers, and some handlers signal
conditions that could be captured by another handler: you'll need to
think through the order carefully.)

The return value of a calling handler is ignored because the code
continues to execute after the handler completes; where would the return
value go? That means that calling handlers are only useful for their
side-effects.

One important side-effect unique to calling handlers is the ability to
\textbf{muffle} the signal. By default, a condition will continue to
propogate to parent handlers, all the way up to the default handler (or
an exiting handler, if provided):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Bubbles all the way up to default handler which generates the message}
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Level 2}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Level 1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> Level 1}
\CommentTok{#> Level 2}
\CommentTok{#> Hello}

\CommentTok{# Bubbles up to tryCatch}
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Level 2}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Level 1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> Level 1}
\CommentTok{#> Level 2}
\end{Highlighting}
\end{Shaded}

If you want to prevent the condition ``bubbling up'' but still run the
rest of the code in the block, you need to explicitly muffle it with
\texttt{rlang::cnd\_muffle()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Muffles the default handler which prints the messages}
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"Level 2}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \},}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Level 1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> Level 1}
\CommentTok{#> Level 2}

\CommentTok{# Muffles level 2 handler and the default handler}
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{cat}\NormalTok{(}\StringTok{"Level 2}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"Level 1}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
      \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{    \},}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> Level 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{call-stacks}{%
\subsection{Call stacks}\label{call-stacks}}

To complete the section, there are some important differences between
the call stacks of exiting and calling handlers. These differences are
generally not important but I'm including it here because I've
occassionally found it useful, and don't want to forget about it!

It's easiest to see the difference by setting up a small example that
uses \texttt{lobstr::cst()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{g}\NormalTok{()}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{h}\NormalTok{()}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{message}\NormalTok{(}\StringTok{"!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Calling handlers are called in the context of the call that signalled
the condition:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withCallingHandlers}\NormalTok{(}\KeywordTok{f}\NormalTok{(), }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{  lobstr}\OperatorTok{::}\KeywordTok{cst}\NormalTok{()}
  \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{\})}
\CommentTok{#> x}
\CommentTok{#> +-withCallingHandlers(...)}
\CommentTok{#> +-f()}
\CommentTok{#> | \textbackslash{}-g()}
\CommentTok{#> |   \textbackslash{}-h()}
\CommentTok{#> |     \textbackslash{}-message("!")}
\CommentTok{#> |       +-withRestarts(...)}
\CommentTok{#> |       | \textbackslash{}-withOneRestart(expr, restarts[[1L]])}
\CommentTok{#> |       |   \textbackslash{}-doWithOneRestart(return(expr), restart)}
\CommentTok{#> |       \textbackslash{}-signalCondition(cond)}
\CommentTok{#> \textbackslash{}-(function (cnd) ...}
\CommentTok{#>   \textbackslash{}-lobstr::cst()}
\end{Highlighting}
\end{Shaded}

Whereas exiting handlers are called in the context of the call to
\texttt{tryCatch()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}\KeywordTok{f}\NormalTok{(), }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) lobstr}\OperatorTok{::}\KeywordTok{cst}\NormalTok{())}
\CommentTok{#> x}
\CommentTok{#> \textbackslash{}-tryCatch(f(), message = function(cnd) lobstr::cst())}
\CommentTok{#>   \textbackslash{}-tryCatchList(expr, classes, parentenv, handlers)}
\CommentTok{#>     \textbackslash{}-tryCatchOne(expr, names, parentenv, handlers[[1L]])}
\CommentTok{#>       \textbackslash{}-value[[3L]](cond)}
\CommentTok{#>         \textbackslash{}-lobstr::cst()}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-23}{%
\subsection{Exercises}\label{exercises-23}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Predict the results of evaluating the following code

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_condition <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"error"}\NormalTok{,}
    \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"warning"}\NormalTok{,}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"message"}\NormalTok{,}
\NormalTok{    \{}
\NormalTok{      code}
      \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{show_condition}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"!"}\NormalTok{))}
\KeywordTok{show_condition}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{show_condition}\NormalTok{(}\KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{))}
\KeywordTok{show_condition}\NormalTok{(\{}
  \DecValTok{10}
  \KeywordTok{message}\NormalTok{(}\StringTok{"?"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}
\item
  Explain the results of running this code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withCallingHandlers}\NormalTok{(}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"b"}\NormalTok{),}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"a"}\NormalTok{),}
    \KeywordTok{message}\NormalTok{(}\StringTok{"c"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> b}
\CommentTok{#> a}
\CommentTok{#> b}
\CommentTok{#> c}
\end{Highlighting}
\end{Shaded}
\item
  Read the source code for \texttt{catch\_cnd()} and explain how it
  works.
\item
  How could you rewrite \texttt{show\_condition()} to use a single
  handler?
\end{enumerate}

\hypertarget{custom-conditions}{%
\section{Custom conditions}\label{custom-conditions}}

\index{conditions!custom}

One of the challenges of error handling in R is that most functions
generate one of the built-in conditions, which contain only a
\texttt{message} and a \texttt{call}. That means that if you want to
detect a specific type of error, you can only work with the text of the
error message. This is error prone, not only because the message might
change over time, but also because messages can be translated into other
languages.

Fortunately R has a powerful, but little used feature: the ability to
create custom conditions that can contain additional metadata. Creating
custom conditions is a little fiddly in base R, but
\texttt{rlang::abort()} makes it very easy as you can supply a custom
\texttt{.subclass} and additional metadata.

The following example shows the basic pattern. I recommend using the
following call structure for custom conditions. This takes advantage of
R's flexible argument matching so that the name of the ``type'' of error
comes first, followed by the user facing text, followed by custom
metadata.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abort}\NormalTok{(}
  \StringTok{"error_not_found"}\NormalTok{,}
  \DataTypeTok{message =} \StringTok{"Path `blah.csv` not found"}\NormalTok{, }
  \DataTypeTok{path =} \StringTok{"blah.csv"}
\NormalTok{)}
\CommentTok{#> Error: Path `blah.csv` not found}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\end{Highlighting}
\end{Shaded}

Custom conditions work just like regular conditions when used
interactively, but allow handlers to do much more.

\hypertarget{motivation}{%
\subsection{Motivation}\label{motivation}}

To explore these ideas in more depth, let's take \texttt{base::log()}.
It does the minimum when throwing errors caused by invalid arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(letters)}
\CommentTok{#> Error in log(letters):}
\CommentTok{#>   non-numeric argument to mathematical function}
\KeywordTok{log}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{base =}\NormalTok{ letters)}
\CommentTok{#> Error in log(1:10, base = letters):}
\CommentTok{#>   non-numeric argument to mathematical function}
\end{Highlighting}
\end{Shaded}

I think we can do better by being explicit about which argument is the
problem (i.e. \texttt{x} or \texttt{base}), and saying what the
problematic input is (not just what it isn't).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_log <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{base =} \KeywordTok{exp}\NormalTok{(}\DecValTok{1}\NormalTok{)) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.numeric}\NormalTok{(x)) \{}
    \KeywordTok{abort}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"`x` must be a numeric vector; not "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }\StringTok{"."}\NormalTok{))}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.numeric}\NormalTok{(base)) \{}
    \KeywordTok{abort}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"`base` must be a numeric vector; not "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(base), }\StringTok{"."}\NormalTok{))}
\NormalTok{  \}}

\NormalTok{  base}\OperatorTok{::}\KeywordTok{log}\NormalTok{(x, }\DataTypeTok{base =}\NormalTok{ base)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This gives us:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{my_log}\NormalTok{(letters)}
\CommentTok{#> Error: `x` must be a numeric vector; not character.}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\KeywordTok{my_log}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{base =}\NormalTok{ letters)}
\CommentTok{#> Error: `base` must be a numeric vector; not character.}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\end{Highlighting}
\end{Shaded}

This is an improvement for interactive usage as the error messages are
more likely to guide the user towards a correct fix. However, they're no
better if you want to programmatically handle the errors: all the useful
metadata about the error is jammed into a single string.

\hypertarget{signalling}{%
\subsection{Signalling}\label{signalling}}

Let's build some infrastructure to improve this situtation, We'll start
by providing a custom \texttt{abort()} function for bad arguments. This
is a little over-generalised for the example at hand, but it reflects
common patterns that I've seen across other functions. The pattern is
fairly simple. We create a nice error message for the user, using
\texttt{glue::glue()}, and store metadata in the condition call for the
developer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abort_bad_argument <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(arg, must, }\DataTypeTok{not =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  msg <-}\StringTok{ }\NormalTok{glue}\OperatorTok{::}\KeywordTok{glue}\NormalTok{(}\StringTok{"`\{arg\}` must \{must\}"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(not)) \{}
\NormalTok{    not <-}\StringTok{ }\KeywordTok{typeof}\NormalTok{(not)}
\NormalTok{    msg <-}\StringTok{ }\NormalTok{glue}\OperatorTok{::}\KeywordTok{glue}\NormalTok{(}\StringTok{"\{msg\}; not \{not\}."}\NormalTok{)}
\NormalTok{  \}}
  
  \KeywordTok{abort}\NormalTok{(}\StringTok{"error_bad_argument"}\NormalTok{, }
    \DataTypeTok{message =}\NormalTok{ msg, }
    \DataTypeTok{arg =}\NormalTok{ arg, }
    \DataTypeTok{must =}\NormalTok{ must, }
    \DataTypeTok{not =}\NormalTok{ not}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you want to throw a custom error without adding a dependency on
rlang, you can create a condition object ``by hand'' and then pass it to
\texttt{stop()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stop_custom <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.subclass, message, }\DataTypeTok{call =} \OtherTok{NULL}\NormalTok{, ...) \{}
\NormalTok{  err <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{message =}\NormalTok{ message,}
      \DataTypeTok{call =}\NormalTok{ call,}
\NormalTok{      ...}
\NormalTok{    ),}
    \DataTypeTok{class =} \KeywordTok{c}\NormalTok{(.subclass, }\StringTok{"error"}\NormalTok{, }\StringTok{"condition"}\NormalTok{)}
\NormalTok{  )}
  \KeywordTok{stop}\NormalTok{(err)}
\NormalTok{\}}

\NormalTok{err <-}\StringTok{ }\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{stop_custom}\NormalTok{(}\StringTok{"error_new"}\NormalTok{, }\StringTok{"This is a custom error"}\NormalTok{, }\DataTypeTok{x =} \DecValTok{10}\NormalTok{))}
\KeywordTok{class}\NormalTok{(err)}
\NormalTok{err}\OperatorTok{$}\NormalTok{x}
\end{Highlighting}
\end{Shaded}

We can now rewrite \texttt{my\_log()} to use this new helper:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_log <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{base =} \KeywordTok{exp}\NormalTok{(}\DecValTok{1}\NormalTok{)) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.numeric}\NormalTok{(x)) \{}
    \KeywordTok{abort_bad_argument}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DataTypeTok{must =} \StringTok{"be numeric"}\NormalTok{, }\DataTypeTok{not =}\NormalTok{ x)}
\NormalTok{  \}}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.numeric}\NormalTok{(base)) \{}
    \KeywordTok{abort_bad_argument}\NormalTok{(}\StringTok{"base"}\NormalTok{, }\DataTypeTok{must =} \StringTok{"be numeric"}\NormalTok{, }\DataTypeTok{not =}\NormalTok{ base)}
\NormalTok{  \}}

\NormalTok{  base}\OperatorTok{::}\KeywordTok{log}\NormalTok{(x, }\DataTypeTok{base =}\NormalTok{ base)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{my\_log()} itself is not much shorter, but is a little more
meanginful, and it ensures that error messages for bad arguments are
consistent across functions. It yields the same interactive error
messages as before:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{my_log}\NormalTok{(letters)}
\CommentTok{#> Error: `x` must be numeric; not character.}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\KeywordTok{my_log}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{base =}\NormalTok{ letters)}
\CommentTok{#> Error: `base` must be numeric; not character.}
\CommentTok{#> Call `rlang::last_error()` to see a backtrace}
\end{Highlighting}
\end{Shaded}

\hypertarget{handling}{%
\subsection{Handling}\label{handling}}

These structured condition objects are much easier to program with. The
first place you might want to use this capability is when testing your
function. Unit testing is not a subject of this book (see
\href{http://r-pkgs.had.co.nz/}{R packages} for details), but the basics
are easy to understand. The following code captures the error, and then
asserts it has the structure that we expect.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(testthat)}
\CommentTok{#> }
\CommentTok{#> Attaching package: 'testthat'}
\CommentTok{#> The following objects are masked from 'package:rlang':}
\CommentTok{#> }
\CommentTok{#>     is_false, is_null, is_true}

\NormalTok{err <-}\StringTok{ }\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{my_log}\NormalTok{(}\StringTok{"a"}\NormalTok{))}
\KeywordTok{expect_s3_class}\NormalTok{(err, }\StringTok{"error_bad_argument"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(err}\OperatorTok{$}\NormalTok{arg, }\StringTok{"x"}\NormalTok{)}
\KeywordTok{expect_equal}\NormalTok{(err}\OperatorTok{$}\NormalTok{not, }\StringTok{"character"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can also use the class (\texttt{error\_bad\_argument}) in
\texttt{tryCatch()} to only handle that specfic error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error_bad_argument =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"bad_argument"}\NormalTok{,}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"other error"}\NormalTok{,}
  \KeywordTok{my_log}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> [1] "bad_argument"}
\end{Highlighting}
\end{Shaded}

Note that when using \texttt{tryCatch()} with multiple handlers and
custom classes, the first handler to match any class in the signal's
class vector is called, not the best match. For this reason, you need to
make sure to put the most specific handlers first. The following code
does not do what you might hope:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tryCatch}\NormalTok{(}
  \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"other error"}\NormalTok{,}
  \DataTypeTok{error_bad_argument =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"bad_argument"}\NormalTok{,}
  \KeywordTok{my_log}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> [1] "other error"}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-24}{%
\subsection{Exercises}\label{exercises-24}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Inside a package, it's occassionally useful to check that a package is
  installed before using it. Write a function that checks if a package
  is installed (with
  \texttt{requireNamespace("pkg",\ quietly\ =\ FALSE))} and if not,
  throws a custom condition that includes the package name in the
  metadata.
\item
  Inside a package you often need to stop with an error when something
  is not right. Other packages that depend on your package might be
  tempted to check these errors in their unit tests. How could you help
  these packages to avoid relying on the error message which is part of
  the user interface rather than the API and might change without
  notice?
\end{enumerate}

\hypertarget{condition-applications}{%
\section{Applications}\label{condition-applications}}

Now that you've learned the basic tools of R's condition system, it's
time to dive into some applications. The goal of this section is not to
show every possible usage of \texttt{tryCatch()} and
\texttt{withCallingHandlers()} but to illustrate some common patterns
that frequently crop up. Hopefully these will get your creative juices
flowing, so when you encounter a new problem you can come up with a
useful solution.

\hypertarget{failure-value}{%
\subsection{Failure value}\label{failure-value}}

There are a few simple, but useful, \texttt{tryCatch()} patterns based
on returning a value from the error handler. The simplest case is a
wrapper to return a ``default'' value if an error occurs:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fail_with <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) value,}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{fail_with}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\DecValTok{10}\NormalTok{), }\OtherTok{NA_real_}\NormalTok{)}
\CommentTok{#> [1] 2.3}
\KeywordTok{fail_with}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\OtherTok{NA_real_}\NormalTok{)}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}

A more sophisticated application is \texttt{base::try()}. Below,
\texttt{try2()} extracts the essence of \texttt{base::try()}; the real
function is more complicated in order to make the error message look
more like what you'd see if \texttt{tryCatch()} wasn't used.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{try2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{silent =} \OtherTok{FALSE}\NormalTok{) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{      msg <-}\StringTok{ }\KeywordTok{conditionMessage}\NormalTok{(cnd)}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{silent) \{}
        \KeywordTok{message}\NormalTok{(}\StringTok{"Error: "}\NormalTok{, msg)}
\NormalTok{      \}}
      \KeywordTok{structure}\NormalTok{(msg, }\DataTypeTok{class =} \StringTok{"try-error"}\NormalTok{)}
\NormalTok{    \},}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{try2}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 1}
\KeywordTok{try2}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"Hi"}\NormalTok{))}
\CommentTok{#> Error: Hi}
\CommentTok{#> [1] "Hi"}
\CommentTok{#> attr(,"class")}
\CommentTok{#> [1] "try-error"}
\KeywordTok{try2}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"Hi"}\NormalTok{), }\DataTypeTok{silent =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] "Hi"}
\CommentTok{#> attr(,"class")}
\CommentTok{#> [1] "try-error"}
\end{Highlighting}
\end{Shaded}

\hypertarget{try-success-failure}{%
\subsection{Success and failure values}\label{try-success-failure}}

We can extend this pattern to returns one value if the code evaluates
successfully (\texttt{success\_val}), and another if it fails
(\texttt{error\_val}). This pattern just requires one small trick:
evaluating the user supplied code, then \texttt{success\_val}. If the
code throws an error, we'll never get to \texttt{success\_val} and will
instead return \texttt{error\_val}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) error_val,}
\NormalTok{    \{}
\NormalTok{      expr}
\NormalTok{      success_val}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can use this to determine if an expression fails:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{does_error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\OtherTok{TRUE}\NormalTok{,}
\NormalTok{    \{}
\NormalTok{      expr}
      \OtherTok{FALSE}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Or to capture any condition, like just \texttt{rlang::catch\_cnd()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnd <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{condition =} \ControlFlowTok{function}\NormalTok{(cnd) cnd, }
\NormalTok{    \{}
\NormalTok{      expr}
      \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can also use this pattern to create a \texttt{try()} variant. One
challenge with \texttt{try()} is that it's slightly challenging to
determine if the code succeeded or failed. Rather than returning an
object with a special class, I think it's slightly nicer to return a
list with two components \texttt{result} and \texttt{error}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safety <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \KeywordTok{list}\NormalTok{(}\DataTypeTok{result =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{error =}\NormalTok{ cnd)}
\NormalTok{    \},}
    \KeywordTok{list}\NormalTok{(}\DataTypeTok{result =}\NormalTok{ expr, }\DataTypeTok{error =} \OtherTok{NULL}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{str}\NormalTok{(}\KeywordTok{safety}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{10}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ result: num 11}
\CommentTok{#>  $ error : NULL}
\KeywordTok{str}\NormalTok{(}\KeywordTok{safety}\NormalTok{(}\KeywordTok{abort}\NormalTok{(}\StringTok{"Error!"}\NormalTok{)))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ result: NULL}
\CommentTok{#>  $ error :List of 4}
\CommentTok{#>   ..$ message: chr "Error!"}
\CommentTok{#>   ..$ call   : NULL}
\CommentTok{#>   ..$ trace  :List of 3}
\CommentTok{#>   .. ..$ calls  :List of 31}
\CommentTok{#>   .. .. ..$ : language local(\{     args = commandArgs(TRUE) ...}
\CommentTok{#>   .. .. ..$ : language eval.parent(substitute(eval(quote(expr), env..}
\CommentTok{#>   .. .. ..$ : language eval(expr, p)}
\CommentTok{#>   .. .. ..$ : language eval(expr, p)}
\CommentTok{#>   .. .. ..$ : language eval(quote(\{     args = commandArgs(TRUE) ...}
\CommentTok{#>   .. .. ..$ : language eval(quote(\{     args = commandArgs(TRUE) ...}
\CommentTok{#>   .. .. ..$ : language do.call(rmarkdown::render, c(args[1], readR"..}
\CommentTok{#>   .. .. ..$ : language (function (input, output_format = NULL, outp..}
\CommentTok{#>   .. .. ..$ : language knitr::knit(knit_input, knit_output, envir =..}
\CommentTok{#>   .. .. ..$ : language process_file(text, output)}
\CommentTok{#>   .. .. ..$ : language withCallingHandlers(if (tangle) process_tang..}
\CommentTok{#>   .. .. ..$ : language process_group(group)}
\CommentTok{#>   .. .. ..$ : language process_group.block(group)}
\CommentTok{#>   .. .. ..$ : language call_block(x)}
\CommentTok{#>   .. .. ..$ : language block_exec(params)}
\CommentTok{#>   .. .. ..$ : language in_dir(input_dir(), evaluate(code, envir = e..}
\CommentTok{#>   .. .. ..$ : language evaluate(code, envir = env, new_device = FAL..}
\CommentTok{#>   .. .. ..$ : language evaluate::evaluate(...)}
\CommentTok{#>   .. .. ..$ : language evaluate_call(expr, parsed$src[[i]], envir =..}
\CommentTok{#>   .. .. ..$ : language timing_fn(handle(ev <- withCallingHandlers(w..}
\CommentTok{#>   .. .. ..$ : language handle(ev <- withCallingHandlers(withVisible..}
\CommentTok{#>   .. .. ..$ : language withCallingHandlers(withVisible(eval(expr, e..}
\CommentTok{#>   .. .. ..$ : language withVisible(eval(expr, envir, enclos))}
\CommentTok{#>   .. .. ..$ : language eval(expr, envir, enclos)}
\CommentTok{#>   .. .. ..$ : language eval(expr, envir, enclos)}
\CommentTok{#>   .. .. ..$ : language str(safety(abort("Error!")))}
\CommentTok{#>   .. .. ..$ : language safety(abort("Error!"))}
\CommentTok{#>   .. .. ..$ : language tryCatch(error = function(cnd) \{     list(re..}
\CommentTok{#>   .. .. .. ..- attr(*, "srcref")= 'srcref' int [1:8] 2 3 7 3 3 3 2 7}
\CommentTok{#>   .. .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfil..}
\CommentTok{#>   .. .. ..$ : language tryCatchList(expr, classes, parentenv, handl..}
\CommentTok{#>   .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers..}
\CommentTok{#>   .. .. ..$ : language doTryCatch(return(expr), name, parentenv, ha..}
\CommentTok{#>   .. ..$ parents: int [1:31] 0 1 2 3 0 5 6 6 8 9 ...}
\CommentTok{#>   .. ..$ envs   :List of 31}
\CommentTok{#>   .. .. ..$ : chr "0x3e725e0"}
\CommentTok{#>   .. .. ..$ : chr "0x3e72490"}
\CommentTok{#>   .. .. ..$ : chr "0x3e72148"}
\CommentTok{#>   .. .. ..$ : chr "global"}
\CommentTok{#>   .. .. ..$ : chr "0x3e71ab8"}
\CommentTok{#>   .. .. ..$ : chr "0x3e71620"}
\CommentTok{#>   .. .. ..$ : chr "0x3e73818"}
\CommentTok{#>   .. .. ..$ : chr "0x3fdf588"}
\CommentTok{#>   .. .. ..$ : chr "0x2cf9638"}
\CommentTok{#>   .. .. ..$ : chr "0x2b3b390"}
\CommentTok{#>   .. .. ..$ : chr "0x5c91870"}
\CommentTok{#>   .. .. ..$ : chr "0x5c91368"}
\CommentTok{#>   .. .. ..$ : chr "0x5c910c8"}
\CommentTok{#>   .. .. ..$ : chr "0x5c90fe8"}
\CommentTok{#>   .. .. ..$ : chr "0x5cd6960"}
\CommentTok{#>   .. .. ..$ : chr "0x5d24278"}
\CommentTok{#>   .. .. ..$ : chr "0x5d26be0"}
\CommentTok{#>   .. .. ..$ : chr "0x5d29200"}
\CommentTok{#>   .. .. ..$ : chr "0x5f66c20"}
\CommentTok{#>   .. .. ..$ : chr "0x5f815d0"}
\CommentTok{#>   .. .. ..$ : chr "0x5f814f0"}
\CommentTok{#>   .. .. ..$ : chr "0x5f811e0"}
\CommentTok{#>   .. .. ..$ : chr "0x5f80c30"}
\CommentTok{#>   .. .. ..$ : chr "0x5f80a00"}
\CommentTok{#>   .. .. ..$ : chr "global"}
\CommentTok{#>   .. .. ..$ : chr "0x5f80808"}
\CommentTok{#>   .. .. ..$ : chr "0x5f80680"}
\CommentTok{#>   .. .. ..$ : chr "0x60d1460"}
\CommentTok{#>   .. .. ..$ : chr "0x60d0d60"}
\CommentTok{#>   .. .. ..$ : chr "0x60d0a18"}
\CommentTok{#>   .. .. ..$ : chr "0x60d06d0"}
\CommentTok{#>   .. ..- attr(*, "class")= chr "rlang_trace"}
\CommentTok{#>   ..$ parent : NULL}
\CommentTok{#>   ..- attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"}
\end{Highlighting}
\end{Shaded}

(This is closely related to \texttt{purrr::safely()}, a function
operator, which we'll come back to in Section \ref{safely}.)

\hypertarget{resignal}{%
\subsection{Resignal}\label{resignal}}

As well as returning default values when a condition is signalled,
handlers can be used to make more informative error messages. One simple
application is to make a function that works like
\texttt{option(warn\ =\ 2)} for a single block of code. The idea is
simple: we handle warnings by throwing an error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{warning2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{abort}\NormalTok{(}\KeywordTok{conditionMessage}\NormalTok{(cnd)),}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{warning2error}\NormalTok{(\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{2} \OperatorTok{^}\StringTok{ }\DecValTok{4}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"Hello"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> Error: Hello}
\end{Highlighting}
\end{Shaded}

You could write a similar function if you were trying to find the source
of an annyoing message.

\hypertarget{record}{%
\subsection{Record}\label{record}}

Another common pattern is to record conditions for later investigation.
The new challenge here is that calling handlers are called only for
their side-effects so we can't return values, but instead need to modify
some object in place.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnds <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  conds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  add_cond <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{    conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \}}
  
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{message =}\NormalTok{ add_cond,}
    \DataTypeTok{warning =}\NormalTok{ add_cond,}
\NormalTok{    expr}
\NormalTok{  )}
  
\NormalTok{  conds}
\NormalTok{\}}

\KeywordTok{catch_cnds}\NormalTok{(\{}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"c"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> [[1]]}
\CommentTok{#> <message: a}
\CommentTok{#> >}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> <warning: b>}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> <message: c}
\CommentTok{#> >}
\end{Highlighting}
\end{Shaded}

What if you also want to capture errors? You'll need to wrap the
\texttt{withCallingHandlers()} in a \texttt{tryCatch()}. If an error
occurs, it will be the last condition.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnds <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  conds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  add_cond <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{    conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \}}
  
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{      conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
\NormalTok{    \},}
    \KeywordTok{withCallingHandlers}\NormalTok{(}
      \DataTypeTok{message =}\NormalTok{ add_cond,}
      \DataTypeTok{warning =}\NormalTok{ add_cond,}
\NormalTok{      expr}
\NormalTok{    )}
\NormalTok{  )}
  
\NormalTok{  conds}
\NormalTok{\}}

\KeywordTok{catch_cnds}\NormalTok{(\{}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
  \KeywordTok{abort}\NormalTok{(}\StringTok{"C"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> [[1]]}
\CommentTok{#> <message: a}
\CommentTok{#> >}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> <warning: b>}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> <error>}
\CommentTok{#> * Message: "C"}
\CommentTok{#> * Class: `rlang_error`}
\CommentTok{#> * Backtrace:}
\CommentTok{#>  -local(...)}
\CommentTok{#>  -catch_cnds(...)}
\CommentTok{#>  -withCallingHandlers(message = add_cond, warning = add_cond, expr)}
\end{Highlighting}
\end{Shaded}

This is the key idea underlying the
\href{https://github.com/r-lib/evaluate}{evaluate} package which powers
knitr: it captures every output into a special data structure so that it
can be later replayed. As a whole, the evaluate package is quite a lot
more complicated than the code here because it also needs to handle
plots and text output.

\hypertarget{no-default-behaviour}{%
\subsection{No default behaviour}\label{no-default-behaviour}}

A final useful pattern is to signal a condition that doesn't inherit
from \texttt{message}, \texttt{warning} or \texttt{error}. Because there
is no default behaviour, this means the condition has no effect unless
the user specifically requests it. For example, you could imagine a
logging system based on conditions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(message, }\DataTypeTok{level =} \KeywordTok{c}\NormalTok{(}\StringTok{"info"}\NormalTok{, }\StringTok{"error"}\NormalTok{, }\StringTok{"fatal"}\NormalTok{)) \{}
\NormalTok{  level <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(level)}
  \KeywordTok{signal}\NormalTok{(message, }\StringTok{"log"}\NormalTok{, }\DataTypeTok{level =}\NormalTok{ level)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When you call \texttt{log()} a condition is signalled, but nothing
happens because it has no default handler:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\StringTok{"This code was run"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To ``activate'' logging you need a handler that does something with the
\texttt{log} condition. Below I define a \texttt{record\_log()} function
that will record all logging messages to a path:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{record_log <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{path =} \KeywordTok{stdout}\NormalTok{()) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{log =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \KeywordTok{cat}\NormalTok{(}
        \StringTok{"["}\NormalTok{, cnd}\OperatorTok{$}\NormalTok{level, }\StringTok{"] "}\NormalTok{, cnd}\OperatorTok{$}\NormalTok{message, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{,}
        \DataTypeTok{file =}\NormalTok{ path, }\DataTypeTok{append =} \OtherTok{TRUE}
\NormalTok{      )}
\NormalTok{    \},}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{record_log}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\StringTok{"Hello"}\NormalTok{))}
\CommentTok{#> [info] Hello}
\end{Highlighting}
\end{Shaded}

You could even imagine layering with another function that allows you to
selectively suppress some logging levels.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ignore_log_levels <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, levels) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(}
    \DataTypeTok{log =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \ControlFlowTok{if}\NormalTok{ (cnd}\OperatorTok{$}\NormalTok{level }\OperatorTok{%in%}\StringTok{ }\NormalTok{levels) \{}
        \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{      \}}
\NormalTok{    \},}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{record_log}\NormalTok{(}\KeywordTok{ignore_log_levels}\NormalTok{(}\KeywordTok{log}\NormalTok{(}\StringTok{"Hello"}\NormalTok{), }\StringTok{"info"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

If you create a condition object by hand, and signal it with
\texttt{signalCondition()}, \texttt{cnd\_muffle()} will not work.
Instead you need to call it with a muffle restart defined, like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withRestarts}\NormalTok{(}\KeywordTok{signalCondition}\NormalTok{(cond), }\DataTypeTok{muffle =} \ControlFlowTok{function}\NormalTok{() }\OtherTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Restarts are currently beyond the scope of the book, but I suspect will
be included in the 3rd edition.

\hypertarget{exercises-25}{%
\subsection{Exercises}\label{exercises-25}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create \texttt{suppressConditions()} that works like
  \texttt{suppressMessages()} and \texttt{supressWarnings()} but
  supresses everything. Think carefully about how you should handle
  errors.
\item
  Compare the following two implementations of \texttt{message2error()}.
  What is the main advantage of \texttt{withCallingHandlers()} in this
  scenario? (Hint: look carefully at the traceback.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) }\KeywordTok{stop}\NormalTok{(e))}
\NormalTok{\}}
\NormalTok{message2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) }\KeywordTok{stop}\NormalTok{(e))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  How would you modify the \texttt{catch\_cnds()} definition if you
  wanted to recreate the original intermingling of warnings and
  messages?
\item
  Why is catching interrupts dangerous? Run this code to find out.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bottles_of_beer <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{i =} \DecValTok{99}\NormalTok{) \{}
  \KeywordTok{message}\NormalTok{(}\StringTok{"There are "}\NormalTok{, i, }\StringTok{" bottles of beer on the wall, "}\NormalTok{, i, }\StringTok{" bottles of beer."}\NormalTok{)}
  \ControlFlowTok{while}\NormalTok{(i }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{tryCatch}\NormalTok{(}
      \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{1}\NormalTok{),}
      \DataTypeTok{interrupt =} \ControlFlowTok{function}\NormalTok{(err) \{}
\NormalTok{        i <<-}\StringTok{ }\NormalTok{i }\OperatorTok{-}\StringTok{ }\DecValTok{1}
        \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
          \KeywordTok{message}\NormalTok{(}
            \StringTok{"Take one down, pass it around, "}\NormalTok{, i, }
            \StringTok{" bottle"}\NormalTok{, }\ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{) }\StringTok{"s"}\NormalTok{, }\StringTok{" of beer on the wall."}
\NormalTok{          )}
\NormalTok{        \}}
\NormalTok{      \}}
\NormalTok{    )}
\NormalTok{  \}}
  \KeywordTok{message}\NormalTok{(}\StringTok{"No more bottles of beer on the wall, no more bottles of beer."}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{conditions-answers}{%
\section{Quiz answers}\label{conditions-answers}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{error}, \texttt{warning}, and \texttt{message}.
\item
  You could use \texttt{try()} or \texttt{tryCatch()}.
\item
  \texttt{tryCatch()} creates exiting handlers which will terminate the
  execution of wrapped code; \texttt{withCallingHandlers()} creates
  calling handlers which don't affect the execution of wrapped code.
\item
  Because you can then capture specific types of error with
  \texttt{tryCatch()}, rather than relying on the comparison of error
  strings, which is risky, especially when messages are translated.
\end{enumerate}

\hypertarget{part-functional-programming}{%
\part{Functional
programming}\label{part-functional-programming}}

\hypertarget{fp}{%
\chapter*{Introduction}\label{fp}}
\addcontentsline{toc}{chapter}{Introduction}

\index{functional programming}

R, at its heart, is a \textbf{functional} language. This means that it
has certain technical properties, but more importantly that it lends
itself to a style of problem solving centered on functions. Below I'll
give a brief overview of the technical definition of a functional
\emph{language}, but in this book I will primarily focus on the
functional \emph{style} of programming, because I think it is an
extremely good fit to the types of problem you commonly encounter when
doing data analysis.

Recently, functional techniques have experienced a surge in interest
because they can produce efficient and elegant solutions to many modern
problems. A functional style tends to create functions that can easily
be analysed in isolation (i.e.~using only local information), and hence
is often much easier to automatically optimise or parallelise. The
traditional weaknesses of function languages, poorer performance and
sometimes unpredictable memory usage, have been much reduced in recent
years. Functional programming is complementary to object oriented
programming, which has been the dominant programming paradigm for the
last several decades.

\hypertarget{functional-programming-languages}{%
\section*{Functional programming
languages}\label{functional-programming-languages}}
\addcontentsline{toc}{section}{Functional programming languages}

Every programming language has functions, so what makes a programming
language functional? There are many defintions for precisely what makes
a language ``functional'', but there are two common threads.

Firstly, functional languages have \textbf{first-class functions},
functions that behave like any other data structure. In R, this means
that you can do anything with a function that you can do with a vector:
you can assign them to variables, store them in lists, pass them as
arguments to other functions, create them inside functions, and even
return them as the result of a function.

Secondly, many functional languages require functions to be
\textbf{pure}. A function is pure if it satisfies two properties:

\begin{itemize}
\tightlist
\item
  The output only depends on the inputs, i.e.~if you call it again with
  the same inputs, you get the same outputs. This excludes functions
  like \texttt{runif()}, \texttt{read.csv()}, or \texttt{Sys.time()}
  that can return different values.
\end{itemize}

\begin{itemize}
\tightlist
\item
  The function has no side-effects, like changing the value of a
  variable, writing to disk, or displaying to the screen. This excludes
  functions like \texttt{print()}, \texttt{write.csv()} and
  \texttt{\textless{}-}.
\end{itemize}

Pure functions are much easier to reason about, but obviously have
significant downsides: imagine doing a data analysis where you couldn't
generate random numbers or read files from disk.

Strictly speaking, R isn't a functional programming \emph{language}
because it doesn't require that you write pure functions. However, you
can certainly adopt a functional style in parts of your code: you don't
\emph{have} to write pure functions, but you often \emph{should}. In my
experience, partitioning code into functions that are either extremely
pure and or extremely impure tends to lead to code that is easier to
understand and extend to new situations.

\hypertarget{functional-style}{%
\section*{Functional style}\label{functional-style}}
\addcontentsline{toc}{section}{Functional style}

It's hard to describe exactly what a functional \emph{style} is, but
generally I think it means decomposing a big problem into smaller pieces
then solving each piece with a function or combination of functions.
When using a functional style you strive to decompose components of the
problem into isolated functions that operate independently. Each
function taken by itself is simple and straightforward to understand;
complexity is handled by composing fuctions in various ways.

The following three chapters discuss the three key functional techniques
that help you to decompose problems into smaller pieces:

\begin{itemize}
\item
  Chapter \ref{functionals} shows you how to replace many for loops with
  \textbf{functionals} which are functions (like \texttt{lapply()}) that
  take another function as an argument. Functionals allow you to take a
  function that solves the problem for a single input, and generalise it
  to handle any number of inputs. Functionals are by far and away the
  most important technique, and you'll use them all the time in data
  analysis.
\item
  Chapter \ref{function-factories} introduces \textbf{function
  factories}, functions that create functions. Function factories are
  less useful than functionals, but often allow you elegantly partition
  work between different parts of your code.
\item
  Chapter \ref{function-operators} shows you how to create
  \textbf{function operators}, functions that take functions as input
  and produce functions as output. They are like adverbs, because they
  typically modify the operation of a function.
\end{itemize}

Collectively, these types of function are caled \textbf{higher-order
functions}, and fill out a two-by-two table:

\begin{center}\includegraphics[width=2.95in]{diagrams/fp} \end{center}

\hypertarget{functionals}{%
\chapter{Functionals}\label{functionals}}

\hypertarget{introduction-7}{%
\section{Introduction}\label{introduction-7}}

\index{functionals} \index{for loops}

\begin{quote}
``To become significantly more reliable, code must become more
transparent. In particular, nested conditions and loops must be viewed
with great suspicion. Complicated control flows confuse programmers.
Messy code often hides bugs.''

\hspace*{\fill} --- Bjarne Stroustrup
\end{quote}

A \textbf{functional} is a function that takes a function as an input
and returns a vector as output. Here's a simple functional: it calls the
function provided as input with 1000 random uniform numbers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{randomise <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f) }\KeywordTok{f}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\FloatTok{1e3}\NormalTok{))}
\KeywordTok{randomise}\NormalTok{(mean)}
\CommentTok{#> [1] 0.506}
\KeywordTok{randomise}\NormalTok{(mean)}
\CommentTok{#> [1] 0.501}
\KeywordTok{randomise}\NormalTok{(sum)}
\CommentTok{#> [1] 489}
\end{Highlighting}
\end{Shaded}

The chances are that you've already used a functional. You might have
used for-loop replacement like base R's \texttt{lapply()},
\texttt{apply()}, or \texttt{tapply()}, or maybe purrr's \texttt{map()};
or maybe you've used a mathemetical functional like \texttt{integrate()}
or \texttt{optim()}.

A common use of functionals is as an alternative to for loops. For loops
have a bad rap in R, because many people believe they are slow\footnote{Typically
  it's not the for loop itself that's slow, but what you're doing inside
  of it. A common culprit of slow loops is modifying a data structure,
  where each modification generates a copy. See Section
  \ref{single-binding} for more details.}, but the real downside of for
loops is that they're very flexible, and hence not very expressive. A
for loop conveys that it's iterating over something, but doesn't clearly
convey what you are trying to achieve. Instead of using a for loop, it's
better to use a functional. Each functional is tailored for a specific
task, so when you recognise the functional you immediately know why it's
being used.

Using functionals is a pattern matching exercise. You look at the for
loop, and find a functional that matches the basic form. If one doesn't
exist, don't try and torture an existing functional to fit the form you
need. Instead, just leave it as a for loop! (Or once you've repeated the
same loop two or more times, maybe think about writing your own
functional).

\hypertarget{outline-5}{%
\subsection*{Outline}\label{outline-5}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{map} introduces your first functional:
  \texttt{purrr::map()}.
\item
  Section \ref{purrr-style} demonstrates how you can combine multiple
  simple functional to solve a more complex problem, and discusses how
  purrr style differs from other approaches.
\item
  Section \ref{map-variants} teaches you about 18 (!!) important
  variants of \texttt{purrr::map()}. Fortunately, their orthogonal
  design makes them easy to learn, remember, and master.
\item
  Section \ref{reduce} introduces a new style of functional:
  \texttt{purrr:reduce()}. \texttt{reduce()} systematically reduces a
  vector to a single result by applying a function that takes two
  inputs.
\item
  Section \ref{predicate-functionals} teaches you about predicates,
  functions that return a single \texttt{TRUE} or \texttt{FALSE}, and
  the family of functionals that use them to solve common probelms.
\item
  Section \ref{base-functionals} reviews some functionals in base R that
  are not members of map, reduce, or predicate families.
\end{itemize}

\hypertarget{prerequisites-3}{%
\subsection*{Prerequisites}\label{prerequisites-3}}
\addcontentsline{toc}{subsection}{Prerequisites}

This chapter will focus on functionals provided by the purrr package.
These functions have a consistent interface that makes it easier to
understand the key ideas than their base equivalents, which have grown
organically over many years. I'll compare and contrast base R functions
as we go, and then wrap up the chapter with a discussion of base
functionals that don't have purrr equivalents.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}
\end{Highlighting}
\end{Shaded}

\hypertarget{map}{%
\section{\texorpdfstring{My first functional:
\texttt{map()}}{My first functional: map()}}\label{map}}

\indexc{map()}
\indexc{lapply()}

The most fundamental functional is \texttt{purrr::map()}\footnote{Not to
  be confused with \texttt{base::Map()}, which is considerably more
  complex. I'll discuss \texttt{Map()} in Section \ref{pmap}.}. It takes
a vector and a function, calls the function once for each element of the
vector, and returns the results in a list. In other words,
\texttt{map(1:3,\ f)} is equivalent to
\texttt{list(f(x{[}{[}1{]}{]}),\ f(x{[}{[}2{]}{]}),\ f(x{[}{[}3{]}{]}))}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{triple <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\DecValTok{3}
\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, triple)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 3}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 6}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 9}
\end{Highlighting}
\end{Shaded}

Or, graphically:

\begin{center}\includegraphics[width=2.7in]{diagrams/functionals/map} \end{center}

You might wonder why this function is called \texttt{map()}. What does
it have to do with depicting physical features of land or sea
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f5fa.png}}?
In fact, the meaning comes from mathematics where map refers to ``an
operation that associates each element of a given set with one or more
elements of a second set''. This makes sense here because \texttt{map()}
defines a mapping from one vector to another. (``Map'' also has the nice
property of being short, which is useful for such a fundamental building
block.)

The implementation of \texttt{map()} is quite simple. We allocate a list
the same length as the input, and then fill in the list with a for loop.
A basic implementation is only a handful of lines of code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_map <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f, ...) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{    out[[i]] <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x[[i]], ...)}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The real \texttt{purrr::map()} function has a few differences: it is
written in C to eke out every last iota of performance, preserves names,
and supports a few shortcuts that you'll learn about in Section
\ref{purrr-shortcuts}.

The base equivalent to \texttt{map()} is \texttt{lapply()}. The only
difference is that \texttt{lapply()} does not support the helpers that
you'll learn about below, so if you're only using \texttt{map()} from
purrr, you can skip the additional dependency and use \texttt{lapply()}
directly.

\hypertarget{producing-atomic-vectors}{%
\subsection{Producing atomic vectors}\label{producing-atomic-vectors}}

\texttt{map()} returns a list, which makes it the most general of the
``map'' family because you can put anything in a list. But it is
inconvenient to return a list when a simpler data structure would do, so
there are four more specific variants: \texttt{map\_lgl()},
\texttt{map\_int()}, \texttt{map\_dbl()} and \texttt{map\_chr()}. Each
returns an atomic vector of the specified type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_chr}\NormalTok{(mtcars, typeof)}
\CommentTok{#>      mpg      cyl     disp       hp     drat       wt     qsec }
\CommentTok{#> "double" "double" "double" "double" "double" "double" "double" }
\CommentTok{#>       vs       am     gear     carb }
\CommentTok{#> "double" "double" "double" "double"}

\KeywordTok{map_lgl}\NormalTok{(mtcars, is.double)}
\CommentTok{#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb }
\CommentTok{#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE}

\KeywordTok{map_dbl}\NormalTok{(mtcars, mean)}
\CommentTok{#>     mpg     cyl    disp      hp    drat      wt    qsec      vs }
\CommentTok{#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438 }
\CommentTok{#>      am    gear    carb }
\CommentTok{#>   0.406   3.688   2.812}

\NormalTok{n_unique <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(x))}
\KeywordTok{map_int}\NormalTok{(mtcars, n_unique)}
\CommentTok{#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb }
\CommentTok{#>   25    3   27   22   22   29   30    2    2    3    6}
\end{Highlighting}
\end{Shaded}

purrr generally adopts the convention that suffixes, like
\texttt{\_dbl()}, refer to the output. All \texttt{map\_*()} functions
can take any type of vector as input.

These examples rely on the fact that data frames are lists containing
vectors of the same length. This is more obvious if we draw a data frame
with the same orientation as vector:

\begin{center}\includegraphics[width=3.49in]{diagrams/functionals/map-list} \end{center}

All map functions always return an output vector the same length as the
input. This means that you'll get an error if the function you are
mapping returns multiple results:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pair <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{c}\NormalTok{(x, x)}
\KeywordTok{map_dbl}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, pair)}
\CommentTok{#> Error: Result 1 is not a length 1 atomic vector}
\end{Highlighting}
\end{Shaded}

When debugging problems like this, it's often useful to switch back to
\texttt{map()} so you can see what the problematic output is.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, pair)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 1 1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 2 2}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 3 3}
\end{Highlighting}
\end{Shaded}

Base R has two apply functions that can return atomic vectors:
\texttt{sapply()} and \texttt{vapply()}.

\texttt{sapply()} tries to simplify the result to an atomic vector
wherever possible. But this simplification depends on the result, so
sometimes you'll get a list, sometimes a vector, and sometimes a matrix.
This makes it difficult to program with, and it should be avoided in
non-interactive settings.

\texttt{vapply()} allows you to provide a template, \texttt{FUN.VALUE},
that describes the output shape. If you want to use only base R code you
should always use \texttt{vapply()} in your functions, not
\texttt{sapply()}. The primary downside of \texttt{vapply()} is its
vebosity: the equivalent to \texttt{map\_dbl(x,\ mean,\ na.rm\ =\ TRUE)}
is \texttt{vapply(x,\ mean,\ na.rm\ =\ TRUE,\ FUN.VALUE\ =\ double(1))}.

\hypertarget{purrr-shortcuts}{%
\subsection{Anonymous functions and shortcuts}\label{purrr-shortcuts}}

Instead of using \texttt{map()} with an existing function, you can
create an inline anonymous function (as mentioned in Section
\ref{first-class-functions}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(mtcars, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(x)))}
\CommentTok{#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb }
\CommentTok{#>   25    3   27   22   22   29   30    2    2    3    6}
\end{Highlighting}
\end{Shaded}

Anonymous functions are very useful, but the syntax is verbose. So purrr
supports a special shortcut:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(mtcars, }\OperatorTok{~}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(.x)))}
\CommentTok{#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb }
\CommentTok{#>   25    3   27   22   22   29   30    2    2    3    6}
\end{Highlighting}
\end{Shaded}

This works because all purrr functions translate formulas, created by
\texttt{\textasciitilde{}} (pronouned ``twiddle''), into functions. You
can see what's happening behind the scenes by calling
\texttt{as\_mapper()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_mapper}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(.x)))}
\CommentTok{#> <lambda>}
\CommentTok{#> function (..., .x = ..1, .y = ..2, . = ..1) }
\CommentTok{#> length(unique(.x))}
\CommentTok{#> attr(,"class")}
\CommentTok{#> [1] "rlang_lambda_function"}
\end{Highlighting}
\end{Shaded}

The function arguments look a little quirky but allow you to refer to
\texttt{.} for one argument functions, \texttt{.x} and \texttt{.y.} for
two argument functions, and \texttt{..1}, \texttt{..2}, \texttt{..3},
etc, for functions with an arbitrary number of arguments. \texttt{.}
remains for backward compatiblity but I don't recommend using it because
it's easily confused with the \texttt{.} use by magrittr's pipe.

This shortcut is particularly useful for generating random data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\KeywordTok{str}\NormalTok{(x)}
\CommentTok{#> List of 3}
\CommentTok{#>  $ : num [1:2] 0.281 0.53}
\CommentTok{#>  $ : num [1:2] 0.433 0.917}
\CommentTok{#>  $ : num [1:2] 0.0275 0.8249}
\end{Highlighting}
\end{Shaded}

Reserve this syntax for short and simple functions. A good rule of thumb
is that if your function spans lines or uses \texttt{\{\}}, it's time to
give it a name.

The map functions also have shortcuts for extracting elements from a
vector, powered by \texttt{purrr::pluck()}. You can use a character
vector to select elements by name, an integer vector to select by
position, or a list to select by both name and position. These are very
useful for working with deeply nested lists, which often arise when
working with JSON.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{), }\DataTypeTok{z =} \StringTok{"a"}\NormalTok{),}
  \KeywordTok{list}\NormalTok{(}\OperatorTok{-}\DecValTok{2}\NormalTok{, }\DataTypeTok{x =} \DecValTok{4}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DataTypeTok{z =} \StringTok{"b"}\NormalTok{),}
  \KeywordTok{list}\NormalTok{(}\OperatorTok{-}\DecValTok{3}\NormalTok{, }\DataTypeTok{x =} \DecValTok{8}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{11}\NormalTok{))}
\NormalTok{)}

\CommentTok{# Select by name}
\KeywordTok{map_dbl}\NormalTok{(x, }\StringTok{"x"}\NormalTok{)}
\CommentTok{#> [1] 1 4 8}

\CommentTok{# Or by position}
\KeywordTok{map_dbl}\NormalTok{(x, }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] -1 -2 -3}

\CommentTok{# Or by both}
\KeywordTok{map_dbl}\NormalTok{(x, }\KeywordTok{list}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] 2 5 9}

\CommentTok{# You'll get an error if a component doesn't exist:}
\KeywordTok{map_chr}\NormalTok{(x, }\StringTok{"z"}\NormalTok{)}
\CommentTok{#> Error: Result 3 is not a length 1 atomic vector}

\CommentTok{# Unless you supply a .default value}
\KeywordTok{map_chr}\NormalTok{(x, }\StringTok{"z"}\NormalTok{, }\DataTypeTok{.default =} \OtherTok{NA}\NormalTok{)}
\CommentTok{#> [1] "a" "b" NA}
\end{Highlighting}
\end{Shaded}

In base R functions, like \texttt{lapply()}, you can provide the name of
the function as a string. This isn't tremendously useful as
\texttt{lapply(x,\ "f")} is almost always equivalent to
\texttt{lapply(x,\ f)} and is more typing.

\hypertarget{passing-arguments}{%
\subsection{\texorpdfstring{Passing arguments with
\texttt{...}}{Passing arguments with ...}}\label{passing-arguments}}

It's often convenient to pass along additional arguments to the function
that you're calling. For example, you might want to pass
\texttt{na.rm\ =\ TRUE} along to \texttt{mean()}. One way to do that is
with an anonymous function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\KeywordTok{map_dbl}\NormalTok{(x, }\OperatorTok{~}\StringTok{ }\KeywordTok{mean}\NormalTok{(.x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> [1] 3.0 5.5}
\end{Highlighting}
\end{Shaded}

But because the map functions pass \texttt{...} along, there's a simpler
form available:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(x, mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 3.0 5.5}
\end{Highlighting}
\end{Shaded}

This is easiest to understand with a picture: any arguments that come
after \texttt{f} in the call to \texttt{map()} are inserted \emph{after}
the data in individual calls to \texttt{f()}:

\begin{center}\includegraphics[width=3.74in]{diagrams/functionals/map-arg} \end{center}

It's important to note that these arguments are not decomposed; or said
another way, \texttt{map()} is only vectorised over its first argument.
If an argument after \texttt{f} is a vector, it will be passed along as
is:

\begin{center}\includegraphics[width=3.59in]{diagrams/functionals/map-arg-recycle} \end{center}

(You'll learn about map variants that \emph{are} vectorised over
multiple arguments in Sections \ref{map2} and \ref{pmap}.)

Note there's a subtle difference between placing extra arguments inside
an anonymous function compared with passing them to \texttt{map()}.
Putting them in an anonymous function means that they will be evaluated
every time \texttt{f()} is executed, not just once when you call
\texttt{map()}. This is easiest to see if we make the additional
argument random:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plus <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) x }\OperatorTok{+}\StringTok{ }\NormalTok{y}

\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\KeywordTok{map_dbl}\NormalTok{(x, plus, }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] 0.0625 0.0625 0.0625 0.0625}
\KeywordTok{map_dbl}\NormalTok{(x, }\OperatorTok{~}\StringTok{ }\KeywordTok{plus}\NormalTok{(.x, }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] 0.903 0.132 0.629 0.945}
\end{Highlighting}
\end{Shaded}

\hypertarget{argument-names}{%
\subsection{Argument names}\label{argument-names}}

In the diagrams, I've omitted argument names to focus on the overall
structure. But I recommend writing out the full names in your code, as
it makes it easier to read. \texttt{map(x,\ mean,\ 0.1)} is perfectly
valid code, but will call \texttt{mean(x{[}{[}1{]}{]},\ 0.1)} so it
relies on the reader remembering that the second argument to
\texttt{mean()} is \texttt{trim}. To avoid unnecesary burden on the
brain of the reader\footnote{Who is highly likely to be future you!}, be
kind and write \texttt{map(x,\ mean,\ trim\ =\ 0.1)}.

This is the reason why the arguments to \texttt{map()} are a little odd:
instead of being \texttt{x} and \texttt{f}, they are \texttt{.x} and
\texttt{.f}. It's easiest to see the problem that leads to these names
using \texttt{simple\_map()} defined above. \texttt{simple\_map()} has
arguments \texttt{x} and \texttt{f} so you'll have problems whenever the
function you are calling has arguments \texttt{x} or \texttt{f}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boostrap_summary <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
  \KeywordTok{f}\NormalTok{(}\KeywordTok{sample}\NormalTok{(x, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{simple_map}\NormalTok{(mtcars, boostrap_summary, }\DataTypeTok{f =}\NormalTok{ mean)}
\CommentTok{#> Error in mean.default(x[[i]], ...):}
\CommentTok{#>   'trim' must be numeric of length one}
\end{Highlighting}
\end{Shaded}

The error is a little bewildering until you remember that the call to
\texttt{simple\_map()} is equivalent to
\texttt{simple\_map(x\ =\ mtcars,\ f\ =\ mean,\ bootstrap\_summary)}
because named matching beats positional matching.

purrr functions reduce the likelihood of such a clash by using
\texttt{.f} and \texttt{.x} instead of the more common \texttt{f} and
\texttt{x}. Of course this technique isn't perfect (because the function
you are calling might still use \texttt{.f} and \texttt{.x}), but it
avoids 99\% of issues. The remaining 1\% of the time, use an anonymous
function.

Base functions that pass along \texttt{...} use a variety of naming
conventions to prevent undesired argument matching:

\begin{itemize}
\item
  The apply family mostly uses capital letters (e.g. \texttt{X} and
  \texttt{FUN}).
\item
  \texttt{transform()} uses the more exotic prefix \texttt{\_}: this
  makes the name non-syntactic so it must always be surrounded in
  \texttt{\textasciigrave{}}, as described in Section
  \ref{non-syntactic}. This makes undesired matches extremely unlikely.
\item
  Other functionals like \texttt{uniroot()} and \texttt{optim()} make no
  effort to avoid clashes but they tend to be used with specially
  created functions so clashes are less likely.
\end{itemize}

\hypertarget{change-argument}{%
\subsection{Varying another argument}\label{change-argument}}

So far the first argument to \texttt{map()} has always become the first
argument to the function. But what happens if the first argument should
be constant, and you want to vary a different argument? How do you get
the result in this picture?

\begin{center}\includegraphics[width=3.74in]{diagrams/functionals/map-arg-flipped} \end{center}

It turns out that there's no way to do it directly, but there are two
tricks you can use instead. To illustrate them, imagine I have a vector
that contains a few unusual values, and I want to explore the effect of
different amounts of trimming when computing the mean. In this case, the
first argument to \texttt{mean()} will be constant, and I want to vary
the second argument, \texttt{trim}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trims <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.5}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\KeywordTok{rcauchy}\NormalTok{(}\DecValTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  The simplest technique is to use an anonymous function to rearrange
  the argument order:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(trims, }\OperatorTok{~}\StringTok{ }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{trim =}\NormalTok{ .x))}
\CommentTok{#> [1] -0.3500  0.0434  0.0354  0.0502}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\begin{itemize}
\item
  Sometimes, if you want to be (too) clever, you can take advantage of
  R's flexible argument matching rules (as described in Section
  \ref{prefix-form}). For example, in this example you can rewrite
  \texttt{mean(x,\ trim\ =\ 0.1)} as \texttt{mean(0.1,\ x\ =\ x)}, so
  you could write the call to \texttt{map\_dbl()} as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(trims, mean, }\DataTypeTok{x =}\NormalTok{ x)}
\CommentTok{#> [1] -0.3500  0.0434  0.0354  0.0502}
\end{Highlighting}
\end{Shaded}

  I don't recommend this technique as it relies on the reader being very
  familiar with both the argument order to \texttt{.f}, and R's argument
  matching rules.
\end{itemize}

You'll see one more alternative in Section \ref{pmap}.

\hypertarget{exercises-26}{%
\subsection{Exercises}\label{exercises-26}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Use \texttt{as\_mapper()} to explore how purrr generates anonymous
  functions for the integer, character, and list helpers. What helper
  allows you to extract attributes? Read the documentation to find out.
\item
  \texttt{map(1:3,\ \textasciitilde{}\ runif(2))} is a useful pattern
  for generating random numbers, but \texttt{map(1:3,\ runif(2))} is
  not. Why not? Can you explain why it returns the result that it does?
\item
  Use the appropriate \texttt{map()} function to:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii})}
  \item
    Compute the standard deviation of every column in a numeric data
    frame.
  \item
    Compute the standard deviation of every numeric column in a mixed
    data frame. (Hint: you'll need to do it in two steps.)
  \item
    Compute the number of levels for every factor in a data frame.
  \end{enumerate}
\item
  The following code simulates the performance of a t-test for
  non-normal data. Extract the p-value from each test, then visualise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trials <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{t.test}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{), }\KeywordTok{rpois}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{10}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}
\item
  The following code uses a map nested inside another map to apply a
  function to every element of a nested list. Why does it fail, and what
  do you need to do to make it work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)),}
  \KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DecValTok{7}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{)}

\NormalTok{triple <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\DecValTok{3}
\KeywordTok{map}\NormalTok{(x, map, }\DataTypeTok{.f =}\NormalTok{ triple)}
\CommentTok{#> Error in .f(.x[[i]], ...):}
\CommentTok{#>   unused argument (map)}
\end{Highlighting}
\end{Shaded}
\item
  Use \texttt{map()} to fit linear models to the \texttt{mtcars} dataset
  using the formulas stored in this list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{formulas <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp,}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp),}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp }\OperatorTok{+}\StringTok{ }\NormalTok{wt,}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp) }\OperatorTok{+}\StringTok{ }\NormalTok{wt}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Fit the model \texttt{mpg\ \textasciitilde{}\ disp} to each of the
  bootstrap replicates of \texttt{mtcars} in the list below, then
  extract the \(R^2\) of the model fit (Hint: you can compute the
  \(R^2\) with \texttt{summary()})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bootstrap <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df) \{}
\NormalTok{  df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}

\NormalTok{bootstraps <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{bootstrap}\NormalTok{(mtcars))}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{purrr-style}{%
\section{Purrr style}\label{purrr-style}}

Before we go on to explore more map variants, let's take a quick look at
how you tend to use multiple purrr functions to solve a moderately
realistic problem: fitting a model to each subgroup and extracting a
coefficient of the model. For this toy example, I'm going to break the
\texttt{mtcars} data set down into groups defined by the number of
cylinders, using the base \texttt{split} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{by_cyl <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\end{Highlighting}
\end{Shaded}

Now imagine we want to fit a linear model, then extract the second
coefficient (i.e.~the intercept). The following code shows how you might
do that with purrr:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{by_cyl }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ .x)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(coef) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{map_dbl}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{#>     4     6     8 }
\CommentTok{#> -5.65 -2.78 -2.19}
\end{Highlighting}
\end{Shaded}

(If you haven't seen \texttt{\%\textgreater{}\%}, the pipe, before, it's
described in Section \ref{function-composition}.)

I think this code is easy to read because each line encapsulates a
single step, you can easily distinguish the functional from what it
does, and the purrr helpers allow us to very concisely describe what to
do in each step.

How would you attack this problem with base R? You certainly
\emph{could} replace each purrr function with the equivalent base
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{by_cyl }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{lapply}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(data) }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ data)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{lapply}\NormalTok{(coef) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{vapply}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) x[[}\DecValTok{2}\NormalTok{]], }\KeywordTok{double}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#>     4     6     8 }
\CommentTok{#> -5.65 -2.78 -2.19}
\end{Highlighting}
\end{Shaded}

But this isn't really base R since we're using the pipe. To tackle
purely in base I think you'd use an intermediate variable, and do more
in each step:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{models <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(by_cyl, }\ControlFlowTok{function}\NormalTok{(data) }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ data))}
\KeywordTok{vapply}\NormalTok{(models, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{coef}\NormalTok{(x)[[}\DecValTok{2}\NormalTok{]], }\KeywordTok{double}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#>     4     6     8 }
\CommentTok{#> -5.65 -2.78 -2.19}
\end{Highlighting}
\end{Shaded}

Or, of course, you could use a for loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{intercepts <-}\StringTok{ }\KeywordTok{double}\NormalTok{(}\KeywordTok{length}\NormalTok{(by_cyl))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(by_cyl)) \{}
\NormalTok{  model <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ by_cyl[[i]])}
\NormalTok{  intercepts[[i]] <-}\StringTok{ }\KeywordTok{coef}\NormalTok{(model)[[}\DecValTok{2}\NormalTok{]]}
\NormalTok{\}}
\NormalTok{intercepts}
\CommentTok{#> [1] -5.65 -2.78 -2.19}
\end{Highlighting}
\end{Shaded}

It's interesting to note that as you move from purrr to base apply
functions to for loops you tend to do more and more in each iteration.
In purrr we iterate 3 times (\texttt{map()}, \texttt{map()},
\texttt{map\_dbl()}), with apply functions we iterate twice
(\texttt{lapply()}, \texttt{vapply()}), and with a for loop we iterate
once. I prefer more, but simpler, steps because I think it makes the
code understand and later modify.

\hypertarget{map-variants}{%
\section{Map variants}\label{map-variants}}

There are 23 primary variants of \texttt{map()}. So far, you've learned
about five (\texttt{map()}, \texttt{map\_lgl()}, \texttt{map\_int()},
\texttt{map\_dbl()} and \texttt{map\_chr()}). That means that you've got
18 (!!) more to learn. That sounds like a lot, but fortunately the
design of purrr means that you only need to learn five new ideas:

\begin{itemize}
\tightlist
\item
  Output same type as input with \texttt{modify()}
\item
  Iterate over two inputs with \texttt{map2()}.
\item
  Iterate with an index using \texttt{imap()}
\item
  Return nothing with \texttt{walk()}.
\item
  Iterate over any number of inputs with \texttt{pmap()}.
\end{itemize}

The map family of functions has orthogonal input and outputs, meaning
that we can organise all the family into a matrix, with inputs in the
rows and outputs in the columns. Once you've mastered the idea in a row,
you can combine it with any column; once you've mastered the idea in a
column, you can combine it with any row.

\begin{longtable}[]{@{}lllll@{}}
\toprule
& List & Atomic & Same type & Nothing\tabularnewline
\midrule
\endhead
One argument & \texttt{map()} & \texttt{map\_lgl()}, \ldots{} &
\texttt{modify()} & \texttt{walk()}\tabularnewline
Two arguments & \texttt{map2()} & \texttt{map2\_lgl()}, \ldots{} &
\texttt{modify2()} & \texttt{walk2()}\tabularnewline
One argument + index & \texttt{imap()} & \texttt{imap\_lgl()}, \ldots{}
& \texttt{imodify()} & \texttt{iwalk()}\tabularnewline
N arguments & \texttt{pmap()} & \texttt{pmap\_lgl()}, \ldots{} & --- &
\texttt{pwalk()}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{modify}{%
\subsection{\texorpdfstring{Same type of output as input:
\texttt{modify()}}{Same type of output as input: modify()}}\label{modify}}

\indexc{modify()}

Imagine you wanted to double every column in a data frame. You might
first try using \texttt{map()}, but \texttt{map()} always returns a
list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{y =} \DecValTok{6}\OperatorTok{:}\DecValTok{4}
\NormalTok{)}

\KeywordTok{map}\NormalTok{(df, }\OperatorTok{~}\StringTok{ }\NormalTok{.x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> $x}
\CommentTok{#> [1] 2 4 6}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> [1] 12 10  8}
\end{Highlighting}
\end{Shaded}

If you want to keep the output as a data frame, you can use
\texttt{modify()}, which always returns the same type of output as the
input:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{modify}\NormalTok{(df, }\OperatorTok{~}\StringTok{ }\NormalTok{.x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#>   x  y}
\CommentTok{#> 1 2 12}
\CommentTok{#> 2 4 10}
\CommentTok{#> 3 6  8}
\end{Highlighting}
\end{Shaded}

Despite the name, \texttt{modify()} doesn't modify in place, it returns
a modified copy, so if you wanted to permanently modify \texttt{df},
you'd need to assign it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{modify}\NormalTok{(df, }\OperatorTok{~}\StringTok{ }\NormalTok{.x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

As usual, the basic implementation of \texttt{modify()} is simple, and
in fact it's even simpler than \texttt{map()} because we don't need to
create a new output vector; we can just progressively replace the input.
(The real code is a little complex to handle edge cases more
gracefully.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_modify <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f, ...) \{}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{    x[[i]] <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x[[i]], ...)}
\NormalTok{  \}}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In Section \ref{predicate-map} you'll learn about a very useful variant
of \texttt{modify()}, called \texttt{modify\_if()}. This allows you to
(e.g.) only double \emph{numeric} columns of a data frame with
\texttt{modify\_if(df,\ is.numeric,\ \textasciitilde{}\ .x\ *\ 2)}.

\hypertarget{map2}{%
\subsection{\texorpdfstring{Two inputs: \texttt{map2()} and
friends}{Two inputs: map2() and friends}}\label{map2}}

\indexc{map2()}

\texttt{map()} is vectorised over a single argument, \texttt{.x}. This
means it only varies \texttt{.x} when calling \texttt{.f}, and all other
arguments are passed along unchanged, thus making it poorly suited for
some problems. For example, how would you find a weighted mean when you
have a list of observations and a list of weights? Imagine we have the
following data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xs <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{8}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\NormalTok{xs[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{ws <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{8}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{) }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can use \texttt{map\_dbl()} to compute the unweighted means:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(xs, mean)}
\CommentTok{#> [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443}
\end{Highlighting}
\end{Shaded}

But passing \texttt{ws} as an additional argument doesn't work because
arguments after \texttt{.f} are not transformed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(xs, weighted.mean, }\DataTypeTok{w =}\NormalTok{ ws)}
\CommentTok{#> Error in weighted.mean.default(.x[[i]], ...):}
\CommentTok{#>   'x' and 'w' must have the same length}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.59in]{diagrams/functionals/map-arg-recycle} \end{center}

We need a new tool: a \texttt{map2()}, which is vectorised over two
arguments. This means both \texttt{.x} and \texttt{.y} are varied in
each call to \texttt{.f}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map2_dbl}\NormalTok{(xs, ws, weighted.mean)}
\CommentTok{#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.84in]{diagrams/functionals/map2} \end{center}

The arguments to \texttt{map2()} are slightly different to the arguments
to \texttt{map()} as two vectors come before the function, rather than
one. Additional arguments still go afterwards:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map2_dbl}\NormalTok{(xs, ws, weighted.mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.72in]{diagrams/functionals/map2-arg} \end{center}

The basic implementation of \texttt{map2()} is simple, and quite similar
to that of \texttt{map()}. Instead of iterating over one vector, we
iterate over two in parallel:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_map2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y, f, ...) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(xs))}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{    out[[i]] <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x[[i]], y[[i]], ...)}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

One of the big differences between \texttt{map2()} and the simple
function above is that \texttt{map2()} recycles its inputs to make sure
that they're the same length:

\begin{center}\includegraphics[width=3.84in]{diagrams/functionals/map2-recycle} \end{center}

In other words, \texttt{map2(x,\ y,\ f)} will automatically behave like
\texttt{map(x,\ f,\ y)} when needed. This is helpful when writing
functions; in scripts you'd generally just use the simpler form
directly.

The closest base equivalent to \texttt{map2()} is \texttt{Map()}, which
is discussed in Section \ref{pmap}.

\hypertarget{no-outputs-walk-and-friends}{%
\subsection{\texorpdfstring{No outputs: \texttt{walk()} and
friends}{No outputs: walk() and friends}}\label{no-outputs-walk-and-friends}}

\indexc{walk()}
\indexc{walk2()}

Most functions are called for the value that they return, so it makes
sense to capture and store it with a \texttt{map()} function. But some
functions are called primarily for their side-effects (e.g.
\texttt{cat()}, \texttt{write.csv()}, or \texttt{ggsave()}) and it
doesn't make sense to capture their results. Take this simple example
that displays a welcome message using \texttt{cat()}. \texttt{cat()}
returns \texttt{NULL}, so while map works (in the sense that it
generates the desired welcomes), it also returns
\texttt{list(NULL,\ NULL)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{welcome <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"Welcome "}\NormalTok{, x, }\StringTok{"!}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}
\NormalTok{names <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{, }\StringTok{"Jenny"}\NormalTok{)}

\CommentTok{# As well as generate the welcomes, it also shows }
\CommentTok{# the return value of cat()}
\KeywordTok{map}\NormalTok{(names, welcome)}
\CommentTok{#> Welcome Hadley!}
\CommentTok{#> Welcome Jenny!}
\CommentTok{#> [[1]]}
\CommentTok{#> NULL}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

You could avoid this problem by assigning the results of \texttt{map()}
to a variable that you never use, but that would muddy the intent of the
code. Instead, purrr provides the walk family of functions that ignore
the return values of the \texttt{.f} and instead return \texttt{.x}
invisibly\footnote{In brief, invisible values are only printed if you
  explicitly request it. This makes them well suited for functions
  called primarily for their side-effects, as it allows their output to
  be ignored by default, while still giving an option to capture it. See
  Section \ref{invisible-values} for more details.}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{walk}\NormalTok{(names, welcome)}
\CommentTok{#> Welcome Hadley!}
\CommentTok{#> Welcome Jenny!}
\end{Highlighting}
\end{Shaded}

My visual depiction of walk attempts to capture the important difference
from \texttt{map()}: the outputs are ephemeral, and the input is
returned invisibly.

\begin{center}\includegraphics[width=2.46in]{diagrams/functionals/walk} \end{center}

One of the most useful \texttt{walk()} variants is \texttt{walk2()}
because a very common side-effect is saving something to disk, and when
saving something to disk you always have a pair of values: the object
and the path that you want to save it to.

\begin{center}\includegraphics[width=3.3in]{diagrams/functionals/walk2} \end{center}

For example, imagine you have a list of data frames (which I've created
here using split), and you'd like to save each one to a separate CSV
file. That's easy with \texttt{walk2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\KeywordTok{dir.create}\NormalTok{(temp)}

\NormalTok{cyls <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\NormalTok{paths <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, }\KeywordTok{names}\NormalTok{(cyls), }\StringTok{".csv"}\NormalTok{))}
\KeywordTok{walk2}\NormalTok{(cyls, paths, write.csv)}

\KeywordTok{dir}\NormalTok{(temp)}
\CommentTok{#> [1] "cyl-4.csv" "cyl-6.csv" "cyl-8.csv"}
\end{Highlighting}
\end{Shaded}

Here the \texttt{walk2()} is equivalent to
\texttt{write.csv(cyls{[}{[}1{]}{]},\ paths{[}{[}1{]}{]})},
\texttt{write.csv(cyls{[}{[}2{]}{]},\ paths{[}{[}2{]}{]})},
\texttt{write.csv(cyls{[}{[}3{]}{]},\ paths{[}{[}3{]}{]})}.

There is no base equivalent to \texttt{walk()}; either wrap the result
of \texttt{lapply()} in \texttt{invisible()} or save it to a variable
that is never used.

\hypertarget{iterating-over-values-and-indices}{%
\subsection{Iterating over values and
indices}\label{iterating-over-values-and-indices}}

\indexc{imap()}

\index{loops!common patterns}

There are three basic ways to loop over a vector with a for loop:

\begin{itemize}
\tightlist
\item
  Loop over the elements: \texttt{for\ (x\ in\ xs)}
\item
  Loop over the numeric indices: \texttt{for\ (i\ in\ seq\_along(xs))}
\item
  Loop over the names: \texttt{for\ (nm\ in\ names(xs))}
\end{itemize}

The first form is analogous to the \texttt{map()} family. The second and
third forms are equivalent to the \texttt{imap()} family which allows
you to iterate over the values and the indices of a vector in parallel.

\texttt{imap()} is like \texttt{map2()} in the sense that your
\texttt{.f} gets called with two arguments, but here both are derived
from the vector. \texttt{imap(x,\ f)} is equivalent to
\texttt{map2(x,\ names(x),\ f)} if x has names, and
\texttt{map2(x,\ seq\_along(x),\ f)} if it does not.

\texttt{imap()} is often useful for constructing labels:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{imap_chr}\NormalTok{(iris, }\OperatorTok{~}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"The first value of "}\NormalTok{, .y, }\StringTok{" is "}\NormalTok{, .x[[}\DecValTok{1}\NormalTok{]]))}
\CommentTok{#>                             Sepal.Length }
\CommentTok{#> "The first value of Sepal.Length is 5.1" }
\CommentTok{#>                              Sepal.Width }
\CommentTok{#>  "The first value of Sepal.Width is 3.5" }
\CommentTok{#>                             Petal.Length }
\CommentTok{#> "The first value of Petal.Length is 1.4" }
\CommentTok{#>                              Petal.Width }
\CommentTok{#>  "The first value of Petal.Width is 0.2" }
\CommentTok{#>                                  Species }
\CommentTok{#>   "The first value of Species is setosa"}
\end{Highlighting}
\end{Shaded}

If the vector is unnamed, the second argument will be the index:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\KeywordTok{imap_chr}\NormalTok{(x, }\OperatorTok{~}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"The highest value of "}\NormalTok{, .y, }\StringTok{" is "}\NormalTok{, }\KeywordTok{max}\NormalTok{(.x)))}
\CommentTok{#> [1] "The highest value of 1 is 885" "The highest value of 2 is 808"}
\CommentTok{#> [3] "The highest value of 3 is 942" "The highest value of 4 is 966"}
\CommentTok{#> [5] "The highest value of 5 is 857" "The highest value of 6 is 671"}
\end{Highlighting}
\end{Shaded}

\texttt{imap()} is a useful helper if you want to work with the values
in a vector along with their positions.

\hypertarget{pmap}{%
\subsection{\texorpdfstring{Any number of inputs: \texttt{pmap()} and
friends}{Any number of inputs: pmap() and friends}}\label{pmap}}

\indexc{pmap()}
\indexc{Map()}
\indexc{mapply()}

Since we have \texttt{map()} and \texttt{map2()}, you might expect
\texttt{map3()}, \texttt{map4()}, \texttt{map5()}, \ldots{} But where
would you stop? Instead of generalising \texttt{map2()} to an arbitrary
number of arguments, purrr takes a slightly different tack with
\texttt{pmap()}: you supply it a single list, which contains any number
of arguments. In most cases, that will be a list of equal-length
vectors, i.e.~something very similar to a data frame. In diagrams, I'll
emphasise that relationship by drawing the input similar to a data
frame.

\begin{center}\includegraphics[width=3.64in]{diagrams/functionals/pmap} \end{center}

There's a simple equivalence between \texttt{map2()} and
\texttt{pmap()}: \texttt{map2(x,\ y,\ f)} is the same as
\texttt{pmap(list(x,\ y),\ f)}. The \texttt{pmap()} equivalent to the
\texttt{map2\_dbl(xs,\ ws,\ weighted.mean)} used above is:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pmap_dbl}\NormalTok{(}\KeywordTok{list}\NormalTok{(xs, ws), weighted.mean)}
\CommentTok{#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464}
\end{Highlighting}
\end{Shaded}

As before, the varying arguments come before \texttt{.f} (although now
they must be wrapped in a list), and the constant arguments come
afterwards.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pmap_dbl}\NormalTok{(}\KeywordTok{list}\NormalTok{(xs, ws), weighted.mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.77in]{diagrams/functionals/pmap-arg} \end{center}

A big difference between \texttt{pmap()} and the other map functions is
that \texttt{pmap()} gives you much finer control over argument matching
because you can name the components of the list. Returning to our
example from Section \ref{change-argument}, where we wanted to vary the
\texttt{trim} argument to \texttt{x}, we could instead use
\texttt{pmap()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trims <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.5}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\KeywordTok{rcauchy}\NormalTok{(}\DecValTok{1000}\NormalTok{)}

\KeywordTok{pmap_dbl}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{trim =}\NormalTok{ trims), mean, }\DataTypeTok{x =}\NormalTok{ x)}
\CommentTok{#> [1] -6.6754  0.0192  0.0228  0.0151}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.67in]{diagrams/functionals/pmap-3} \end{center}

I think it's good practice to name the list to make it very clear how
the function will be called.

It's often convenient to call \texttt{pmap()} with a data frame. A handy
way to create that data frame is with \texttt{tibble::tribble()}, which
allows you to describe a data frame row-by-row (rather than
column-by-column, as usual): thinking about the parameters to a function
as a data frame is a very powerful pattern. The following example shows
how you might draw random uniform numbers with varying parameters:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{params <-}\StringTok{ }\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tribble}\NormalTok{(}
  \OperatorTok{~}\StringTok{ }\NormalTok{n, }\OperatorTok{~}\StringTok{ }\NormalTok{min, }\OperatorTok{~}\StringTok{ }\NormalTok{max,}
\NormalTok{   1L,     }\DecValTok{0}\NormalTok{,     }\DecValTok{1}\NormalTok{,}
\NormalTok{   2L,    }\DecValTok{10}\NormalTok{,   }\DecValTok{100}\NormalTok{,}
\NormalTok{   3L,   }\DecValTok{100}\NormalTok{,  }\DecValTok{1000}
\NormalTok{)}

\KeywordTok{pmap}\NormalTok{(params, runif)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 0.718}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 19.5 39.9}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 535 476 231}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.67in]{diagrams/functionals/pmap-3} \end{center}

Here, the column names are critical: I've carefully chosen to match them
to the arguments to \texttt{runif()}, so the
\texttt{pmap(params,\ runif)} is equivalent to
\texttt{runif(n\ =\ 1L,\ min\ =\ 0,\ max\ =\ 1)},
\texttt{runif(n\ =\ 2,\ min\ =\ 10,\ max\ =\ 100)},
\texttt{runif(n\ =\ 3L,\ min\ =\ 100,\ max\ =\ 1000)}. (If you have a
data frame in hand, and the names don't match, use
\texttt{dplyr::rename()} or similar.)

There are two base equivalents to the \texttt{pmap()} family:
\texttt{Map()} and \texttt{mapply()}. Both have significant drawbacks:

\begin{itemize}
\item
  \texttt{Map()} vectorises over all arguments so you cannot supply
  arguments that do not vary.
\item
  \texttt{mapply()} is the multidimensional version of
  \texttt{sapply()}; conceptually it takes the output of \texttt{Map()}
  and simplifies it if possible. This gives it similar issues to
  \texttt{sapply()}. There is no multi-input equivalent of
  \texttt{vapply()}.
\end{itemize}

\hypertarget{exercises-27}{%
\subsection{Exercises}\label{exercises-27}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Explain the results of \texttt{modify(mtcars,\ 1)}.
\item
  Rewrite the following code to use \texttt{iwalk()} instead of
  \texttt{walk2()}. What are the advantages and disadvantages?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cyls <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\NormalTok{paths <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, }\KeywordTok{names}\NormalTok{(cyls), }\StringTok{".csv"}\NormalTok{))}
\KeywordTok{walk2}\NormalTok{(cyls, paths, write.csv)}
\end{Highlighting}
\end{Shaded}
\item
  Explain how the following code transforms a data frame using functions
  stored in a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trans <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{disp =} \ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\FloatTok{0.0163871}\NormalTok{,}
  \DataTypeTok{am =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{factor}\NormalTok{(x, }\DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"auto"}\NormalTok{, }\StringTok{"manual"}\NormalTok{))}
\NormalTok{)}

\NormalTok{vars <-}\StringTok{ }\KeywordTok{names}\NormalTok{(trans)}
\NormalTok{mtcars[vars] <-}\StringTok{ }\KeywordTok{map2}\NormalTok{(trans, mtcars[vars], }\ControlFlowTok{function}\NormalTok{(f, var) }\KeywordTok{f}\NormalTok{(var))}
\end{Highlighting}
\end{Shaded}

  Compare and constrast the \texttt{map2()} approach to this
  \texttt{map()} approach:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[vars] <-}\StringTok{ }\KeywordTok{map}\NormalTok{(vars, }\OperatorTok{~}\StringTok{ }\NormalTok{trans[[.x]](mtcars[[.x]]))}
\end{Highlighting}
\end{Shaded}
\item
  What does \texttt{write.csv()} return? i.e.~what happens if you use it
  with \texttt{map2()} instead of \texttt{walk2()}?
\end{enumerate}

\hypertarget{reduce}{%
\section{Reduce}\label{reduce}}

After the map family, the next most important family of functions is the
reduce family. This family is much smaller, with only two main variants,
and is used less commonly, but it's a powerful idea, gives us the
opportunity to discuss some useful algebra, and powers the map-reduce
framework frequently used for processing very large datasets.

\hypertarget{basics-1}{%
\subsection{Basics}\label{basics-1}}

\indexc{reduce()}

\index{fold}

\texttt{reduce()} takes a vector of length n and produces a vector of
length one by calling a function with a pair of values at a time:
\texttt{reduce(1:4,\ f)} is equivalent to
\texttt{f(f(f(1,\ 2),\ 3),\ 4)}.

\begin{center}\includegraphics[width=3.25in]{diagrams/functionals/reduce} \end{center}

\texttt{reduce()} is a useful way to generalise a function that works
with two inputs (a \textbf{binary} function) to work with any number of
inputs. Imagine you have a list of numeric vectors, and you want to find
the values that occur in every element:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DataTypeTok{replace =}\NormalTok{ T))}
\KeywordTok{str}\NormalTok{(l)}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : int [1:15] 7 5 9 7 9 9 5 10 5 5 ...}
\CommentTok{#>  $ : int [1:15] 6 3 6 10 3 4 4 2 9 9 ...}
\CommentTok{#>  $ : int [1:15] 5 3 4 6 1 1 9 9 6 8 ...}
\CommentTok{#>  $ : int [1:15] 4 2 6 6 8 5 10 6 7 1 ...}
\end{Highlighting}
\end{Shaded}

To solve this challenge we need to use \texttt{intersect()} repeatedly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out <-}\StringTok{ }\NormalTok{l[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{out <-}\StringTok{ }\KeywordTok{intersect}\NormalTok{(out, l[[}\DecValTok{2}\NormalTok{]])}
\NormalTok{out <-}\StringTok{ }\KeywordTok{intersect}\NormalTok{(out, l[[}\DecValTok{3}\NormalTok{]])}
\NormalTok{out <-}\StringTok{ }\KeywordTok{intersect}\NormalTok{(out, l[[}\DecValTok{4}\NormalTok{]])}
\NormalTok{out}
\CommentTok{#> [1] 5 1}
\end{Highlighting}
\end{Shaded}

\texttt{reduce()} automates this solution for us, so we can write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(l, intersect)}
\CommentTok{#> [1] 5 1}
\end{Highlighting}
\end{Shaded}

We could apply the same idea if we wanted to list all the elements that
appear in at least one entry. All we have to do is switch from
\texttt{intersect()} to \texttt{union()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(l, union)}
\CommentTok{#>  [1]  7  5  9 10  1  6  3  4  2  8}
\end{Highlighting}
\end{Shaded}

Like the map family, you can also pass additional arguments.
\texttt{intersect()} and \texttt{union()} don't take extra arguments so
I can't demonstrate them here, but the principle is straightforward and
I drew you a picture.

\begin{center}\includegraphics[width=4.03in]{diagrams/functionals/reduce-arg} \end{center}

As usual, the essence of \texttt{reduce()} can be reduced to a simple
wrapper around a for loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_reduce <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
\NormalTok{  out <-}\StringTok{ }\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))) \{}
\NormalTok{    out <-}\StringTok{ }\KeywordTok{f}\NormalTok{(out, x[[i]])}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The base equivalent is \texttt{Reduce()}. Note that the argument order
is different: the function comes first, followed by the vector, and
there is no way to supply additional arguments.

\hypertarget{accumulate}{%
\subsection{Accumulate}\label{accumulate}}

The first \texttt{reduce()} variant, \texttt{accumulate()}, is useful
for understanding how reduce works, because instead of returning just
the final result, it returns all the intermediate results as well:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{accumulate}\NormalTok{(l, intersect)}
\CommentTok{#> [[1]]}
\CommentTok{#>  [1]  7  5  9  7  9  9  5 10  5  5  5 10  9  9  1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1]  5  9 10  1}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 5 9 1}
\CommentTok{#> }
\CommentTok{#> [[4]]}
\CommentTok{#> [1] 5 1}
\end{Highlighting}
\end{Shaded}

Another useful way to understand reduce is to think about
\texttt{sum()}: \texttt{sum(x)} is equivalent to
\texttt{x{[}{[}1{]}{]}\ +\ x{[}{[}2{]}{]}\ +\ x{[}{[}3{]}{]}\ +\ ...},
i.e. \texttt{reduce(x,\ \textasciigrave{}+\textasciigrave{})}. Then
\texttt{accumulate(x,\ \textasciigrave{}+\textasciigrave{})} is the
cumulative sum:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\KeywordTok{reduce}\NormalTok{(x, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] 17}

\KeywordTok{accumulate}\NormalTok{(x, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1]  4  7 17}
\end{Highlighting}
\end{Shaded}

\hypertarget{output-types}{%
\subsection{Output types}\label{output-types}}

In the above example using \texttt{+}, what should \texttt{reduce()}
return when \texttt{x} is short, i.e.~length 1 or 0? Without additional
arguments, \texttt{reduce()} just returns the input when \texttt{x} is
length 1:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

This means that \texttt{reduce()} has no way to check that the input is
valid:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] "a"}
\end{Highlighting}
\end{Shaded}

What if it's length 0? We get an error that suggests we need to use the
\texttt{.init} argument:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(}\KeywordTok{integer}\NormalTok{(), }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> Error: `.x` is empty, and no `.init` supplied}
\end{Highlighting}
\end{Shaded}

What should \texttt{.init} be here? To figure that out, we need to see
what happens when \texttt{.init} is supplied:

\begin{center}\includegraphics[width=4.23in]{diagrams/functionals/reduce-init} \end{center}

So if we call
\texttt{reduce(1,\ \textasciigrave{}+\textasciigrave{},\ init)} the
result will be \texttt{1\ +\ init}. Now we know that the result should
be just \texttt{1}, so that suggests that \texttt{.init} should be 0:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(}\KeywordTok{integer}\NormalTok{(), }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{, }\DataTypeTok{.init =} \DecValTok{0}\NormalTok{)}
\CommentTok{#> [1] 0}
\end{Highlighting}
\end{Shaded}

This also ensures that \texttt{reduce()} checks that length 1 inputs are
valid for the function that you're calling:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{reduce}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{, }\DataTypeTok{.init =} \DecValTok{0}\NormalTok{)}
\CommentTok{#> Error in .x + .y:}
\CommentTok{#>   non-numeric argument to binary operator}
\end{Highlighting}
\end{Shaded}

If you want to get algebraic about it, 0 is called the \textbf{identity}
of the real numbers under the operation of addition: if you add a 0 to
any number, you get the same number back. R applies the same principle
to determine what a summary function with a zero length input should
return:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{integer}\NormalTok{())  }\CommentTok{# x + 0 = x}
\CommentTok{#> [1] 0}
\KeywordTok{prod}\NormalTok{(}\KeywordTok{integer}\NormalTok{()) }\CommentTok{# x * 1 = x}
\CommentTok{#> [1] 1}
\KeywordTok{min}\NormalTok{(}\KeywordTok{integer}\NormalTok{())  }\CommentTok{# min(x, Inf) = x}
\CommentTok{#> [1] Inf}
\KeywordTok{max}\NormalTok{(}\KeywordTok{integer}\NormalTok{())  }\CommentTok{# max(x, -Inf) = x}
\CommentTok{#> [1] -Inf}
\end{Highlighting}
\end{Shaded}

If you're using \texttt{reduce()} in a function, you should always
supply \texttt{.init}. Think carefully about what your function should
return when passed a vector of length zero or one, and make sure to test
your implementation.

\hypertarget{multiple-inputs}{%
\subsection{Multiple inputs}\label{multiple-inputs}}

Very occassionally you need to pass two arguments to the function that
you're reducing. For example, you might have a list of data frames that
you want to join together, and the variables that you are joining by
vary from element to element. This is a very specialised scenario, so I
don't want to spend much time on it, except to know that it exists.

Note that the length of the second argument varies based on whether or
not \texttt{.init} is supplied: if you have four elements of \texttt{x},
\texttt{f} will only be called three times. If you supply init,
\texttt{f} will be called four times.

\begin{center}\includegraphics[width=5.41in]{diagrams/functionals/reduce2} \end{center}

\begin{center}\includegraphics[width=5.41in]{diagrams/functionals/reduce2-init} \end{center}

\hypertarget{map-reduce}{%
\subsection{Map-reduce}\label{map-reduce}}

You might have heard of map-reduce, the idea that powers technology like
Hadoop. Now you can see how simple and powerful the underlying idea is:
all map-reduce is a map combined with a reduce. The difference for large
data is that the data is spread over multiple computers. Each computer
performs the map on the data that it has, then it sends the result to
back to a coordinator which \emph{reduces} the individual results back
to a single result.

\hypertarget{predicate-functionals}{%
\section{Predicate functionals}\label{predicate-functionals}}

\index{predicates} \index{functions!predicate|see{predicates}}

A \textbf{predicate} is a function that returns a single \texttt{TRUE}
or \texttt{FALSE}, like \texttt{is.character()}, \texttt{is.null()}, or
\texttt{all()}, and we say a predicate \textbf{matches} a vector if it
returns \texttt{TRUE}.

\hypertarget{basics-2}{%
\subsection{Basics}\label{basics-2}}

A \textbf{predicate functional} applies a predicate to each element of a
vector. purrr proivdes six useful functions which come in three pairs:

\begin{itemize}
\tightlist
\item
  \texttt{some(.x,\ .p)} returns \texttt{TRUE} if \emph{any} element
  matches; \texttt{every(.x,\ .p)} returns \texttt{TRUE} if \emph{all}
  elements match.
\end{itemize}

\begin{itemize}
\tightlist
\item
  \texttt{detect(.x,\ .p)} returns the \emph{value} of the first match;
  \texttt{detect\_index(.x,\ .p)} returns the \emph{location} of the
  first match.
\end{itemize}

\begin{itemize}
\tightlist
\item
  \texttt{keep(.x,\ .p)} \emph{keeps} all matching elements;
  \texttt{discard(.x,\ .p)} \emph{drops} all matching elements.
\end{itemize}

The following example shows how you might use these functionals with a
data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\KeywordTok{detect}\NormalTok{(df, is.factor)}
\CommentTok{#> [1] a b c}
\CommentTok{#> Levels: a b c}
\KeywordTok{detect_index}\NormalTok{(df, is.factor)}
\CommentTok{#> [1] 2}

\KeywordTok{str}\NormalTok{(}\KeywordTok{keep}\NormalTok{(df, is.factor))}
\CommentTok{#> 'data.frame':    3 obs. of  1 variable:}
\CommentTok{#>  $ y: Factor w/ 3 levels "a","b","c": 1 2 3}
\KeywordTok{str}\NormalTok{(}\KeywordTok{discard}\NormalTok{(df, is.factor))}
\CommentTok{#> 'data.frame':    3 obs. of  1 variable:}
\CommentTok{#>  $ x: int  1 2 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{predicate-map}{%
\subsection{Map variants}\label{predicate-map}}

\texttt{map()} and \texttt{modify()} come in variants that also take
predicate functions, transforming only the elements of \texttt{.x} with
\texttt{.p} is \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{map_if}\NormalTok{(iris, is.numeric, mean))}
\CommentTok{#> List of 5}
\CommentTok{#>  $ Sepal.Length: num 5.84}
\CommentTok{#>  $ Sepal.Width : num 3.06}
\CommentTok{#>  $ Petal.Length: num 3.76}
\CommentTok{#>  $ Petal.Width : num 1.2}
\CommentTok{#>  $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1..}
\KeywordTok{str}\NormalTok{(}\KeywordTok{modify_if}\NormalTok{(iris, is.numeric, mean))}
\CommentTok{#> 'data.frame':    150 obs. of  5 variables:}
\CommentTok{#>  $ Sepal.Length: num  5.84 5.84 5.84 5.84 5.84 ...}
\CommentTok{#>  $ Sepal.Width : num  3.06 3.06 3.06 3.06 3.06 ...}
\CommentTok{#>  $ Petal.Length: num  3.76 3.76 3.76 3.76 3.76 ...}
\CommentTok{#>  $ Petal.Width : num  1.2 1.2 1.2 1.2 1.2 ...}
\CommentTok{#>  $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1..}
\KeywordTok{str}\NormalTok{(}\KeywordTok{map}\NormalTok{(}\KeywordTok{keep}\NormalTok{(iris, is.numeric), mean))}
\CommentTok{#> List of 4}
\CommentTok{#>  $ Sepal.Length: num 5.84}
\CommentTok{#>  $ Sepal.Width : num 3.06}
\CommentTok{#>  $ Petal.Length: num 3.76}
\CommentTok{#>  $ Petal.Width : num 1.2}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-28}{%
\subsection{Exercises}\label{exercises-28}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Why isn't \texttt{is.na()} a predicate function? What base R function
  is closest to being a predicate version of \texttt{is.na()}?
\item
  What's the relationship between \texttt{which()} and
  \texttt{Position()}? What's the relationship between \texttt{where()}
  and \texttt{Filter()}?
\item
  \texttt{simple\_reduce()} has a problem when \texttt{x} is length 0 or
  length 1. Describe the source of the problem and how you might go
  about fixing it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_reduce <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
\NormalTok{  out <-}\StringTok{ }\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))) \{}
\NormalTok{    out <-}\StringTok{ }\KeywordTok{f}\NormalTok{(out, x[[i]])}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Implement the \texttt{span()} function from Haskell: given a list
  \texttt{x} and a predicate function \texttt{f}, \texttt{span()}
  returns the location of the longest sequential run of elements where
  the predicate is true. (Hint: you might find \texttt{rle()} helpful.)
\item
  Implement \texttt{arg\_max()}. It should take a function and a vector
  of inputs, and return the elements of the input where the function
  returns the highest value. For example,
  \texttt{arg\_max(-10:5,\ function(x)\ x\ \^{}\ 2)} should return -10.
  \texttt{arg\_max(-5:5,\ function(x)\ x\ \^{}\ 2)} should return
  \texttt{c(-5,\ 5)}. Also implement the matching \texttt{arg\_min()}
  function.
\item
  The function below scales a vector so it falls in the range {[}0,
  1{]}. How would you apply it to every column of a data frame? How
  would you apply it to every numeric column in a data frame?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scale01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  rng <-}\StringTok{ }\KeywordTok{range}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  (x }\OperatorTok{-}\StringTok{ }\NormalTok{rng[}\DecValTok{1}\NormalTok{]) }\OperatorTok{/}\StringTok{ }\NormalTok{(rng[}\DecValTok{2}\NormalTok{] }\OperatorTok{-}\StringTok{ }\NormalTok{rng[}\DecValTok{1}\NormalTok{])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{base-functionals}{%
\section{Base functionals}\label{base-functionals}}

To finish up the chapter, here I provide a survey of important base
functionals that are not members of the map, reduce, or predicate
families, and hence have no equivalent in purrr. This is not to say that
they're not important, but they have more of a mathematical/statistical
flavour, so they are generally less useful in data analysis.

\hypertarget{matrices-and-arrays}{%
\subsection{Matrices and arrays}\label{matrices-and-arrays}}

\indexc{apply()}

\texttt{map()} and friends are specialised to work with 1d vectors.
\texttt{base::apply()} is specialised to work with 2d and higher
vectors, i.e.~matrices and arrays. You can think of \texttt{apply()} as
an operation that summarises a matrix or array by collapsing each row or
column to a single value. It has four arguments:

\begin{itemize}
\item
  \texttt{X}, the matrix or array to summarise.
\item
  \texttt{MARGIN}, an integer vector giving the dimensions to summarise
  over, 1 = rows, 2 = columns, etc. (The argument name comes from
  thinking about the ``margins'' of a joint distribution.)
\item
  \texttt{FUN}, a summary function.
\item
  \texttt{...} other arguments passed on to \texttt{FUN}.
\end{itemize}

A typical example of \texttt{apply()} looks like this

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{)}
\KeywordTok{apply}\NormalTok{(a, }\DecValTok{1}\NormalTok{, mean)}
\CommentTok{#> [1]  8.5  9.5 10.5 11.5 12.5}
\KeywordTok{apply}\NormalTok{(a, }\DecValTok{2}\NormalTok{, mean)}
\CommentTok{#> [1]  3  8 13 18}
\end{Highlighting}
\end{Shaded}

You can specify multiple dimensions to \texttt{MARGIN}, which is useful
for high-d arrays:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{24}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\KeywordTok{apply}\NormalTok{(a, }\DecValTok{1}\NormalTok{, mean)}
\CommentTok{#> [1] 12 13}
\KeywordTok{apply}\NormalTok{(a, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), mean)}
\CommentTok{#>      [,1] [,2] [,3]}
\CommentTok{#> [1,]   10   12   14}
\CommentTok{#> [2,]   11   13   15}
\end{Highlighting}
\end{Shaded}

There are two caveats to using \texttt{apply()}:

\begin{itemize}
\item
  Like \texttt{base::sapply()}, you have no control over the output
  type; it will automatically be simplified to a list, matrix, or
  vector. However, you usually use \texttt{apply()} with numeric arrays
  and a numeric summary function so you are less likely to encounter a
  problem than with \texttt{sapply()}.
\item
  \texttt{apply()} is also not idempotent in the sense that if the
  summary function is the identity operator, the output is not always
  the same as the input.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a1 <-}\StringTok{ }\KeywordTok{apply}\NormalTok{(a, }\DecValTok{1}\NormalTok{, identity)}
\KeywordTok{identical}\NormalTok{(a, a1)}
\CommentTok{#> [1] FALSE}

\NormalTok{a2 <-}\StringTok{ }\KeywordTok{apply}\NormalTok{(a, }\DecValTok{2}\NormalTok{, identity)}
\KeywordTok{identical}\NormalTok{(a, a2)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}
\item
  Never use \texttt{apply()} with a data frame. It always coerces it to
  a matrix, which will lead to undesirable results if your data frame
  contains anything other than numbers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\KeywordTok{apply}\NormalTok{(df, }\DecValTok{2}\NormalTok{, mean)}
\CommentTok{#> Warning in mean.default(newX[, i], ...): argument is not numeric or}
\CommentTok{#> logical: returning NA}

\CommentTok{#> Warning in mean.default(newX[, i], ...): argument is not numeric or}
\CommentTok{#> logical: returning NA}
\CommentTok{#>  x  y }
\CommentTok{#> NA NA}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{mathematical}{%
\subsection{Mathematical}\label{mathematical}}

\indexc{integrate()} 
\indexc{uniroot()} 
\indexc{optimise()}

Functionals are very common in mathematics. The limit, the maximum, the
roots (the set of points where \texttt{f(x)\ =\ 0}), and the definite
integral are all functionals: given a function, they return a single
number (or vector of numbers). At first glance, these functions don't
seem to fit in with the theme of eliminating loops, but if you dig
deeper you'll find out that they are all implemented using an algorithm
that involves iteration.

Base R provides a useful set:

\begin{itemize}
\tightlist
\item
  \texttt{integrate()} finds the area under the curve defined by
  \texttt{f()}
\item
  \texttt{uniroot()} finds where \texttt{f()} hits zero
\item
  \texttt{optimise()} finds the location of the lowest (or highest)
  value of \texttt{f()}
\end{itemize}

The following example shows how they might be used with a simple
function, \texttt{sin()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{integrate}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi)}
\CommentTok{#> 2 with absolute error < 2.2e-14}
\KeywordTok{str}\NormalTok{(}\KeywordTok{uniroot}\NormalTok{(sin, pi }\OperatorTok{*}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{, }\DecValTok{3} \OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)))}
\CommentTok{#> List of 5}
\CommentTok{#>  $ root      : num 3.14}
\CommentTok{#>  $ f.root    : num 1.22e-16}
\CommentTok{#>  $ iter      : int 2}
\CommentTok{#>  $ init.it   : int NA}
\CommentTok{#>  $ estim.prec: num 6.1e-05}
\KeywordTok{str}\NormalTok{(}\KeywordTok{optimise}\NormalTok{(sin, }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{pi)))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ minimum  : num 4.71}
\CommentTok{#>  $ objective: num -1}
\KeywordTok{str}\NormalTok{(}\KeywordTok{optimise}\NormalTok{(sin, }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, pi), }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ maximum  : num 1.57}
\CommentTok{#>  $ objective: num 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-29}{%
\subsection{Exercises}\label{exercises-29}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How does \texttt{apply()} arrange the output? Read the documentation
  and perform some experiments.
\item
  What do \texttt{eapply()} and \texttt{rapply()} do? Does purrr have
  equivalents?
\item
  Challenge: read about the
  \href{https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html\#\%_idx_1096}{fixed
  point algorithm}. Complete the exercises using R.
\end{enumerate}

\hypertarget{function-factories}{%
\chapter{Function factories}\label{function-factories}}

\index{function factories}

\hypertarget{introduction-8}{%
\section{Introduction}\label{introduction-8}}

A \textbf{function factory} is a function that makes functions. Here's a
very simple example: we use a function factory (\texttt{power1()}) to
make two child functions (\texttt{square()} and \texttt{cube()}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(exp) \{}
  \KeywordTok{force}\NormalTok{(exp)}
  
  \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x }\OperatorTok{^}\StringTok{ }\NormalTok{exp}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{square <-}\StringTok{ }\KeywordTok{power1}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{cube <-}\StringTok{ }\KeywordTok{power1}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

I'll call \texttt{square()} and \texttt{cube()} \textbf{manufactured
functions}, but this is just a term to ease communication with other
humans: from R's perspective they are no different to functions created
any other way.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{square}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 9}
\KeywordTok{cube}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 27}
\end{Highlighting}
\end{Shaded}

You have already learned about the individual components that make
function factories possible:

\begin{itemize}
\item
  In Section \ref{first-class-functions}, you learned about R's
  ``first-class'' functions. In R, you bind a function to a name in the
  same way as you bind any object to a name: with \texttt{\textless{}-}.
\item
  In Section \ref{the-function-environment}, you learned that a function
  captures (encloses) the environment in which it is created.
\item
  In Section \ref{execution-environments}, you learned that a function
  creates a new execution environment every time it is run. This
  environment is usually ephemeral, but here it becomes the enclosing
  environment of the manufactured function.
\end{itemize}

In this chapter, you'll learn how the non-obvious combination of these
three features lead to the function factory. You'll also see examples of
their usage in visualisation and statistics.

Of the three main functional programming tools (functionals, function
factories, and function operators), function factories are probably the
least useful. Generally, they don't tend to reduce overall code
complexity. Instead, they tend to partition complexity into more easily
digested chunks. Function factories are also an important building block
for the very useful function operators, which you'll learn about in
Chapter \ref{function-operators}.

\hypertarget{outline-6}{%
\subsection*{Outline}\label{outline-6}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{factory-fundamentals} begins the chapter with an
  explanation of how function factories work, pulling together ideas
  from scoping and environments. You'll also see how function factories
  can be used to implement a ``memory'' for functions, allowing data to
  persist across calls.
\item
  Section \ref{graph-fact} illustrates the use of function factories
  with examples from ggplot2. You'll see two examples of how ggplot2
  works with user supplied function factories, and one example of where
  ggplot2 uses a function factory internally.
\item
  Section \ref{stat-fact} uses function factories to tackle three
  challenges from statistics: understanding the Box-Cox transform,
  solving maximum likelihood problems, and drawing bootstrap resamples.
\item
  Section \ref{functional-factories} shows how you can combine function
  factories and functionals to rapidly generate a family of functions
  from data.
\end{itemize}

\hypertarget{prerequisites-4}{%
\subsection*{Prerequisites}\label{prerequisites-4}}
\addcontentsline{toc}{subsection}{Prerequisites}

Make sure you're familiar with the contents of Sections
\ref{first-class-functions} (first-class functions),
\ref{the-function-environment} (function environments), and
\ref{execution-environments} (execution environments) mentioned above.

Function factories only need base R. We'll use a little rlang to peek
inside of them more easily, and we'll use ggplot2 and scales to explore
the use of function factories in visualisation.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The development version includes some printing tweaks that we need here}
\CommentTok{# devtools::install_github("r-lib/rlang")}
\KeywordTok{library}\NormalTok{(rlang)}

\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{library}\NormalTok{(scales)}
\end{Highlighting}
\end{Shaded}

\hypertarget{factory-fundamentals}{%
\section{Factory fundamentals}\label{factory-fundamentals}}

\index{closures|see{functions}}

The key idea that makes function factories work can be expressed very
concisely:

\begin{quote}
The enclosing environment of the manufactured function is an execution
environment of the function factory.
\end{quote}

It only takes few words to express these big ideas, but it takes a lot
more work to really understand what this means. This section will help
you put the pieces together with interactive exploration and some
diagrams.

\hypertarget{environments-1}{%
\subsection{Environments}\label{environments-1}}

Let's start by taking a look at \texttt{square()} and \texttt{cube()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{square}
\CommentTok{#> function(x) \{}
\CommentTok{#>     x ^ exp}
\CommentTok{#>   \}}
\CommentTok{#> <environment: 0x12bd9d8>}

\NormalTok{cube}
\CommentTok{#> function(x) \{}
\CommentTok{#>     x ^ exp}
\CommentTok{#>   \}}
\CommentTok{#> <bytecode: 0x186b7e0>}
\CommentTok{#> <environment: 0x1cf1e00>}
\end{Highlighting}
\end{Shaded}

Printing manufactured functions is not revealing because the bodies are
identical; it's the contents of the enclosing environment that's
important. We can get a little more insight by using
\texttt{rlang::env\_print()}. That shows us that we have two different
environments (each of which was originally an execution environment of
\texttt{power1()}). The environments have the same parent, which is the
enclosing environment of \texttt{power1()}, the global environment.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_print}\NormalTok{(square)}
\CommentTok{#> <environment: 0x12bd9d8>}
\CommentTok{#>   parent: <environment: global>}
\CommentTok{#>   bindings:}
\CommentTok{#>    * exp: <dbl>}

\KeywordTok{env_print}\NormalTok{(cube)}
\CommentTok{#> <environment: 0x1cf1e00>}
\CommentTok{#>   parent: <environment: global>}
\CommentTok{#>   bindings:}
\CommentTok{#>    * exp: <dbl>}
\end{Highlighting}
\end{Shaded}

\texttt{env\_print()} shows us that both environments have a binding to
\texttt{exp}, but we want to see its value\footnote{A future version of
  \texttt{env\_print()} is likely to do better at summarising the
  contents so you don't need this step.}. That's easily done with
\texttt{env\_get()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_get}\NormalTok{(square, }\StringTok{"exp"}\NormalTok{)}
\CommentTok{#> Warning: Passing an environment wrapper like a function is deprecated.}
\CommentTok{#> Please retrieve the environment before calling `env_get()`}
\CommentTok{#> This warning is displayed once per session.}
\CommentTok{#> [1] 2}

\KeywordTok{env_get}\NormalTok{(cube, }\StringTok{"exp"}\NormalTok{)}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

This is what makes manufactured functions behave differently from one
another: names in the enclosing environment are bound to different
values.

\hypertarget{diagram-conventions}{%
\subsection{Diagram conventions}\label{diagram-conventions}}

We can also show these relationships in a diagram:

\begin{center}\includegraphics[width=3.69in]{diagrams/function-factories/power-full} \end{center}

There's a lot going on this diagram and some of the details aren't that
important. We can simplify considerably by using two conventions:

\begin{itemize}
\item
  Any free floating symbol lives in the global environment.
\item
  Any environment without an explicit parent inherits from the global
  environment.
\end{itemize}

\begin{center}\includegraphics[width=3.44in]{diagrams/function-factories/power-simple} \end{center}

This view, which focuses on the environments, doesn't show any direct
link between \texttt{cube()} and \texttt{square()}. That's because the
link is the through the body of the function, which is identical for
both, but is not shown in this diagram.

To finish up, let's look at the execution environment of
\texttt{square(10)}. When \texttt{square()} executes
\texttt{x\ \^{}\ exp} it finds \texttt{x} in the execution environment
and \texttt{exp} in its enclosing environment.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{square}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 100}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.44in]{diagrams/function-factories/power-exec} \end{center}

\hypertarget{stateful-funs}{%
\subsection{Stateful functions}\label{stateful-funs}}

\indexc{<<-}

\index{copy-on-modify!exceptions}

Function factories also allow you to maintain state across function
invocations, which is generally hard to do because of the fresh start
principle described in Section \ref{fresh-start}.

There are two things that make this possible:

\begin{itemize}
\item
  The enclosing environment of the manufactured function is unique and
  constant.
\item
  R has a special assignment operator, \texttt{\textless{}\textless{}-},
  which modifies bindings in the enclosing environment.
\end{itemize}

The usual assignment operator, \texttt{\textless{}-}, always creates a
binding in the current environment. The \textbf{super assignment
operator}, \texttt{\textless{}\textless{}-} rebinds an existing name
found in a parent environment.

The following example example shows how we can combine these ideas to
create a function that records how many times it has been called:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_counter <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  i <-}\StringTok{ }\DecValTok{0}
  
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    i <<-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{    i}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{counter_one <-}\StringTok{ }\KeywordTok{new_counter}\NormalTok{()}
\NormalTok{counter_two <-}\StringTok{ }\KeywordTok{new_counter}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.69in]{diagrams/function-factories/counter-1} \end{center}

When the manufactured function is run
\texttt{i\ \textless{}\textless{}-\ i\ +\ 1} will modify \texttt{i} in
its enclosing environment. Because manufactured functions have
independent enclosing environments, they have independent counts:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{counter_one}\NormalTok{()}
\CommentTok{#> [1] 1}
\KeywordTok{counter_one}\NormalTok{()}
\CommentTok{#> [1] 2}
\KeywordTok{counter_two}\NormalTok{()}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.69in]{diagrams/function-factories/counter-2} \end{center}

Stateful functions are best used in moderation. As soon as your function
starts managing the state of multiple variables, it's better to switch
to R6, the topic of Chapter \ref{r6}.

\hypertarget{factory-pitfalls}{%
\subsection{Potential pitfalls}\label{factory-pitfalls}}

There are two potential pitfalls to be aware of when creating your own
function factories: forgetting to evaluate all inputs and accidentally
capturing large objects.

Generally, you can rely on lazy evaluation to evaluate function inputs
at the right time. However, there's a catch when it comes to function
factories: if you don't eagerly evaluate every argument, it's possible
to get confusing behaviour, as shown below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(exp) \{}
  \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    x }\OperatorTok{^}\StringTok{ }\NormalTok{exp}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{exp2 <-}\StringTok{ }\DecValTok{2}
\NormalTok{square2 <-}\StringTok{ }\KeywordTok{power2}\NormalTok{(exp2)}
\NormalTok{exp2 <-}\StringTok{ }\DecValTok{3}

\KeywordTok{square2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 8}
\end{Highlighting}
\end{Shaded}

This is described in Section \ref{forcing-evaluation}, and happens when
a binding changes in between calling the factory function and calling
the manufactured function. This is likely to only happen rarely, but
when it does, it will lead to a real head-scratcher of a bug. Avoid
future pain by ensuring every argument is evaluated, using
\texttt{force()} if the argument is only used by the manufactured
function.

With most functions, you can rely on the GC to clean up any large
temporary objects created inside a function. However, manufactured
functions hold on to the execution environment, so you'll need to
explicitly unbind any large temporary objects with \texttt{rm()}.
Compare the sizes of \texttt{g1()} and \texttt{g2()} in the example
below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(n)}
\NormalTok{  m <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
  \ControlFlowTok{function}\NormalTok{() m}
\NormalTok{\}}

\NormalTok{g1 <-}\StringTok{ }\KeywordTok{f1}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(g1)}
\CommentTok{#> 8,013,656 B}

\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(n)}
\NormalTok{  m <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
  \KeywordTok{rm}\NormalTok{(x)}
  \ControlFlowTok{function}\NormalTok{() m}
\NormalTok{\}}

\NormalTok{g2 <-}\StringTok{ }\KeywordTok{f2}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(g2)}
\CommentTok{#> 13,496 B}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-30}{%
\subsection{Exercises}\label{exercises-30}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Base R contains two function factories, \texttt{approxfun()} and
  \texttt{ecdf()}. Read their documentation and experiment to figure out
  what the functions do and what they return.
\item
  Create a function \texttt{pick()} that takes an index, \texttt{i}, as
  an argument and returns a function with an argument \texttt{x} that
  subsets \texttt{x} with \texttt{i}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pick}\NormalTok{(}\DecValTok{1}\NormalTok{)(x)}
\CommentTok{# should be equivalent to}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}

\KeywordTok{lapply}\NormalTok{(mtcars, }\KeywordTok{pick}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\CommentTok{# should be equivalent to}
\KeywordTok{lapply}\NormalTok{(mtcars, }\ControlFlowTok{function}\NormalTok{(x) x[[}\DecValTok{5}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}
\item
  Create a function that creates functions that compute the
  i\textsuperscript{th}
  \href{http://en.wikipedia.org/wiki/Central_moment}{central moment} of
  a numeric vector. You can test it by running the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{m2 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m1}\NormalTok{(x), }\DecValTok{0}\NormalTok{))}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m2}\NormalTok{(x), }\KeywordTok{var}\NormalTok{(x) }\OperatorTok{*}\StringTok{ }\DecValTok{99} \OperatorTok{/}\StringTok{ }\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  What happens if you don't use a closure? Make predictions, then verify
  with the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\DecValTok{0}
\NormalTok{new_counter2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  i <<-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  i}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  What happens if you use \texttt{\textless{}-} instead of
  \texttt{\textless{}\textless{}-}? Make predictions, then verify with
  the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_counter3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  i <-}\StringTok{ }\DecValTok{0}
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    i <-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{    i}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{graph-fact}{%
\section{Graphical factories}\label{graph-fact}}

We'll begin our exploration of useful function factories with a few
examples from ggplot2.

\hypertarget{labelling}{%
\subsection{Labelling}\label{labelling}}

One of the goals of the \href{http://scales.r-lib.org}{scales} package
is to make it easy to customise the labels on ggplot2. It provides many
functions to control the fine details of axes and legends. One useful
class of functions are the formatter functions\footnote{It's an
  unfortunate accident of history that scales uses function suffixes
  instead of function prefixes. That's because it was written before I
  understood the autocomplete advantages to using common prefixes
  instead of common suffixes.} which which make it easier to control the
appearance of axis breaks. The design of these functions might initially
seem a little odd: they all return a function, which you have to call in
order to format a number.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{12345}\NormalTok{, }\DecValTok{123456}\NormalTok{, }\DecValTok{1234567}\NormalTok{)}
\KeywordTok{comma_format}\NormalTok{()(y)}
\CommentTok{#> [1] "12,345"    "123,456"   "1,234,567"}

\KeywordTok{number_format}\NormalTok{(}\DataTypeTok{scale =} \FloatTok{1e-3}\NormalTok{, }\DataTypeTok{suffix =} \StringTok{" K"}\NormalTok{)(y)}
\CommentTok{#> [1] "12 K"    "123 K"   "1 235 K"}
\end{Highlighting}
\end{Shaded}

In other words, the primary interface is a function factory. At first
glance, this seems to add extra complexity for little gain. But it
enables a nice interaction with ggplot2's scales, because they accept
functions in the \texttt{label} argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ y)}
\NormalTok{core <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(x, y)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{scale_x_continuous}\NormalTok{(}\DataTypeTok{breaks =} \DecValTok{1}\NormalTok{, }\DataTypeTok{labels =} \OtherTok{NULL}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{, }\DataTypeTok{y =} \OtherTok{NULL}\NormalTok{)}
  
\NormalTok{core}
\NormalTok{core }\OperatorTok{+}\StringTok{ }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{label =} \KeywordTok{comma_format}\NormalTok{())}
\NormalTok{core }\OperatorTok{+}\StringTok{ }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{label =} \KeywordTok{number_format}\NormalTok{(}\DataTypeTok{scale =} \FloatTok{1e-3}\NormalTok{, }\DataTypeTok{suffix =} \StringTok{" K"}\NormalTok{))}
\NormalTok{core }\OperatorTok{+}\StringTok{ }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{label =} \KeywordTok{scientific_format}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=0.25\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-22-1}
\includegraphics[width=0.25\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-22-2}
\includegraphics[width=0.25\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-22-3}
\includegraphics[width=0.25\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-22-4}

\hypertarget{histogram-bins}{%
\subsection{Histogram bins}\label{histogram-bins}}

A little known feature of \texttt{geom\_histogram()} is that the
\texttt{binwidth} argument can be a function. This is particularly
useful because the function is executed once for each group, which means
you can have different binwidths in different facets, which is otherwise
not possible.

To illustrate this idea, and see where variable binwidth might be
useful, I'm going to construct an example where a fixed binwidth isn't
great.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# construct some sample data with very different numbers in each cell}
\NormalTok{sd <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{15}\NormalTok{)}
\NormalTok{n <-}\StringTok{ }\DecValTok{100}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{rnorm}\NormalTok{(}\DecValTok{3} \OperatorTok{*}\StringTok{ }\NormalTok{n, }\DataTypeTok{sd =}\NormalTok{ sd), }\DataTypeTok{sd =} \KeywordTok{rep}\NormalTok{(sd, n))}

\KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(x)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\StringTok{ }\NormalTok{sd, }\DataTypeTok{scales =} \StringTok{"free_x"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.9\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-23-1} \end{center}

Here each facet has the same number of observations, but the variability
is very different. It would be nice if we could request that the
binwidths vary so we get approximately the same number of observations
in each bin. One way to do that is with a function factory that inputs
the desired number of bins (\texttt{n}), and outputs a function that
takes a numeric vector and returns a binwidth:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{binwidth_bins <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
  \KeywordTok{force}\NormalTok{(n)}
  
  \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    (}\KeywordTok{max}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(x)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \KeywordTok{binwidth_bins}\NormalTok{(}\DecValTok{20}\NormalTok{)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\StringTok{ }\NormalTok{sd, }\DataTypeTok{scales =} \StringTok{"free_x"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.9\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-24-1} \end{center}

We could use this same pattern to wrap around the base R functions that
automatically find the ``optimal''\footnote{ggplot2 doesn't expose these
  functions directly because I don't think the defintion of optimality
  needed to make the problem mathematically tractable is a good match to
  the actual needs of data exploration.} binwidth,
\texttt{nclass.Sturges()}, \texttt{nclass.scott()}, and
\texttt{nclass.FD()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{base_bins <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(type) \{}
\NormalTok{  fun <-}\StringTok{ }\ControlFlowTok{switch}\NormalTok{(type,}
    \DataTypeTok{Sturges =}\NormalTok{ nclass.Sturges,}
    \DataTypeTok{scott =}\NormalTok{ nclass.scott,}
    \DataTypeTok{FD =}\NormalTok{ nclass.FD,}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Unknown type"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  )}
  
  \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    (}\KeywordTok{max}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\KeywordTok{fun}\NormalTok{(x)}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(x)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \KeywordTok{base_bins}\NormalTok{(}\StringTok{"FD"}\NormalTok{)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\StringTok{ }\NormalTok{sd, }\DataTypeTok{scales =} \StringTok{"free_x"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \OtherTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.9\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-25-1} \end{center}

\hypertarget{ggsave}{%
\subsection{ggsave}\label{ggsave}}

Finally, I want to show a function factory used internally by ggplot2.
\texttt{ggplot2:::plot\_dev()} is used by \texttt{ggsave()} to go from a
file extension (e.g. \texttt{png}, \texttt{jpeg} etc) to a graphics
device function (e.g. \texttt{png()}, \texttt{jpeg()}). The challenge
here arises because the base graphics devices have some minor
inconsistencies which we need to paper over:

\begin{itemize}
\item
  Most have \texttt{filename} as first argument but some have
  \texttt{file}.
\item
  The \texttt{width} and \texttt{height} of raster graphic devices use
  pixels units by default, but the vector graphics use inches.
\end{itemize}

A mildly simplified version of \texttt{plot\_dev()} is shown below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plot_dev <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(ext, }\DataTypeTok{dpi =} \DecValTok{96}\NormalTok{) \{}
  \KeywordTok{force}\NormalTok{(dpi)}
  
  \ControlFlowTok{switch}\NormalTok{(ext,}
    \DataTypeTok{eps =}\NormalTok{  ,}
    \DataTypeTok{ps  =}  \ControlFlowTok{function}\NormalTok{(filename, ...) \{}
\NormalTok{      grDevices}\OperatorTok{::}\KeywordTok{postscript}\NormalTok{(}
        \DataTypeTok{file =}\NormalTok{ filename, ..., }\DataTypeTok{onefile =} \OtherTok{FALSE}\NormalTok{, }
        \DataTypeTok{horizontal =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{paper =} \StringTok{"special"}
\NormalTok{      )}
\NormalTok{    \},}
    \DataTypeTok{tex =}  \ControlFlowTok{function}\NormalTok{(filename, ...) grDevices}\OperatorTok{::}\KeywordTok{pictex}\NormalTok{(}\DataTypeTok{file =}\NormalTok{ filename, ...),}
    \DataTypeTok{pdf =}  \ControlFlowTok{function}\NormalTok{(filename, ...) grDevices}\OperatorTok{::}\KeywordTok{pdf}\NormalTok{(}\DataTypeTok{file =}\NormalTok{ filename, ...),}
    \DataTypeTok{svg  =} \ControlFlowTok{function}\NormalTok{(filename, ...) svglite}\OperatorTok{::}\KeywordTok{svglite}\NormalTok{(}\DataTypeTok{file =}\NormalTok{ filename, ...),}
    \DataTypeTok{emf  =}\NormalTok{ ,}
    \DataTypeTok{wmf  =} \ControlFlowTok{function}\NormalTok{(...) grDevices}\OperatorTok{::}\KeywordTok{win.metafile}\NormalTok{(...),}
    \DataTypeTok{png  =} \ControlFlowTok{function}\NormalTok{(...) grDevices}\OperatorTok{::}\KeywordTok{png}\NormalTok{(..., }\DataTypeTok{res =}\NormalTok{ dpi, }\DataTypeTok{units =} \StringTok{"in"}\NormalTok{),}
    \DataTypeTok{jpg  =}\NormalTok{ ,}
    \DataTypeTok{jpeg =} \ControlFlowTok{function}\NormalTok{(...) grDevices}\OperatorTok{::}\KeywordTok{jpeg}\NormalTok{(..., }\DataTypeTok{res =}\NormalTok{ dpi, }\DataTypeTok{units =} \StringTok{"in"}\NormalTok{),}
    \DataTypeTok{bmp  =} \ControlFlowTok{function}\NormalTok{(...) grDevices}\OperatorTok{::}\KeywordTok{bmp}\NormalTok{(..., }\DataTypeTok{res =}\NormalTok{ dpi, }\DataTypeTok{units =} \StringTok{"in"}\NormalTok{),}
    \DataTypeTok{tiff =} \ControlFlowTok{function}\NormalTok{(...) grDevices}\OperatorTok{::}\KeywordTok{tiff}\NormalTok{(..., }\DataTypeTok{res =}\NormalTok{ dpi, }\DataTypeTok{units =} \StringTok{"in"}\NormalTok{),}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Unknown graphics extension: "}\NormalTok{, ext, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{plot_dev}\NormalTok{(}\StringTok{"pdf"}\NormalTok{)}
\CommentTok{#> function(filename, ...) grDevices::pdf(file = filename, ...)}
\CommentTok{#> <bytecode: 0x4f98f30>}
\CommentTok{#> <environment: 0x49b9148>}
\KeywordTok{plot_dev}\NormalTok{(}\StringTok{"png"}\NormalTok{)}
\CommentTok{#> function(...) grDevices::png(..., res = dpi, units = "in")}
\CommentTok{#> <bytecode: 0x529d8e0>}
\CommentTok{#> <environment: 0x572ade0>}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-31}{%
\subsection{Exercises}\label{exercises-31}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compare and contrast \texttt{ggplot2::label\_bquote()} with
  \texttt{scales::number\_format()}
\end{enumerate}

\hypertarget{stat-fact}{%
\section{Statistical factories}\label{stat-fact}}

More motivating examples for function factories come from statistics:

\begin{itemize}
\tightlist
\item
  The Box-Cox transformation.
\item
  Bootstrap resampling.
\item
  Maximum likelihood estimation.
\end{itemize}

All of these examples can be tackled without function factories, but I
think function factories are a good fit for these problems and provide
elegant solutions. These examples expect some statistical background, so
feel free to skip if they don't make much sense to you.

\hypertarget{box-cox-transformation}{%
\subsection{Box-Cox transformation}\label{box-cox-transformation}}

\index{Box-Cox transformation}

The Box-Cox transformation is a flexible transformation often used to
transform data towards normality. It has a single parameter,
\(\lambda\), which controls the strength of the transformation. We could
express the transformation as a simple two argument function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boxcox1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, lambda) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(lambda) }\OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{)}
  
  \ControlFlowTok{if}\NormalTok{ (lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{log}\NormalTok{(x)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    (x }\OperatorTok{^}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{lambda}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

But re-formulating as a function factory makes it easy to explore its
behaviour with \texttt{stat\_function()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boxcox2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lambda) \{}
  \ControlFlowTok{if}\NormalTok{ (lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{log}\NormalTok{(x)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{^}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{lambda}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{stat_boxcox <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lambda) \{}
  \KeywordTok{stat_function}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ lambda), }\DataTypeTok{fun =} \KeywordTok{boxcox2}\NormalTok{(lambda), }\DataTypeTok{size =} \DecValTok{1}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{5}\NormalTok{)), }\KeywordTok{aes}\NormalTok{(x)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{lapply}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{1.5}\NormalTok{), stat_boxcox) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{scale_colour_viridis_c}\NormalTok{(}\DataTypeTok{limits =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{1.5}\NormalTok{))}

\CommentTok{# visually, log() does seem to make sense as the limit as lambda -> 0}
\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.01}\NormalTok{, }\DecValTok{1}\NormalTok{)), }\KeywordTok{aes}\NormalTok{(x)) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{lapply}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\FloatTok{0.25}\NormalTok{, }\FloatTok{0.1}\NormalTok{, }\DecValTok{0}\NormalTok{), stat_boxcox) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{scale_colour_viridis_c}\NormalTok{(}\DataTypeTok{limits =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\FloatTok{1.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics[width=0.5\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-28-1}
\includegraphics[width=0.5\linewidth]{Function-factories_files/figure-latex/unnamed-chunk-28-2}

In general, this allows you to use a Box-Cox transformation with any
function that accepts a unary transformation function: you don't have to
worry about that function providing \texttt{...} to pass along
additional arguments. I also think that the partitioning of
\texttt{lambda} and \texttt{x} into two different function arguments is
natural since \texttt{lambda} plays quite a different role than
\texttt{x}.

\hypertarget{bootstrap-generators}{%
\subsection{Bootstrap generators}\label{bootstrap-generators}}

\index{boostraping generator}

Function factories are a useful approach for bootstrapping. Instead of
thinking about a single bootstrap (you always need more than one!), you
can think about a bootstrap \textbf{generator}, a function that yields a
fresh bootstrap every time it is called:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_permute <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, var) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{nrow}\NormalTok{(df)}
  \KeywordTok{force}\NormalTok{(var)}
  
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    df[[var]][}\KeywordTok{sample}\NormalTok{(n, n, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)]}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{boot_mtcars1 <-}\StringTok{ }\KeywordTok{boot_permute}\NormalTok{(mtcars, }\StringTok{"mpg"}\NormalTok{)}
\KeywordTok{head}\NormalTok{(}\KeywordTok{boot_mtcars1}\NormalTok{())}
\CommentTok{#> [1] 18.1 22.8 21.5 14.7 21.4 17.3}
\KeywordTok{head}\NormalTok{(}\KeywordTok{boot_mtcars1}\NormalTok{())}
\CommentTok{#> [1] 19.2 19.2 14.3 21.0 13.3 21.4}
\end{Highlighting}
\end{Shaded}

The advantage of a function factory is more clear with a parametric
bootstrap where we have to first fit a model. We can do this setup step
once, when the factory is called, rather than once every time we
generate the bootstrap:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_model <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, formula) \{}
\NormalTok{  mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(formula, }\DataTypeTok{data =}\NormalTok{ df)}
\NormalTok{  fitted <-}\StringTok{ }\KeywordTok{unname}\NormalTok{(}\KeywordTok{fitted}\NormalTok{(mod))}
\NormalTok{  resid <-}\StringTok{ }\KeywordTok{unname}\NormalTok{(}\KeywordTok{resid}\NormalTok{(mod))}
  \KeywordTok{rm}\NormalTok{(mod)}

  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    fitted }\OperatorTok{+}\StringTok{ }\KeywordTok{sample}\NormalTok{(resid)}
\NormalTok{  \}}
\NormalTok{\} }

\NormalTok{boot_mtcars2 <-}\StringTok{ }\KeywordTok{boot_model}\NormalTok{(mtcars, mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt)}
\KeywordTok{head}\NormalTok{(}\KeywordTok{boot_mtcars2}\NormalTok{())}
\CommentTok{#> [1] 23.1 24.3 23.0 19.1 19.1 16.2}
\KeywordTok{head}\NormalTok{(}\KeywordTok{boot_mtcars2}\NormalTok{())}
\CommentTok{#> [1] 30.2 17.4 31.3 26.1 17.8 16.7}
\end{Highlighting}
\end{Shaded}

I use \texttt{rm(mod)} because linear model objects are quite large
(they include complete copies of the model matrix and input data) and I
want to keep the manufactured function as small as possible.

\hypertarget{MLE}{%
\subsection{Maximum likelihood estimation}\label{MLE}}

\index{maximum likelihood} \indexc{optimise()} \indexc{optim()}

The goal of maximum likelihood estimation (MLE) is to find the parameter
values for a distribution that make the observed data ``most likely''.
To do MLE, you start with a probability function. For example, take the
Poisson distribution. If we know \(\lambda\), we can compute the
probability of getting a vector \(\mathbf{x}\) of values (\(x_1\),
\(x_2\), \ldots{}, \(x_n\)) by multiplying the Poisson probability
function as follows:

\[ P(\lambda, \mathbf{x}) = \prod_{i=1}^{n} \frac{\lambda ^ {x_i} e^{-\lambda}}{x_i!} \]

In statistics, we almost always work with the log of this function. The
log is a monotonic transformation which preserves important properties
(i.e.~the extrema occur in the same place), but has specific advantages:

\begin{itemize}
\item
  The log turns a product into a sum, which is easier to work with.
\item
  Multiplying small numbers yields even smaller numbers, which makes the
  floating point approximation used by a computer less accurate.
\end{itemize}

Let's apply a log transformation to this probability function and
simplify it as much as possible:

\[ \log(P(\lambda, \mathbf{x})) = \sum_{i=1}^{n} \log(\frac{\lambda ^ {x_i} e^{-\lambda}}{x_i!}) \]

\[ \log(P(\lambda, \mathbf{x})) = \sum_{i=1}^{n} \left( x_i \log(\lambda) - \lambda - \log(x_i!) \right) \]

\[ \log(P(\lambda, \mathbf{x})) = 
     \sum_{i=1}^{n} x_i \log(\lambda)
   - \sum_{i=1}^{n} \lambda 
   - \sum_{i=1}^{n} \log(x_i!) \]

\[ \log(P(\lambda, \mathbf{x})) = 
   \log(\lambda) \sum_{i=1}^{n} x_i - n \lambda - \sum_{i=1}^{n} \log(x_i!) \]

We can now turn this function into an R function. The R function is
quite elegant because R is vectorised and, because it's a statistical
programming language, R comes with built-in functions like the
log-factorial (\texttt{lfactorial()}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lprob_poisson <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lambda, x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{  (}\KeywordTok{log}\NormalTok{(lambda) }\OperatorTok{*}\StringTok{ }\KeywordTok{sum}\NormalTok{(x)) }\OperatorTok{-}\StringTok{ }\NormalTok{(n }\OperatorTok{*}\StringTok{ }\NormalTok{lambda) }\OperatorTok{-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{lfactorial}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Consider this vector of observations:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{41}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{38}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{38}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can use \texttt{lprob\_poisson()} to compute the (logged) probability
of \texttt{x1} for different values of \texttt{lambda}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lprob_poisson}\NormalTok{(}\DecValTok{10}\NormalTok{, x1)}
\CommentTok{#> [1] -184}
\KeywordTok{lprob_poisson}\NormalTok{(}\DecValTok{20}\NormalTok{, x1)}
\CommentTok{#> [1] -61.1}
\KeywordTok{lprob_poisson}\NormalTok{(}\DecValTok{30}\NormalTok{, x1)}
\CommentTok{#> [1] -31}
\end{Highlighting}
\end{Shaded}

So far we've been thinking of \texttt{lambda} as fixed and known and the
function told us the probability of getting different values of
\texttt{x}. But in real-life, we observe \texttt{x} and it is
\texttt{lambda} that is unknown. The likelihood is the probability
function seen through this lens: we want to find the \texttt{lambda}
that makes the observed \texttt{x} the ``most likely''. That is, given
\texttt{x}, what value of \texttt{lambda} gives us the highest value of
\texttt{lprob\_poisson}()?

In statistics, we highlight this change in perspective by writing
\(f_{\mathbf{x}}(\lambda)\) instead of \(f(\lambda, \mathbf{x})\). In R,
we can use a function factory. We provide \texttt{x} and generate a
function with a single parameter, \texttt{lambda}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ll_poisson1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}

  \ControlFlowTok{function}\NormalTok{(lambda) \{}
    \KeywordTok{log}\NormalTok{(lambda) }\OperatorTok{*}\StringTok{ }\KeywordTok{sum}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{lfactorial}\NormalTok{(x))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

One nice thing about this approach is that we can do some
precomputation: any term that only involves \texttt{x} can be computed
once in the factory. This is useful because we're going to need to call
this function many times to find the best \texttt{lambda}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ll_poisson2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{  sum_x <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(x)}
\NormalTok{  c <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{lfactorial}\NormalTok{(x))}

  \ControlFlowTok{function}\NormalTok{(lambda) \{}
    \KeywordTok{log}\NormalTok{(lambda) }\OperatorTok{*}\StringTok{ }\NormalTok{sum_x }\OperatorTok{-}\StringTok{ }\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\NormalTok{c}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now we can use this function to find the value of \texttt{lambda} that
maximizes the (log) likelihood:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ll1 <-}\StringTok{ }\KeywordTok{ll_poisson2}\NormalTok{(x1)}

\KeywordTok{ll1}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] -184}
\KeywordTok{ll1}\NormalTok{(}\DecValTok{20}\NormalTok{)}
\CommentTok{#> [1] -61.1}
\KeywordTok{ll1}\NormalTok{(}\DecValTok{30}\NormalTok{)}
\CommentTok{#> [1] -31}
\end{Highlighting}
\end{Shaded}

Rather than trial and error, we can automate the process of finding the
best value with \texttt{optimise()}. It will evaluate \texttt{ll1()}
many times, using mathematical tricks to narrow in on the largest value
as quickly as possible. The results tell us that the highest value is
\texttt{-30.27} which occurs when \texttt{lambda\ =\ 32.1}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{optimise}\NormalTok{(ll1, }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{), }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> $maximum}
\CommentTok{#> [1] 32.1}
\CommentTok{#> }
\CommentTok{#> $objective}
\CommentTok{#> [1] -30.3}
\end{Highlighting}
\end{Shaded}

Now, we could have solved this problem without using a function factory
because \texttt{optimise()} passes \texttt{...} on to the function being
optimised. That means we could use the log-probability function
directly:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{optimise}\NormalTok{(lprob_poisson, }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{), }\DataTypeTok{x =}\NormalTok{ x1, }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> $maximum}
\CommentTok{#> [1] 32.1}
\CommentTok{#> }
\CommentTok{#> $objective}
\CommentTok{#> [1] -30.3}
\end{Highlighting}
\end{Shaded}

The advantage of using a function factory here is fairly small, but
there are two niceties:

\begin{itemize}
\item
  We can precompute some values in the factory itself, saving
  computation time in each iteration.
\item
  I think the two-level design better reflects the mathematical
  structure of the underlying problem.
\end{itemize}

These advantages get bigger in more complex MLE problems, where you have
multiple parameters and multiple data vectors.

\hypertarget{exercises-32}{%
\subsection{Exercises}\label{exercises-32}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In \texttt{boot\_model()}, why don't I need to force the evaluation of
  \texttt{df} or \texttt{model}?
\item
  Why might you formulate the Box-Cox transformation like this?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boxcox3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{function}\NormalTok{(lambda) \{}
    \ControlFlowTok{if}\NormalTok{ (lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
      \KeywordTok{log}\NormalTok{(x)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      (x }\OperatorTok{^}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{lambda}
\NormalTok{    \}}
\NormalTok{  \}  }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Why don't you need to worry that \texttt{boot\_permute()} stores a
  copy of the data inside the function that it generates?
\item
  How much time does \texttt{ll\_poisson2()} save compared to
  \texttt{ll\_poisson1()}? Use \texttt{bench::mark()} to see how much
  faster the optimisation occurs. How does changing the length of
  \texttt{x} change the results?
\end{enumerate}

\hypertarget{functional-factories}{%
\section{Function factories + functionals}\label{functional-factories}}

To finish off the chapter, I'll show how you might combine functionals
and function factories to turn data into many functions. The following
code creates many specially named power functions by iterating over a
list of arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{names <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{square =} \DecValTok{2}\NormalTok{, }
  \DataTypeTok{cube =} \DecValTok{3}\NormalTok{, }
  \DataTypeTok{root =} \DecValTok{1}\OperatorTok{/}\DecValTok{2}\NormalTok{, }
  \DataTypeTok{cuberoot =} \DecValTok{1}\OperatorTok{/}\DecValTok{3}\NormalTok{, }
  \DataTypeTok{reciprocal =} \DecValTok{-1}
\NormalTok{)}
\NormalTok{funs <-}\StringTok{ }\NormalTok{purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(names, power1)}

\NormalTok{funs}\OperatorTok{$}\KeywordTok{root}\NormalTok{(}\DecValTok{64}\NormalTok{)}
\CommentTok{#> [1] 8}
\NormalTok{funs}\OperatorTok{$}\NormalTok{root}
\CommentTok{#> function(x) \{}
\CommentTok{#>     x ^ exp}
\CommentTok{#>   \}}
\CommentTok{#> <bytecode: 0x186b7e0>}
\CommentTok{#> <environment: 0x5b516a0>}
\end{Highlighting}
\end{Shaded}

This idea extends in a straightforward way if your function factory
takes two (replace \texttt{map()} with \texttt{map2()}) or more (replace
with \texttt{pmap()}) arguments.

\hypertarget{moving-a-list-to-the-global-environment}{%
\subsection{Moving a list to the global
environment}\label{moving-a-list-to-the-global-environment}}

\indexc{with()}
\indexc{attach()}
\indexc{env\_bind()}

One downside of the current construction is that you have to prefix
every function call with \texttt{funs\$}. There are three ways to
eliminate this additional syntax:

\begin{itemize}
\item
  For a very temporary effect, you can use \texttt{with()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with}\NormalTok{(funs, }\KeywordTok{root}\NormalTok{(}\DecValTok{100}\NormalTok{))}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

  I recommend this because it makes it very clear when code is being
  executed in a special context and what that context is.
\item
  For a longer effect, you can \texttt{attach()} the functions to the
  search path, then \texttt{detach()} when you're done:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attach}\NormalTok{(funs)}
\CommentTok{#> The following objects are masked _by_ .GlobalEnv:}
\CommentTok{#> }
\CommentTok{#>     cube, square}
\KeywordTok{root}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\CommentTok{#> [1] 10}
\KeywordTok{detach}\NormalTok{(funs)}
\end{Highlighting}
\end{Shaded}

  You've probably been told to avoid using \texttt{attach()}, and that's
  generally good advice. However, the situation is a little different to
  the usual because we're attaching a list of functions, not a data
  frame. It's less likely that you'll modify a function than a column in
  a data frame, so the some of the worst problems with \texttt{attach()}
  don't apply.
\item
  Finally, you could copy the functions to the global environment with
  \texttt{env\_bind()}. This is mostly permanent:
\end{itemize}

\begin{verbatim}
```r
rlang::env_bind(globalenv(), !!!funs)
root(100)
#> [1] 10
```

You can later unbind those same names, but there's no guarantee that 
they haven't been rebound in the meantime, and you might be deleting an
object that someone else created.


```r
rlang::env_unbind(globalenv(), names(funs))
```
\end{verbatim}

\hypertarget{another-approach}{%
\subsection{Another approach}\label{another-approach}}

You'll learn an alternative approach to the same problem in Section
\ref{quasi-function}. Instead of using a function factory, you could
construct the function with quasiquotation. This requires additional
knowledge, but generates functions with readable bodies, and avoids
accidentally capturing large objects in the enclosing scope. The
following code is a quick preview of how we could rewrite
\texttt{power1()} to use quasiquotation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(exponent) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ ), }
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      x }\OperatorTok{^}\StringTok{ }\OperatorTok{!!}\NormalTok{exponent}
\NormalTok{    \}), }
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\NormalTok{funs <-}\StringTok{ }\NormalTok{purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(names, power3)}

\NormalTok{funs}\OperatorTok{$}\NormalTok{root}
\CommentTok{#> function (x) }
\CommentTok{#> \{}
\CommentTok{#>     x^0.5}
\CommentTok{#> \}}
\CommentTok{#> <environment: 0x5acf868>}
\end{Highlighting}
\end{Shaded}

As well as \texttt{0.5} appearing directly in the body, note that the
environment of the function is the global environment, not an execution
environment of \texttt{power3()}.

\hypertarget{exercises-33}{%
\subsection{Exercises}\label{exercises-33}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Which of the following commands is equivalent to
  \texttt{with(x,\ f(z))}?

  \begin{enumerate}
  \def\labelenumii{(\alph{enumii})}
  \tightlist
  \item
    \texttt{x\$f(x\$z)}.
  \item
    \texttt{f(x\$z)}.
  \item
    \texttt{x\$f(z)}.
  \item
    \texttt{f(z)}.
  \item
    It depends.
  \end{enumerate}
\item
  Compare and contrast the effects of \texttt{env\_bind()} vs.
  \texttt{attach()} for the following code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{mean =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
  \DataTypeTok{sum =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{)}

\KeywordTok{attach}\NormalTok{(funs)}
\CommentTok{#> The following objects are masked from package:base:}
\CommentTok{#> }
\CommentTok{#>     mean, sum}
\NormalTok{mean <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{)}
\KeywordTok{detach}\NormalTok{(funs)}

\KeywordTok{env_bind}\NormalTok{(}\KeywordTok{globalenv}\NormalTok{(), }\OperatorTok{!!!}\NormalTok{funs)}
\NormalTok{mean <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{) }
\KeywordTok{env_unbind}\NormalTok{(}\KeywordTok{globalenv}\NormalTok{(), }\KeywordTok{names}\NormalTok{(funs))}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{function-operators}{%
\chapter{Function operators}\label{function-operators}}

\hypertarget{introduction-9}{%
\section{Introduction}\label{introduction-9}}

\index{function operators}

In this chapter, you'll learn about function operators (FOs). A function
operator is a function that takes one (or more) functions as input and
returns a function as output. The following code shows a simple function
operator, \texttt{chatty()}. It wraps a function, making a new function
that prints out its first argument. You might create a function like
this because it gives you a window to see how functionals, like
\texttt{map\_int()}, work.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chatty <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f) \{}
  \KeywordTok{force}\NormalTok{(f)}
  
  \ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{    res <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x, ...)}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"Processing "}\NormalTok{, x, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{    res}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{s <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}

\NormalTok{purrr}\OperatorTok{::}\KeywordTok{map_dbl}\NormalTok{(s, }\KeywordTok{chatty}\NormalTok{(f))}
\CommentTok{#> Processing 3}
\CommentTok{#> Processing 2}
\CommentTok{#> Processing 1}
\CommentTok{#> [1] 9 4 1}
\end{Highlighting}
\end{Shaded}

Function operators are closely related to function factories; indeed
they're just a function factory that takes a function as input. Like
factories, there's nothing you can't do without them, but they often
allow you to factor out complexity in order to make your code more
readable and resuable.

Function operators are typically paired with functionals. If you're
using a for-loop, there's rarely a reason to use a FO, as it will make
your code more complex for little gain.

If you're familiar with Python, decorators are just another name for
function operators.

\hypertarget{outline-7}{%
\subsection*{Outline}\label{outline-7}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{existing-fos} introduces you to two extremely useful
  existing FOs, and shows you how to use them to solve real problems.
\item
  Section \ref{fo-case-study} works through a problem amenable to
  solution with function operators: downloading many web pages.
\end{itemize}

\hypertarget{prerequisites-5}{%
\subsection*{Prerequisites}\label{prerequisites-5}}
\addcontentsline{toc}{subsection}{Prerequisites}

Function operators are a type of function factory, so make sure you're
familiar with at least Section \ref{function-fundamentals} before you go
on.

We'll use purrr for a couple of functionals that you learned about in
Chapter \ref{functionals}, and some function operators that you'll learn
about below. We'll also use the memoise package for the
\texttt{memoise()} operator.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}
\KeywordTok{library}\NormalTok{(memoise)}
\end{Highlighting}
\end{Shaded}

\hypertarget{existing-fos}{%
\section{Existing FOs}\label{existing-fos}}

There are two very useful function operators that will both help you
solve common recurring problems, and give you a sense for what FOs can
do: \texttt{purrr::safely()} and \texttt{memoise::memoise()}.

\hypertarget{safely}{%
\subsection{\texorpdfstring{Capturing errors with
\texttt{purrr::safely()}}{Capturing errors with purrr::safely()}}\label{safely}}

\indexc{safely()}

One advantage of for-loops is that if one of the iterations fails, you
can still access all the results up to the failure:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{c}\NormalTok{(}\FloatTok{0.512}\NormalTok{, }\FloatTok{0.165}\NormalTok{, }\FloatTok{0.717}\NormalTok{),}
  \KeywordTok{c}\NormalTok{(}\FloatTok{0.064}\NormalTok{, }\FloatTok{0.781}\NormalTok{, }\FloatTok{0.427}\NormalTok{),}
  \KeywordTok{c}\NormalTok{(}\FloatTok{0.890}\NormalTok{, }\FloatTok{0.785}\NormalTok{, }\FloatTok{0.495}\NormalTok{),}
  \StringTok{"oops"}
\NormalTok{)}

\NormalTok{out <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\OtherTok{NA_real_}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{  out[[i]] <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(x[[i]])}
\NormalTok{\}}
\CommentTok{#> Error in sum(x[[i]]):}
\CommentTok{#>   invalid 'type' (character) of argument}
\NormalTok{out}
\CommentTok{#> [1] 1.39 1.27 2.17   NA}
\end{Highlighting}
\end{Shaded}

If you do the same thing with a functional, you get no output, making it
hard to figure out where the problem lies:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(x, sum)}
\CommentTok{#> Error in sum(..., na.rm = na.rm):}
\CommentTok{#>   invalid 'type' (character) of argument}
\end{Highlighting}
\end{Shaded}

\texttt{purrr::safely()} provides a tool to help with this problem.
\texttt{safely()} is a function operator that transforms a function to
turn errors into data. (You can learn the basic idea that makes it work
in Section \ref{try-success-failure}). Let's start by taking a look at
it outside of \texttt{map\_dbl()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safe_sum <-}\StringTok{ }\KeywordTok{safely}\NormalTok{(sum)}
\NormalTok{safe_sum}
\CommentTok{#> function (...) }
\CommentTok{#> capture_error(.f(...), otherwise, quiet)}
\CommentTok{#> <bytecode: 0x151e1d8>}
\CommentTok{#> <environment: 0x151e670>}
\end{Highlighting}
\end{Shaded}

Like all function operators, \texttt{safely()} takes a function and
returns a wrapped function which we can call as usual:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{safe_sum}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]]))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ result: num 1.39}
\CommentTok{#>  $ error : NULL}
\KeywordTok{str}\NormalTok{(}\KeywordTok{safe_sum}\NormalTok{(x[[}\DecValTok{4}\NormalTok{]]))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ result: NULL}
\CommentTok{#>  $ error :List of 2}
\CommentTok{#>   ..$ message: chr "invalid 'type' (character) of argument"}
\CommentTok{#>   ..$ call   : language sum(..., na.rm = na.rm)}
\CommentTok{#>   ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"}
\end{Highlighting}
\end{Shaded}

You can see that a function transformed by \texttt{safely()} always
returns a list with two elements, \texttt{result} and \texttt{error}. If
the function runs successfully, \texttt{error} is \texttt{NULL} and
\texttt{result} contains the result; if the function fails,
\texttt{result} is \texttt{NULL} and \texttt{error} contains the error.

Now lets use \texttt{safely()} with a functional:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out <-}\StringTok{ }\KeywordTok{map}\NormalTok{(x, }\KeywordTok{safely}\NormalTok{(sum))}
\KeywordTok{str}\NormalTok{(out)}
\CommentTok{#> List of 4}
\CommentTok{#>  $ :List of 2}
\CommentTok{#>   ..$ result: num 1.39}
\CommentTok{#>   ..$ error : NULL}
\CommentTok{#>  $ :List of 2}
\CommentTok{#>   ..$ result: num 1.27}
\CommentTok{#>   ..$ error : NULL}
\CommentTok{#>  $ :List of 2}
\CommentTok{#>   ..$ result: num 2.17}
\CommentTok{#>   ..$ error : NULL}
\CommentTok{#>  $ :List of 2}
\CommentTok{#>   ..$ result: NULL}
\CommentTok{#>   ..$ error :List of 2}
\CommentTok{#>   .. ..$ message: chr "invalid 'type' (character) of argument"}
\CommentTok{#>   .. ..$ call   : language sum(..., na.rm = na.rm)}
\CommentTok{#>   .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condit"..}
\end{Highlighting}
\end{Shaded}

The output is in a slightly inconvenient form, since we have four lists,
each of which is a list containing the \texttt{result} and the
\texttt{error}. We can make the output easier to use with
\texttt{purrr::transpose()}. This turns it ``inside-out'' so that we get
a list of \texttt{result}s and a list of \texttt{error}s:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out <-}\StringTok{ }\KeywordTok{transpose}\NormalTok{(}\KeywordTok{map}\NormalTok{(x, }\KeywordTok{safely}\NormalTok{(sum)))}
\KeywordTok{str}\NormalTok{(out)}
\CommentTok{#> List of 2}
\CommentTok{#>  $ result:List of 4}
\CommentTok{#>   ..$ : num 1.39}
\CommentTok{#>   ..$ : num 1.27}
\CommentTok{#>   ..$ : num 2.17}
\CommentTok{#>   ..$ : NULL}
\CommentTok{#>  $ error :List of 4}
\CommentTok{#>   ..$ : NULL}
\CommentTok{#>   ..$ : NULL}
\CommentTok{#>   ..$ : NULL}
\CommentTok{#>   ..$ :List of 2}
\CommentTok{#>   .. ..$ message: chr "invalid 'type' (character) of argument"}
\CommentTok{#>   .. ..$ call   : language sum(..., na.rm = na.rm)}
\CommentTok{#>   .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condit"..}
\end{Highlighting}
\end{Shaded}

Now we can easily find the results that worked, or the inputs that
failed:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ok <-}\StringTok{ }\KeywordTok{map_lgl}\NormalTok{(out}\OperatorTok{$}\NormalTok{error, is.null)}
\NormalTok{ok}
\CommentTok{#> [1]  TRUE  TRUE  TRUE FALSE}

\NormalTok{x[}\OperatorTok{!}\NormalTok{ok]}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] "oops"}

\NormalTok{out}\OperatorTok{$}\NormalTok{result[ok]}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 1.39}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 1.27}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 2.17}
\end{Highlighting}
\end{Shaded}

\index{fitting many models} You can use this same technique in many
different situtations. For example, imagine you're fitting a generalised
linear model (GLM) to a list of data frames. GLMs can sometimes fail
because of optimisation problems, but you still want to be able to try
to fit all the models, and later look back at those that failed:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fit_model <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df) \{}
  \KeywordTok{glm}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2 }\OperatorTok{*}\StringTok{ }\NormalTok{x3, }\DataTypeTok{data =}\NormalTok{ df)}
\NormalTok{\}}

\NormalTok{models <-}\StringTok{ }\KeywordTok{transpose}\NormalTok{(}\KeywordTok{map}\NormalTok{(datasets, }\KeywordTok{safely}\NormalTok{(fit_model)))}
\NormalTok{ok <-}\StringTok{ }\KeywordTok{map_lgl}\NormalTok{(models}\OperatorTok{$}\NormalTok{error, is.null)}

\CommentTok{# which data failed to converge?}
\NormalTok{datasets[}\OperatorTok{!}\NormalTok{ok]}

\CommentTok{# which models were successful?}
\NormalTok{models[ok]}
\end{Highlighting}
\end{Shaded}

I think this is a great example of the power of combining functionals
and function operators: \texttt{safely()} lets you succinctly express
what you need to solve a common data analysis problem.

purrr comes with three other function operators in a similar vein:

\begin{itemize}
\item
  \texttt{possibly()}: returns a default value when there's an error. 
\item
  \texttt{quietly()}: turns output, messages, and warning side-effects
  into \texttt{output}, \texttt{message}, and \texttt{warning}
  components of the output.
\item
  \texttt{auto\_browser()}: automatically executes \texttt{browser()}
  inside the function when there's an error.
\end{itemize}

See their documentation for more details.

\hypertarget{memoise}{%
\subsection{\texorpdfstring{Caching computations with
\texttt{memoise::memoise()}}{Caching computations with memoise::memoise()}}\label{memoise}}

\index{memoisation} \indexc{memoise()} \index{Fibonacci series}

Another handy FO is \texttt{memoise::memoise()}. It \textbf{memoises} a
function, meaning that the function will remember previous inputs and
return cached results. Memoisation is an example of the classic computer
science tradeoff of memory versus speed. A memoised function can run
much faster because it stores all of the previous inputs and outputs,
using more memory.

Let's explore this idea with a toy function that simulates an expensive
operation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{slow_function <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{  x }\OperatorTok{*}\StringTok{ }\DecValTok{10} \OperatorTok{*}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{slow_function}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] 0.808}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>       0       0       1}

\KeywordTok{system.time}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{slow_function}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] 8.34}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>    0.00    0.00    1.01}
\end{Highlighting}
\end{Shaded}

When we memoise this function, it's slow when we call it with new
arguments. But when we call it with arguments that it's seen before it's
instanteous: it retrieves the previous value of the computation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fast_function <-}\StringTok{ }\NormalTok{memoise}\OperatorTok{::}\KeywordTok{memoise}\NormalTok{(slow_function)}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{fast_function}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] 6.01}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>       0       0       1}

\KeywordTok{system.time}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{fast_function}\NormalTok{(}\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] 6.01}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.016   0.000   0.017}
\end{Highlighting}
\end{Shaded}

A relatively realistic use of memoisation is computing the Fibonacci
series. The Fibonacci series is defined recursively: the first two
values are defined by convention, \(f(0) = 0\), \(f(n) = 1\), and then
\(f(n) = f(n - 1) + f(n - 2)\) (for any positive integer). A naive
version is slow because, for example, \texttt{fib(10)} computes
\texttt{fib(9)} and \texttt{fib(8)}, and \texttt{fib(9)} computes
\texttt{fib(8)} and \texttt{fib(7)}, and so on.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fib <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
  \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{<}\StringTok{ }\DecValTok{2}\NormalTok{) }\KeywordTok{return}\NormalTok{(}\DecValTok{1}\NormalTok{)}
  \KeywordTok{fib}\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{fib}\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{fib}\NormalTok{(}\DecValTok{23}\NormalTok{))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.040   0.004   0.043}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{fib}\NormalTok{(}\DecValTok{24}\NormalTok{))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.064   0.000   0.067}
\end{Highlighting}
\end{Shaded}

Memoising \texttt{fib()} makes the implementation much faster because
each value is computed only once:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fib2 <-}\StringTok{ }\NormalTok{memoise}\OperatorTok{::}\KeywordTok{memoise}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(n) \{}
  \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{<}\StringTok{ }\DecValTok{2}\NormalTok{) }\KeywordTok{return}\NormalTok{(}\DecValTok{1}\NormalTok{)}
  \KeywordTok{fib2}\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{fib2}\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{\})}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{fib2}\NormalTok{(}\DecValTok{23}\NormalTok{))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.024   0.000   0.025}
\end{Highlighting}
\end{Shaded}

And future calls can rely on previous computations:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{fib2}\NormalTok{(}\DecValTok{24}\NormalTok{))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.000   0.000   0.001}
\end{Highlighting}
\end{Shaded}

This is an example of \textbf{dynamic programming}, where a complex
problem can be broken down into many overlapping subproblems, and
remembering the results of a subproblem considerably improves
performance.

Think carefully before memoising a function. If the function is not
\textbf{pure}, i.e.~the output does not depend only on the input, you
will get misleading and confusing results. I created a subtle bug in
devtools because I memoised the results of \texttt{available.package()},
which is rather slow because it has to download a large file from CRAN.
The available packages don't change that frequently, but if you have an
R process that's been running for a few days, the changes can become
important, and because the problem only arose in long-running R
processes, the bug was very painful to find.

\hypertarget{exercises-34}{%
\subsection{Exercises}\label{exercises-34}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Base R provides a function operator in the form of
  \texttt{Vectorize()}. What does it do? When might you use it?
\item
  Read the source code for \texttt{possibly()}. How does it work?
\item
  Read the source code for \texttt{safely()}. How does it work?
\end{enumerate}

\hypertarget{fo-case-study}{%
\section{Case study: creating your own FOs}\label{fo-case-study}}

\indexc{delay\_by()}
\indexc{dot\_every()}

\texttt{meomoise()} and \texttt{safely()} are very useful but also quite
complex. In this case study you'll learn how to create your own simpler
function operators. Imagine you have a named vector of URLs and you'd
like to download each one to disk. That's pretty simple with
\texttt{walk2()} and \texttt{file.download()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{urls <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"adv-r"}\NormalTok{ =}\StringTok{ "https://adv-r.hadley.nz"}\NormalTok{, }
  \StringTok{"r4ds"}\NormalTok{ =}\StringTok{ "http://r4ds.had.co.nz/"}
  \CommentTok{# and many many more}
\NormalTok{)}
\NormalTok{path <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\KeywordTok{names}\NormalTok{(urls), }\StringTok{".html"}\NormalTok{)}

\KeywordTok{walk2}\NormalTok{(urls, path, download.file, }\DataTypeTok{quiet =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This approach is fine for a handful of URLs, but as the vector gets
longer, it'd be nice to add a couple more features:

\begin{itemize}
\item
  Add a small delay between each request to avoid hammering the server.
\item
  Display a \texttt{.} every few URLs so that we know that the function
  is still working.
\end{itemize}

It's relatively easy to add these extra features if we're using a for
loop:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(urls)) \{}
  \KeywordTok{Sys.sleep}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{%%}\StringTok{ }\DecValTok{10} \OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{cat}\NormalTok{(}\StringTok{"."}\NormalTok{)}
  \KeywordTok{download.file}\NormalTok{(urls[[i]], paths[[i]])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

I think this for loop is suboptimal because it interleaves different
concerns: pausing, showing progress, and downloading. This makes the
code harder to read, and it makes it harder to reuse the components in
new situations. Instead, let's see if we can use function operators to
extract out pausing and showing progress and make them reusable.

First, let's write an FO that adds a small delay. I'm going to call it
\texttt{delay\_by()} for reasons that will be more clear shortly, and it
has two arguments: the function to wrap, and the amount of delay to add.
The actual implementation is quite simple. The main trick is forcing
evaluation of all arguments as described in Section
\ref{factory-pitfalls}, because function operators are a special type of
function factory:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{delay_by <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, amount) \{}
  \KeywordTok{force}\NormalTok{(f)}
  \KeywordTok{force}\NormalTok{(amount)}
  
  \ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{Sys.sleep}\NormalTok{(amount)}
    \KeywordTok{f}\NormalTok{(...)}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>       0       0       0}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{delay_by}\NormalTok{(runif, }\FloatTok{0.1}\NormalTok{)(}\DecValTok{100}\NormalTok{))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.000   0.000   0.101}
\end{Highlighting}
\end{Shaded}

And we can use it with the original \texttt{walk2()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{walk2}\NormalTok{(urls, path, }\KeywordTok{delay_by}\NormalTok{(download.file, }\FloatTok{0.1}\NormalTok{), }\DataTypeTok{quiet =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Creating a function to display the occasional dot is a little harder,
because we can no longer rely on the index from the loop. We could pass
the index along as another argument, but that breaks encapsulation: a
concern of the progress function now becomes a problem that the higher
level wrapper needs to handle. Instead, we'll use another function
factory trick (from Section \ref{stateful-funs}), so that the progress
wrapper can manage its own internal counter:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dot_every <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, n) \{}
  \KeywordTok{force}\NormalTok{(f)}
  \KeywordTok{force}\NormalTok{(n)}
  
\NormalTok{  i <-}\StringTok{ }\DecValTok{1}
  \ControlFlowTok{function}\NormalTok{(...) \{}
    \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{%%}\StringTok{ }\NormalTok{n }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{cat}\NormalTok{(}\StringTok{"."}\NormalTok{)}
\NormalTok{    i <<-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
    \KeywordTok{f}\NormalTok{(...)}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{walk}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, runif)}
\KeywordTok{walk}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\KeywordTok{dot_every}\NormalTok{(runif, }\DecValTok{10}\NormalTok{))}
\CommentTok{#> ..........}
\end{Highlighting}
\end{Shaded}

Now we can express our original for loop as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{walk2}\NormalTok{(}
\NormalTok{  urls, path, }
  \KeywordTok{dot_every}\NormalTok{(}\KeywordTok{delay_by}\NormalTok{(download.file, }\FloatTok{0.1}\NormalTok{), }\DecValTok{10}\NormalTok{), }
  \DataTypeTok{quiet =} \OtherTok{TRUE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This is starting to get a little hard to read because we are composing
many function calls, and the arguments are getting spread out. One way
to resolve that is to use the pipe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{walk2}\NormalTok{(}
\NormalTok{  urls, path, }
\NormalTok{  download.file }\OperatorTok{%>%}\StringTok{ }\KeywordTok{dot_every}\NormalTok{(}\DecValTok{10}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{delay_by}\NormalTok{(}\FloatTok{0.1}\NormalTok{), }
  \DataTypeTok{quiet =} \OtherTok{TRUE}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The pipe works well here because I've carefully chosen the function
names to yield an (almost) readable sentence: take
\texttt{download.file} then (add) a dot every 10 iterations, then delay
by 0.1s. The more clearly you can express the intent of your code
through function names, the more easily others (including future you!)
can read and understand the code.

\hypertarget{exercises-35}{%
\subsection{Exercises}\label{exercises-35}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Weigh the pros and cons of
  \texttt{download.file\ \%\textgreater{}\%\ dot\_every(10)\ \%\textgreater{}\%\ delay\_by(0.1)}
  vs
  \texttt{download.file\ \%\textgreater{}\%\ delay\_by(0.1)\ \%\textgreater{}\%\ dot\_every(10)}.
\item
  Should you memoise \texttt{file.download()}? Why/why not?
\item
  Create a FO that reports whenever a file is created or deleted in the
  working directory, using \texttt{dir()} and \texttt{setdiff()}. What
  other global function effects might you want to track?
\item
  Write a FO that logs a timestamp and message to a file every time a
  function is run.
\item
  Modify \texttt{delay\_by()} so that instead of delaying by a fixed
  amount of time, it ensures that a certain amount of time has elapsed
  since the function was last called. That is, if you called
  \texttt{g\ \textless{}-\ delay\_by(1,\ f);\ g();\ Sys.sleep(2);\ g()}
  there shouldn't be an extra delay.
\end{enumerate}

\hypertarget{part-object-oriented-programming}{%
\part{Object oriented
programming}\label{part-object-oriented-programming}}

\index{object-oriented programming}

\hypertarget{oo}{%
\chapter*{Introduction}\label{oo}}
\addcontentsline{toc}{chapter}{Introduction}

In the following five chapters you'll learn about \textbf{object
oriented programming} (OOP). OOP is a little more challenging in R than
in other languages because:

\begin{itemize}
\item
  There are multiple OOP systems to choose from. In this book, I'll
  focus on the three that I believe are most important: \textbf{S3},
  \textbf{R6}, and \textbf{S4}. S3 and S4 are provided by base R. R6 is
  provided by the R6 package, and is similar to the ``Reference
  Classes'', or \textbf{RC} for short, from base R.
\item
  There is disagreement about the relative importance of the OOP
  systems. I think S3 is most important, followed by R6, then S4. Others
  believe that S4 is most important, followed by RC, and that S3 should
  be avoided. This means that different R communities use different
  systems.
\item
  S3 and S4 use ``generic function OOP'' which is rather different from
  the ``encapsulated OOP'' used by most languages popular
  today\footnote{The exception is Julia, which also uses generic
    function OOP. Compared to R, Julia's implementation is fully
    developed and extremely performant.}. We'll come back to preisely
  what those terms mean shortly, but basically, while the underlying
  ideas of OOP are the same across languages, their expressions are
  rather different. This means that you can't immediately transfer your
  existing OOP skills to R.
\end{itemize}

Generally in R, functional programming is much more important than
object oriented programming, because you typically solve complex
problems by decomposing them into simple functions, not simple objects.
Nevertheless, there are important reasons to learn each of the three
systems:

\begin{itemize}
\item
  S3 allows your functions to return rich results with user-friendly
  display and programmer-friendly internals. S3 is used throughout base
  R, so it's important to master if you want to extend base R functions
  to work with new types of input.
\item
  R6 provides a standardised way to escape R's from copy-on-modify
  semantics. This is particularly important if you want to model objects
  that exist independently of R. Today, a common need for R6 is to model
  data that comes from a web API, and where changes come from inside or
  outside of R.
\item
  S4 is a rigorous system that forces you to think carefully about
  program design. It's particuarly well-suited for building large
  systems that evolve over time and will receive contributions from many
  programmers. This is why it is used by the Bioconductor project, so
  another reason to learn S4 is in order to contribute to that project.
\end{itemize}

The goal of this brief introdutory chapter is to give you some important
vocabulary and some tools to identify OOP systems in the wild. The
following four chapters (Base types, S3, R6, and S4) then dive into the
details of R's OOP systems.

Note that this book focusses on the mechanics of OOP, not its effective
use, and it may be challenging to fully understand if you have done
object oriented programming before. You might wonder why I chose not to
provide more immediately useful coverage. I have focussed on mechanics
here because they need to be well described somewhere (writing these
chapters required a considerable amount of reading, exploration, and
synthesis on my behalf), and using OOP effectively is sufficiently
complex to require book-length treatment; there's simply not enough room
in Advanced R to cover it in the depth required.

\hypertarget{oop-systems}{%
\section*{OOP systems}\label{oop-systems}}
\addcontentsline{toc}{section}{OOP systems}

Different people use OOP terms in different ways, so this section
provides a quick overview of important vocabulary. The explanations are
necessarily compressed, but we will come back to these ideas multiple
times.

The main reason to use OOP is \textbf{polymorphism} (literally: many
shapes). Polymorphism means that a developer can consider a function's
interface separately from its implementation, making it possible to use
the same function form for different types of input. This is closely
related to the idea of \textbf{encapsulation}: the user doesn't need to
worry about details of an object because they are encapsulated behind a
standard interface.

To be concrete, polymorphism is what allows \texttt{summary()} to
produce different outputs for numeric and factor variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds <-}\StringTok{ }\NormalTok{ggplot2}\OperatorTok{::}\NormalTok{diamonds}

\KeywordTok{summary}\NormalTok{(diamonds}\OperatorTok{$}\NormalTok{carat)}
\CommentTok{#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. }
\CommentTok{#>    0.20    0.40    0.70    0.80    1.04    5.01}

\KeywordTok{summary}\NormalTok{(diamonds}\OperatorTok{$}\NormalTok{cut)}
\CommentTok{#>      Fair      Good Very Good   Premium     Ideal }
\CommentTok{#>      1610      4906     12082     13791     21551}
\end{Highlighting}
\end{Shaded}

You could imagine \texttt{summary()} containing a series of if-else
statements, but that would mean only the original author could add new
implementations. An OOP system makes it possible for any developer to
extend the interface with implementations for new types of input.

To be more precise, OO systems call the ``type'' of an object its
\textbf{class}, and an implementation for a specific class is called a
\textbf{method}. Roughly speaking, a class defines what an object
\emph{is} and methods describe what that object can \emph{do}. The class
defines the \textbf{fields}, the data possessed by every instance of
that class. Classes are organised in a hierarchy so that if a method
does not exist for one class, its parent's method is used, and the child
is said to \textbf{inherit} behaviour. For example, in R, an ordered
factor inherits from a regular factor, and a generalised linear model
inherits from a linear model. The process of finding the correct method
given a class is called \textbf{method dispatch}.

There are two main paradigms of object-oriented programming which differ
in how methods and classes are related. In this book, we'll borrow the
terminology of \emph{Extending R} (Chambers
\protect\hyperlink{ref-extending-R}{2016}) and call these paradigms
encapsulated and functional:

\begin{itemize}
\item
  In \textbf{encapsulated} OOP, methods belong to objects or classes,
  and method calls typically look like
  \texttt{object.method(arg1,\ arg2)}. This is called encapsulated
  because the object encapsulates both data (with fields) and behaviour
  (with methods), and is the paradigm found in most popular languages.
\item
  In \textbf{functional} OOP, methods belong to \textbf{generic}
  functions, and method calls look like ordinary function calls:
  \texttt{generic(object,\ arg2,\ arg3)}. This is called functional
  because from the outside it looks like a regular function call, and
  internally the components are also functions.
\end{itemize}

With this terminology in hand, we can now talk precisely about the
different OO systems available in R.

\hypertarget{oop-in-r}{%
\section*{OOP in R}\label{oop-in-r}}
\addcontentsline{toc}{section}{OOP in R}

Base R provides three OOP systems: S3, S4, and reference classes (RC):

\begin{itemize}
\item
  \textbf{S3} is R's first OOP system, and is described in
  \emph{Statistical Models in S} (Chambers and Hastie
  \protect\hyperlink{ref-white-book}{1992}). S3 is an informal
  implementation of functional OOP and relies on common conventions
  rather than ironclad guarantees. This makes it easy to get started
  with, providing a low cost way of solving many simple problems.
\item
  \textbf{S4} is a formal and rigorous rewrite of S3, and was introduced
  in \emph{Programming with Data} (Chambers
  \protect\hyperlink{ref-programming-with-data}{1998}). It requires more
  upfront work than S3, but in return provides more guaranetees and
  greater encapsulation. S4 is implemented in the base \textbf{methods}
  package, which is always installed with R.

  (You might wonder if S1 and S2 exist. They don't: S3 and S4 were named
  according to the versions of S that they accompanied. The first two
  versions of S didn't have any OOP framework.)
\item
  \textbf{RC} implements encapsulated OO. RC objects are a special type
  of S4 objects that are also \textbf{mutable}, i.e., instead of using
  R's usual copy-on-modify semantics, they can be modified in place.
  This makes them harder to reason about, but allows them to solve
  problems that are difficult to solve in the functional OOP style of S3
  and S4.
\end{itemize}

A number of other OOP systems are provided by CRAN packages:

\begin{itemize}
\item
  \textbf{R6} (Chang \protect\hyperlink{ref-R6}{2017}) implements
  encapsulated OOP like RC, but resolves some important issues. In this
  book, you'll learn about R6 instead of RC, for reasons described in
  Section \ref{why-r6}.
\item
  \textbf{R.oo} (Bengtsson \protect\hyperlink{ref-R.oo}{2003}) provides
  some formalism on top of S3, and makes it possible to have mutable S3
  objects.
\item
  \textbf{proto} (Grothendieck, Kates, and Petzoldt
  \protect\hyperlink{ref-proto}{2016}) implements another style of OOP
  based on the idea of \textbf{prototypes}, which blur the distinctions
  between classes and instances of classes (objects). I was briefly
  enamored with prototype based programming (Wickham
  \protect\hyperlink{ref-mutatr}{2011}) and used it in ggplot2, but now
  think it's better to stick with the standard forms.
\end{itemize}

Apart from R6, which is widely used, these systems are primarily of
theoretical interest. They do have their strengths, but few R users know
and understand them, so it is hard for others to read and contribute to
your code.

\hypertarget{sloop}{%
\section*{sloop}\label{sloop}}
\addcontentsline{toc}{section}{sloop}

Before we go on I want to introduce the sloop package:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# install_github("r-lib/sloop")}
\KeywordTok{library}\NormalTok{(sloop)}
\end{Highlighting}
\end{Shaded}

The sloop package (think ``sail the seas of OOP'') provides a number of
helpers that fill in missing pieces in base R. The first of these is
\texttt{sloop::otype()}. It makes it easy to figure out the OOP system
used by a wild-caught object:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{otype}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] "base"}

\KeywordTok{otype}\NormalTok{(mtcars)}
\CommentTok{#> [1] "S3"}

\NormalTok{mle_obj <-}\StringTok{ }\NormalTok{stats4}\OperatorTok{::}\KeywordTok{mle}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{) (x }\OperatorTok{-}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\KeywordTok{otype}\NormalTok{(mle_obj)}
\CommentTok{#> [1] "S4"}
\end{Highlighting}
\end{Shaded}

Use this function to figure out which chapter to read to understand how
to work with an existing object.

\hypertarget{base-types}{%
\chapter{Base types}\label{base-types}}

\hypertarget{introduction-10}{%
\section{Introduction}\label{introduction-10}}

To talk about objects and OOP in R we first need to clear up a
fundamental confusion about two uses of the word ``object''. So far in
this book, we've used the word in the general sense captured by John
Chambers' pithy quote: ``Everything that exists in R is an object''.
However, while everything \emph{is} an object, not everything is
``object-oriented''. This confusion arises because the base objects come
from S, and were developed before anyone thought that S might need an
OOP system. The tools and nomenclature evolved organically over many
years without a single guiding principle.

Most of the time, the distinction between objects and object-oriented
objects is not important. But here we need to get into the nitty gritty
details so we'll use the terms \textbf{base objects} and \textbf{OO
objects} to distinguish them.

\begin{center}\includegraphics[width=2.21in]{diagrams/oo-venn} \end{center}

\hypertarget{outline-8}{%
\subsection*{Outline}\label{outline-8}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{base-vs-oo} shows you how to identify base and OO
  objects.
\item
  Section \ref{base-types-2} gives a complete set of the base types that
  all objects are built up from.
\end{itemize}

\hypertarget{base-vs-oo}{%
\section{Base vs OO objects}\label{base-vs-oo}}

\indexc{is.object()}
\indexc{mode()}

\index{attributes!class}

To tell the difference between a base and OO object, use
\texttt{is.object()} or \texttt{sloop::otype()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# A base object:}
\KeywordTok{is.object}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{otype}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] "base"}

\CommentTok{# An OO object}
\KeywordTok{is.object}\NormalTok{(mtcars)}
\CommentTok{#> [1] TRUE}
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{otype}\NormalTok{(mtcars)}
\CommentTok{#> [1] "S3"}
\end{Highlighting}
\end{Shaded}

Technically, the difference between base and OO objects is that OO
objects have a ``class'' attribute:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attr}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\StringTok{"class"}\NormalTok{)}
\CommentTok{#> NULL}

\KeywordTok{attr}\NormalTok{(mtcars, }\StringTok{"class"}\NormalTok{)}
\CommentTok{#> [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

You may already be familiar with the \texttt{class()} function. This
function is safe to apply to S3 and S4 objects, but it returns
misleading results when applied to base objects. It's safer to use
\texttt{sloop::s3\_class()}, which returns the implicit class that the
S3 and S4 systems will use to pick methods. You'll learn more about
\texttt{s3\_class()} in Section \ref{implicit-class}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{)}
\KeywordTok{class}\NormalTok{(x)}
\CommentTok{#> [1] "matrix"}
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{s3_class}\NormalTok{(x)}
\CommentTok{#> [1] "matrix"  "integer" "numeric"}
\end{Highlighting}
\end{Shaded}

\hypertarget{base-types-2}{%
\section{Base types}\label{base-types-2}}

\indexc{mode()}
\indexc{typeof()}

While only OO objects have a class attribute, every object has a
\textbf{base type}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] "integer"}

\KeywordTok{typeof}\NormalTok{(mtcars)}
\CommentTok{#> [1] "list"}
\end{Highlighting}
\end{Shaded}

Base types do not form an OOP system because functions that behave
differently for different base types are primarily written in C code
that uses switch statements. This means that only R-core can create new
types, and creating a new type is a lot of work because every switch
statement needs to be modified to handle a new case. As a consequence,
new base types are rarely added. The most recent change, in 2011, added
two exotic types that you never see in R itself, but are needed for
diagnosing memory problems. Prior to that, the last type added was a
special base type for S4 objects added in 2005.

In total, there are 25 different base types. They are listed below,
loosely grouped according to where they're discussed in this book. These
types are most important in C code, so you'll often see them called by
their C type names. I've included those in parentheses.

\begin{itemize}
\item
  Vectors, Chapter \ref{vectors-chap}, include types \texttt{NULL}
  (\texttt{NULLSXP}), \texttt{logical} (\texttt{LGLSXP}),
  \texttt{integer} (\texttt{INTSXP}), \texttt{double}
  (\texttt{REALSXP}), \texttt{complex} (\texttt{CPLSXP}),
  \texttt{character} (\texttt{STRSXP}), \texttt{list} (\texttt{VECSXP}),
  and \texttt{raw} (\texttt{RAWSXP}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> [1] "NULL"}
\KeywordTok{typeof}\NormalTok{(1L)}
\CommentTok{#> [1] "integer"}
\KeywordTok{typeof}\NormalTok{(1i)}
\CommentTok{#> [1] "complex"}
\end{Highlighting}
\end{Shaded}
\item
  Functions, Chapter \ref{functions}, include types \texttt{closure}
  (regular R functions, \texttt{CLOSXP}), \texttt{special} (internal
  functions, \texttt{SPECIALSXP}), and \texttt{builtin} (primitive
  functions, \texttt{BUILTINSXP}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(mean)}
\CommentTok{#> [1] "closure"}
\KeywordTok{typeof}\NormalTok{(}\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] "special"}
\KeywordTok{typeof}\NormalTok{(sum)    }
\CommentTok{#> [1] "builtin"}
\end{Highlighting}
\end{Shaded}

  Internal and primitive functions are described in Section
  \ref{primitive-functions}.
\item
  Environments, Chapter \ref{environments}, have type
  \texttt{environment} (\texttt{ENVSXP}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\KeywordTok{globalenv}\NormalTok{())}
\CommentTok{#> [1] "environment"}
\end{Highlighting}
\end{Shaded}
\item
  The \texttt{S4} type (\texttt{S4SXP}), Chapter \ref{s4}, is used for
  S4 classes that don't inherit from an existing base type.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mle_obj <-}\StringTok{ }\NormalTok{stats4}\OperatorTok{::}\KeywordTok{mle}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{) (x }\OperatorTok{-}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\KeywordTok{typeof}\NormalTok{(mle_obj)}
\CommentTok{#> [1] "S4"}
\end{Highlighting}
\end{Shaded}
\item
  Language components, Chapter \ref{expressions}, include
  \texttt{symbol} (aka name, \texttt{SYMSXP}), \texttt{language}
  (usually called calls, \texttt{LANGSXP}), and \texttt{pairlist} (used
  for function arguments, \texttt{LISTSXP}) types.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\KeywordTok{quote}\NormalTok{(a))}
\CommentTok{#> [1] "symbol"}
\KeywordTok{typeof}\NormalTok{(}\KeywordTok{quote}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] "language"}
\KeywordTok{typeof}\NormalTok{(}\KeywordTok{formals}\NormalTok{(mean))}
\CommentTok{#> [1] "pairlist"}
\end{Highlighting}
\end{Shaded}

  \texttt{expression} (\texttt{EXPRSXP}) is a special purpose type
  that's only returned by \texttt{parse()} and \texttt{expression()}.
  Expressions are generally not needed in user code.
\item
  The remaining types are esoteric and rarely seen in R. They are
  important primarily for C code: \texttt{externalptr}
  (\texttt{EXTPTRSXP}), \texttt{weakref} (\texttt{WEAKREFSXP}),
  \texttt{bytecode} (\texttt{BCODESXP}), \texttt{promise}
  (\texttt{PROMSXP}), \texttt{...} (\texttt{DOTSXP}), and \texttt{any}
  (\texttt{ANYSXP}).
\end{itemize}

You may have heard of \texttt{mode()} and \texttt{storage.mode()}. Do
not use these functions: they exist only to provide type names that
compatible with S.

\hypertarget{numeric-type}{%
\subsection{Numeric type}\label{numeric-type}}

Be careful when talking about the ``numeric'' type, because R uses
``numeric'' to mean three slightly different things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In some places numeric is used as an alias for the ``double'' type.
  For example \texttt{as.numeric()} is identical to
  \texttt{as.double()}, and \texttt{numeric()} is identical to
  \texttt{double()}.

  (R also occasionally uses ``real'' instead of double;
  \texttt{NA\_real\_} is the one place that you're likely to encounter
  this in practice.)
\item
  In the S3 and S4 systems, numeric is used as a shorthand for either
  integer or double type, and is used when picking methods:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{s3_class}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] "double"  "numeric"}
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{s3_class}\NormalTok{(1L)}
\CommentTok{#> [1] "integer" "numeric"}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{is.numeric()} tests for objects that \emph{behave} like
  numbers. For example, factors have type ``integer'' but don't behave
  like numbers (i.e.~it doesn't make sense to take the mean of factor).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\KeywordTok{factor}\NormalTok{(}\StringTok{"x"}\NormalTok{))}
\CommentTok{#> [1] "integer"}
\KeywordTok{is.numeric}\NormalTok{(}\KeywordTok{factor}\NormalTok{(}\StringTok{"x"}\NormalTok{))}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

In this book, I consistently use numeric to mean an object of type
integer or double.

\hypertarget{s3}{%
\chapter{S3}\label{s3}}

\hypertarget{introduction-11}{%
\section{Introduction}\label{introduction-11}}

\index{S3} \index{objects!S3|see{S3}}

S3 is R's first and simplest OO system. S3 is informal and ad hoc, but
there is a certain elegance in its minimalism: you can't take away any
part of it and still have a useful OO system. For these reasons, you
should use it, unless you have a compelling reason to do otherwise. S3
is the only OO system used in the base and stats packages, and it's the
most commonly used system in CRAN packages. \index{S3}
\index{objects!S3|see{S3}}

S3 is very flexible, which means it allows you to do things that are
quite ill-advised. If you're coming from a strict environment like Java
this will seem pretty frightening, but it gives R programmers a
tremendous amount of freedom. It may be very difficult to prevent
someone from doing something you don't want them to do, but your users
will never be held back because there is something you haven't
implemented yet. Since S3 has few built-in constraints, the key to its
successful use is applying the constraints yourself. This chapter will
therefore teach you the conventions you should (almost) always adhere
to.

The goal of this chapter is to show you how the S3 system works, not how
to use it effectively to create new classes and generics. I'd recommend
coupling the theoretical knowledge from this chapter with the practical
knowledge encoded in the \href{https://vctrs.r-lib.org}{vctrs package}.

\hypertarget{outline-9}{%
\subsection*{Outline}\label{outline-9}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{s3-basics} gives a rapid overview of all the main
  components of S3: classes, generics, and methods. You'll also learn
  about \texttt{sloop::s3\_dispatch()}, which we'll use throughout the
  chapter to explore how S3 works.
\item
  Section \ref{s3-classes} goes into the details of creating a new S3
  class, including the three functions that should accompany most
  classes: a constructor, a helper, and a validator.
\item
  Section \ref{s3-methods} describes how S3 generics and methods work,
  including the basics of method dispatch.
\item
  Section \ref{object-styles} discusses the four main styles of S3
  objects: vector, record, data frame, and scalar.
\item
  Section \ref{s3-inheritance} demonstrates how inheritance works in S3,
  and shows you what you need to make a class ``subclassable''.
\item
  Section \ref{s3-dispatch} concludes the chapter with a discussion of
  the finer details of method dispatch including base types, internal
  generics, group generics, and double dispatch.
\end{itemize}

\hypertarget{prerequisites-6}{%
\subsection*{Prerequisites}\label{prerequisites-6}}
\addcontentsline{toc}{subsection}{Prerequisites}

S3 classes are implemented using attributes, so make sure you're
familiar with the details described in Section \ref{attributes}. We'll
use existing base S3 vectors for examples and exploration, so make sure
that you're familiar with the factor, Date, difftime, POSIXct, and
POSIXlt classes described in Section \ref{s3-atomic-vectors}.

We'll use the sloop package for interactive helpers, and the vctrs
package for some niceties for creating new S3 classes.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# install_github("r-lib/sloop")}
\CommentTok{# install_github("r-lib/vctrs")}

\KeywordTok{library}\NormalTok{(sloop)}
\end{Highlighting}
\end{Shaded}

\hypertarget{s3-basics}{%
\section{Basics}\label{s3-basics}}

An S3 object is a base type with at least a ``class'' attribute (other
attributes may be used to store other data). For example, take the
factor. Its base type is the integer vector, it has a class attribute of
``factor'', and a levels attribute that stores the possible levels:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}

\KeywordTok{typeof}\NormalTok{(f)}
\CommentTok{#> [1] "integer"}
\KeywordTok{attributes}\NormalTok{(f)}
\CommentTok{#> $levels}
\CommentTok{#> [1] "a" "b" "c"}
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "factor"}
\end{Highlighting}
\end{Shaded}

You can get the ``underlying'' base type by \texttt{unclass()}ing it,
which strips the class attribute, causing it to lose its special
behaviour:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{unclass}\NormalTok{(f)}
\CommentTok{#> [1] 1 2 3}
\CommentTok{#> attr(,"levels")}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

An S3 object behaves differently from its underlying base type whenever
it's passed to a \textbf{generic} (short for generic function). The
easiest way to tell if a function is a generic is to use
\texttt{sloop::ftype()} and look for ``generic'' in the output:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ftype}\NormalTok{(print)}
\CommentTok{#> [1] "S3"      "generic"}
\KeywordTok{ftype}\NormalTok{(str)}
\CommentTok{#> [1] "S3"      "generic"}
\KeywordTok{ftype}\NormalTok{(unclass)}
\CommentTok{#> [1] "primitive"}
\end{Highlighting}
\end{Shaded}

A generic function defines an interface, which uses a different
implementation depending on the class of an argument (almost always the
first argument). Many base R functions are generic, including the
important \texttt{print()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{print}\NormalTok{(f)}
\CommentTok{#> [1] a b c}
\CommentTok{#> Levels: a b c}

\CommentTok{# stripping class reverts to integer behaviour}
\KeywordTok{print}\NormalTok{(}\KeywordTok{unclass}\NormalTok{(f))}
\CommentTok{#> [1] 1 2 3}
\CommentTok{#> attr(,"levels")}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

Beware that \texttt{str()} is generic, and some S3 classes use that
generic to hide the internal details. For example, the \texttt{POSIXlt}
class used to represent date-time data is actually built on top of a
list, a fact which is hidden by its \texttt{str()} method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{time <-}\StringTok{ }\KeywordTok{strptime}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"2017-01-01"}\NormalTok{, }\StringTok{"2020-05-04 03:21"}\NormalTok{), }\StringTok{"%Y-%m-%d"}\NormalTok{)}
\KeywordTok{str}\NormalTok{(time)}
\CommentTok{#>  POSIXlt[1:2], format: "2017-01-01" "2020-05-04"}

\KeywordTok{str}\NormalTok{(}\KeywordTok{unclass}\NormalTok{(time))}
\CommentTok{#> List of 9}
\CommentTok{#>  $ sec  : num [1:2] 0 0}
\CommentTok{#>  $ min  : int [1:2] 0 0}
\CommentTok{#>  $ hour : int [1:2] 0 0}
\CommentTok{#>  $ mday : int [1:2] 1 4}
\CommentTok{#>  $ mon  : int [1:2] 0 4}
\CommentTok{#>  $ year : int [1:2] 117 120}
\CommentTok{#>  $ wday : int [1:2] 0 1}
\CommentTok{#>  $ yday : int [1:2] 0 124}
\CommentTok{#>  $ isdst: int [1:2] 0 0}
\CommentTok{#>  - attr(*, "tzone")= chr "UTC"}
\end{Highlighting}
\end{Shaded}

The generic is a middleman: its job is to define the interface (i.e.~the
arguments) then find the right implementation for the job. The
implementation for a specific class is called a \textbf{method}, and the
generic finds that method by performing \textbf{method dispatch}.

You can use \texttt{sloop::s3\_dispatch()} to see the process of method
dispatch:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{print}\NormalTok{(f))}
\CommentTok{#> => print.factor}
\CommentTok{#>  * print.default}
\end{Highlighting}
\end{Shaded}

We'll come back to the details of dispatch in Section
\ref{method-dispatch}, for now note that S3 methods are functions with a
special naming scheme, \texttt{generic.class()}. For example, the
\texttt{factor} method for the \texttt{print()} generic is called
\texttt{print.factor()}. You should never call the method directly, but
instead rely on the generic to find it for you.

Generally, you can identify a method by the presence of \texttt{.} in
the function name, but there are a number of important functions in base
R that were written before S3, and hence use \texttt{.} to join words.
If you're unsure, check with \texttt{sloop::ftype()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ftype}\NormalTok{(t.test)}
\CommentTok{#> [1] "S3"      "generic"}
\KeywordTok{ftype}\NormalTok{(t.data.frame)}
\CommentTok{#> [1] "S3"     "method"}
\end{Highlighting}
\end{Shaded}

Unlike most functions, you can't see the source code for most S3
methods\footnote{The exceptions are methods found in the base package,
  like \texttt{t.data.frame}, and methods that you've created.} just by
typing their names. That's because S3 methods are not usually exported:
they live only inside the package, and are not available from the global
environment. Instead, you can use \texttt{sloop::s3\_get\_method()},
which will work regardless of where the method lives:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{weighted.mean.Date}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'weighted.mean.Date' not found}

\KeywordTok{s3_get_method}\NormalTok{(weighted.mean.Date)}
\CommentTok{#> function (x, w, ...) }
\CommentTok{#> structure(weighted.mean(unclass(x), w, ...), class = "Date")}
\CommentTok{#> <bytecode: 0x74d59e8>}
\CommentTok{#> <environment: namespace:stats>}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-36}{%
\subsection{Exercises}\label{exercises-36}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Describe the difference between \texttt{t.test()} and
  \texttt{t.data.frame()}? When is each function called?
\item
  Make a list of commonly used base R functions that contain \texttt{.}
  in their name but are not S3 methods.
\item
  What does the \texttt{as.data.frame.data.frame()} method do? Why is it
  confusing? How could you avoid this confusion in your own code?
\item
  Describe the difference in behaviour in these two calls.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1014}\NormalTok{)}
\NormalTok{some_days <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2017-01-31"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\KeywordTok{mean}\NormalTok{(some_days)}
\CommentTok{#> [1] "2017-02-05"}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{unclass}\NormalTok{(some_days))}
\CommentTok{#> [1] 17202}
\end{Highlighting}
\end{Shaded}
\item
  What class of object does the following code return? What base type is
  it built on? What attributes does it use?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{ecdf}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> Empirical CDF }
\CommentTok{#> Call: ecdf(rpois(100, 10))}
\CommentTok{#>  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01}
\end{Highlighting}
\end{Shaded}
\item
  What class of object does the following code return? What base type is
  it built on? What attributes does it use?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{table}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> }
\CommentTok{#>  1  2  3  4  5  6  7  8  9 10 }
\CommentTok{#>  8  5 18 14 12 19 12  3  5  4}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{s3-classes}{%
\section{Classes}\label{s3-classes}}

\index{S3!classes} \index{classes!S3} \indexc{class()}
\index{attributes!class}

If you have done object oriented programming in other languages, you may
be surprised to learn that S3 has no formal definition of a class: to
make an object an instance of a class, you simply set the \textbf{class
attribute}. You can do that during creation with \texttt{structure()},
or after the fact with \texttt{class\textless{}-()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create and assign class in one step}
\NormalTok{x <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \StringTok{"my_class"}\NormalTok{)}

\CommentTok{# Create, then set class}
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\KeywordTok{class}\NormalTok{(x) <-}\StringTok{ "my_class"}
\end{Highlighting}
\end{Shaded}

You can determine the class of an S3 object with \texttt{class(x)}, and
see if an object is an instance of a class using
\texttt{inherits(x,\ "classname")}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(x)}
\CommentTok{#> [1] "my_class"}
\KeywordTok{inherits}\NormalTok{(x, }\StringTok{"my_class"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{inherits}\NormalTok{(x, }\StringTok{"your_class"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

The class name can be any string, but I recommend using only letters and
\texttt{\_}. Avoid \texttt{.} because (as mentioned earlier) it can be
confused with the \texttt{.} separator between a generic name and a
class name. When using a class in a package, I recommend including the
package name in the class name. That ensures you won't accidental clash
with a class defined by another package.

S3 has no checks for correctness which means you can change the class of
existing objects:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a linear model}
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(}\KeywordTok{log}\NormalTok{(mpg) }\OperatorTok{~}\StringTok{ }\KeywordTok{log}\NormalTok{(disp), }\DataTypeTok{data =}\NormalTok{ mtcars)}
\KeywordTok{class}\NormalTok{(mod)}
\CommentTok{#> [1] "lm"}
\KeywordTok{print}\NormalTok{(mod)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = log(mpg) ~ log(disp), data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)    log(disp)  }
\CommentTok{#>       5.381       -0.459}

\CommentTok{# Turn it into a date (?!)}
\KeywordTok{class}\NormalTok{(mod) <-}\StringTok{ "Date"}

\CommentTok{# Unsurprisingly this doesn't work very well}
\KeywordTok{print}\NormalTok{(mod)}
\CommentTok{#> Error in as.POSIXlt.Date(x):}
\CommentTok{#>   (list) object cannot be coerced to type 'double'}
\end{Highlighting}
\end{Shaded}

If you've used other OO languages, this might make you feel queasy, but
in practice this flexibility causes few problems. R doesn't stop you
from shooting yourself in the foot, but as long as you don't aim the gun
at your toes and pull the trigger, you won't have a problem.

To avoid foot-bullet intersections when creating your own class, I
recommend that you usually provide three functions:

\begin{itemize}
\item
  A low-level \textbf{constructor}, \texttt{new\_myclass()}, that
  efficiently creates new objects with the correct structure.
\item
  A \textbf{validator}, \texttt{validate\_myclass()}, that performs more
  expensive checks to ensure that the object has correct values.
\item
  A user-friendly \textbf{helper}, \texttt{myclass()}, that provides a
  convenient way for others to create objects of your class.
\end{itemize}

You don't need a validator for very simple classes, and you can skip the
helper if the class is for internal use only, but you should always
provide a constructor.

\hypertarget{s3-constrcutor}{%
\subsection{Constructors}\label{s3-constrcutor}}

S3 doesn't provide a formal definition of a class, so it has no built-in
way to ensure that all objects of a given class have the same structure
(i.e.~the same base type and the same attributes with the same types).
Instead, you must enforce a consistent structure yourself by using a
\textbf{constructor}.

The constructor should follow three principles:

\begin{itemize}
\item
  Be called \texttt{new\_myclass()}.
\item
  Have one argument for the base object, and one for each attribute.
\item
  Check the type of the base object and the types of each attribute.
\end{itemize}

I'll illustrate these ideas by creating constructors for base
classes\footnote{Recent versions of R have \texttt{.Date()},
  \texttt{.difftime()}, \texttt{.POSIXct()}, and \texttt{.POSIXlt()}
  constructors but they are internal, not well documented, and do not
  follow the principles that I recommend.} that you're already familiar
with. To start, lets make a constructor for the simplest S3 class:
\texttt{Date}. A \texttt{Date} is just a double with a ``Date'' class
attribute, and no additional attributes. This makes for a very simple
constructor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_Date <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{double}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.double}\NormalTok{(x))}
  \KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"Date"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{new_Date}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] "1969-12-31" "1970-01-01" "1970-01-02"}
\end{Highlighting}
\end{Shaded}

The purpose of constructors is to help you, the developer. That means
you can keep them simple, and you don't need to optimise error messages
for public consumption. If you expect users to also create objects, you
should create a friendly helper function, called \texttt{class\_name()},
which I'll describe shortly.

A slightly more complicated constructor is that for \texttt{difftime},
which is used to represent time differences. It is again built on a
double, but has a units attribute that must take one of a small set of
values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_difftime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{double}\NormalTok{(), }\DataTypeTok{units =} \StringTok{"secs"}\NormalTok{) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.double}\NormalTok{(x))}
\NormalTok{  units <-}\StringTok{ }\KeywordTok{match.arg}\NormalTok{(units, }\KeywordTok{c}\NormalTok{(}\StringTok{"secs"}\NormalTok{, }\StringTok{"mins"}\NormalTok{, }\StringTok{"hours"}\NormalTok{, }\StringTok{"days"}\NormalTok{, }\StringTok{"weeks"}\NormalTok{))}

  \KeywordTok{structure}\NormalTok{(x,}
    \DataTypeTok{class =} \StringTok{"difftime"}\NormalTok{,}
    \DataTypeTok{units =}\NormalTok{ units}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{new_difftime}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3600}\NormalTok{), }\StringTok{"secs"}\NormalTok{)}
\CommentTok{#> Time differences in secs}
\CommentTok{#> [1]    1   10 3600}
\KeywordTok{new_difftime}\NormalTok{(}\DecValTok{52}\NormalTok{, }\StringTok{"weeks"}\NormalTok{)}
\CommentTok{#> Time difference of 52 weeks}
\end{Highlighting}
\end{Shaded}

The constructor is a developer function: it will be called in many
places, by an experienced user. That means it's ok to trade a little
safety in return for performance, and you should avoid potentially
time-consuming checks in the constructor.

\hypertarget{validators}{%
\subsection{Validators}\label{validators}}

More complicated classes require more complicated checks for validity.
Take factors, for example. A constructor only checks that types are
correct, making it possible to create malformed factors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_factor <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{integer}\NormalTok{(), }\DataTypeTok{levels =} \KeywordTok{character}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.integer}\NormalTok{(x))}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.character}\NormalTok{(levels))}

  \KeywordTok{structure}\NormalTok{(}
\NormalTok{    x,}
    \DataTypeTok{levels =}\NormalTok{ levels,}
    \DataTypeTok{class =} \StringTok{"factor"}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{new_factor}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\CommentTok{#> Error in as.character.factor(x):}
\CommentTok{#>   malformed factor}
\KeywordTok{new_factor}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\CommentTok{#> Error in as.character.factor(x):}
\CommentTok{#>   malformed factor}
\end{Highlighting}
\end{Shaded}

Rather than encumbering the constructor with complicated checks, it's
better to put them in a separate function. Doing so allows you to
cheaply create new objects when you know that the values are correct,
and easily re-use the checks in other places.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{validate_factor <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  values <-}\StringTok{ }\KeywordTok{unclass}\NormalTok{(x)}
\NormalTok{  levels <-}\StringTok{ }\KeywordTok{attr}\NormalTok{(x, }\StringTok{"levels"}\NormalTok{)}

  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{all}\NormalTok{(}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(values) }\OperatorTok{&}\StringTok{ }\NormalTok{values }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{)) \{}
    \KeywordTok{stop}\NormalTok{(}
      \StringTok{"All `x` values must be non-missing and greater than zero"}\NormalTok{,}
      \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(levels) }\OperatorTok{<}\StringTok{ }\KeywordTok{max}\NormalTok{(values)) \{}
    \KeywordTok{stop}\NormalTok{(}
      \StringTok{"There must at least as many `levels` as possible values in `x`"}\NormalTok{,}
      \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}

\NormalTok{  x}
\NormalTok{\}}

\KeywordTok{validate_factor}\NormalTok{(}\KeywordTok{new_factor}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\CommentTok{#> Error: There must at least as many `levels` as possible values in `x`}
\KeywordTok{validate_factor}\NormalTok{(}\KeywordTok{new_factor}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\CommentTok{#> Error: All `x` values must be non-missing and greater than zero}
\end{Highlighting}
\end{Shaded}

This validator function is called primarily for its side-effects
(throwing an error if the object is invalid) so you'd expect it to
invisibly return its primary input (as described in Section
\ref(invisible)). However, it's useful for validation methods to return
visibly, as we'll see next.

\hypertarget{helpers}{%
\subsection{Helpers}\label{helpers}}

If you want users to construct objects from your class, you should also
provide a helper method that makes their life as easy as possible. A
helper should always:

\begin{itemize}
\item
  Have the same name as the class, e.g. \texttt{myclass()}.
\item
  Finish by calling the constructor, and the validator, if it exists.
\item
  Create carefully crafted error messages tailored towards an end-user.
\item
  Have a thoughtfully crafted user interface with carefully chosen
  default values and useful conversions.
\end{itemize}

The last bullet is the trickiest, and it's hard to give general advice.
However, there are three common patterns:

\begin{itemize}
\item
  Sometimes all the helper needs to do is coerce its inputs to the
  desired type. For example, \texttt{new\_difftime()} is very strict,
  and violates the usual convention that you can use an integer vector
  wherever you can use a double vector:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{new_difftime}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error in new_difftime(1:10):}
\CommentTok{#>   is.double(x) is not TRUE}
\end{Highlighting}
\end{Shaded}

  It's not the job of the constructor to flexible, so here we create a
  helper that just coerces the input to a double.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{difftime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{double}\NormalTok{(), }\DataTypeTok{units =} \StringTok{"secs"}\NormalTok{) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{as.double}\NormalTok{(x)}
  \KeywordTok{new_difftime}\NormalTok{(x, }\DataTypeTok{units =}\NormalTok{ units)}
\NormalTok{\}}

\KeywordTok{difftime}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\CommentTok{#> Time differences in secs}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}
\item
  Often, the most natural representation of a complex object is a
  string. For example, it's very convenient to specify factors with a
  character vector. The code below shows a simple version of
  \texttt{factor()}: it takes a character vector, and guesses that the
  levels should the unique values. This is not always correct (since
  some levels might not be seen in the data), but it's a useful default.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{factor <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{character}\NormalTok{(), }\DataTypeTok{levels =} \KeywordTok{unique}\NormalTok{(x)) \{}
\NormalTok{  ind <-}\StringTok{ }\KeywordTok{match}\NormalTok{(x, levels)}
  \KeywordTok{validate_factor}\NormalTok{(}\KeywordTok{new_factor}\NormalTok{(ind, levels))}
\NormalTok{\}}

\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\CommentTok{#> [1] a a b}
\CommentTok{#> Levels: a b}
\end{Highlighting}
\end{Shaded}
\item
  Some complex objects are most naturally specified by multiple simple\\
  components. For example, I think it's natural to construct a date-time
  by supplying the individual components (year, month, day etc). That
  leads me to this \texttt{POSIXct()} helper that resembles the existing
  \texttt{ISODatetime()} function\footnote{Note that this helper is not
    efficient: behind the scenes \texttt{ISODatetime()} works by pasting
    the components into a string and then using \texttt{strptime()}. A
    more efficient equivalent is available in
    \texttt{lubridate::make\_datetime()}.}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{POSIXct <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{year =} \KeywordTok{integer}\NormalTok{(), }
                    \DataTypeTok{month =} \KeywordTok{integer}\NormalTok{(), }
                    \DataTypeTok{day =} \KeywordTok{integer}\NormalTok{(), }
                    \DataTypeTok{hour =}\NormalTok{ 0L, }
                    \DataTypeTok{minute =}\NormalTok{ 0L, }
                    \DataTypeTok{sec =} \DecValTok{0}\NormalTok{, }
                    \DataTypeTok{tzone =} \StringTok{""}\NormalTok{) \{}
  \KeywordTok{ISOdatetime}\NormalTok{(year, month, day, hour, minute, sec, }\DataTypeTok{tz =}\NormalTok{ tzone)}
\NormalTok{\}}

\KeywordTok{POSIXct}\NormalTok{(}\DecValTok{2020}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DataTypeTok{tzone =} \StringTok{"America/New_York"}\NormalTok{)}
\CommentTok{#> [1] "2020-01-01 EST"}
\end{Highlighting}
\end{Shaded}
\end{itemize}

For more complicated classes, you should feel free to go beyond these
patterns to make life as easy as possible for your users.

\hypertarget{exercises-37}{%
\subsection{Exercises}\label{exercises-37}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Write a constructor for \texttt{data.frame} objects. What base type is
  a data frame built on? What attributes does it use? What are the
  restrictions placed on the individual elements? What about the names?
\item
  Enhance my \texttt{factor()} helper to have better behaviour when one
  or more \texttt{values} is not found in \texttt{levels}. What does
  \texttt{base::factor()} do in this situation?
\item
  Carefully read the source code of \texttt{factor()}. What does it do
  that my constructor does not?
\item
  Factors have an optional ``contrasts'' attribute. Read the help for
  \texttt{C()}, and briefly describe the purpose of the attribute. What
  type should it have? Rewrite the \texttt{new\_factor()} constructor to
  include this attribute.
\item
  Read the documentation for \texttt{utils::as.roman()}. How would you
  write a constructor for this class? Does it need a validator? What
  might a helper do?
\end{enumerate}

\hypertarget{s3-methods}{%
\section{Generics and methods}\label{s3-methods}}

\indexc{UseMethod()}

\index{S3!new generic}

The job of an S3 generic is to perform method dispatch, i.e.~find the
specific implementation for a class. Method dispatch is performed by
\texttt{UseMethod()}, which every generic calls\footnote{The exception
  is internal generics, which are implemented in C, and are the topic of
  Section \ref{internal-generics}.}. \texttt{UseMethod()} takes two
arguments: the name of the generic function (required), and the argument
to use for method dispatch (optional). If you omit the second argument,
it will dispatch based on the first argument, which is almost always
what is desired.

Most generics are very simple, and consist of only a call to
\texttt{UseMethod()}. Take \texttt{mean()} for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean}
\CommentTok{#> function (x, ...) }
\CommentTok{#> UseMethod("mean")}
\CommentTok{#> <bytecode: 0x3d152c0>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

Creating your own generic is similarly simple:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_new_generic <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{UseMethod}\NormalTok{(}\StringTok{"my_new_generic"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(If you wonder why we have to repeat \texttt{my\_new\_generic} twice,
think back to Section \ref{first-class-functions}.)

Note that you don't pass any of the arguments of the generic to
\texttt{UseMethod()}; it uses deep magic to pass to the method
automatically. The precise process is complicated and frequently
surprising, so you should avoid doing any computation in a generic. To
learn the full details, carefully read the ``technical details'' section
in \texttt{?UseMethod}.

\hypertarget{method-dispatch}{%
\subsection{Method dispatch}\label{method-dispatch}}

How does \texttt{UseMethod()} work? It basically creates a vector of
method names,
\texttt{paste0("generic",\ ".",\ c(class(x),\ "default"))}, and then
looks for each potential method in turn. We can see this in action with
\texttt{sloop::s3\_dispatch()}. You give it a call to an S3 generic, and
it lists all the possible methods. For example, what method is called
when you print a \texttt{Date} object?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{Sys.Date}\NormalTok{()}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{print}\NormalTok{(x))}
\CommentTok{#> => print.Date}
\CommentTok{#>  * print.default}
\end{Highlighting}
\end{Shaded}

The output here is simple:

\begin{itemize}
\tightlist
\item
  \texttt{=\textgreater{}} indicates the method that is called, here
  \texttt{print.Date()}
\item
  \texttt{*} indicates a method that is defined, but not called, here
  \texttt{print.default()}.
\end{itemize}

The ``default'' class is a special \textbf{pseudo-class}. This is not a
real class, but is included to make it possible to define a standard
fallback that is found whenever a class-specific method is not
available.

The essence of method dispatch is quite simple, but as the chapter
proceeds you'll see it get progressively more complicated to encompass
inheritance, base types, internal generics, and group generics. The code
below shows a couple of more complicated cases which we'll come back to
in Sections \ref{inheritance} and \ref{s3-dispatch}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{)}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x))}
\CommentTok{#>    mean.matrix}
\CommentTok{#>    mean.integer}
\CommentTok{#>    mean.numeric}
\CommentTok{#> => mean.default}

\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()))}
\CommentTok{#>    sum.POSIXct}
\CommentTok{#>    sum.POSIXt}
\CommentTok{#>    sum.default}
\CommentTok{#> => Summary.POSIXct}
\CommentTok{#>    Summary.POSIXt}
\CommentTok{#>    Summary.default}
\CommentTok{#> -> sum (internal)}
\end{Highlighting}
\end{Shaded}

\hypertarget{finding-methods}{%
\subsection{Finding methods}\label{finding-methods}}

\texttt{sloop::s3\_dispatch()} lets you find the specific method used
for a single call. What if you want to find all methods defined for a
generic or associated with a class? That's the job of
\texttt{sloop::s3\_methods\_generic()} and
\texttt{sloop::s3\_methods\_class()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_methods_generic}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\CommentTok{#> # A tibble: 6 x 4}
\CommentTok{#>   generic class    visible source             }
\CommentTok{#>   <chr>   <chr>    <lgl>   <chr>              }
\CommentTok{#> 1 mean    Date     TRUE    base               }
\CommentTok{#> 2 mean    default  TRUE    base               }
\CommentTok{#> 3 mean    difftime TRUE    base               }
\CommentTok{#> 4 mean    POSIXct  TRUE    base               }
\CommentTok{#> 5 mean    POSIXlt  TRUE    base               }
\CommentTok{#> 6 mean    quosure  FALSE   registered S3method}

\KeywordTok{s3_methods_class}\NormalTok{(}\StringTok{"ordered"}\NormalTok{)}
\CommentTok{#> # A tibble: 4 x 4}
\CommentTok{#>   generic       class   visible source             }
\CommentTok{#>   <chr>         <chr>   <lgl>   <chr>              }
\CommentTok{#> 1 as.data.frame ordered TRUE    base               }
\CommentTok{#> 2 Ops           ordered TRUE    base               }
\CommentTok{#> 3 relevel       ordered FALSE   registered S3method}
\CommentTok{#> 4 Summary       ordered TRUE    base}
\end{Highlighting}
\end{Shaded}

\hypertarget{s3-arguments}{%
\subsection{Creating methods}\label{s3-arguments}}

There are two wrinkles to be aware of when you create a new method:

\begin{itemize}
\item
  First, you should only every write a method if you own the generic or
  the class. R will allow you to define a method even if you don't, but
  it is exceedingly bad manners. Instead, work with the author of either
  the generic or the class to add the method in their code.
\item
  A method must have the same arguments as its generic. This is enforced
  in packages by \texttt{R\ CMD\ check}, but it's good practice even if
  you're not creating a package.

  There is one exception to this rule: if the generic has \texttt{...},
  the method can contain a superset of the arguments. This allows
  methods to take arbitrary additional arguments. The downside of using
  \texttt{...}, however, is that any misspelled arguments will be
  silently swallowed\footnote{See
    \url{https://github.com/hadley/ellipsis} for an experimental way of
    warning when methods fail to use all the argument in \texttt{...},
    providing a potential resolution of this issue.}, as mentioned in
  Section \ref{fun-dot-dot-dot}.
\end{itemize}

\hypertarget{exercises-38}{%
\subsection{Exercises}\label{exercises-38}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Read the source code for \texttt{t()} and \texttt{t.test()} and
  confirm that \texttt{t.test()} is an S3 generic and not an S3 method.
  What happens if you create an object with class \texttt{test} and call
  \texttt{t()} with it? Why?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{class =} \StringTok{"test"}\NormalTok{)}
\KeywordTok{t}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}
\item
  What generics does the \texttt{table} class have methods for?
\item
  What generics does the \texttt{ecdf} class have methods for?
\item
  Which base generic has the greatest number of defined methods?
\item
  Carefully read the documentation for \texttt{UseMethod()} and explain
  why the following code returns the results that it does. What two
  usual rules of function evaluation does \texttt{UseMethod()} violate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{10}
\NormalTok{  y <-}\StringTok{ }\DecValTok{10}
  \KeywordTok{UseMethod}\NormalTok{(}\StringTok{"g"}\NormalTok{)}
\NormalTok{\}}
\NormalTok{g.default <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)}

\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{y <-}\StringTok{ }\DecValTok{1}
\KeywordTok{g}\NormalTok{(x)}
\CommentTok{#>  x  y }
\CommentTok{#>  1 10}
\end{Highlighting}
\end{Shaded}
\item
  What are the arguments to \texttt{{[}}? Why is this a hard question to
  answer?
\end{enumerate}

\hypertarget{object-styles}{%
\section{Object styles}\label{object-styles}}

So far I've focussed on ``vector style'' classes like \texttt{Date} and
\texttt{factor}. These have the key property that \texttt{length(x)}
represents the number of observations in the vector. There are three
variants that do not have this property:

\begin{itemize}
\item
  ``Record style'' objects use a list of equal-length vectors to
  represent individual components of the object. The best example of
  this is \texttt{POSIXlt}, which underneath the hood is a list of 11
  date-time components like year, month, and day. Record style classes
  override \texttt{length()} and subsetting methods to conceal this
  implementation detail.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\KeywordTok{ISOdatetime}\NormalTok{(}\DecValTok{2020}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> [1] "2020-01-01 00:00:01 UTC" "2020-01-01 00:00:02 UTC"}
\CommentTok{#> [3] "2020-01-01 00:00:03 UTC"}

\KeywordTok{length}\NormalTok{(x)}
\CommentTok{#> [1] 3}
\KeywordTok{length}\NormalTok{(}\KeywordTok{unclass}\NormalTok{(x))}
\CommentTok{#> [1] 9}

\NormalTok{x[[}\DecValTok{1}\NormalTok{]] }\CommentTok{# the first date time}
\CommentTok{#> [1] "2020-01-01 00:00:01 UTC"}
\KeywordTok{unclass}\NormalTok{(x)[[}\DecValTok{1}\NormalTok{]] }\CommentTok{# the first component, the number of seconds}
\CommentTok{#> [1] 1 2 3}
\end{Highlighting}
\end{Shaded}
\item
  Data frames are similar to record style objects in that both use lists
  of equal length vectors. However, data frames are conceptually two
  dimensional, and the individual components are readly exposed to the
  user. The number of observations is the number of rows, not the
  length:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{)}
\KeywordTok{length}\NormalTok{(x)}
\CommentTok{#> [1] 2}
\KeywordTok{nrow}\NormalTok{(x)}
\CommentTok{#> [1] 100}
\end{Highlighting}
\end{Shaded}
\item
  Scalar objects typically use a list to represent a single ``thing''.
  For example, an \texttt{lm} object is a list of length 12 but it
  represents one model.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\KeywordTok{length}\NormalTok{(mod)}
\CommentTok{#> [1] 12}
\end{Highlighting}
\end{Shaded}

  Scalar objects can also be built on top of functions, calls, and
  environments\footnote{You can also build an object on top of a
    pairlist, but I have yet to find a good reason to do so.}. This is
  less generally useful, but you can see applications in
  \texttt{stats::ecdf()}, R6 (Chapter \ref{r6}), and
  \texttt{rlang::quo()} (Chapter \ref{quasiquotation}).
\end{itemize}

Unfortunately, describing the appropriate use of each of these object
styles is beyond the scope of this book. However, you can learn more
from the documentation of the vctrs package
(\url{https://vctrs.r-lib.org}); the package also provides constructors
and helper that make implementation of the different styles easiser.

\hypertarget{exercises-39}{%
\subsection{Exercises}\label{exercises-39}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Categorise the objects returned by \texttt{lm()}, \texttt{factor()},
  \texttt{table()}, \texttt{as.Date()}, \texttt{as.POSIXct()}
  \texttt{ecdf()}, \texttt{ordered()}, \texttt{I()} into the styles
  described above.
\item
  What would a constructor function for \texttt{lm} objects,
  \texttt{new\_lm()}, look like? Why is a constructor function less
  useful for linear models? (Think about what functions would call
  \texttt{new\_lm()}.)
\end{enumerate}

\hypertarget{s3-inheritance}{%
\section{Inheritance}\label{s3-inheritance}}

S3 classes can share behaviour through a mechanism called
\textbf{inheritance}. Inheritance is powered by three ideas:

\begin{itemize}
\item
  The class can be a character \emph{vector}. For example, the
  \texttt{ordered} and \texttt{POSIXct} classes have two components in
  their class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\KeywordTok{ordered}\NormalTok{(}\StringTok{"x"}\NormalTok{))}
\CommentTok{#> [1] "ordered" "factor"}
\KeywordTok{class}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{())}
\CommentTok{#> [1] "POSIXct" "POSIXt"}
\end{Highlighting}
\end{Shaded}
\item
  If a method is not found for the class in the first element of the
  vector, R looks for a method for the second class (and so on):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{ordered}\NormalTok{(}\StringTok{"x"}\NormalTok{)))}
\CommentTok{#>    print.ordered}
\CommentTok{#> => print.factor}
\CommentTok{#>  * print.default}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()))}
\CommentTok{#> => print.POSIXct}
\CommentTok{#>    print.POSIXt}
\CommentTok{#>  * print.default}
\end{Highlighting}
\end{Shaded}
\item
  A method can delegate work by calling \texttt{NextMethod()}. We'll
  come back to that very shortly; for now, note that
  \texttt{s3\_dispatch()} reports delegation with
  \texttt{-\textgreater{}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{ordered}\NormalTok{(}\StringTok{"x"}\NormalTok{)[}\DecValTok{1}\NormalTok{])}
\CommentTok{#>    [.ordered}
\CommentTok{#> => [.factor}
\CommentTok{#>    [.default}
\CommentTok{#> -> [ (internal)}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> => [.POSIXct}
\CommentTok{#>    [.POSIXt}
\CommentTok{#>    [.default}
\CommentTok{#> -> [ (internal)}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Before we continue we need a bit of vocabulary to describe the
relationship between the classes that appear together in a class vector.
We'll say that \texttt{ordered} is a \textbf{subclass} of
\texttt{factor} because it always appears before it in the class vector,
and, conversely, we'll say \texttt{factor} is a \textbf{superclass} of
\texttt{ordered}.

S3 imposes no restrictions on the relationship between sub- and
superclasses but your life will be easier if you impose some yourself. I
recommend that you adhere to two simple principles when creating a
subclass:

\begin{itemize}
\item
  The base type of the subclass should be that same as the superclass.
\item
  The attributes of the subclass should be a superset of the attributes
  of the superclass.
\end{itemize}

Note that \texttt{POSIXt} does not adhere to these principles becase
\texttt{POSIXct} has type double, and \texttt{POSIXlt} has type list.
This means that \texttt{POSIXt} is not a superclass, and illustrates
that it's quite possible to use the S3 inheritance system to implement
other styles of code sharing (here \texttt{POSIXt} plays a role more
like an interface), but you'll need to figure out safe conventions
yourself.

\hypertarget{nextmethod}{%
\subsection{\texorpdfstring{\texttt{NextMethod()}}{NextMethod()}}\label{nextmethod}}

\texttt{NextMethod()} is the hardest part of inheritance to understand,
so we'll start with a concrete example for the most common use case:
\texttt{{[}}. We'll start by creating a simple toy class: a
\texttt{secret} class that hides its output when printed:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_secret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{double}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.double}\NormalTok{(x))}
  \KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"secret"}\NormalTok{)}
\NormalTok{\}}

\NormalTok{print.secret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{strrep}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\KeywordTok{nchar}\NormalTok{(x)))}
  \KeywordTok{invisible}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\KeywordTok{new_secret}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{15}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{456}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> [1] "xx"  "x"   "xxx"}
\end{Highlighting}
\end{Shaded}

This works, but the default \texttt{{[}} method doesn't preserve the
class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(x[}\DecValTok{1}\NormalTok{])}
\CommentTok{#>    [.secret}
\CommentTok{#>    [.default}
\CommentTok{#> => [ (internal)}
\NormalTok{x[}\DecValTok{1}\NormalTok{]}
\CommentTok{#> [1] 15}
\end{Highlighting}
\end{Shaded}

To fix this, we need to provide a \texttt{{[}.secret} method. How could
we implement this method? The naive approach won't work because we'll
get stuck in an infinite loop:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.secret}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, i) \{}
  \KeywordTok{new_secret}\NormalTok{(x[i])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Instead, we need some way to call the the underlying \texttt{{[}} code,
i.e.~the implementation that would get called if we didn't have a
\texttt{{[}.secret} method. One appraoch would be to \texttt{unclass()}
the object:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.secret}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, i) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{unclass}\NormalTok{(x)}
  \KeywordTok{new_secret}\NormalTok{(x[i])}
\NormalTok{\}}
\NormalTok{x[}\DecValTok{1}\NormalTok{]}
\CommentTok{#> [1] "xx"}
\end{Highlighting}
\end{Shaded}

This works, but is inefficient because it creates a copy of \texttt{x}.
A better approach is to use \texttt{NextMethod()}, which concisely
solves the problem delegating to the method that would've have been
called if \texttt{{[}.secret} didn't exist:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.secret}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, i) \{}
  \KeywordTok{new_secret}\NormalTok{(}\KeywordTok{NextMethod}\NormalTok{())}
\NormalTok{\}}
\NormalTok{x[}\DecValTok{1}\NormalTok{]}
\CommentTok{#> [1] "xx"}
\end{Highlighting}
\end{Shaded}

We can see what's going on with \texttt{sloop::s3\_dispatch()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(x[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> => [.secret}
\CommentTok{#>    [.default}
\CommentTok{#> -> [ (internal)}
\end{Highlighting}
\end{Shaded}

The \texttt{=\textgreater{}} indicates that \texttt{{[}.secret} is
called, but that \texttt{NextMethod()} delegates work to the underlying
internal \texttt{{[}} method, as shown by the \texttt{-\textgreater{}}.

As with \texttt{UseMethod()}, the precise semantics of
\texttt{NextMethod()} are complex. In particular, it tracks the list of
potential next methods with a special variable, which means that
modifying the object that's being dispatched upon will have no impact on
which method gets called next.

\hypertarget{s3-subclassing}{%
\subsection{Allowing subclassing}\label{s3-subclassing}}

When you create a class, you need to decide if you want to allow
subclasses, because it requires some changes to the constructor and
careful thought in your methods.

To allow subclasses, the parent constructor needs to have \texttt{...}
and \texttt{class} arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_secret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ..., }\DataTypeTok{class =} \KeywordTok{character}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.double}\NormalTok{(x))}

  \KeywordTok{structure}\NormalTok{(}
\NormalTok{    x,}
\NormalTok{    ...,}
    \DataTypeTok{class =} \KeywordTok{c}\NormalTok{(class, }\StringTok{"secret"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then the subclass constructor can just call to the parent class
constructor with additional arguments as needed. For example, imagine we
want to create a supersecret class which also hides the number of
characters:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_supersecret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{new_secret}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"supersecret"}\NormalTok{)}
\NormalTok{\}}

\NormalTok{print.supersecret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\StringTok{"xxxxx"}\NormalTok{, }\KeywordTok{length}\NormalTok{(x)))}
  \KeywordTok{invisible}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{x2 <-}\StringTok{ }\KeywordTok{new_supersecret}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{15}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{456}\NormalTok{))}
\NormalTok{x2}
\CommentTok{#> [1] "xxxxx" "xxxxx" "xxxxx"}
\end{Highlighting}
\end{Shaded}

To allow inheritance, you also need to think carefully about your
methods, as you can no longer use the constructor. If you do, the method
will always return the same class, regardless of the input. This forces
whoever makes a subclass to do a lot of extra work.

Concretely, this means we need to revise the \texttt{{[}.secret} method.
Currently it always returns a \texttt{secret()}, even when given a
supersecret:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.secret}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{new_secret}\NormalTok{(}\KeywordTok{NextMethod}\NormalTok{())}
\NormalTok{\}}

\NormalTok{x2[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{#> [1] "xx"  "x"   "xxx"}
\end{Highlighting}
\end{Shaded}

We want to make sure that \texttt{{[}.secret} returns the same class as
\texttt{x} even if it's a subclass. As far as I can tell, there is no
way to solve this problem using base R alone. Instead, you'll need to
use the vctrs package, which provides a solution in the form of the
\texttt{vctrs::vec\_restore()} generic. This generic takes two inputs: a
object which has lost subclass information, and a template object to use
for restoration.

Typically \texttt{vec\_restore()} methods are quite simple: you just
call the constructor with appropriate arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec_restore.secret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, to) }\KeywordTok{new_secret}\NormalTok{(x)}
\NormalTok{vec_restore.supersecret <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, to) }\KeywordTok{new_supersecret}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

(If your class has attributes, you'll need to pass them from \texttt{to}
into the constructor.)

Now we can use \texttt{vec\_restore()} in the \texttt{{[}.secret}
method:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.secret}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{  vctrs}\OperatorTok{::}\KeywordTok{vec_restore}\NormalTok{(}\KeywordTok{NextMethod}\NormalTok{(), x)}
\NormalTok{\}}
\NormalTok{x2[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{#> [1] "xxxxx" "xxxxx" "xxxxx"}
\end{Highlighting}
\end{Shaded}

(I only fully understood this issue quite recently, so at time of
writing it is not used in the tidyverse. Hopefully by the time you're
reading this, it will have rolled put, making it much easier to (e.g.)
subclass tibbles.)

If you build your class using the tools provided by the vctrs package,
\texttt{{[}} will gain this behaviour automatically. You will only need
to provide your own \texttt{{[}} method if you attributes that depend on
the data or want non-standard subsetting behaviour. See
\texttt{?vctrs::new\_vctr} for details.

\hypertarget{exercises-40}{%
\subsection{Exercises}\label{exercises-40}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How does \texttt{{[}.Date} support subclasses? How does it fail to
  support subclasses?
\item
  R has two classes for representing date time data, \texttt{POSIXct}
  and \texttt{POSIXlt}, which both inherit from \texttt{POSIXt}. Which
  generics have different behaviours for the two classes? Which generics
  share the same behaviour?
\item
  What do you expect this code to return? What does it actually return?
  Why?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generic2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"generic2"}\NormalTok{)}
\NormalTok{generic2.a1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"a1"}
\NormalTok{generic2.a2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"a2"}
\NormalTok{generic2.b <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ "a1"}
  \KeywordTok{NextMethod}\NormalTok{()}
\NormalTok{\}}

\KeywordTok{generic2}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"a2"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{s3-dispatch}{%
\section{Dispatch details}\label{s3-dispatch}}

This chapter concludes with a few additional details about method
dispatch. It is safe to skip these details if you're new to S3.

\hypertarget{implicit-class}{%
\subsection{S3 and base types}\label{implicit-class}}

\index{implicit class} \index{base types!implicit class}

What happens when you call an S3 generic with a base object, i.e.~an
object with no class? You might think it would dispatch on what
\texttt{class()} returns:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{))}
\CommentTok{#> [1] "matrix"}
\end{Highlighting}
\end{Shaded}

But unfortunately dispatch actually occurs on the \textbf{implicit
class}, which has three components:

\begin{itemize}
\tightlist
\item
  ``array'' or ``matrix'' (if the object has dimensions).
\item
  \texttt{typeof()} (with a few minor tweaks).
\item
  If it's ``integer'' or ``double'', ``numeric''.
\end{itemize}

There is no base function that will compute the implicit class, but you
can use \texttt{sloop::s3\_class()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_class}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{))}
\CommentTok{#> [1] "matrix"  "integer" "numeric"}
\end{Highlighting}
\end{Shaded}

This is used by \texttt{s3\_dispatch()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)))}
\CommentTok{#>    print.matrix}
\CommentTok{#>    print.integer}
\CommentTok{#>    print.numeric}
\CommentTok{#> => print.default}
\end{Highlighting}
\end{Shaded}

Note that this means that the \texttt{class()} of an object does not
uniquely determine its dispatch:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\KeywordTok{class}\NormalTok{(x1)}
\CommentTok{#> [1] "integer"}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x1))}
\CommentTok{#>    mean.integer}
\CommentTok{#>    mean.numeric}
\CommentTok{#> => mean.default}

\NormalTok{x2 <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(x1, }\DataTypeTok{class =} \StringTok{"integer"}\NormalTok{)}
\KeywordTok{class}\NormalTok{(x2)}
\CommentTok{#> [1] "integer"}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x2))}
\CommentTok{#>    mean.integer}
\CommentTok{#> => mean.default}
\end{Highlighting}
\end{Shaded}

\hypertarget{internal-generics}{%
\subsection{Internal generics}\label{internal-generics}}

Some base functions, like \texttt{{[}}, \texttt{sum()}, and
\texttt{cbind()}, are called \textbf{internal generics} because they
don't call \texttt{UseMethod()} but instead call the C functions
\texttt{DispatchGroup()} or \texttt{DispatchOrEval()}.
\texttt{s3\_dispatch()} shows internal generics by including the name of
the generic followed by \texttt{(internal)}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> => [.POSIXct}
\CommentTok{#>    [.POSIXt}
\CommentTok{#>    [.default}
\CommentTok{#> -> [ (internal)}
\end{Highlighting}
\end{Shaded}

For performance reasons, internal generics do not dispatch to methods
unless the class attribute has been set, which means that internal
generics do not use the implicit class. Again, if you're ever confused
about method dispatch, you can rely on \texttt{s3\_dispatch()}.

\hypertarget{group-generics}{%
\subsection{Group generics}\label{group-generics}}

\index{group generics} \index{S3!group generics}

Group generics are the most complicated part of S3 method dispatch
because they involve both \texttt{NextMethod()} and internal generics.
Like internal generics, they only exist in base R, and you cannot define
your own group generic.

There are four group generics:

\begin{itemize}
\item
  \textbf{Math}: \texttt{abs()}, \texttt{sign()}, \texttt{sqrt()},
  \texttt{floor()}, \texttt{cos()}, \texttt{sin()}, \texttt{log()}, and
  more (see \texttt{?Math} for the complete list).
\item
  \textbf{Ops}: \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/},
  \texttt{\^{}}, \texttt{\%\%}, \texttt{\%/\%}, \texttt{\&},
  \texttt{\textbar{}}, \texttt{!}, \texttt{==}, \texttt{!=},
  \texttt{\textless{}}, \texttt{\textless{}=}, \texttt{\textgreater{}=},
  and \texttt{\textgreater{}}.
\item
  \textbf{Summary}: \texttt{all()}, \texttt{any()}, \texttt{sum()},
  \texttt{prod()}, \texttt{min()}, \texttt{max()}, and \texttt{range()}.
\item
  \textbf{Complex}: \texttt{Arg()}, \texttt{Conj()}, \texttt{Im()},
  \texttt{Mod()}, \texttt{Re()}.
\end{itemize}

Defining a single group generic for your class overrides the default
behaviour for all of the members of the group. Methods for group
generics are looked for only if the methods for the specific generic do
not exist:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()))}
\CommentTok{#>    sum.POSIXct}
\CommentTok{#>    sum.POSIXt}
\CommentTok{#>    sum.default}
\CommentTok{#> => Summary.POSIXct}
\CommentTok{#>    Summary.POSIXt}
\CommentTok{#>    Summary.default}
\CommentTok{#> -> sum (internal)}
\end{Highlighting}
\end{Shaded}

Most group generics involve a call to \texttt{NextMethod()}. For
example, take \texttt{difftime()} objects. If you look at the method
dispatch for \texttt{abs()}, you'll see there's a \texttt{Math} group
generic defined.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{as.difftime}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DataTypeTok{units =} \StringTok{"mins"}\NormalTok{)}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{abs}\NormalTok{(y))}
\CommentTok{#>    abs.difftime}
\CommentTok{#>    abs.default}
\CommentTok{#> => Math.difftime}
\CommentTok{#>    Math.default}
\CommentTok{#> -> abs (internal)}
\end{Highlighting}
\end{Shaded}

\texttt{Math.difftime} basically looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Math.difftime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{new_difftime}\NormalTok{(}\KeywordTok{NextMethod}\NormalTok{(), }\DataTypeTok{units =} \KeywordTok{attr}\NormalTok{(x, }\StringTok{"units"}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It dispatches to the next method, here the internal default, to perform
the actual computation, then restore the class and attributes. (To
better support subclasses of \texttt{difftime} this would need to call
\texttt{vec\_restore()}, as described in Section \ref{s3-subclassing}.)

Note that inside a group generic function a special variable
\texttt{.Generic} provides the actual generic function called. This can
be useful when producing error messages, and can sometimes be useful if
you need to manually re-call the generic with different arguments.

\hypertarget{double-dispatch}{%
\subsection{Double dispatch}\label{double-dispatch}}

Generics in the ``Ops'' group, which includes the two-argument
arithmetic and boolean operators like \texttt{-} and \texttt{\&},
implement a special type of method dispatch. They dispatch on the type
of \emph{both} of the arguments, which is called \textbf{double
dispatch}. This is necessary to preserve the commutative property of
many operators, i.e. \texttt{a\ +\ b} should equal \texttt{b\ +\ a}.
Take the following simple example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2017-01-01"}\NormalTok{)}
\NormalTok{integer <-}\StringTok{ }\NormalTok{1L}

\NormalTok{date }\OperatorTok{+}\StringTok{ }\NormalTok{integer}
\CommentTok{#> [1] "2017-01-02"}
\NormalTok{integer }\OperatorTok{+}\StringTok{ }\NormalTok{date}
\CommentTok{#> [1] "2017-01-02"}
\end{Highlighting}
\end{Shaded}

If \texttt{+} dispatched only on the first argument, it would return
different values for the two cases. To overcome this problem, generics
in the Ops group use a slightly different strategy from usual. Rather
than doing a single method dispatch, they do two, one for each input.
There are three possible outcomes of this lookup:

\begin{itemize}
\item
  The methods are the same, so it doesn't matter which method is used.
\item
  The methods are different, and R falls back to the internal method
  with a warning.
\item
  One method is internal, in which case R calls the other method.
\end{itemize}

This approach is error prone so if you want to implement robust double
dispatch for algebraic operators, I recommend using the vctrs package.
See \texttt{?vctrs::vec\_arith} for details.

\hypertarget{exercises-41}{%
\subsection{Exercises}\label{exercises-41}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Explain the differences in dispatch below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{length.integer <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\DecValTok{10}

\NormalTok{x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\KeywordTok{class}\NormalTok{(x1)}
\CommentTok{#> [1] "integer"}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{length}\NormalTok{(x1))}
\CommentTok{#>  * length.integer}
\CommentTok{#>    length.numeric}
\CommentTok{#>    length.default}
\CommentTok{#> => length (internal)}

\NormalTok{x2 <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(x1, }\DataTypeTok{class =} \StringTok{"integer"}\NormalTok{)}
\KeywordTok{class}\NormalTok{(x2)}
\CommentTok{#> [1] "integer"}
\KeywordTok{s3_dispatch}\NormalTok{(}\KeywordTok{length}\NormalTok{(x2))}
\CommentTok{#> => length.integer}
\CommentTok{#>    length.default}
\CommentTok{#>  * length (internal)}
\end{Highlighting}
\end{Shaded}
\item
  What classes have a method for the \texttt{Math} group generic in base
  R? Read the source code. How do the methods work?
\item
  \texttt{Math.difftime()} is more complicated than I described. Why?
\end{enumerate}

\hypertarget{r6}{%
\chapter{R6}\label{r6}}

\hypertarget{introduction-12}{%
\section{Introduction}\label{introduction-12}}

This chapter describes the R6 OOP system. R6 has two special properties:

\begin{itemize}
\item
  It uses the encapsulated OOP paradigm, which means that methods belong
  to objects, not generics, and you call them like
  \texttt{object\$method()}.
\item
  R6 objects are \textbf{mutable}, which means that they are modified in
  place, and hence have reference semantics.
\end{itemize}

If you've learned OOP in another programming language, it's likely that
R6 will feel very natural, and you'll be inclined to prefer it over S3.
Resist the temptation to follow the path of least resistance: in most
cases R6 will lead you to non-idiomatic R code. We'll come back to this
theme in Section \ref{s3-r6}.

R6 is very similar to a base OOP system called \textbf{reference
classes}, or RC for short. I describe why I teach R6 and not RC in
Section \ref{why-r6}.

\hypertarget{outline-10}{%
\subsection*{Outline}\label{outline-10}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{r6-classes} introduces \texttt{R6::R6class()}, the one
  function that you need to know to create R6 classes. You'll learn
  about the constructor method, \texttt{\$new()}, which allows you to
  create R6 objects, as well as other important methods like
  \texttt{\$initialize()} and \texttt{\$print()}.
\item
  Section \ref{r6-access} discusses the access mechanisms of R6: private
  and active fields. Together, these allow you to hide data from the
  user, or expose private data for reading but not writing.
\item
  Section \ref{r6-semantics} explores the consequnces of R6's reference
  semantics. You'll learn about the use of finalizers to automatically
  clean up any operations performed in the intializer, and a common
  gotcha if you use an R6 object as a field in another R6 object.
\item
  Section \ref{why-r6} describes why I cover R6, rather than the base RC
  system.
\end{itemize}

\hypertarget{prerequisites-7}{%
\subsection*{Prerequisites}\label{prerequisites-7}}
\addcontentsline{toc}{subsection}{Prerequisites}

Because R6 is not built into base R, you'll need to install and load the
R6 package to use it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# install.packages("R6")}
\KeywordTok{library}\NormalTok{(R6)}
\end{Highlighting}
\end{Shaded}

R6 objects have reference semantics which means that they are modified
in-place, not copied-on-modify. If you're not familiar with these terms,
brush up your vocab by reading Section \ref{modify-in-place}.

\hypertarget{r6-classes}{%
\section{Classes and methods}\label{r6-classes}}

R6 only needs a single function call to create both the class and its
methods: \texttt{R6::R6Class()}. This is the only function from the
package that you'll ever use!\footnote{That means if you're creating R6
  in a package, you only need to make sure it's listed in the
  \texttt{Imports} field of the \texttt{DESCRIPTION}. There's no need to
  import the package into the \texttt{NAMESPACE}.}

The following example shows the two most important arguments to
\texttt{R6Class()}:

\begin{itemize}
\item
  The first argument is the \texttt{classname}. It's not strictly
  needed, but it improves error messages and makes it possible to use R6
  objects with S3 generics. By convention, R6 classes have
  \texttt{UpperCamelCase} names.
\item
  The second argument, \texttt{public}, supplies a list of methods
  (functions) and fields (anything else) that make up the public
  interface of the object. By convention, methods and fields use
  \texttt{snake\_case}. Methods can access the methods and fields of the
  current object via \texttt{self\$}.\footnote{Unlike in \texttt{this}
    in python, the \texttt{self} variable is automatically provided by
    R6, and does not form part of the method signature.}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Accumulator <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Accumulator"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{sum =} \DecValTok{0}\NormalTok{,}
  \DataTypeTok{add =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{) \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{sum <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{sum }\OperatorTok{+}\StringTok{ }\NormalTok{x }
    \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{  \})}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You should always assign the result of \texttt{R6Class()} into a
variable with the same name as the class, because \texttt{R6Class()}
returns an R6 object that defines the class:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Accumulator}
\CommentTok{#> <Accumulator> object generator}
\CommentTok{#>   Public:}
\CommentTok{#>     sum: 0}
\CommentTok{#>     add: function (x = 1) }
\CommentTok{#>     clone: function (deep = FALSE) }
\CommentTok{#>   Parent env: <environment: R_GlobalEnv>}
\CommentTok{#>   Locked objects: TRUE}
\CommentTok{#>   Locked class: FALSE}
\CommentTok{#>   Portable: TRUE}
\end{Highlighting}
\end{Shaded}

You construct a new object from the class by calling the \texttt{new()}
method. In R6, methods belong to objects, so you use \texttt{\$} to
access \texttt{new()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\NormalTok{Accumulator}\OperatorTok{$}\KeywordTok{new}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

You can then call methods and access fields with \texttt{\$}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{4}\NormalTok{) }
\NormalTok{x}\OperatorTok{$}\NormalTok{sum}
\CommentTok{#> [1] 4}
\end{Highlighting}
\end{Shaded}

In this class, the fields and methods are public, which means that you
can get or set the value of any field. Later, we'll see how to use
private fields and methods to prevent casual access to the internals of
your class.

To make it clear when we're talking about fields and methods as opposed
to variables and functions, I'll prefix their names with \texttt{\$}.
For example, the \texttt{Accumulate} class has field \texttt{\$sum} and
method \texttt{\$add()}.

\hypertarget{method-chaining}{%
\subsection{Method chaining}\label{method-chaining}}

\texttt{\$add()} is called primarily for its side-effect of updating
\texttt{\$sum}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Accumulator <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Accumulator"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{sum =} \DecValTok{0}\NormalTok{,}
  \DataTypeTok{add =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{) \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{sum <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{sum }\OperatorTok{+}\StringTok{ }\NormalTok{x }
    \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{  \})}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Side-effect R6 methods should always return \texttt{self} invisibly.
This returns the ``current'' object and makes it possible to chain
together multiple method calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{$}\NormalTok{sum}
\CommentTok{#> [1] 24}
\end{Highlighting}
\end{Shaded}

For, readability, you might put one method call on each line:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{$}
\StringTok{  }\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\NormalTok{sum}
\CommentTok{#> [1] 44}
\end{Highlighting}
\end{Shaded}

This technique is called \textbf{method chaining} and is commonly used
in languages like Python and JavaScript. Method chaining is deeply
related to the pipe, and we'll discuss the pros and cons of each
approach in Section \ref{tradeoffs-pipe}.

\hypertarget{r6-important-methods}{%
\subsection{Important methods}\label{r6-important-methods}}

There are two important methods that should be defined for most classes:
\texttt{\$initialize()} and \texttt{\$print()}. They're not required,
but providing them will make your class easier to use.

\texttt{\$initialize()} overrides the default behaviour of
\texttt{\$new()}. For example, the following code defines an Person
class with fields \texttt{\$name} and \texttt{\$age}. To ensure that
that \texttt{\$name} is always a single string, and \texttt{\$age} is
always a single number, I placed checks in \texttt{\$initialize()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{name =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{age =} \OtherTok{NA}\NormalTok{,}
  \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{age =} \OtherTok{NA}\NormalTok{) \{}
    \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.character}\NormalTok{(name), }\KeywordTok{length}\NormalTok{(name) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
    \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.numeric}\NormalTok{(age), }\KeywordTok{length}\NormalTok{(age) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
    
\NormalTok{    self}\OperatorTok{$}\NormalTok{name <-}\StringTok{ }\NormalTok{name}
\NormalTok{    self}\OperatorTok{$}\NormalTok{age <-}\StringTok{ }\NormalTok{age}
\NormalTok{  \}}
\NormalTok{))}

\NormalTok{hadley <-}\StringTok{ }\NormalTok{Person}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"thirty-eight"}\NormalTok{)}
\CommentTok{#> Error in .subset2(public_bind_env, "initialize")(...):}
\CommentTok{#>   is.numeric(age) is not TRUE}

\NormalTok{hadley <-}\StringTok{ }\NormalTok{Person}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{38}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you have more expensive validation requirements, implement them in a
separate \texttt{\$validate()} and only call when needed.

Defining \texttt{\$print()} allows you to override the default printing
behaviour. As with any R6 method called for its side effects,
\texttt{\$print()} should return \texttt{invisible(self)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{name =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{age =} \OtherTok{NA}\NormalTok{,}
  \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{age =} \OtherTok{NA}\NormalTok{) \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{name <-}\StringTok{ }\NormalTok{name}
\NormalTok{    self}\OperatorTok{$}\NormalTok{age <-}\StringTok{ }\NormalTok{age}
\NormalTok{  \},}
  \DataTypeTok{print =} \ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"Person: }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"  Name: "}\NormalTok{, self}\OperatorTok{$}\NormalTok{name, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
    \KeywordTok{cat}\NormalTok{(}\StringTok{"  Age:  "}\NormalTok{, self}\OperatorTok{$}\NormalTok{age, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
    \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{  \}}
\NormalTok{))}

\NormalTok{hadley2 <-}\StringTok{ }\NormalTok{Person}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{)}
\NormalTok{hadley2}
\CommentTok{#> Person: }
\CommentTok{#>   Name: Hadley}
\CommentTok{#>   Age:  NA}
\end{Highlighting}
\end{Shaded}

This code illustrates an important aspect of R6. Because methods are
bound to individual objects, the previously created \texttt{hadley}
object does not get this new method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hadley}
\CommentTok{#> <Person>}
\CommentTok{#>   Public:}
\CommentTok{#>     age: 38}
\CommentTok{#>     clone: function (deep = FALSE) }
\CommentTok{#>     initialize: function (name, age = NA) }
\CommentTok{#>     name: Hadley}

\NormalTok{hadley}\OperatorTok{$}\NormalTok{print}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

From the perspective of R6, there is no relationship between
\texttt{hadley} and \texttt{hadley2}; they just coincidentally share the
same class name. This doesn't cause problems when using already
developed R6 problems but can make interactive experimentation
confusing. If you're changing the code and can't figure out why the
results of method calls aren't any different, make sure you've
re-constructed R6 objects with the new class.

\hypertarget{adding-methods-after-creation}{%
\subsection{Adding methods after
creation}\label{adding-methods-after-creation}}

Instead of continuously creating new classes, it's also possible to
modify the fields and methods of an existing class. This is useful when
exploring interactively, or when you have a class with many functions
that you'd like to break up into pieces. Add new elements to an existing
class with \texttt{\$set()}, supplying the visibility (more on in
Section \ref{r6-access}), the name, and the component.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Accumulator <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Accumulator"}\NormalTok{)}
\NormalTok{Accumulator}\OperatorTok{$}\KeywordTok{set}\NormalTok{(}\StringTok{"public"}\NormalTok{, }\StringTok{"sum"}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\NormalTok{Accumulator}\OperatorTok{$}\KeywordTok{set}\NormalTok{(}\StringTok{"public"}\NormalTok{, }\StringTok{"add"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{) \{}
\NormalTok{  self}\OperatorTok{$}\NormalTok{sum <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{sum }\OperatorTok{+}\StringTok{ }\NormalTok{x }
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

As above, new methods and fields are only available to new objects; they
are not retrospectively added to existing objects.

\hypertarget{inheritance}{%
\subsection{Inheritance}\label{inheritance}}

To inherit behaviour from an existing class, provide the class object to
the \texttt{inherit} argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AccumulatorChatty <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"AccumulatorChatty"}\NormalTok{, }
  \DataTypeTok{inherit =}\NormalTok{ Accumulator,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{add =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{) \{}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"Adding "}\NormalTok{, x, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{      super}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{x2 <-}\StringTok{ }\NormalTok{AccumulatorChatty}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{x2}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{$}\NormalTok{sum}
\CommentTok{#> Adding 10}
\CommentTok{#> Adding 1}
\CommentTok{#> [1] 11}
\end{Highlighting}
\end{Shaded}

Note that \texttt{\$add()} overrides the implementation in the
superclass, but we can delegate to the superclass implementation through
\texttt{super\$}. (This is analagous to \texttt{NextMethod()} in S3, as
discussed in Section \ref{s3-inheritance}.) Any methods which are not
overridden will use the implementation in the parent class.

\hypertarget{introspection}{%
\subsection{Introspection}\label{introspection}}

Every R6 object has an S3 class that reflects its hierarchy of R6
classes. This means that the easiest way to determine the class (and all
classes it inherits from) is to use \texttt{class()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(hadley2)}
\CommentTok{#> [1] "Person" "R6"}
\end{Highlighting}
\end{Shaded}

The S3 hierarchy includes the base ``R6'' class. This provides common
behaviour, including a \texttt{print.R6()} method which calls
\texttt{\$print()}, as described above.

You can list all methods and fields with \texttt{names()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(hadley2)}
\CommentTok{#> [1] ".__enclos_env__" "name"            "clone"          }
\CommentTok{#> [4] "initialize"      "age"             "print"}
\end{Highlighting}
\end{Shaded}

We defined \texttt{\$name}, \texttt{\$age}, \texttt{\$print}, and
\texttt{\$initialize}. As suggested by the name
\texttt{.\_\_enclos\_env\_\_} is an internal implementation detail that
you shouldn't touch; we'll come back to \texttt{\$clone()} in Section
\ref{r6-semantics}.

\hypertarget{exercises-42}{%
\subsection{Exercises}\label{exercises-42}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a bank account R6 class that stores a balance and allows you to
  deposit and withdraw money. Create a subclass that throws an error if
  you attempt to go into overdraft. Create another subclass that allows
  you to go into overdraft, but charges you a fee.
\item
  Create an R6 class that represents a shuffled deck of cards. You
  should be able to draw cards from the deck with \texttt{\$draw(n)},
  and return all cards to the deck and reshuffle with
  \texttt{\$reshuffle()}. Use the following code to make a vector of
  cards.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suit <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"♠"}\NormalTok{, }\StringTok{"♥"}\NormalTok{, }\StringTok{"♦"}\NormalTok{, }\StringTok{"♣"}\NormalTok{)}
\NormalTok{value <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\StringTok{"J"}\NormalTok{, }\StringTok{"Q"}\NormalTok{, }\StringTok{"K"}\NormalTok{)}
\NormalTok{cards <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\KeywordTok{rep}\NormalTok{(value, }\DecValTok{4}\NormalTok{), suit)}
\end{Highlighting}
\end{Shaded}
\item
  Why can't you model a bank account or a deck of cards with an S3
  class?
\item
  Create an R6 class that allows you to get and set the current
  timezone. You can access the current timezone with
  \texttt{Sys.timezone()} and set it with
  \texttt{Sys.setenv(TZ\ =\ "newtimezone")}. When setting the time zone,
  make sure the new time zone is in the list provided by
  \texttt{OlsonNames()}.
\item
  Create an R6 class that manages the current working directory. It
  should have \texttt{\$get()} and \texttt{\$set()} methods.
\item
  Why can't you model the time zone or current working directory with an
  S3 class?
\item
  What base type are R6 objects built on top of? What attributes do they
  have?
\end{enumerate}

\hypertarget{r6-access}{%
\section{Controlling access}\label{r6-access}}

\texttt{R6Class()} has two other arguments that work similarly to
\texttt{public}:

\begin{itemize}
\item
  \texttt{private} allows you to create fields and methods that are only
  available from within the class, not outside of it.
\item
  \texttt{active} allows you to use accessor functions to define
  dynamic, or active, fields.
\end{itemize}

These are described in the following sections.

\hypertarget{privacy}{%
\subsection{Privacy}\label{privacy}}

With R6 you can define \textbf{private} fields and methods, elements
that can only be accessed from within the class, not from the
outside\footnote{Because R is such a flexible language, it's technically
  still possible to access private values, but you'll have to try much
  harder, spelunking in to the details of R6's implementation.}. There
are two things that you need to know to take advantage of private
elements:

\begin{itemize}
\item
  The \texttt{private} argument to \texttt{R6Class} works in the same
  way as the \texttt{public} argument: you give it a named list of
  methods (functions) and fields (everything else).
\item
  Fields and methods defined in \texttt{private} are available within
  the methods using \texttt{private\$} instead of \texttt{self\$}. You
  cannot access private fields or methods outside of the class.
\end{itemize}

To make this concrete, we could make \texttt{\$age} and \texttt{\$name}
fields of the Person class private. With this definition of
\texttt{Person} we can only set \texttt{\$age} and \texttt{\$name}
during object creation, and we cannot access their values from outside
of the class.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{age =} \OtherTok{NA}\NormalTok{) \{}
\NormalTok{      private}\OperatorTok{$}\NormalTok{name <-}\StringTok{ }\NormalTok{name}
\NormalTok{      private}\OperatorTok{$}\NormalTok{age <-}\StringTok{ }\NormalTok{age}
\NormalTok{    \},}
    \DataTypeTok{print =} \ControlFlowTok{function}\NormalTok{(...) \{}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"Person: }\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"  Name: "}\NormalTok{, private}\OperatorTok{$}\NormalTok{name, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"  Age:  "}\NormalTok{, private}\OperatorTok{$}\NormalTok{age, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  ),}
  \DataTypeTok{private =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{age =} \OtherTok{NA}\NormalTok{,}
    \DataTypeTok{name =} \OtherTok{NULL}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{hadley3 <-}\StringTok{ }\NormalTok{Person}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{)}
\NormalTok{hadley3}
\CommentTok{#> Person: }
\CommentTok{#>   Name: Hadley}
\CommentTok{#>   Age:  NA}
\NormalTok{hadley3}\OperatorTok{$}\NormalTok{name}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

The distinction between public and private fields is important when you
create complex networks of classes, and you want to make it as clear as
possible what it's ok for others to access. Anything that's private can
be more easily refactored because you know others aren't relying on it.
Private methods tend to be less important in R compared to other
programming languages because the object hierarchies in R tend to be
simpler.

\hypertarget{active-fields}{%
\subsection{Active fields}\label{active-fields}}

Active fields allow you to define components that look like fields from
the outside, but are defined with functions, like methods. Active fields
are implemented using \textbf{active bindings} (see Section
\ref{advanced-bindings} for details). Each active binding is a function
that takes a single argument: \texttt{value}. If the argument is
\texttt{missing()}, the value is being retrieved; otherwise it's being
modified.

For example, you could make an active field \texttt{random} that returns
a different value every time you access it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Rando <-}\StringTok{ }\NormalTok{R6}\OperatorTok{::}\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Rando"}\NormalTok{, }\DataTypeTok{active =} \KeywordTok{list}\NormalTok{(}
  \DataTypeTok{random =} \ControlFlowTok{function}\NormalTok{(value) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(value)) \{}
      \KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)  }
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't set `$random`"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{))}
\NormalTok{x <-}\StringTok{ }\NormalTok{Rando}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{x}\OperatorTok{$}\NormalTok{random}
\CommentTok{#> [1] 0.0808}
\NormalTok{x}\OperatorTok{$}\NormalTok{random}
\CommentTok{#> [1] 0.834}
\NormalTok{x}\OperatorTok{$}\NormalTok{random}
\CommentTok{#> [1] 0.601}
\end{Highlighting}
\end{Shaded}

Active fields are particularly useful in conjunction with private
fields, because they make it possible to implement components that look
like fields from the outside but provide additional checks. For example,
we can use then make a read-only \texttt{age} field, and to ensure that
\texttt{name} is a length 1 character vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }
  \DataTypeTok{private =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{.age =} \OtherTok{NA}\NormalTok{,}
    \DataTypeTok{.name =} \OtherTok{NULL}
\NormalTok{  ),}
  \DataTypeTok{active =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{age =} \ControlFlowTok{function}\NormalTok{(value) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(value)) \{}
\NormalTok{        private}\OperatorTok{$}\NormalTok{.age}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{stop}\NormalTok{(}\StringTok{"`$age` is read only"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{      \}}
\NormalTok{    \},}
    \DataTypeTok{name =} \ControlFlowTok{function}\NormalTok{(value) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(value)) \{}
\NormalTok{        private}\OperatorTok{$}\NormalTok{.name}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.character}\NormalTok{(value), }\KeywordTok{length}\NormalTok{(value) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{        private}\OperatorTok{$}\NormalTok{.name <-}\StringTok{ }\NormalTok{value}
\NormalTok{        self}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  ),}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{age =} \OtherTok{NA}\NormalTok{) \{}
\NormalTok{      private}\OperatorTok{$}\NormalTok{.name <-}\StringTok{ }\NormalTok{name}
\NormalTok{      private}\OperatorTok{$}\NormalTok{.age <-}\StringTok{ }\NormalTok{age}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{hadley4 <-}\StringTok{ }\NormalTok{Person}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{38}\NormalTok{)}
\NormalTok{hadley4}\OperatorTok{$}\NormalTok{name}
\CommentTok{#> [1] "Hadley"}
\NormalTok{hadley4}\OperatorTok{$}\NormalTok{name <-}\StringTok{ }\DecValTok{10}
\CommentTok{#> Error in (function (value) :}
\CommentTok{#>   is.character(value) is not TRUE}
\NormalTok{hadley4}\OperatorTok{$}\NormalTok{age <-}\StringTok{ }\DecValTok{20}
\CommentTok{#> Error: `$age` is read only}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-43}{%
\subsection{Exercises}\label{exercises-43}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a bank account class that prevents you from directly setting
  the account balance, but you can still withdraw from and deposit to.
  Throw an error if you attempt to go into overdraft.
\item
  Create an class with a write-only \texttt{\$password} field. It should
  have \texttt{\$check\_password(password)} method that returns
  \texttt{TRUE} or \texttt{FALSE}, but there should be no way to view
  the complete password.
\item
  Extend the \texttt{Rando} class with another active binding that
  allows you to access the previous random value. Ensure that active
  binding is the only way to access the value.
\item
  Can subclasses access private fields/methods from their parent?
  Perform an experiment to find out.
\end{enumerate}

\hypertarget{r6-semantics}{%
\section{Reference semantics}\label{r6-semantics}}

One of the big differences between R6 and most other objects is that
they have reference semantics. The primary consequence of reference
semantics is that objects are not copied when modified:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y1 <-}\StringTok{ }\NormalTok{Accumulator}\OperatorTok{$}\KeywordTok{new}\NormalTok{() }
\NormalTok{y2 <-}\StringTok{ }\NormalTok{y1}

\NormalTok{y1}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{c}\NormalTok{(}\DataTypeTok{y1 =}\NormalTok{ y1}\OperatorTok{$}\NormalTok{sum, }\DataTypeTok{y2 =}\NormalTok{ y2}\OperatorTok{$}\NormalTok{sum)}
\CommentTok{#> y1 y2 }
\CommentTok{#> 10 10}
\end{Highlighting}
\end{Shaded}

Instead, if you want a copy, you'll need to explicitly
\texttt{\$clone()} the object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y1 <-}\StringTok{ }\NormalTok{Accumulator}\OperatorTok{$}\KeywordTok{new}\NormalTok{() }
\NormalTok{y2 <-}\StringTok{ }\NormalTok{y1}\OperatorTok{$}\KeywordTok{clone}\NormalTok{()}

\NormalTok{y1}\OperatorTok{$}\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{c}\NormalTok{(}\DataTypeTok{y1 =}\NormalTok{ y1}\OperatorTok{$}\NormalTok{sum, }\DataTypeTok{y2 =}\NormalTok{ y2}\OperatorTok{$}\NormalTok{sum)}
\CommentTok{#> y1 y2 }
\CommentTok{#> 10  0}
\end{Highlighting}
\end{Shaded}

(Note that \texttt{\$clone()} does not recursively clone nested R6
objects. If you want that, you'll need to use
\texttt{\$clone(deep\ =\ TRUE)}.)

There are three other less obvious consequences:

\begin{itemize}
\item
  It is harder to reason about code that uses R6 objects because you
  need to understand more context.
\item
  It makes sense to think about when an R6 object is deleted, and you
  can write a \texttt{\$finalize()} to complement the
  \texttt{\$initialize()}.
\item
  If one of the fields is an R6 object, you must create it inside
  \texttt{\$initialize()}, not \texttt{R6Class()}.
\end{itemize}

These consequences are described in more detail below.

\hypertarget{reasoning}{%
\subsection{Reasoning}\label{reasoning}}

Generally, reference semantics makes code harder to reason about. Take
this very simple example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}

\NormalTok{z <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

For the vast majority of functions, you know that the final line only
modifies \texttt{z}.

Take a similar example that uses an imaginary \texttt{List} reference
class:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\NormalTok{List}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\NormalTok{List}\OperatorTok{$}\KeywordTok{new}\NormalTok{(}\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}

\NormalTok{z <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x, y)}
\end{Highlighting}
\end{Shaded}

The final line is much harder to reason about: if \texttt{f()} calls
methods of \texttt{x} or \texttt{y}, it might modify them as well as
\texttt{z}. This is the biggest potential downside of R6 and you should
take care to avoid it by writing functions that either return a value,
or modify their R6 inputs, but not both. That said, doing both can lead
to substantially simpler code in some cases, and we'll discuss further
in Section \ref{threading-state}.

\hypertarget{finalizer}{%
\subsection{Finalizer}\label{finalizer}}

One useful property of reference semantics is that it makes sense to
think about when an R6 object is \textbf{finalized}, i.e.~when it's
deleted. This doesn't make sense for most objects because copy-on-modify
semantics mean that there may be many transient versions of an object,
as alluded to in Section \ref{gc}. For example, the following creates
two two factor objects: the second is created when the levels are
modified, leaving the first to be destroyed by the garbage collector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\KeywordTok{levels}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Since R6 objects are not copied-on-modify they are only deleted once,
and it makes sense to think about \texttt{\$finalize()} as a complement
to \texttt{\$initialize()}. Finalizers usually play a similar role to
\texttt{on.exit()} (as described in Section \ref{on-exit}), cleaning up
any resources created by the initializer. For example, the following
class wraps up a temporary file, automatically deleting it when the
class is finalized.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TemporaryFile <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"TemporaryFile"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{path =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{path <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\NormalTok{  \},}
  \DataTypeTok{finalize =} \ControlFlowTok{function}\NormalTok{() \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Cleaning up "}\NormalTok{, self}\OperatorTok{$}\NormalTok{path)}
    \KeywordTok{unlink}\NormalTok{(self}\OperatorTok{$}\NormalTok{path)}
\NormalTok{  \}}
\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The finalize method will be run when the object is deleted (or more
precisely, by the first garbage collection after the object has been
unbound from all names) or when R exits. This means that the finalizer
can called effectively anywhere in your R code, and therefore it's
almost impossible to reason about finalizer code that touches shared
data structures. Avoid these potential problems by only using the
finalizer to clean up private resources allocated by initializer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tf <-}\StringTok{ }\NormalTok{TemporaryFile}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\KeywordTok{rm}\NormalTok{(tf)}
\CommentTok{#> Cleaning up /tmp/Rtmpk73JdI/file155f31d8424bd}
\end{Highlighting}
\end{Shaded}

\hypertarget{r6-fields}{%
\subsection{R6 fields}\label{r6-fields}}

A final consequence of reference semantics can crop up where you don't
expect it. If you use a R6 class as the default value of a field, it
will be shared across all instances of the object! Take the following
code: we want to create a temporary database every time we call
\texttt{TemporaryDatabase\$new()}, but the current code always uses the
same path.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TemporaryDatabase <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"TemporaryDatabase"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{con =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{file =}\NormalTok{ TemporaryFile}\OperatorTok{$}\KeywordTok{new}\NormalTok{(),}
  \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{con <-}\StringTok{ }\NormalTok{DBI}\OperatorTok{::}\KeywordTok{dbConnect}\NormalTok{(RSQLite}\OperatorTok{::}\KeywordTok{SQLite}\NormalTok{(), }\DataTypeTok{path =}\NormalTok{ file}\OperatorTok{$}\NormalTok{path)}
\NormalTok{  \},}
  \DataTypeTok{finalize =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    DBI}\OperatorTok{::}\KeywordTok{dbDisconnect}\NormalTok{(self}\OperatorTok{$}\NormalTok{con)}
\NormalTok{  \}}
\NormalTok{))}

\NormalTok{db_a <-}\StringTok{ }\NormalTok{TemporaryDatabase}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{db_b <-}\StringTok{ }\NormalTok{TemporaryDatabase}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}

\NormalTok{db_a}\OperatorTok{$}\NormalTok{file}\OperatorTok{$}\NormalTok{path }\OperatorTok{==}\StringTok{ }\NormalTok{db_b}\OperatorTok{$}\NormalTok{file}\OperatorTok{$}\NormalTok{path}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

(If you're familiar with Python, this is very similar to the ``mutable
default argument'' problem.)

The problem arises because \texttt{TemporaryFile\$new()} is called only
once when the \texttt{TemporaryDatabase} class is defined. To fix the
problem, we need to make sure it's called every time that
\texttt{TemporaryDatabase\$new()} is called, i.e.~we need to put it in
\texttt{\$initialize()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TemporaryDatabase <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}\StringTok{"TemporaryDatabase"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{con =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{file =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{file <-}\StringTok{ }\NormalTok{TemporaryFile}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{    self}\OperatorTok{$}\NormalTok{con <-}\StringTok{ }\NormalTok{DBI}\OperatorTok{::}\KeywordTok{dbConnect}\NormalTok{(RSQLite}\OperatorTok{::}\KeywordTok{SQLite}\NormalTok{(), }\DataTypeTok{path =}\NormalTok{ file}\OperatorTok{$}\NormalTok{path)}
\NormalTok{  \},}
  \DataTypeTok{finalize =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    DBI}\OperatorTok{::}\KeywordTok{dbDisconnect}\NormalTok{(self}\OperatorTok{$}\NormalTok{con)}
\NormalTok{  \}}
\NormalTok{))}

\NormalTok{db_a <-}\StringTok{ }\NormalTok{TemporaryDatabase}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{db_b <-}\StringTok{ }\NormalTok{TemporaryDatabase}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}

\NormalTok{db_a}\OperatorTok{$}\NormalTok{file}\OperatorTok{$}\NormalTok{path }\OperatorTok{==}\StringTok{ }\NormalTok{db_b}\OperatorTok{$}\NormalTok{file}\OperatorTok{$}\NormalTok{path}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-44}{%
\subsection{Exercises}\label{exercises-44}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a class that allows you to write a line to a specified file.
  You should open a connection to the file in \texttt{\$initialize()},
  append a line using \texttt{cat()} in \texttt{\$append\_line()}, and
  close the connection in \texttt{\$finalize()}.
\end{enumerate}

\hypertarget{why-r6}{%
\section{Why R6?}\label{why-r6}}

R6 is very similar to a built-in OO system called \textbf{reference
classes}, or RC for short. I prefer R6 to RC because:

\begin{itemize}
\item
  R6 is much simpler. Both R6 and RC are built on top of environments,
  but while R6 uses S3, RC uses S4. This means to fully understand RC,
  you need to understand how the more complicated S4 works.
\item
  R6 has comprehensive online documentation at
  \url{https://r6.r-lib.org}.
\item
  R6 has a simpler mechnaism for cross-package subclassing, which just
  works without you having to think about. For RC, read the details in
  the ``External Methods; Inter-Package Superclasses'' section of
  \texttt{?setRefClass}.
\item
  RC mingles variables and fields in the same stack of environments so
  that you get (\texttt{field}) and set
  (\texttt{field\ \textless{}\textless{}-\ value}) fields like regular
  values. R6 puts fields in a separate environment so you get
  (\texttt{self\$field}) and set
  (\texttt{self\$field\ \textless{}-\ value}) with a prefix. The R6
  approach is more verbose but I like it because it is more explicit.
\item
  R6 is much faster than RC. Generally, the speed of method dispatch is
  not important outside of microbenchmarks. However, RC is quite slow,
  and switching from RC to R6 had a substantial performance improvements
  in the shiny package. For more details, see
  \texttt{vignette("Performance",\ "R6")}.
\item
  RC is tied to R. That means if any bugs are fixed, you can only take
  advantage of the fixes by requiring a newer version of R. This makes
  it difficult for packages (like those in the tidyverse) that need to
  work across many R versions.
\item
  Finally, because the ideas that underlie R6 and RC are similar, it
  will only require a small amount of additional effort to learn RC if
  you need to.
\end{itemize}

\hypertarget{s4}{%
\chapter{S4}\label{s4}}

\hypertarget{introduction-13}{%
\section{Introduction}\label{introduction-13}}

S4 provides a formal approach to functional OOP. The underlying ideas
are similar to S3 (the topic of Chapter \ref{s3}), but implementation is
much stricter and makes use of specialised functions for creating
classes (\texttt{setClass()}), generics (\texttt{setGeneric()}), and
methods (\texttt{setMethod()}). Additionally, S4 provides both multiple
inheritance (i.e.~a class can have multiple parents) and multiple
dispatch (i.e.~method dispatch can use the class of multiple arguments).

An important new component of S4 is the \textbf{slot}, a named component
of the object that is accessed using the specialised subsetting operator
\texttt{@} (pronounced at). The set of slots, and their classes, forms
an important part of the definition of an S4 class.

Like the other OO chapters, the focus here will be on S4 works, not how
to deploy it most effectively.

\hypertarget{learning-more}{%
\subsection*{Learning more}\label{learning-more}}
\addcontentsline{toc}{subsection}{Learning more}

There are two main challenges when learning S4:

\begin{itemize}
\item
  There is no one reference that will answer all your questions about
  S4.
\item
  R's built-in documentation sometimes clashes with community best
  practices.
\end{itemize}

As you move towards more advanced usage, you will need to piece together
needed information by carefully reading the documentation, asking
questions on StackOverflow, and performing experiments. Some
recommendations:

\begin{itemize}
\item
  The Bioconductor community is a long-term user S4 and have produced
  much of best material about its effective use. Start with
  \href{https://bioconductor.org/help/course-materials/2017/Zurich/S4-classes-and-methods.html}{S4
  classes and methods} taught by Martin Morgan and Hervé Pagès, or check
  for a newer version at
  \href{https://bioconductor.org/help/course-materials/}{Bioconductor
  course materials}.

  Martin Morgan is a member of R-core and the project lead of
  Bioconductor. He's a world expert on the practical use of S4, and I
  recommend reading anything he has written about it, starting with the
  questions he has answered on
  \href{http://stackoverflow.com/search?tab=votes\&q=user\%3a547331\%20\%5bs4\%5d\%20is\%3aanswe}{stackoverflow}.
\item
  John Chambers is the author of the S4 system, and provides an
  overview\\
  of its motivation and historical context in ``Object-oriented
  programming, functional programming and R'' (Chambers
  \protect\hyperlink{ref-chambers-2014}{2014}). For a fuller exploration
  of S4, see his book ``Software for Data Analysis'' (Chambers
  \protect\hyperlink{ref-s4da}{2008}).
\end{itemize}

\hypertarget{outline-11}{%
\subsection*{Outline}\label{outline-11}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{s4-basics} gives a quick overview of the main components
  of S4: classes, generics, and methods.
\item
  Section \ref{s4-classes} dives into the details of S4 classes,
  including prototypes, constructors, helpers, and validators.
\item
  Section \ref{s4-generics} shows you how to create new S4 generics, and
  how to supply those generics with methods. You'll also learn about
  accessor functions which are designed to allow users to safely inspect
  and modify object slots.
\item
  Section \ref{s4-dispatch} dives into the full details of method
  dispatch in S4. The basic idea is simple, the it rapidly gets more
  complex once multiple inheritance and multiple dispatch are combined.
\item
  Section \ref{s4-s3} discusses the interaction between S4 and S3,
  showing you how to use them together.
\end{itemize}

\hypertarget{prerequisites-8}{%
\subsection*{Prerequisites}\label{prerequisites-8}}
\addcontentsline{toc}{subsection}{Prerequisites}

All functions related to S4 live in the methods package. This package is
always available when you're running R interactively, but may not be
available when running R in batch mode, i.e.~from
\texttt{Rscript}\footnote{This is a historical quirk introduced because
  the methods package used to take a long time to load and
  \texttt{Rscript} is optimised for fast command line invocation.}. For
this reason, it's a good idea to call \texttt{library(methods)} whenever
you use S4. This also signals to the reader that you'll be using the S4
object system.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(methods)}
\end{Highlighting}
\end{Shaded}

\hypertarget{s4-basics}{%
\section{Basics}\label{s4-basics}}

We'll start with a quick overview of the main components of S4. You
define a S4 class by calling \texttt{setClass()} with the class name and
a definition of its slots, the names and classes of the class data:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }
    \DataTypeTok{age =} \StringTok{"numeric"}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Once the class is defined, you can construct new objects from it by
calling \texttt{new()} with the name of the class and a value for each
slot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{john <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"John Smith"}\NormalTok{, }\DataTypeTok{age =} \OtherTok{NA_real_}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Given an S4 object you can see it's class with \texttt{is()} and access
slots with \texttt{@} (equivalent to \texttt{\$}) and \texttt{slot()}
(equivalent to \texttt{{[}{[}}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is}\NormalTok{(john)}
\CommentTok{#> [1] "Person"}
\NormalTok{john}\OperatorTok{@}\NormalTok{name}
\CommentTok{#> [1] "John Smith"}
\KeywordTok{slot}\NormalTok{(john, }\StringTok{"age"}\NormalTok{)}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}

Generally, you should only use \texttt{@} in your methods. If you're
working with someone else's class, look for \textbf{accessor} functions
that allow you to safely set and get slot values. As the developer of a
class, you should also provide your own accessor functions. Accessors
are typically S4 generics allowing multiple classes to share the same
external interface.

Here we'll create a setter and getter for the \texttt{age} slot by first
creating generics with \texttt{setGeneric()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"age"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"age"}\NormalTok{))}
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"age<-"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, value) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"age<-"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

And then defining methods with \texttt{setMethod()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"age"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{@}\NormalTok{age)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"age<-"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, value) \{}
\NormalTok{  x}\OperatorTok{@}\NormalTok{age <-}\StringTok{ }\NormalTok{value}
\NormalTok{  x}
\NormalTok{\})}

\KeywordTok{age}\NormalTok{(john) <-}\StringTok{ }\DecValTok{50}
\KeywordTok{age}\NormalTok{(john)}
\CommentTok{#> [1] 50}
\end{Highlighting}
\end{Shaded}

If you're using an S4 class defined in a package, you can get help on it
with \texttt{class?Person}. To get help for a method, put \texttt{?} in
front of a call (e.g. \texttt{?age(john)}) and \texttt{?} will use the
class of the arguments to figure out which help file you need.

Finally, you can use sloop functions to identify S4 objects and generics
found in the wild:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{otype}\NormalTok{(john)}
\CommentTok{#> [1] "S4"}
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{ftype}\NormalTok{(age)}
\CommentTok{#> [1] "S4"      "generic"}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-45}{%
\subsection{Exercises}\label{exercises-45}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{lubridate::period()} returns an S4 class. What slots does it
  have? What class is each slot? What accessors does it provide?
\item
  What other ways can you find help for a method? Read \texttt{?"?"} and
  summarise the details.
\end{enumerate}

\hypertarget{s4-classes}{%
\section{Classes}\label{s4-classes}}

\index{setClass()}

To define an S4 class, call \texttt{setClass()} with three arguments:

\begin{itemize}
\item
  The class \textbf{name}. By convention, S4 class names use
  \texttt{UpperCamelCase}.
\item
  A named character vector that describes the names and classes of the
  \textbf{slots} (fields). For example, a person might be represented by
  a character name and a numeric age:
  \texttt{c(name\ =\ "character",\ age\ =\ "numeric")}. The pseudo-class
  \texttt{ANY} allows a slot to accept objects of any type.
\item
  A \textbf{prototype}, a list of default values for each slot.
  Technically, the prototype is optional\footnote{Note that
    \texttt{?setClass} recommends that you avoid the the
    \texttt{prototype} argument, but this is generally considered to be
    bad advice.}, but you should always provide it.
\end{itemize}

The code below illustrates the three arguments by creating a
\texttt{Person} class with character \texttt{name} and numeric
\texttt{age} slots.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }
    \DataTypeTok{age =} \StringTok{"numeric"}
\NormalTok{  ), }
  \DataTypeTok{prototype =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{name =} \OtherTok{NA_character_}\NormalTok{,}
    \DataTypeTok{age =} \OtherTok{NA_real_}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{me <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{)}
\KeywordTok{str}\NormalTok{(me)}
\CommentTok{#> Formal class 'Person' [package ".GlobalEnv"] with 2 slots}
\CommentTok{#>   ..@ name: chr "Hadley"}
\CommentTok{#>   ..@ age : num NA}
\end{Highlighting}
\end{Shaded}

\hypertarget{inheritance-1}{%
\subsection{Inheritance}\label{inheritance-1}}

There is one other important argument to \texttt{setClass()}:
\texttt{contains}. This specifies a class (or classes) to inherit slots
and behaviour from. For example, we can create an \texttt{Employee}
class that inherits from the \texttt{Person} class, adding an extra slot
desribes their \texttt{boss}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Employee"}\NormalTok{, }
  \DataTypeTok{contains =} \StringTok{"Person"}\NormalTok{, }
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{boss =} \StringTok{"Person"}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{boss =} \KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{str}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Employee"}\NormalTok{))}
\CommentTok{#> Formal class 'Employee' [package ".GlobalEnv"] with 3 slots}
\CommentTok{#>   ..@ boss:Formal class 'Person' [package ".GlobalEnv"] with 2 slots}
\CommentTok{#>   .. .. ..@ name: chr NA}
\CommentTok{#>   .. .. ..@ age : num NA}
\CommentTok{#>   ..@ name: chr NA}
\CommentTok{#>   ..@ age : num NA}
\end{Highlighting}
\end{Shaded}

\texttt{setClass()} has 9 other arguments but they are either deprecated
or not recommended.

\hypertarget{introspection-1}{%
\subsection{Introspection}\label{introspection-1}}

To determine what classes an object inherits from, use \texttt{is()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{))}
\CommentTok{#> [1] "Person"}
\KeywordTok{is}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Employee"}\NormalTok{))}
\CommentTok{#> [1] "Employee" "Person"}
\end{Highlighting}
\end{Shaded}

To test if an object inherits from a specific class, use the second
argument of \texttt{is()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is}\NormalTok{(john, }\StringTok{"person"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{redefinition}{%
\subsection{Redefinition}\label{redefinition}}

In most programming languages, class definition occurs at compile-time
and object construction occurs later, at run-time. In R, however, both
definition and construction occur at run time. When you call
\texttt{setClass()}, you are registering a class definition in a
(hidden) global variable. As with all state-modifying functions you need
to use \texttt{setClass()} with care. It's possible to create invalid
objects if you redefine a class after already having instantiated an
object:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"numeric"}\NormalTok{))}
\NormalTok{a <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\DataTypeTok{x =} \DecValTok{10}\NormalTok{)}

\KeywordTok{setClass}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{a_different_slot =} \StringTok{"numeric"}\NormalTok{))}
\NormalTok{a}
\CommentTok{#> An object of class "A"}
\CommentTok{#> Slot "a_different_slot":}
\CommentTok{#> Error in slot(object, what):}
\CommentTok{#>   no slot of name "a_different_slot" for this object of class "A"}
\end{Highlighting}
\end{Shaded}

This can cause confusion during interactive creation of new classes. (R6
classes have the same problem, as described in Section
\ref{r6-important-methods}.)

\hypertarget{helper}{%
\subsection{Helper}\label{helper}}

\texttt{new()} is a low-level constructor suitable for use by you, the
developer. User-facing classes should always be paired with a
user-friendly helper. A helper should always:

\begin{itemize}
\item
  Have the same name as the class, e.g. \texttt{myclass()}.
\item
  Have a thoughtfully crafted user interface with carefully chosen
  default values and useful conversions.
\item
  Create carefully crafted error messages tailored towards an end-user.
\item
  Finish by calling by calling \texttt{methods::new()}.
\end{itemize}

The \texttt{Person} class is so simple so a helper is almost
superfluous, but we can use it to clearly define the contract:
\texttt{age} is optional but \texttt{name} is required. We'll also
coerce age to a dobule so the helper also works when passed an integer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Person <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{age =} \OtherTok{NA}\NormalTok{) \{}
\NormalTok{  age <-}\StringTok{ }\KeywordTok{as.double}\NormalTok{(age)}
  
  \KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =}\NormalTok{ name, }\DataTypeTok{age =}\NormalTok{ age)}
\NormalTok{\}}

\KeywordTok{Person}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{)}
\CommentTok{#> An object of class "Person"}
\CommentTok{#> Slot "name":}
\CommentTok{#> [1] "Hadley"}
\CommentTok{#> }
\CommentTok{#> Slot "age":}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}

\hypertarget{validator}{%
\subsection{Validator}\label{validator}}

The constructor automatically checks that the slots have correct
classes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Person}\NormalTok{(mtcars)}
\CommentTok{#> Error in validObject(.Object):}
\CommentTok{#>   Error in validObject(.Object): invalid class "Person" object:}
\CommentTok{#>   invalid object for slot "name" in class "Person": got class}
\CommentTok{#>   "data.frame", should be or extend class "character"}
\end{Highlighting}
\end{Shaded}

You will need to implement more complicated checks (i.e.~checks that
involve lengths, or multiple slots) yourself. For example, we might want
to make it clear that the Person class is a vector class, and can store
data about multiple people. That's not currently clear because
\texttt{@name} and \texttt{@age} can be different lengths:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Person}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \KeywordTok{c}\NormalTok{(}\DecValTok{30}\NormalTok{, }\DecValTok{37}\NormalTok{))}
\CommentTok{#> An object of class "Person"}
\CommentTok{#> Slot "name":}
\CommentTok{#> [1] "Hadley"}
\CommentTok{#> }
\CommentTok{#> Slot "age":}
\CommentTok{#> [1] 30 37}
\end{Highlighting}
\end{Shaded}

To enforce these additional constraints we write a validator with
\texttt{setValidity()}. It takes class and a function that returns
\texttt{TRUE} if the input is valid, and otherwise returns a character
vector describing the problem(s):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setValidity}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{name) }\OperatorTok{!=}\StringTok{ }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{age)) \{}
    \StringTok{"@name and @age must be same length"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \OtherTok{TRUE}
\NormalTok{  \}}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

Now we can no longer create an invalid object:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Person}\NormalTok{(}\StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \KeywordTok{c}\NormalTok{(}\DecValTok{30}\NormalTok{, }\DecValTok{37}\NormalTok{))}
\CommentTok{#> Error in validObject(.Object):}
\CommentTok{#>   invalid class "Person" object: @name and @age must be same length}
\end{Highlighting}
\end{Shaded}

Note that the validity method is only called automatically by
\texttt{new()}, so you can still create an invalid object by modifying
it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alex <-}\StringTok{ }\KeywordTok{Person}\NormalTok{(}\StringTok{"Alex"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{30}\NormalTok{)}
\NormalTok{alex}\OperatorTok{@}\NormalTok{age <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

You can explicitly check the validity yourself by calling
\texttt{validObject()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{validObject}\NormalTok{(alex)}
\CommentTok{#> Error in validObject(alex):}
\CommentTok{#>   invalid class "Person" object: @name and @age must be same length}
\end{Highlighting}
\end{Shaded}

In Section \ref{accessors}, we'll use \texttt{validObject()} to create
accessors can not create invalid objects.

\hypertarget{exercises-46}{%
\subsection{Exercises}\label{exercises-46}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Extend the Person class with fields to match \texttt{utils::person()}.
  Think about what slots you will need, what class each slot should
  have, and what you'll need to check in your validity method.
\item
  What happens if you define a new S4 class that doesn't have any slots?
  (Hint: read about virtual classes in \texttt{?setClass}.)
\item
  Imagine you were going to reimplement factors, dates, and data frames
  in S4. Sketch out the \texttt{setClass()} calls that you would use to
  define the classes. Think about appropriate \texttt{slots} and
  \texttt{prototype}.
\end{enumerate}

\hypertarget{s4-generics}{%
\section{Generics and methods}\label{s4-generics}}

\index{S4!generics} \index{S4!methods} \index{generics!S4}
\index{methods!S4} \indexc{setGeneric()} \indexc{standardGeneric()}

The job of a generic is to perform method dispatch, i.e.~find the
specific implementation for the combination of classes passed to the
generic. Here you'll learn how to define S4 generics and methods, then
in the next section we'll explore precisely how S4 method dispatch
works.

To create a new S4 generic, call \texttt{setGeneric()} with a function
that calls \texttt{standardGeneric()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

By convention, new S4 generics should use \texttt{lowerCamelCase}.

It is bad practice to use \texttt{\{\}} in the generic as it triggers a
special case that is more expensive, and generally best avoided.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Don't do this!}
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\hypertarget{signature}{%
\subsection{Signature}\label{signature}}

Like \texttt{setClass()}, \texttt{setGeneric()} has many other
arguments. There is only one that you need to know about:
\texttt{signature}. This allows you to control the arguments that are
used for method dispatch. If \texttt{signature} is not supplied, all
arguments (apart from \texttt{...}) are used. It is occassionally useful
to remove arguments from dispatch. This allows you to require that
methods provide arguments like \texttt{verbose\ =\ TRUE} or
\texttt{quiet\ =\ FALSE}, but they don't take part in dispatch.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{, }
  \ControlFlowTok{function}\NormalTok{(x, ..., }\DataTypeTok{verbose =} \OtherTok{TRUE}\NormalTok{) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{),}
  \DataTypeTok{signature =} \StringTok{"x"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{methods}{%
\subsection{Methods}\label{methods}}

\indexc{setMethod()}

A generic isn't useful without some methods, and in S4 you define
methods with \texttt{setMethod()}. There are three important arguments:
the name of the generic, the name of the class, and the method itself.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"myGeneric"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
  \CommentTok{# method implementation}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

More formally, the second argument to \texttt{setMethod()} is called the
\textbf{signature}. In S4, unlike S3, the signature can include multiple
arguments. This makes method dispatch in S4 substantially more
complicated, but avoids having to implement double-dispatch as
specially. We'll talk more about multiple dispatch in the next section.
\texttt{setMethod()} has other arguments, but you should never use them.

To list all the methods that belong to a generic, or that are associated
with a class, use \texttt{methods("generic")} or
\texttt{methods(class\ =\ "class")}; to find the implementation of a
specific method, use \texttt{selectMethod("generic",\ "class")}.

\hypertarget{show-method}{%
\subsection{Show method}\label{show-method}}

The most commonly defined S4 method controls printing is
\texttt{show()}, which controls how the object appears when it is
printed. To define a method for an existing generic, you must first
determine the arguments. You can get those from the documentation or by
looking at the \texttt{args()} of the generic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{args}\NormalTok{(}\KeywordTok{getGeneric}\NormalTok{(}\StringTok{"show"}\NormalTok{))}
\CommentTok{#> function (object) }
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

Our show method needs to have a single argument \texttt{object}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
  \KeywordTok{cat}\NormalTok{(}\KeywordTok{is}\NormalTok{(object)[[}\DecValTok{1}\NormalTok{]], }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}
      \StringTok{"  Name: "}\NormalTok{, object}\OperatorTok{@}\NormalTok{name, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}
      \StringTok{"  Age:  "}\NormalTok{, object}\OperatorTok{@}\NormalTok{age, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,}
      \DataTypeTok{sep =} \StringTok{""}
\NormalTok{  )}
\NormalTok{\})}
\NormalTok{john}
\CommentTok{#> Person}
\CommentTok{#>   Name: John Smith}
\CommentTok{#>   Age:  50}
\end{Highlighting}
\end{Shaded}

\hypertarget{accessors}{%
\subsection{Accessors}\label{accessors}}

Slots should be considered an internal implementation detail: they can
change without warning and user code should avoid accessing them
directly. Instead, all user-accessible slots should be accompanied by a
pair of \textbf{accessors}. If the slot is unique to the class, this can
just be a function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{person_name <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{@}\NormalTok{name}
\end{Highlighting}
\end{Shaded}

Typically, however, you'll define a generic so that multiple classes can
use the same interface:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"name"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"name"}\NormalTok{))}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"name"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{@}\NormalTok{name)}

\KeywordTok{name}\NormalTok{(john)}
\CommentTok{#> [1] "John Smith"}
\end{Highlighting}
\end{Shaded}

If the slot is also writeable, you should provide a setter function. You
should always \texttt{validObject()} in the setter to prevent the user
from creating invalid objects.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"name<-"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, value) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"name<-"}\NormalTok{))}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"name<-"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, value) \{}
\NormalTok{  x}\OperatorTok{@}\NormalTok{name <-}\StringTok{ }\NormalTok{value}
  \KeywordTok{validObject}\NormalTok{(x)}
\NormalTok{  x}
\NormalTok{\})}

\KeywordTok{name}\NormalTok{(john) <-}\StringTok{ "Jon Smythe"}
\KeywordTok{name}\NormalTok{(john)}
\CommentTok{#> [1] "Jon Smythe"}

\KeywordTok{name}\NormalTok{(john) <-}\StringTok{ }\NormalTok{letters}
\CommentTok{#> Error in validObject(x):}
\CommentTok{#>   invalid class "Person" object: @name and @age must be same length}
\end{Highlighting}
\end{Shaded}

(If the \texttt{name\textless{}-} notation is unfamiliar, review Section
\ref{function-forms}.)

\hypertarget{exercises-47}{%
\subsection{Exercises}\label{exercises-47}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add \texttt{age()} accessors for the \texttt{Person} class.
\item
  In the definition of the generic, why is it necessary to repeat the
  name of the generic twice?
\item
  Why does the \texttt{show()} method defined in Section
  \ref{show-method} use \texttt{is(object){[}{[}1{]}{]}}. (Hint: try
  printing the employee subclass.)
\item
  What happens if you define a method with different argument names to
  the generic?
\end{enumerate}

\hypertarget{s4-dispatch}{%
\section{Method dispatch}\label{s4-dispatch}}

S4 dispatch is complicated because S4 has two important features:

\begin{itemize}
\tightlist
\item
  Multiple inheritance, i.e.~a class can have multiple parents,
\item
  Multiple dispatch, i.e.~a generic can use multiple arguments to pick a
  method.
\end{itemize}

These features make S4 very powerful, but can also make it hard to
understand which method will get selected for a given combination of
inputs. In practice, keep method dispatch as simple as possible by
avoiding multiple inheritance, and reserving multiple dispatch only for
where it is absolutely necessary.

But it's important to describe the full details, so here we'll start
simple with single inheritance and single dispatch, and work our way up
to the more complicated cases. To illustrate the ideas without getting
bogged down in the details, we'll use an imaginary \textbf{class graph}
based on emoji:

\begin{center}\includegraphics[width=2.36in]{diagrams/s4/emoji} \end{center}

Emoji give us very compact class names that evoke the relationships
between the classes. It should be straightforward to remember that
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f61c.png}}
inherits from
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f609.png}}
which inherits from
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f636.png}},
and that
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f60e.png}}
inherits from both
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f576.png}}
and
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f642.png}}.

\hypertarget{single-dispatch}{%
\subsection{Single dispatch}\label{single-dispatch}}

Let's start with the simplest case: a generic function that dispatches
on a single class with a single parent. The method dispatch here is
simple so it's a good place to define the graphical conventions we'll
use for the more complex cases.

\begin{center}\includegraphics[width=1.97in]{diagrams/s4/single} \end{center}

There are two parts to this diagram:

\begin{itemize}
\item
  The top part, \texttt{f(...)}, defines the scope of the diagram. Here
  we have a generic with one argument, that has a class hierarchy that
  is three levels deep.
\item
  The bottom part is the \textbf{method graph} and displays all the
  possible methods that could be defined. Methods that exist, i.e.~that
  have been defined with \texttt{setMethod()}, have a grey background.
\end{itemize}

To find the method that gets called, you start with the most specific
class of the actual arguments, then follow the arrows until you find a
method that exists. For example, if you called the function with an
object of class
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f609.png}}
you would follow the arrow right to find the method defined for the more
general
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f636.png}}
class. If no method is found, method dispatch has failed and an error is
thrown. In practice, this means that you should alway define methods
defined for the terminal nodes, i.e.~those on the far right.

There are two \textbf{pseudo-classes} that you can define methods for.
These are called pseudo-classes because they don't actually exist, but
allow you to define useful behaviours. The first pseudo-class is
\texttt{ANY} which matches any class{[}\^{}s3-default{]}. For technical
reasons that we'll get to later, the link to the \texttt{ANY} method is
longer than the links between the other classes:

{[}\^{}s3-default{]} The S4 \texttt{ANY} pseudoclass plays the same same
role as the S3 \texttt{default} pseudo-class.

\begin{center}\includegraphics[width=2.8in]{diagrams/s4/single-any} \end{center}

The second pseudo-class is \texttt{MISSING}. If you define a method for
this pesudo-class, it will match whenever the argument is missing.
It'snot useful for single dispatch, but is important for functions like
\texttt{+} and \texttt{-} that use double dispatch and behave
differently depending on whether they have one or two arguments.

\hypertarget{multiple-inheritance}{%
\subsection{Multiple inheritance}\label{multiple-inheritance}}

Things get more complicated when the class has multiple parents.

\begin{center}\includegraphics[width=1.87in]{diagrams/s4/multiple} \end{center}

The basic process remains the same: you start from the actual class
supplied to the generic, then follow the arrows until you find a defined
method. The wrinkle is that now there are multiple arrows to follow, so
you might find multiple methods. If that happens, you pick the method
that is closest, i.e.~requires travelling the fewest arrows.

NB: while the method graph is a powerful metaphor for understanding
method dispatch, implementing it in this way would be rather
inefficient, so the actual approach that S4 uses is somewhat different.
You can read the details in \texttt{?Methods\_Details}

What happens if methods are the same distance? For example, imagine
we've defined methods for
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f576.png}}
and
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f642.png}},
and we call the generic with
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f60e.png}}.
Note that no method can be found for the
\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f636.png}}
class, which I'll highlight with a red double outline.

\begin{center}\includegraphics[width=1.72in]{diagrams/s4/multiple-ambig} \end{center}

This is called an \textbf{ambiguous} method, and in diagrams I'll
illustrate it with a thick dotted border. When this happens in R, you'll
get a warning, and the method for the class that comes earlier in the
alphabet will be picked (this is effectively random and should not be
relied upon). When you discover ambiguity you should always resolve it
by providing a more precise method:

\begin{center}\includegraphics[width=1.72in]{diagrams/s4/multiple-ambig-2} \end{center}

The fallback \texttt{ANY} method still exists but the rules are little
more complex. As indicated by the wavy dotted lines, the \texttt{ANY}
method is always considered further away than a method for a real class.
This means that it will never contribute to ambiguity.

\begin{center}\includegraphics[width=2.51in]{diagrams/s4/multiple-any} \end{center}

With multiple inheritances it is hard to simultaneously prevent
ambiguity, ensure that every terminal method has an implementation, and
minimise the number of defined methods (in order to benefit from OOP).
For example, of the six ways to define only two methods for this call,
only one is free from problems. For this reason, I recommend using
multiple inheritance with extreme care: you will need to carefully think
about the method graph and plan accordingly.

\begin{center}\includegraphics[width=4.33in]{diagrams/s4/multiple-all} \end{center}

\hypertarget{multiple-dispatch}{%
\subsection{Multiple dispatch}\label{multiple-dispatch}}

Once you understand multiple inheritance, understanding multiple
dispatch is straightforward. You follow multiple arrows in the same way
as previously, but now each method is specified by two classes
(separated by a comma).

\begin{center}\includegraphics[width=3.3in]{diagrams/s4/single-single} \end{center}

I'm not going to show examples of dispatching on more than two
arguments, but you can follow the basic principles to generate your own
method graphs.

The main difference between multiple inheritance and multiple dispatch
is that there are many more arrows to follow. The following diagram
shows four defined methods which produce two ambiguous cases:

\begin{center}\includegraphics[width=3.3in]{diagrams/s4/single-single-ambig} \end{center}

Multiple dispatch tends to be less tricky to work with than multiple
inheritance because there are usually fewer terminal class combinations.
In this example, there's only one. That means, at a minimum, you can
define a single method and have default behaviour for all inputs.

\hypertarget{multiple-dispatch-and-multiple-inheritance}{%
\subsection{Multiple dispatch and multiple
inheritance}\label{multiple-dispatch-and-multiple-inheritance}}

Of course you can combine multiple dispatch with multiple inheritance:

\begin{center}\includegraphics[width=3.2in]{diagrams/s4/single-multiple} \end{center}

A still more complicated case dispatches on two classes, both of which
have multiple inheritance:

\begin{center}\includegraphics[width=2.46in]{diagrams/s4/multiple-multiple} \end{center}

As the method graph gets more and more complicated it gets harder and
harder to predict which method will get called given a combination of
inputs, and it gets harder and harder to make sure that you haven't
introduced ambiguity. If you have to draw diagrams to figure out what
method is actually going to be called, it's a strong indication that you
should go back and simplify your design.

\hypertarget{exercises-48}{%
\subsection{Exercises}\label{exercises-48}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Draw the method graph for
  \texttt{f(}\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f605.png}},
  \raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f63d.png}}\texttt{)}.
\item
  Draw the method graph for
  \texttt{f(}\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f603.png}},
  \raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f609.png}},
  \raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f619.png}}\texttt{)}.
\item
  Take the last example which shows multiple dispatch over two classes
  that use multiple inheritance. What happens if you define a method for
  all terminal classes? Why does method dispatch not save us much work
  here?
\end{enumerate}

\hypertarget{s4-s3}{%
\section{S4 and S3}\label{s4-s3}}

When writing S4 code, you'll often need to interact with existing S3
classes and generics. This section describes how S4 classes, methods,
and generics interact with existing code.

\hypertarget{classes}{%
\subsection{Classes}\label{classes}}

In \texttt{slots} and \texttt{contains} you can use S4 classes, S3
classes, or the implicit class (Section \ref{implicit-class}) of a base
type. To use an S3 class, you must first register it with
\texttt{setOldClass()}. You call this function once for each S3 class,
giving it the class attribute. For example, the following definitions
are already provided by base R:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setOldClass}\NormalTok{(}\StringTok{"data.frame"}\NormalTok{)}
\KeywordTok{setOldClass}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"ordered"}\NormalTok{, }\StringTok{"factor"}\NormalTok{))}
\KeywordTok{setOldClass}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"glm"}\NormalTok{, }\StringTok{"lm"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

However, it's generally better to be more specific and provide a full S4
definition with \texttt{slots} and a \texttt{prototype}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"factor"}\NormalTok{,}
  \DataTypeTok{contains =} \StringTok{"integer"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{levels =} \StringTok{"character"}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{structure}\NormalTok{(}
    \KeywordTok{integer}\NormalTok{(),}
    \DataTypeTok{levels =} \KeywordTok{character}\NormalTok{()}
\NormalTok{  )}
\NormalTok{)}
\KeywordTok{setOldClass}\NormalTok{(}\StringTok{"factor"}\NormalTok{, }\DataTypeTok{S4Class =} \StringTok{"factor"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Generally, these definitions should be provided by the creator of the S3
class. If you're trying to build an S4 class on top of an S3 class
provided by a package, you should request that the package maintainer
add this call to their package, rather than adding it to your own code.

If an S4 object inherits from an S3 class or a base type, it will have a
special virtual slot called \texttt{.Data}. This contains the underlying
base type or S3 object: \indexc{.Data}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RangedNumeric <-}\StringTok{ }\KeywordTok{setClass}\NormalTok{(}
  \StringTok{"RangedNumeric"}\NormalTok{,}
  \DataTypeTok{contains =} \StringTok{"numeric"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{min =} \StringTok{"numeric"}\NormalTok{, }\DataTypeTok{max =} \StringTok{"numeric"}\NormalTok{),}
  \DataTypeTok{prototype =} \KeywordTok{structure}\NormalTok{(}\KeywordTok{numeric}\NormalTok{(), }\DataTypeTok{min =} \OtherTok{NA_real_}\NormalTok{, }\DataTypeTok{max =} \OtherTok{NA_real_}\NormalTok{)}
\NormalTok{)}
\NormalTok{rn <-}\StringTok{ }\KeywordTok{RangedNumeric}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{min =} \DecValTok{1}\NormalTok{, }\DataTypeTok{max =} \DecValTok{10}\NormalTok{)}
\NormalTok{rn}\OperatorTok{@}\NormalTok{min}
\CommentTok{#> [1] 1}
\NormalTok{rn}\OperatorTok{@}\NormalTok{.Data}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

It is possible to define S3 methods for S4 generics, and S4 methods for
S3 generics (provided you've called \texttt{setOldClass()}). However,
it's more complicated than it might appear at first glance, so make sure
you thoroughly read \texttt{?Methods\_for\_S3}.

\hypertarget{generics}{%
\subsection{Generics}\label{generics}}

As well as creating a new generic from scratch, it's also possible to
convert an existing S3 generic to an S4 generic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In this case, the existing function becomes the default (\texttt{ANY})
method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{selectMethod}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\StringTok{"ANY"}\NormalTok{)}
\CommentTok{#> Method Definition (Class "derivedDefaultMethod"):}
\CommentTok{#> }
\CommentTok{#> function (x, ...) }
\CommentTok{#> UseMethod("mean")}
\CommentTok{#> <bytecode: 0x303e8f0>}
\CommentTok{#> <environment: namespace:base>}
\CommentTok{#> }
\CommentTok{#> Signatures:}
\CommentTok{#>         x    }
\CommentTok{#> target  "ANY"}
\CommentTok{#> defined "ANY"}
\end{Highlighting}
\end{Shaded}

Note that \texttt{setMethod()} will automatically call
\texttt{setGeneric()} if the first argument isn't already a generic,
enabling you to turn any existing function into an S4 generic. It is ok
to convert an existing S3 generic to S4, but you should avoid converting
regular functions to S4 generics in packages because requires careful
coordination if done by multiple packages.

\hypertarget{exercises-49}{%
\subsection{Exercises}\label{exercises-49}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What would a full \texttt{setOldClass()} definition look like for an
  ordered factor? (i.e.~add \texttt{slots} and \texttt{prototype} the
  definition above)
\item
  Define a \texttt{length} method for the \texttt{Person} class.
\end{enumerate}

\hypertarget{oo-tradeoffs}{%
\chapter{Trade-offs}\label{oo-tradeoffs}}

\hypertarget{introduction-14}{%
\section{Introduction}\label{introduction-14}}

You now know about the three most important OOP toolkits available in R.
Now that you understand their basic operation and the principles that
underlie them, we can start to compare and contrast the systems in order
to understand their strengths and weaknesses. This will help you pick
the system that is most likely to solve new problems.

Overall, when picking an OO system, I recommend that you default to S3.
S3 is simple, and widely used throughout base R and CRAN. While it's far
from perfect, its idiosyncracies are well understood and there are known
approaches to overcome most shortcomings. If you have an existing
background in programming you are likely to lean towards R6, because it
will feel familiar. I think you should resist this tendency for two
reasons. Firstly, if you use R6 it's very easy to create a non-idiomatic
API that will feel very odd to native R users, and will have surprising
pain points because of the reference semantics. Secondly, if you stick
to R6, you'll lose out on learning a new way of thinking about OOP that
gives you a new set of tools for solving problems.

\hypertarget{outline-12}{%
\subsection*{Outline}\label{outline-12}}
\addcontentsline{toc}{subsection}{Outline}

This chapter is divided into two parts. \protect\hyperlink{s3-s4}{S4 vs
S3} compares S3 and S4. In brief, S4 is more formal and tends to require
more upfront planning. That makes it more suitable for big projects
developed by teams, not individuals. \protect\hyperlink{s3-r6}{R6 vs S3}
compares S3 and R6. This section is quite long because these two systems
are fundamentally different and there are a number of tradeoffs that you
need to consider.

\hypertarget{s3-s4}{%
\section{S4 vs S3}\label{s3-s4}}

Once you've mastered S3, S4 is not too difficult to pick up: the
underlying ideas are the same, S4 is just more formal, more strict, and
more verbose. The strictness and formality of S4 make it well suited for
large teams. Since more structure is provided by the system itself,
there is less need for convention, and new contributors don't need as
much training. S4 tends to require more upfront design than S3, and this
investment is more likely to pay off on larger projects where greater
resources are available.

One large team effort where S4 is used to good effect is Bioconductor.
Bioconductor is similar to CRAN: it's a way of sharing packages amongst
a wider audience. Bioconductor is smaller than CRAN
(\textasciitilde{}1,300 vs \textasciitilde{}10,000 packages, July 2017)
and the packages tend to be more tightly integrated because of the
shared domain and because Bioconductor has a stricter review process.
Bioconductor packages are not required to use S4, but most will because
the key data structures (e.g.~SummarizedExperiment, IRanges,
DNAStringSet) are built using S4.

S4 is also a good fit for complex systems of interrelated objects, and
it's possible to minimise code duplication through careful
implementation of methods. The best example of such a system is the
Matrix package (Bates and Maechler
\protect\hyperlink{ref-Matrix}{2018}). It is designed to efficiently
store and compute with many different types of sparse and dense
matrices. As of version 1.2.14, it defines 102 classes, 21 generic
functions, and 1993 methods, and to give you some idea of the
complexity, a small subset of the class graph is shown in Figure
\ref{fig:matrix-classes}.

\begin{figure}

{\centering \includegraphics[width=0.8\linewidth]{diagrams/s4/Matrix} 

}

\caption{A small subset of the Matrix class graph showing the inheritance of sparse matrices. Each concrete class inherits from two virtual parents: one that describes how the data is stored (C = column oriented, R = row oriented, T = tagged) and one that describes any restriction on the matrix (s = symmetric, t = triangle, g = general)}\label{fig:matrix-classes}
\end{figure}

This domain is a good fit for S4 because there are often computational
shortcuts for specific combinations of sparse matrices. S4 makes it easy
to provide a general method that works for all inputs, and then provide
more specialised methods where the inputs allow a more efficient
implementation. This requires careful planning to avoid method dispatch
ambiguity, but the planning pays off with higher performance.

The biggest challenge to using S4 is the combination of increased
complexity and absence of a single source of documentation. S4 is a
complex system and it can be challenging to use effectively in practice.
This wouldn't be such a problem if S4 documentation wasn't scattered
through R documentation, books, and websites. S4 needs a book length
treatment, but that book does not (yet) exist. (The documentation for S3
is no better, but the lack is less painful because S3 is much simpler.)

\hypertarget{s3-r6}{%
\section{R6 vs S3}\label{s3-r6}}

R6 is a profoundly different OO system from S3 and S4 because it is
built on encapsulated objects, rather than generic functions.
Additionally R6 objects have reference semantics, which means that they
can be modified in place. These two big differences have a number of
non-obvious consequences which we'll explore here:

\begin{itemize}
\item
  A generic is a regular function so lives in the global namespace. An
  R6 method belongs to an object so lives in a local namespace. This
  influences how we think about naming.
\item
  R6's reference semantics allow methods to simultaneously return a
  value and modify an object. This solves a painful problem called
  ``threading state''.
\item
  You invoke an R6 method using \texttt{\$}, which is an infix operator.
  If you set up your methods correctly you can use chains of method
  calls as an alternative to the pipe.
\end{itemize}

These are general trade-offs between functional and encapsulated OOP, so
they also serve as a discussion of system design in R vs Python.

\hypertarget{namespacing}{%
\subsection{Namespacing}\label{namespacing}}

One non-obvious difference between S3 and R6 is the ``space'' in which
methods are found:

\begin{itemize}
\tightlist
\item
  Generic functions are global: all packages share the same namespace.
\item
  Encapsulated methods are local: methods are bound to a single object.
\end{itemize}

The advantage of a global namespace is that multiple packages can use
the same verbs for working with different types of objects. Generic
functions provide a uniform API that makes it easier to perform typical
actions with a new object because there are strong naming conventions.
This works well for data analysis because you often want to do the same
thing to different types of objects. In particular, this is one reason
that R's modelling system is so useful: regardless of where the model
has been implemented you always work with it using the same set of tools
(\texttt{summary()}, \texttt{predict()}, \ldots{}).

The disadvantage of a global namespace is that it forces you to think
more deeply about naming. You want to avoid multiple generics with the
same name in different packages because it requires the user to type
\texttt{::} frequently. This can be hard because function names are
usually English verbs, and verbs often have multiple meanings. Take
\texttt{plot()} for example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(data)       }\CommentTok{# plot some data}
\KeywordTok{plot}\NormalTok{(bank_heist) }\CommentTok{# plot a crime}
\KeywordTok{plot}\NormalTok{(land)       }\CommentTok{# create a new plot of land}
\KeywordTok{plot}\NormalTok{(movie)      }\CommentTok{# extract plot of a movie}
\end{Highlighting}
\end{Shaded}

Generally, you should avoid methods that are homonyms of the original
generic, and instead define a new generic.

This problem doesn't occur with R6 methods because they are scoped to
the object. The following code is fine, because there is no implication
that the plot method of two different R6 objects has the same meaning:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data}\OperatorTok{$}\KeywordTok{plot}\NormalTok{()}
\NormalTok{bank_heist}\OperatorTok{$}\KeywordTok{plot}\NormalTok{()}
\NormalTok{land}\OperatorTok{$}\KeywordTok{plot}\NormalTok{()}
\NormalTok{movie}\OperatorTok{$}\KeywordTok{plot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

These considerations also apply to the arguments to the generic. S3
generics must have the same core arguments, which mean they generally
have non-specific names like \texttt{x} or \texttt{.data}. S3 generics
generally need \texttt{...} to pass on additional arguments to methods,
but this has the downside that mispelled argument names will not create
an error. In comparison, R6 methods can vary more widely and use more
specific and evocative argument names.

A secondary advantage of local namespacing is that creating an R6 method
is very cheap. Most encapsulated OO languages encourage you to create
many small methods, each doing one thing well with an evocative name.
Creating a new S3 method is more expensive, because you may also have to
create a generic, and think about the naming issues described above.
That means that the advice to create many small methods does not apply
to S3. It's still a good idea to break your code down into small, easily
understood chunks, but they should generally just be regular functions,
not methods.

\hypertarget{threading-state}{%
\subsection{Threading state}\label{threading-state}}

One challenge of programming with S3 is when you want to both return a
value and modify the object. This violates our guideline that a function
should either be called for its return value or for its side effects,
but is necessary in a handful of cases.

For example, imagine you want to create a \textbf{stack} of objects. A
stack has two main methods:

\begin{itemize}
\tightlist
\item
  \texttt{push()} adds a new object to the top of the stack.
\item
  \texttt{pop()} returns the top most value, and removes it from the
  stack.
\end{itemize}

The implementation of the constructor and the \texttt{push()} method is
straightforward. A stack contains a list of items, and pushing an object
to the stack simply appends to this list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_stack <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{items =} \KeywordTok{list}\NormalTok{()) \{}
  \KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{items =}\NormalTok{ items), }\DataTypeTok{class =} \StringTok{"stack"}\NormalTok{)}
\NormalTok{\}}

\NormalTok{push <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{  x}\OperatorTok{$}\NormalTok{items <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x}\OperatorTok{$}\NormalTok{items, }\KeywordTok{list}\NormalTok{(y))}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(Note that I haven't created a real method for \texttt{push()} because
making it generic would just make this example more complicated for no
real benefit.)

Implementing \texttt{pop()} is more challenging because it has to both
return a value (the object at the top of the stack), and have a
side-effect (remove that object from that top). Since we can't modify
the input object in S3 we need to return two things: the value, and the
updated object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x}\OperatorTok{$}\NormalTok{items)}
  
\NormalTok{  item <-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{items[[n]]}
\NormalTok{  x}\OperatorTok{$}\NormalTok{items <-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{items[}\OperatorTok{-}\NormalTok{n]}
  
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{item =}\NormalTok{ item, }\DataTypeTok{x =}\NormalTok{ x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This leads to rather awkward usage:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ }\KeywordTok{new_stack}\NormalTok{()}
\NormalTok{s <-}\StringTok{ }\KeywordTok{push}\NormalTok{(s, }\DecValTok{10}\NormalTok{)}
\NormalTok{s <-}\StringTok{ }\KeywordTok{push}\NormalTok{(s, }\DecValTok{20}\NormalTok{)}

\NormalTok{out <-}\StringTok{ }\KeywordTok{pop}\NormalTok{(s)}
\NormalTok{out}\OperatorTok{$}\NormalTok{item}
\CommentTok{#> [1] 20}
\NormalTok{s <-}\StringTok{ }\NormalTok{out}\OperatorTok{$}\NormalTok{x}
\NormalTok{s}
\CommentTok{#> $items}
\CommentTok{#> $items[[1]]}
\CommentTok{#> [1] 10}
\CommentTok{#> }
\CommentTok{#> }
\CommentTok{#> attr(,"class")}
\CommentTok{#> [1] "stack"}
\end{Highlighting}
\end{Shaded}

This problem is known as \textbf{threading state} or \textbf{accumulator
programming}, because no matter how deeply the \texttt{pop()} is called,
you have to thread the modified stack object all the way back to where
it lives.

One way that other FP languages deal with this challenge is to provide a
\textbf{multiple assign} (or destructuring bind) operator that allows
you to assign multiple values in a single step. The zeallot package
(Teetor \protect\hyperlink{ref-zeallot}{2018}) provides multi-assign for
R with \texttt{\%\textless{}-\%}. This makes the code more elegant, but
doesn't solve the key problem:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(zeallot)}

\KeywordTok{c}\NormalTok{(value, s) }\OperatorTok{%<-%}\StringTok{ }\KeywordTok{pop}\NormalTok{(s)}
\NormalTok{value}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

An R6 implementation of a stack is simpler because \texttt{\$pop()} can
modify the object in place, and return only the top-most value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Stack <-}\StringTok{ }\NormalTok{R6}\OperatorTok{::}\KeywordTok{R6Class}\NormalTok{(}\StringTok{"Stack"}\NormalTok{, }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{items =} \KeywordTok{list}\NormalTok{(),}
  \DataTypeTok{push =} \ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    self}\OperatorTok{$}\NormalTok{items <-}\StringTok{ }\KeywordTok{c}\NormalTok{(self}\OperatorTok{$}\NormalTok{items, x)}
    \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{  \},}
  \DataTypeTok{pop =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    item <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{items[[self}\OperatorTok{$}\KeywordTok{length}\NormalTok{()]]}
\NormalTok{    self}\OperatorTok{$}\NormalTok{items <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{items[}\OperatorTok{-}\NormalTok{self}\OperatorTok{$}\KeywordTok{length}\NormalTok{()]}
\NormalTok{    item}
\NormalTok{  \},}
  \DataTypeTok{length =} \ControlFlowTok{function}\NormalTok{() \{}
    \KeywordTok{length}\NormalTok{(self}\OperatorTok{$}\NormalTok{items)}
\NormalTok{  \}}
\NormalTok{))}
\end{Highlighting}
\end{Shaded}

This leads to more natural code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ }\NormalTok{Stack}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{s}\OperatorTok{$}\KeywordTok{push}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{s}\OperatorTok{$}\KeywordTok{push}\NormalTok{(}\DecValTok{20}\NormalTok{)}
\NormalTok{s}\OperatorTok{$}\KeywordTok{pop}\NormalTok{()}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

I encounted a real-life example of threading state in ggplot2 scales.
Scales are complex because they need to combine data across every facet
and every layer. I originally used S3 classes, but it required passing
scale data to and from many functions. Switching to R6 made the code
substantially simpler. However, it also introduced some problems because
I forgot to call to \texttt{\$clone()} when modifying a plot. This
allowed independent plots to share the same scale data, creating a
subtle bug that was hard to track down.

\hypertarget{tradeoffs-pipe}{%
\subsection{Method chaining}\label{tradeoffs-pipe}}

The pipe, \texttt{\%\textgreater{}\%}, is useful because it provides an
infix operator that makes it easy to compose functions from
left-to-right. Interestingly, the pipe is not so important for R6
objects because they already use an infix operator: \texttt{\$}. This
allows the user to chain together multiple method calls in a single
expression, a technique known as \textbf{method chaining}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ }\NormalTok{Stack}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{s}\OperatorTok{$}
\StringTok{  }\KeywordTok{push}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{push}\NormalTok{(}\DecValTok{20}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{pop}\NormalTok{()}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

This technique is commonly used in other programming languages, like
Python and JavaScript, and is made possible with one convention: any R6
method that is primarily called for its side-effects (usually modifying
the object) should return \texttt{invisible(self)}.

The primary advantage of method chaining is that you can get useful
autocomplete; the primary disadvantage is that only the creator of the
class can add new methods (and there's no way to use multiple dispatch).

\hypertarget{part-metaprogramming}{%
\part{Metaprogramming}\label{part-metaprogramming}}

\hypertarget{meta}{%
\chapter*{Introduction}\label{meta}}
\addcontentsline{toc}{chapter}{Introduction}

\index{non-standard evaluation}

One of the most intriguing things about R is its capability for
\textbf{metaprogramming}: the idea that code is itself data, and can be
inspected and modified programmatically. This is powerful idea and
deeply influences much R code. At a simple level this tooling allows you
to write \texttt{library(purrr)} instead of \texttt{library("purrr")}
and enables \texttt{plot(x,\ sin(x))} to label the axes with \texttt{x}
and \texttt{sin(x)}. At a deeper level it allows
\texttt{y\ \textasciitilde{}\ x1\ +\ x2} to represent a model that
predicts the value of \texttt{y} from \texttt{x1} and \texttt{x2}. It
allows \texttt{subset(df,\ x\ ==\ y)} to be translated to
\texttt{df{[}df\$x\ ==\ df\$y,\ ,\ drop\ =\ FALSE{]}}, and for
\texttt{dplyr::filter(db,\ is.na(x))} to generate the SQL
\texttt{WHERE\ x\ IS\ NULL} when \texttt{db} is a remote database table.

Closely related to metaprogramming is \textbf{non-standard evalution},
or NSE for short. This a term that's commonly used to describe the
behaviour of R functions, but there are two problems with the term that
lead me to avoid it. Firstly, NSE is actually a property of an argument
(or arguments) of a function, so talking about NSE functions is a little
sloppy. Secondly, it's confusing to define something by what it is not
(standard), so in this book I'll teach you more precise vocabulary. In
particular, this book focusses on tidy evaluation, or tidy eval for
short. Tidy eval which is made up of three major ideas: quasiquotation,
quosures, and data masks. This book focusses on the theroetical side of
tidy evaluation, so you can fully understand how it works from the
ground up. If you are looking for a practical introduction, I recommend
the ``tidy evaluation book'',
\url{https://tidyeval.tidyverse.org}\footnote{The tidy evaluation book
  is a work-in-progress at the time I wrote this chapter, but will
  hopefully be finished by the time you read it!}.

Metaprogramming is the hardest topic in this book because it forces you
grapple with issues that you haven't thought about before. Don't be
surprised if you're frustrated or confused at first; this is a natural
part of the process that happens to everyone!

\hypertarget{big-ideas}{%
\section{Big ideas}\label{big-ideas}}

But before you dive into details, I wanted to give you an overview of
the most important ideas and vocabulary of metaprogramming::

\begin{itemize}
\tightlist
\item
  Code is data; captured code is called an expression.
\item
  Code has a tree-like structure called an abstract syntax tree.
\item
  Expressions can be generated by code.
\item
  Evaluation executes an expression in an environment.
\item
  Evaluation can be customised by modifying or overriding the
  environment.
\item
  Data masks blur environments and data frames.
\item
  A quosure captures an expression with its environment.
\end{itemize}

Below, I'll use tools primarily from the rlang package, as it allows you
to focus on the big ideas, rather than implementation quirks that arise
from R's history. This approach seems backward to some, but it's
analogous to learning how to drive an automatic transmission before a
manual transmission so you can focus on the big picture before learning
the details.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\end{Highlighting}
\end{Shaded}

\hypertarget{code-is-data}{%
\subsection{Code is data}\label{code-is-data}}

The first big idea is that code is data: you can capture code and
compute on it like any other type of data. To compute on code, you first
need some way to capture it. The first function that captures code is
\texttt{rlang::expr()}. You can think of it returning exactly what you
pass in:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> mean(x, na.rm = TRUE)}
\KeywordTok{expr}\NormalTok{(}\DecValTok{10} \OperatorTok{+}\StringTok{ }\DecValTok{100} \OperatorTok{+}\StringTok{ }\DecValTok{1000}\NormalTok{)}
\CommentTok{#> 10 + 100 + 1000}
\end{Highlighting}
\end{Shaded}

More formally, captured code is called an \textbf{expression}. An
expression isn't a single type of object, but is a collective term for
any of four types (call, symbol, constant, or pairlist), which you'll
learn more about in Chapter \ref{expressions}.

\texttt{expr()} lets you capture code that you've typed. You need a
different tool to capture code passed to a function because
\texttt{expr()} doesn't work:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture_it <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{expr}\NormalTok{(x)}
\NormalTok{\}}
\KeywordTok{capture_it}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c)}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

Here you need to use a function specifically designed to capture user
input in a function argument: \texttt{enexpr()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture_it <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{enexpr}\NormalTok{(x)}
\NormalTok{\}}
\KeywordTok{capture_it}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c)}
\CommentTok{#> a + b + c}
\end{Highlighting}
\end{Shaded}

Once you have captured an expression, you can inspect and modify it.
Complex expressions behave much like lists. That means you can modify
them using \texttt{{[}{[}} and \texttt{\$}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{))}

\CommentTok{# Add a new argument}
\NormalTok{f}\OperatorTok{$}\NormalTok{z <-}\StringTok{ }\DecValTok{3}
\NormalTok{f}
\CommentTok{#> f(x = 1, y = 2, z = 3)}

\CommentTok{# Or remove an argument:}
\NormalTok{f[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{f}
\CommentTok{#> f(y = 2, z = 3)}
\end{Highlighting}
\end{Shaded}

Note that the first element of the call is the function to be called,
which means the first argument is in the second position. You'll learn
about the full details in Section \ref{calls}.

\hypertarget{code-is-a-tree}{%
\subsection{Code is a tree}\label{code-is-a-tree}}

To do more complex manipulation with code, you need to fully understand
its structure. Behind the scenes, almost every programming language
represents code as a tree, often called the \textbf{abstract syntax
tree}, or AST for short. R is unusual in that you can actually inspect
and manipulate this tree.

A very convenient tool for understanding the tree-like structure is
\texttt{lobstr::ast()}. Given some code, will display the underlying
tree structure. Function calls form the branches of the tree, and are
shown by rectangles. The leaves of the tree are symbols (like
\texttt{a}) and constants (like \texttt{"b"}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(a, }\StringTok{"b"}\NormalTok{))}
\CommentTok{#> █─f }
\CommentTok{#> ├─a }
\CommentTok{#> └─"b"}
\end{Highlighting}
\end{Shaded}

Nested function calls create more deeply branching trees:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{f1}\NormalTok{(}\KeywordTok{f2}\NormalTok{(a, b), }\KeywordTok{f3}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{f4}\NormalTok{(}\DecValTok{2}\NormalTok{))))}
\CommentTok{#> █─f1 }
\CommentTok{#> ├─█─f2 }
\CommentTok{#> │ ├─a }
\CommentTok{#> │ └─b }
\CommentTok{#> └─█─f3 }
\CommentTok{#>   ├─1 }
\CommentTok{#>   └─█─f4 }
\CommentTok{#>     └─2}
\end{Highlighting}
\end{Shaded}

Because all function forms in can be written in prefix form (Section
\ref{prefix-form}), every R expression can be displayed in this way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> █─`+` }
\CommentTok{#> ├─1 }
\CommentTok{#> └─█─`*` }
\CommentTok{#>   ├─2 }
\CommentTok{#>   └─3}
\end{Highlighting}
\end{Shaded}

Displaying the code tree in this way provides useful tools for exploring
R's grammar, the topic of Section \ref{grammar}.

\hypertarget{code-can-generate-code}{%
\subsection{Code can generate code}\label{code-can-generate-code}}

As well as seeing the tree from code typed by a human, you can also use
code to create new trees. There are two main tools: \texttt{call2()} and
unquoting.

\texttt{rlang::call2()} constructs a function call from its components:
the function to call, and the arguments to call it with.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> f(1, 2, 3)}
\KeywordTok{call2}\NormalTok{(}\StringTok{"+"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\KeywordTok{call2}\NormalTok{(}\StringTok{"*"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\CommentTok{#> 1 + 2 * 3}
\end{Highlighting}
\end{Shaded}

This is often convenient to program with, but is a bit clunkly for
interactive use. An alternative technique is to build complex code trees
by combining simpler code trees with a template. \texttt{expr()} and
\texttt{enexpr()} have built-in support for this idea via \texttt{!!}
(pronounced bang-bang), the \textbf{unquote operator}.

The precise details are the topic of Chapter \ref{quasiquotation}, but
basically \texttt{!!x} inserts the code tree stored in \texttt{x}. This
makes it easy to build complex trees from simple fragments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xx <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{x)}
\NormalTok{yy <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{y)}

\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{xx }\OperatorTok{/}\StringTok{ }\OperatorTok{!!}\NormalTok{yy)}
\CommentTok{#> (x + x)/(y + y)}
\end{Highlighting}
\end{Shaded}

Notice that the output preserves the operator precedence so we get
\texttt{(x\ +\ x)\ /\ (y\ +\ y)} not \texttt{x\ +\ x\ /\ y\ +\ y} (i.e.
\texttt{x\ +\ (x\ /\ y)\ +\ y}). This is important to note, particularly
if you've been thinking ``wouldn't this be easier to do by pasting
strings?''.

Unquoting gets even more useful when you wrap it up into a function,
first using \texttt{enexpr()} to capture the user's expression, then
\texttt{expr()} and \texttt{!!} to create an new expression using a
template. The example below shows you might generate an expression that
computes the coefficient of variation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cv <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(var) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(var)}
  \KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\OperatorTok{!!}\NormalTok{var) }\OperatorTok{/}\StringTok{ }\KeywordTok{sd}\NormalTok{(}\OperatorTok{!!}\NormalTok{var))}
\NormalTok{\}}

\KeywordTok{cv}\NormalTok{(x)}
\CommentTok{#> mean(x)/sd(x)}
\KeywordTok{cv}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> mean(x + y)/sd(x + y)}
\end{Highlighting}
\end{Shaded}

Importantly, this works even when given weird variable names:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cv}\NormalTok{(}\StringTok{`}\DataTypeTok{)}\StringTok{`}\NormalTok{)}
\CommentTok{#> mean(`)`)/sd(`)`)}
\end{Highlighting}
\end{Shaded}

Dealing with non-syntactic variable names is another good reason to
\texttt{paste()} when generating R code. You might think this is an
esoteric concern, but not worrying about it when generating SQL code in
web applications lead to SQL injection attacks that have collectively
cost billions of dollars.

These techniques become yet more powerful when combined with functional
programming. You'll explore these ideas in detail in Section
\ref{quasi-case-studies} but the teaser belows shows how you might
generate a complex model specification from simple inputs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}
\CommentTok{#> }
\CommentTok{#> Attaching package: 'purrr'}
\CommentTok{#> The following objects are masked from 'package:rlang':}
\CommentTok{#> }
\CommentTok{#>     %@%, %||%, as_function, flatten, flatten_chr,}
\CommentTok{#>     flatten_dbl, flatten_int, flatten_lgl, invoke,}
\CommentTok{#>     list_along, modify, prepend, rep_along, splice}

\NormalTok{poly <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\NormalTok{  i <-}\StringTok{ }\KeywordTok{as.double}\NormalTok{(}\KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, n))}
\NormalTok{  xs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{expr}\NormalTok{(x), }\KeywordTok{map}\NormalTok{(i, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{expr}\NormalTok{(}\KeywordTok{I}\NormalTok{(x}\OperatorTok{^!!}\NormalTok{i))))}
\NormalTok{  terms <-}\StringTok{ }\KeywordTok{reduce}\NormalTok{(xs, call2, }\DataTypeTok{.fn =} \StringTok{"+"}\NormalTok{)}
  \KeywordTok{expr}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\OperatorTok{!!}\NormalTok{terms)}
\NormalTok{\}}
\KeywordTok{poly}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{#> y ~ 1 + x + I(x^2) + I(x^3) + I(x^4) + I(x^5)}
\end{Highlighting}
\end{Shaded}

\hypertarget{evaluation-excutes-an-expression-in-an-environment}{%
\subsection{Evaluation excutes an expression in an
environment}\label{evaluation-excutes-an-expression-in-an-environment}}

Inspecting and modifying code gives you one set of powerful tools. You
get another set of powerful tools when you \textbf{evaluate},
i.e.~execute, an expression. Evaluating an expression requires an
environment. This tells R what the symbols (found in the leaves of tree)
mean. You'll learn the details of evaluation in Chapter
\ref{evaluation}.

The primary tool for evaluating expressions is \texttt{base::eval()},
which takes an expression and an environment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{10}\NormalTok{))}
\CommentTok{#> [1] 11}
\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{2}\NormalTok{, }\DataTypeTok{y =} \DecValTok{100}\NormalTok{))}
\CommentTok{#> [1] 102}
\end{Highlighting}
\end{Shaded}

If you omit the environment, it will use the current environment. Here
that's the global environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{y <-}\StringTok{ }\DecValTok{100}
\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y))}
\CommentTok{#> [1] 110}
\end{Highlighting}
\end{Shaded}

One of the big advantages of evaluating code manually is that you can
tweak the execution environment. There are two main reaons to do this:

\begin{itemize}
\tightlist
\item
  To temporarily override functions to implement a domain specific
  language.
\item
  To add a data mask so you can to refer to variables in a data frame as
  if they are variables in an environment.
\end{itemize}

\hypertarget{you-can-override-functions-to-make-a-dsl}{%
\subsection{You can override functions to make a
DSL}\label{you-can-override-functions-to-make-a-dsl}}

It's fairly straightforward to understand customising the environment
with different variable values. It's less obvious that you can also
rebind functions to do different things. This is a big idea that we'll
come back to in Chapter \ref{translating}, but I wanted to show a small
example here.

The example below evalutes code in a special environment where the basic
algebraic operators (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/})
have been overridden to work with string instead of numbers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{string_math <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  e <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}
    \KeywordTok{caller_env}\NormalTok{(),}
    \StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{ =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\KeywordTok{paste0}\NormalTok{(x, y),}
    \StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{ =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\KeywordTok{strrep}\NormalTok{(x, y),}
    \StringTok{`}\DataTypeTok{-}\StringTok{`}\NormalTok{ =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\KeywordTok{sub}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(y, }\StringTok{"$"}\NormalTok{), }\StringTok{""}\NormalTok{, x),}
    \StringTok{`}\DataTypeTok{/}\StringTok{`}\NormalTok{ =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\KeywordTok{substr}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\KeywordTok{nchar}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\NormalTok{y)}
\NormalTok{  )}

  \KeywordTok{eval}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(x), e)}
\NormalTok{\}}

\NormalTok{name <-}\StringTok{ "Hadley"}
\KeywordTok{string_math}\NormalTok{(}\StringTok{"Hi"} \OperatorTok{-}\StringTok{ "i"} \OperatorTok{+}\StringTok{ "ello "} \OperatorTok{+}\StringTok{ }\NormalTok{name)}
\CommentTok{#> [1] "Hello Hadley"}
\KeywordTok{string_math}\NormalTok{(}\StringTok{"x-"} \OperatorTok{*}\StringTok{ }\DecValTok{3} \OperatorTok{+}\StringTok{ "y"}\NormalTok{)}
\CommentTok{#> [1] "x-x-x-y"}
\end{Highlighting}
\end{Shaded}

dplyr takes this idea to the extreme, running code in an environment
that generates SQL for execution in a remote database:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}

\NormalTok{con <-}\StringTok{ }\NormalTok{DBI}\OperatorTok{::}\KeywordTok{dbConnect}\NormalTok{(RSQLite}\OperatorTok{::}\KeywordTok{SQLite}\NormalTok{(), }\DataTypeTok{filename =} \StringTok{":memory:"}\NormalTok{)}
\NormalTok{mtcars_db <-}\StringTok{ }\KeywordTok{copy_to}\NormalTok{(con, mtcars)}

\NormalTok{mtcars_db }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(cyl }\OperatorTok{>}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(mpg}\OperatorTok{:}\NormalTok{hp) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{head}\NormalTok{(}\DecValTok{10}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{show_query}\NormalTok{()}
\CommentTok{#> <SQL>}
\CommentTok{#> SELECT `mpg`, `cyl`, `disp`, `hp`}
\CommentTok{#> FROM `mtcars`}
\CommentTok{#> WHERE (`cyl` > 2.0)}
\CommentTok{#> LIMIT 10}

\NormalTok{DBI}\OperatorTok{::}\KeywordTok{dbDisconnect}\NormalTok{(con)}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-masks-blur-the-line-between-data-frames-and-environments}{%
\subsection{Data masks blur the line between data frames and
environments}\label{data-masks-blur-the-line-between-data-frames-and-environments}}

Rebinding functions is an extremely powerful technique, but it tends to
require a lot of investment. A more immediately practical application is
modifying evaluation to look for variables in a data frame instead of an
environment. This idea powers the base \texttt{subset()} and
\texttt{transform()} functions, as well as many tidyverse functions like
\texttt{ggplot2::aes()} and \texttt{dplyr::mutate()}. It's possible to
use \texttt{eval()} for this, but there are a few potential pitfalls, so
we'll use \texttt{rlang::eval\_tidy()} instead.

As well as expression and environment, \texttt{eval\_tidy()} also takes
a \textbf{data mask}, which is typically a data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{sample}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), df)}
\CommentTok{#> [1] 2 6 5 9 8}
\end{Highlighting}
\end{Shaded}

Evaluating with a data mask is a useful technique for interactive
analysis because it allows you to write \texttt{x\ +\ y} rather than
\texttt{df\$x\ +\ df\$y}. However, that convenience comes at a cost:
ambiguity. In Section \ref{pronouns} you'll learn how to deal ambiugity
using special \texttt{.data} and \texttt{.env} pronouns.

We can wrap this pattern up into a function by using \texttt{enexpr()}.
This gives us a function very similar to \texttt{base::with()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, expr) \{}
  \KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(expr), df)}
\NormalTok{\}}

\KeywordTok{with2}\NormalTok{(df, x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> [1] 2 6 5 9 8}
\end{Highlighting}
\end{Shaded}

Unfortunately, however, this function has a subtle bug, and we need a
new data structure to deal with it.

\hypertarget{quosures-capture-an-expression-with-its-environment}{%
\subsection{Quosures capture an expression with its
environment}\label{quosures-capture-an-expression-with-its-environment}}

To make the problem more obvious, I'm going to modify \texttt{with2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, expr) \{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1000}
  \KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(expr), df)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(The problem occurs without this modification but it's a sublter and
creates error messages that are harder to understand.)

We can see the problem if we attempt to use \texttt{with2()} mingling a
variable from the data frame, and a variable called \texttt{a} in the
current environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\NormalTok{a <-}\StringTok{ }\DecValTok{10}
\KeywordTok{with2}\NormalTok{(df, x }\OperatorTok{+}\StringTok{ }\NormalTok{a)}
\CommentTok{#> [1] 1001 1002 1003}
\end{Highlighting}
\end{Shaded}

That's because we really want to evaluate the captured expression in the
environment where it was written (where \texttt{a} is 10), not the
environment inside of \texttt{with2()} (where \texttt{a} is 1000).

Fortunately we call solve this problem by using a new data structure:
the \textbf{quosure} which bundles an expression with an environment.
\texttt{eval\_tidy()} knows how to work with quosures so all we need to
do is switch out \texttt{enexpr()} for \texttt{enquo()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, expr) \{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1000}
  \KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{enquo}\NormalTok{(expr), df)}
\NormalTok{\}}

\KeywordTok{with2}\NormalTok{(df, x }\OperatorTok{+}\StringTok{ }\NormalTok{a)}
\CommentTok{#> [1] 11 12 13}
\end{Highlighting}
\end{Shaded}

Whenever you use a data mask, you must always use \texttt{enquo()}
instead of \texttt{enexpr()}. This is the topic of Chapter
\ref{evaluation}.

\hypertarget{overview-1}{%
\section*{Overview}\label{overview-1}}
\addcontentsline{toc}{section}{Overview}

In the following chapters, you'll learn about the three pieces that
underpin metaprogramming:

\begin{itemize}
\item
  In \textbf{Expressions}, Chapter \ref{expressions}, you'll learn that
  all R code forms a tree. You'll learn how to visualise that tree, how
  the rules of R's grammar convert linear sequences of characters into a
  tree, and how to use recursive functions to work with code trees.
\item
  In \textbf{Quasiquotation}, Chapter \ref{quasiquotation}, you'll learn
  to use tools from rlang to capture (``quote'') unevaluated function
  arguments. You'll also learn about quasiquotation, which provides a
  set of techniques for ``unquoting'' input that makes it possible to
  easily generate new trees from code fragments.
\item
  In \textbf{Evaluation}, Chapter \ref{evaluation}, you'll learn about
  the inverse of quotation: evaluation. Here you'll learn about an
  important data structure, the \textbf{quosure}, which ensures correct
  evaluation by capturing both the code to evaluate, and the environment
  in which to evaluate it. This chapter will show you how to put all the
  pieces together to understand how NSE in base R works, and how to
  write your own functions that work like \texttt{subset()}.
\item
  Finally, in \textbf{Translating R code}, Chapter \ref{translation},
  you'll see how to combine first-class environments, lexical scoping,
  and metaprogramming to translate R code into other languages, namely
  HTML and LaTeX.
\end{itemize}

Each chapter follows the same basic structure. You'll get the lay of the
land in introduction, then see a motivating example. Next you'll learn
the big ideas using functions from the rlang package (Henry and Wickham
\protect\hyperlink{ref-rlang}{2018}), and then we'll circle back to talk
about how those ideas are expressed in base R.

\hypertarget{expressions}{%
\chapter{Expressions}\label{expressions}}

\hypertarget{introduction-15}{%
\section{Introduction}\label{introduction-15}}

To compute on the language, we first need to understand its structure.
That requires some new vocabulary, some new tools, and some new ways of
thinking about R code. The first thing you'll need to understand is the
distinction between an operation and its result. Take the following
code, which takes a variable \texttt{x}, multiplies it by 10, and saves
the result to a new variable called \texttt{y}. It doesn't work because
we haven't defined a variable called \texttt{x}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{10}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'x' not found}
\end{Highlighting}
\end{Shaded}

It would be nice if we could capture the intent of the code, without
executing it. In other words, how can we separate our description of the
action from the action itself? One way is to use \texttt{rlang::expr()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{expr}\NormalTok{(y <-}\StringTok{ }\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{10}\NormalTok{)}
\NormalTok{z}
\CommentTok{#> y <- x * 10}
\end{Highlighting}
\end{Shaded}

\texttt{expr()} returns an expression, an object that captures the
structure of the code without evaluating it (i.e.~running it). If you
have an expression, you can evaluate it with \texttt{base::eval()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{4}
\KeywordTok{eval}\NormalTok{(z)}
\NormalTok{y}
\CommentTok{#> [1] 40}
\end{Highlighting}
\end{Shaded}

The focus of this chapter is the data structures that underlie
expresssions. Mastering this knowledge will allow you to inspect and
modify captured code. We'll come back to \texttt{expr()} in Section
\ref{quotation}, and to \texttt{eval()} in Section \ref{eval}.

\hypertarget{outline-13}{%
\subsection*{Outline}\label{outline-13}}
\addcontentsline{toc}{subsection}{Outline}

\hypertarget{prerequisites-9}{%
\subsection*{Prerequisites}\label{prerequisites-9}}
\addcontentsline{toc}{subsection}{Prerequisites}

Make sure you've read the metaprogramming overview in Chapter \ref{meta}
to get a broad overview of the motivation and the basic vocabulary.
You'll also need the rlang package to capture and compute on
expressions, and the lobstr package to visualise them.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}

\CommentTok{# devtools::install_github("r-lib/lobstr")}
\KeywordTok{library}\NormalTok{(lobstr)}
\end{Highlighting}
\end{Shaded}

\hypertarget{abstract-syntax-trees}{%
\section{Abstract syntax trees}\label{abstract-syntax-trees}}

\index{abstract syntax tree}

Expressions are also called \textbf{abstract syntax trees} (ASTs)
because the structure of code is hierarchical and can be naturally
represented as a tree. Understanding this tree structure is crucial for
inspecting and modifying expressions (i.e.~metaprogramming).

\hypertarget{drawing}{%
\subsection{Drawing}\label{drawing}}

So we'll start by introducing some conventions for drawing ASTs,
starting with a simple call that shows the main components:
\texttt{f(x,\ "y",\ 1)}. I'll draw trees in two ways:

\begin{itemize}
\item
  By ``hand'' (with omnigraffle):

  \begin{center}\includegraphics[width=1.97in]{diagrams/expressions/simple} \end{center}
\item
  With \texttt{lobstr::ast()}\footnote{For more complex code, you can
    also use RStudio's tree viewer which doesn't obey quite the same
    graphical conventions, but allows you to interactively explore the
    AST. Try it out with \texttt{View(expr(f(x,\ "y",\ 1)))}.}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(x, }\StringTok{"y"}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\CommentTok{#> █─f }
\CommentTok{#> ├─x }
\CommentTok{#> ├─"y" }
\CommentTok{#> └─1}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Both approaches share conventions as much as possible:

\begin{itemize}
\item
  The leaves of the tree are either symbols, like \texttt{f} and
  \texttt{x}, or constants, like \texttt{1} or \texttt{"y"}. Symbols are
  drawn in purple and have rounded corners. Constants have black borders
  and square corners. Strings and symbols are easily confused, so
  strings are always surrounded in quotes.
\item
  The branches of the tree are function calls, represended by call
  objects and drawn as orange squares. The first child (\texttt{f}) is
  the function that gets called; the second and subsequent children
  (\texttt{x}, \texttt{"y"}, and \texttt{1}) are the arguments to that
  function.
\end{itemize}

The above example only contained one function call, making for a very
shallow tree. Most expressions will contain considerably more calls,
creating trees with multiple levels of hierarchy. For example, consider
\texttt{f(g(1,\ 2),\ h(3,\ 4,\ i()))}:

\begin{center}\includegraphics[width=3.15in]{diagrams/expressions/complicated} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\KeywordTok{i}\NormalTok{())))}
\CommentTok{#> █─f }
\CommentTok{#> ├─█─g }
\CommentTok{#> │ ├─1 }
\CommentTok{#> │ └─2 }
\CommentTok{#> └─█─h }
\CommentTok{#>   ├─3 }
\CommentTok{#>   ├─4 }
\CommentTok{#>   └─█─i}
\end{Highlighting}
\end{Shaded}

You can read the hand-drawn diagrams from left-to-right (ignoring
vertical position), and the lobstr-drawn diagrams from top-to-bottom
(ignoring horizontal position). The depth within the tree is determined
by the nesting of function calls. This also determines evaluation order,
as evaluation generally proceeds from deepest-to-shallowest (but this is
not guaranteed because of lazy evaluation, Section
\ref{lazy-evaluation}). Also note the appearance of \texttt{i()}, a
function call with no arguments; it's a branch with a single (symbol)
leaf.

\hypertarget{non-code-components}{%
\subsection{Non-code components}\label{non-code-components}}

You might have wondered why these are \emph{abstract} syntax trees. They
are abstract because they only capture important structural details of
the code, not whitespace or comments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}
  \KeywordTok{f}\NormalTok{(x,  y)  }\CommentTok{# important!}
\NormalTok{)}
\CommentTok{#> █─f }
\CommentTok{#> ├─x }
\CommentTok{#> └─y}
\end{Highlighting}
\end{Shaded}

There's one important situtation where whitespace does affect the AST:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(y <-}\StringTok{ }\NormalTok{x)}
\CommentTok{#> █─`<-` }
\CommentTok{#> ├─y }
\CommentTok{#> └─x}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(y }\OperatorTok{<}\StringTok{ }\OperatorTok{-}\NormalTok{x)}
\CommentTok{#> █─`<` }
\CommentTok{#> ├─y }
\CommentTok{#> └─█─`-` }
\CommentTok{#>   └─x}
\end{Highlighting}
\end{Shaded}

\hypertarget{infix-calls}{%
\subsection{Infix calls}\label{infix-calls}}

Every call in R can be written in tree form, even if it doesn't look
like it at first glance. Take \texttt{y\ \textless{}-\ x\ *\ 10} again:
what are the functions that are being called? It is not as easy to spot
as \texttt{f(x,\ 1)} because this expression contains two infix calls:
\texttt{\textless{}-} and \texttt{*}.

However, as discussed in Section \ref{prefix-transform}, any call can be
rewritten in prefix form. That means that these two lines of code are
equivalent:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{10}
\StringTok{`}\DataTypeTok{<-}\StringTok{`}\NormalTok{(y, }\StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{(x, }\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

And they both have this AST\footnote{The names of non-prefix functions
  are non-syntactic so I show them with \texttt{\textasciigrave{}}, as
  in Section \ref{non-syntactic}.}:

\begin{center}\includegraphics[width=2.26in]{diagrams/expressions/prefix} \end{center}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(y <-}\StringTok{ }\NormalTok{x }\OperatorTok{*}\StringTok{ }\DecValTok{10}\NormalTok{)}
\CommentTok{#> █─`<-` }
\CommentTok{#> ├─y }
\CommentTok{#> └─█─`*` }
\CommentTok{#>   ├─x }
\CommentTok{#>   └─10}
\end{Highlighting}
\end{Shaded}

There really is no difference between the ASTs, and if you generate an
expression with prefix calls, R will still print them in infix form:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(}\StringTok{`}\DataTypeTok{<-}\StringTok{`}\NormalTok{(y, }\StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{(x, }\DecValTok{10}\NormalTok{)))}
\CommentTok{#> y <- x * 10}
\end{Highlighting}
\end{Shaded}

The order in which infix operators are applied is governed by a set of
rules called operator precedence. In Section \ref{operator-precedence}
we'll use \texttt{lobstr::ast()} to explore R's rules.

\hypertarget{exercises-50}{%
\subsection{Exercises}\label{exercises-50}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Reconstruct the code represented by the trees below:

\begin{verbatim}
#> █─f 
#> └─█─g 
#>   └─█─h
#> █─`+` 
#> ├─█─`+` 
#> │ ├─1 
#> │ └─2 
#> └─3
#> █─`*` 
#> ├─█─`(` 
#> │ └─█─`+` 
#> │   ├─x 
#> │   └─y 
#> └─z
\end{verbatim}
\item
  Draw the following trees by hand then check your answers with
  \texttt{lobstr::ast()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\KeywordTok{h}\NormalTok{(}\KeywordTok{i}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))))}
\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\KeywordTok{i}\NormalTok{())))}
\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\KeywordTok{i}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}
\item
  How are function factories (Chapter \ref{function-factories}) show in
  the AST? What makes the ASTs of the expressions below special?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(x)(y))}
\CommentTok{#> █─█─f }
\CommentTok{#> │ └─x }
\CommentTok{#> └─y}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{)(}\DecValTok{2}\NormalTok{)(}\DecValTok{3}\NormalTok{)(}\DecValTok{4}\NormalTok{))}
\CommentTok{#> █─█─█─█─f }
\CommentTok{#> │ │ │ └─1 }
\CommentTok{#> │ │ └─2 }
\CommentTok{#> │ └─3 }
\CommentTok{#> └─4}
\end{Highlighting}
\end{Shaded}
\item
  What's happening with the ASTs below? (Hint: carefully read
  \texttt{?"\^{}"})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\StringTok{`}\DataTypeTok{x}\StringTok{`} \OperatorTok{+}\StringTok{ `}\DataTypeTok{y}\StringTok{`}\NormalTok{)}
\CommentTok{#> █─`+` }
\CommentTok{#> ├─x }
\CommentTok{#> └─y}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(x }\OperatorTok{**}\StringTok{ }\NormalTok{y)}
\CommentTok{#> █─`^` }
\CommentTok{#> ├─x }
\CommentTok{#> └─y}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\DecValTok{1}\NormalTok{ ->}\StringTok{ }\NormalTok{x)}
\CommentTok{#> █─`<-` }
\CommentTok{#> ├─x }
\CommentTok{#> └─1}
\end{Highlighting}
\end{Shaded}
\item
  What is special about the AST below? (Hint: re-read Section
  \ref{function-components})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x, y) x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> █─`function` }
\CommentTok{#> ├─█─x = `` }
\CommentTok{#> │ └─y = `` }
\CommentTok{#> ├─█─`+` }
\CommentTok{#> │ ├─x }
\CommentTok{#> │ └─y }
\CommentTok{#> └─<inline srcref>}
\end{Highlighting}
\end{Shaded}
\item
  What does the call tree of an \texttt{if} statement with multiple
  \texttt{else\ if} conditions look like? Why?
\end{enumerate}

\hypertarget{expressions-1}{%
\section{Expressions}\label{expressions-1}}

Collectively, the data structures present in the AST are called
expressions. More precisely, an \textbf{expression} is any member of the
set of base types created by parsing code: constant scalars, symbols,
call objects. These are the data structures used to represented captured
code form \texttt{expr()}, and so \texttt{is\_expression(expr(...))} is
always true\footnote{It is \emph{possible} to insert any other base type
  into an expression, but this is unusual and only needed in rare
  circumstances. We'll come back to the idea in Section
  \ref{non-standard-ast}.}. In the subsequent sections, we'll come back
to define each of these types precisely, and show you how to create,
inspect, and modify them.

There are couple of data structures that we'll come back to later.
Pairlists are used in one place, but behave identially to lists; we'll
discuss them in Section \ref{pairlists}. There also a special symbol
used to represent missing arguments, we'll come back to that in Section
\ref{empty-symbol}.

NB: In base R documentation ``expression'' is used to mean two things.
As well as the definition above, expression is also used to refer to the
type of object returned by \texttt{expression()} and \texttt{parse()},
which are basically lists of expressions as defined above. In this book
I'll call these \textbf{expression vectors}, and I'll come back to them
in Section \ref{expression-vectors}.

\hypertarget{constants}{%
\subsection{Constants}\label{constants}}

\index{constants}

Constants are the simplest component of the AST, and use data structures
that you learned about in Chapter \ref{vector}. More precisely, a
\textbf{constant} is either \texttt{NULL} or a length-1 atomic
vector\footnote{Technically, the R language does not possess scalars,
  and everything that looks like a scalar is actually a vector of length
  one. This however, is mainly a theoretical distinction, and blurring
  the distinction between scalar and length-1 vector is unlikely to harm
  your code.} like \texttt{TRUE}, \texttt{1L}, \texttt{2.5} or
\texttt{"x"}. You can test for a constant with
\texttt{rlang::is\_syntactic\_literal()}.

\footnote{Technically, the R language does not possess scalars, and
  everything that looks like a scalar is actually a vector of length
  one. This however, is mainly a theoretical distinction, and blurring
  the distinction between scalar and length-1 vector is unlikely to harm
  your code.} See Section \ref(scalars) for the conventions for creating
these scalars.

Constants are ``self-quoting'' in the sense that the expression used to
represent a constant is the constant itself:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\OtherTok{TRUE}\NormalTok{), }\OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{1}\NormalTok{), }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{expr}\NormalTok{(2L), 2L)}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\StringTok{"x"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{symbols}{%
\subsection{Symbols}\label{symbols}}

\index{symbols}

A \textbf{symbol} represents the name of an object like \texttt{x},
\texttt{mtcars}, or \texttt{mean}. In base R, symbol and name are used
interchangeably (i.e. \texttt{is.name()} is identical to
\texttt{is.symbol()}), but in this book I used symbol consistently
because ``name'' has many other non-technical meanings. You can test for
a symbol with \texttt{is.symbol()}.

You can create a symbol in two ways: by capturing code that references
an object with \texttt{expr()}, or turning a string into a symbol with
\texttt{sym()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(x)}
\CommentTok{#> x}
\KeywordTok{sym}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

You can turn a symbol back into a string with \texttt{as.character()} or
\texttt{as\_string()}. \texttt{as\_string()} has the advantage of
clearly signalling that you'll get a character vector of length 1.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_string}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x))}
\CommentTok{#> [1] "x"}
\end{Highlighting}
\end{Shaded}

You can recognise a symbol because it's printed without quotes, and
\texttt{str()} tells you that it's a symbol:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x))}
\CommentTok{#>  symbol x}
\end{Highlighting}
\end{Shaded}

The symbol type is not vectorised, i.e.~a symbol is always length 1. If
you want multiple symbols, you'll need to put them in a list, using
(e.g.) \texttt{rlang::syms()}.

\hypertarget{calls}{%
\subsection{Calls}\label{calls}}

\index{calls}

A \textbf{call object} represents a captured function call. Call objects
are vectors: the first component is name of the function to call
(usually repesented as a symbol), and the remaining elements are the
arguments for that call. Call objects create branches in the AST,
because calls can be nested inside other calls.

You can identify a call object when printed because it looks just like a
function call. Unfortunately \texttt{typeof()} and \texttt{str()} print
``language''\footnote{Avoid \texttt{is.language()} which returns
  \texttt{TRUE} for symbols, calls, and expression vectors.} for call
objects, but \texttt{is\_call()} returns \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{read.table}\NormalTok{(}\StringTok{"important.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{))}
\CommentTok{#> █─read.table }
\CommentTok{#> ├─"important.csv" }
\CommentTok{#> └─row.names = FALSE}
\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{read.table}\NormalTok{(}\StringTok{"important.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{))}

\KeywordTok{typeof}\NormalTok{(x)}
\CommentTok{#> [1] "language"}
\KeywordTok{is.call}\NormalTok{(x)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{subsetting-1}{%
\subsubsection{Subsetting}\label{subsetting-1}}

Calls generally behave like lists, i.e.~you can use standard subsetting
tools. The first element of the call object the function to call, which
is a usually a symbol{[}\^{}symbol-exception{]}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> read.table}
\KeywordTok{is_symbol}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

The primary exception{[}\^{}function-factories{]} to this rule occurs
when you use \texttt{::} to call a function in a specific package. In
that case the first element will be another call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(base}\OperatorTok{::}\KeywordTok{read.csv}\NormalTok{(}\StringTok{"important.csv"}\NormalTok{))}
\CommentTok{#> █─█─`::` }
\CommentTok{#> │ ├─base }
\CommentTok{#> │ └─read.csv }
\CommentTok{#> └─"important.csv"}
\end{Highlighting}
\end{Shaded}

{[}\^{}function-factories{]} This is a general example of calls to a
function factory, a function that returns a function, the topic of
Chapter \ref{function-factories}.

The remainder of the elements are the arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.list}\NormalTok{(x[}\OperatorTok{-}\DecValTok{1}\NormalTok{])}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] "important.csv"}
\CommentTok{#> }
\CommentTok{#> $row.names}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

You can extract individual arguments with \texttt{{[}{[}} or \texttt{\$}
(if named):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[[}\DecValTok{2}\NormalTok{]]}
\CommentTok{#> [1] "important.csv"}
\NormalTok{x}\OperatorTok{$}\NormalTok{row}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

You can determine the number of arguments in call object by subtracting
1 from the length:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

Extracting specific arguments from calls is challenging because of R's
flexible rules for argument matching: it could potentially be in any
location, with the full name, with an abbreviated name, or with no name.
To work around this problem, you can use
\texttt{rlang::call\_standardise()} which standardises all arguments to
use the full name: \indexc{standardise\_call()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rlang}\OperatorTok{::}\KeywordTok{call_standardise}\NormalTok{(x)}
\CommentTok{#> read.table(file = "important.csv", row.names = FALSE)}
\end{Highlighting}
\end{Shaded}

(Note that if the function uses \texttt{...} it's not possible to
standardise all arguments.)

Calls can be modified in the same way as lists:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{$}\NormalTok{header <-}\StringTok{ }\OtherTok{TRUE}
\NormalTok{x}
\CommentTok{#> read.table("important.csv", row.names = FALSE, header = TRUE)}
\end{Highlighting}
\end{Shaded}

\hypertarget{function-position}{%
\subsubsection{Function position}\label{function-position}}

The first element of the call object is the \textbf{function position}.
This contains the function that will be called when the object is
evaluated, and is usually a symbol\footnote{Peculiarly, it can also be a
  number, as in the expression \texttt{3()}. But this call will always
  fail to evaluate because a number is not a function.}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{foo}\NormalTok{())}
\CommentTok{#> █─foo}
\end{Highlighting}
\end{Shaded}

Note that while R allows you to surround the name of the function with
quotes, the parser still converts this to a symbol:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\StringTok{"foo"}\NormalTok{())}
\CommentTok{#> █─foo}
\end{Highlighting}
\end{Shaded}

However, sometimes the function doesn't exist in the current environment
and you need to do some computation to retrieve it. For example, the
function is in another package, is a method of an R6 object, or it's
created by a function factory. In this case, the function position will
be occupied by another call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(pkg}\OperatorTok{::}\KeywordTok{foo}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> █─█─`::` }
\CommentTok{#> │ ├─pkg }
\CommentTok{#> │ └─foo }
\CommentTok{#> └─1}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(obj}\OperatorTok{$}\KeywordTok{foo}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> █─█─`$` }
\CommentTok{#> │ ├─obj }
\CommentTok{#> │ └─foo }
\CommentTok{#> └─1}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\DecValTok{1}\NormalTok{)(}\DecValTok{2}\NormalTok{))}
\CommentTok{#> █─█─foo }
\CommentTok{#> │ └─1 }
\CommentTok{#> └─2}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.03in]{diagrams/expressions/call-call} \end{center}

\hypertarget{call2}{%
\subsubsection{Constructing}\label{call2}}

You can construct a call object from its components by using
\texttt{rlang::call2()}. The first argument is the name of function to
call (either as a string, a symbol, or another call). The remaining
arguments will be passed along to the call:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> mean(x = x, na.rm = TRUE)}
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(base}\OperatorTok{::}\NormalTok{mean), }\DataTypeTok{x =} \KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> base::mean(x = x, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

Note that infix calls created in this way still print as usual.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\StringTok{"<-"}\NormalTok{, }\KeywordTok{expr}\NormalTok{(x), }\DecValTok{10}\NormalTok{)}
\CommentTok{#> x <- 10}
\end{Highlighting}
\end{Shaded}

Using \texttt{call2()} to create complex expressions is a bit clunky.
You'll learn another technique in Chapter \ref{quasiquotation}.

\hypertarget{vocabulary}{%
\subsection{Vocabulary}\label{vocabulary}}

\begin{longtable}[]{@{}lll@{}}
\toprule
& str & typeof\tabularnewline
\midrule
\endhead
Scalar constant & \texttt{logi}/\texttt{int}/\texttt{num}/\texttt{chr} &
\texttt{logical}/\texttt{integer}/\texttt{double}/\texttt{character}\tabularnewline
Symbol & \texttt{symbol} & \texttt{symbol}\tabularnewline
Call object & \texttt{language} & \texttt{language}\tabularnewline
Pairlist & Dotted pair list & \texttt{pairlist}\tabularnewline
Expression vector & \texttt{expression()} &
\texttt{expression}\tabularnewline
\bottomrule
\end{longtable}

\begin{longtable}[]{@{}lll@{}}
\toprule
& base & rlang\tabularnewline
\midrule
\endhead
Scalar constant & --- & \texttt{is\_syntactic\_literal()}\tabularnewline
Symbol & \texttt{is.symbol()} & \texttt{is\_symbol()}\tabularnewline
Call object & \texttt{is.call()} & \texttt{is\_call()}\tabularnewline
Pairlist & \texttt{is.pairlist()} &
\texttt{is\_pairlist()}\tabularnewline
Expression vector & \texttt{is.expression()} & ---\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{exercises-51}{%
\subsection{Exercises}\label{exercises-51}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Which two of the six types of atomic vector can't appear in an
  expression? Why? Why can't you create an expression that contains an
  atomic vector of length greater than one?
\item
  What happens when you subset a call object to remove the first
  element? e.g.
  \texttt{expr(read.csv("foo.csv",\ header\ =\ TRUE)){[}-1{]}}. Why?
\item
  Describe the differences between the following call objects.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}

\KeywordTok{call2}\NormalTok{(median, x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(median), x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{call2}\NormalTok{(median, }\KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(median), }\KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{rlang::call\_standardise()} doesn't work so well for the
  following calls. Why? What makes \texttt{mean()} special?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, na.rm = TRUE)}
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DataTypeTok{n =}\NormalTok{ T, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, n = T)}
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, , }\OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, , TRUE)}
\end{Highlighting}
\end{Shaded}
\item
  Why does this code not make sense?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{))}
\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Construct the expression
  \texttt{if(x\ \textgreater{}\ 1)\ "a"\ else\ "b"} using multiple calls
  to \texttt{call2()}. How does the code structure reflect the structure
  of the AST?
\end{enumerate}

\hypertarget{grammar}{%
\section{Parsing and grammar}\label{grammar}}

We've talked a lot about expressions and the AST, but not how
expressions are created from code that you type. The process by which a
computer language takes a string like (like \texttt{"x\ +\ y"}) and
constructs an expression is called \textbf{parsing}, and it is governed
by a set of rules known as a \textbf{grammar}. In this section, we'll
use \texttt{lobstr::ast()} to explore some of the details of R's
grammar, and then see how you can transform back and forth between
expressions and strings.

\hypertarget{operator-precedence}{%
\subsection{Operator precedence}\label{operator-precedence}}

Infix functions introduce ambiguity in a way that prefix functions do
not\footnote{This ambiguity dooes not arise without infix operators,
  which can be considered an advantage of purely prefix and postfix
  languages. It's interesting to compare a simple arithmetic operation
  in Lisp (prefix) and Forth (postfix). In Lisp you'd write
  \texttt{(*\ (+\ 1\ 2)\ 3))}; this avoids ambiguity by requiring
  parentheses everywhere. In Forth, you'd write \texttt{1\ 2\ +\ 3\ *};
  this doesn't require any parentheses, but does require more thought
  when reading.}. The parser has to resolve two sources of ambiguity
when parsing infix operators. First, what does \texttt{1\ +\ 2\ *\ 3}
yield? Do you get 9 (i.e. \texttt{(1\ +\ 2)\ *\ 3}), or 7 (i.e.
\texttt{1\ +\ (2\ *\ 3)})? In other words, which of the two possible
parse trees below does R use?

\begin{center}\includegraphics[width=3.89in]{diagrams/expressions/ambig-order} \end{center}

Programming languages use conventions called \textbf{operator
precedence} to resolve this ambiguity. We can use \texttt{ast()} to see
what R does:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> █─`+` }
\CommentTok{#> ├─1 }
\CommentTok{#> └─█─`*` }
\CommentTok{#>   ├─2 }
\CommentTok{#>   └─3}
\end{Highlighting}
\end{Shaded}

Predicting the precedence of arithmetic operations is usually easy
because it's drilled into you in school and is consistent across the
vast majority of programming languages. Predicting the precedence of
other operators is harder. There's one particularly surprising case in
R: \texttt{!} has a much lower precedence (i.e.~it binds less tightly)
than you might expect. This allows you to write useful operations like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!}\NormalTok{x }\OperatorTok{%in%}\StringTok{ }\NormalTok{y)}
\CommentTok{#> █─`!` }
\CommentTok{#> └─█─`%in%` }
\CommentTok{#>   ├─x }
\CommentTok{#>   └─y}
\end{Highlighting}
\end{Shaded}

R has over 30 infix operators divided into 18 precedence groups. While
the details are described in \texttt{?Syntax}, very few people have
memorised the complete ordering. Indeed, if there's any confusion, use
parentheses!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{((}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> █─`*` }
\CommentTok{#> ├─█─`(` }
\CommentTok{#> │ └─█─`+` }
\CommentTok{#> │   ├─1 }
\CommentTok{#> │   └─2 }
\CommentTok{#> └─3}
\end{Highlighting}
\end{Shaded}

Note the appearance of the parentheses in the AST as a call to the
\texttt{(} function.

\hypertarget{associativity}{%
\subsection{Associativity}\label{associativity}}

Another source of ambiguity is introduced by repeated usage of the same
infix function. For example, is \texttt{1\ +\ 2\ +\ 3} equivalent to
\texttt{(1\ +\ 2)\ +\ 3} or to \texttt{1\ +\ (2\ +\ 3)}? This normally
doesn't matter because \texttt{x\ +\ (y\ +\ z)\ ==\ (x\ +\ y)\ +\ z},
i.e.~addition is associative, but is needed because some S3 classes
define \texttt{+} in a non-associative way. For example, ggplot2
overloads \texttt{+} to build up a complex plot from simple pieces; this
is non-associative because earlier layers are drawn underneath later
layers (i.e. \texttt{geom\_point()} + \texttt{geom\_smooth()} does not
yield the same plot as \texttt{geom\_smooth()} +
\texttt{geom\_point()}).

In R, most operators are \textbf{left-associative}, i.e.~the operations
on the left are evaluated first:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> █─`+` }
\CommentTok{#> ├─█─`+` }
\CommentTok{#> │ ├─1 }
\CommentTok{#> │ └─2 }
\CommentTok{#> └─3}
\end{Highlighting}
\end{Shaded}

There are two exceptions: exponentiation and assignment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\DecValTok{2}\OperatorTok{^}\DecValTok{2}\OperatorTok{^}\DecValTok{3}\NormalTok{)}
\CommentTok{#> █─`^` }
\CommentTok{#> ├─2 }
\CommentTok{#> └─█─`^` }
\CommentTok{#>   ├─2 }
\CommentTok{#>   └─3}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(x <-}\StringTok{ }\NormalTok{y <-}\StringTok{ }\NormalTok{z)}
\CommentTok{#> █─`<-` }
\CommentTok{#> ├─x }
\CommentTok{#> └─█─`<-` }
\CommentTok{#>   ├─y }
\CommentTok{#>   └─z}
\end{Highlighting}
\end{Shaded}

\hypertarget{parsing-and-deparsing}{%
\subsection{Parsing and deparsing}\label{parsing-and-deparsing}}

Most of the time you type code into the console, and R takes care of
turning the characters you've typed into an AST. But occasionally you
have code stored in a string, and you want to parse it yourself. You can
do so using \texttt{rlang::parse\_expr()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ "y <- x + 10"}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!!}\NormalTok{x1)}
\CommentTok{#> "y <- x + 10"}

\NormalTok{x2 <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{parse_expr}\NormalTok{(x1)}
\NormalTok{x2}
\CommentTok{#> y <- x + 10}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!!}\NormalTok{x2)}
\CommentTok{#> █─`<-` }
\CommentTok{#> ├─y }
\CommentTok{#> └─█─`+` }
\CommentTok{#>   ├─x }
\CommentTok{#>   └─10}
\end{Highlighting}
\end{Shaded}

\texttt{parse\_expr()} always returns a single expression. If you have
multiple expression separated by \texttt{;} or
\texttt{\textbackslash{}n}, you'll need to use
\texttt{rlang::parse\_exprs()}. It returns a list of expressions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x3 <-}\StringTok{ "a <- 1; a + 1"}
\NormalTok{rlang}\OperatorTok{::}\KeywordTok{parse_exprs}\NormalTok{(x3)}
\CommentTok{#> [[1]]}
\CommentTok{#> a <- 1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> a + 1}
\end{Highlighting}
\end{Shaded}

If you find yourself working with strings containing code very
frequently, you should reconsider your process. Read the Chapter
\ref{quasiquotation} and consider if you can instead more safely
generate expressions using quasiquotation.

The base equivalent to \texttt{parse\_exprs()} is \texttt{parse()}. It
is a little harder to use because it's specialised for parsing R code
stored in files. You need supply your string to the \texttt{text}
argument. It returns an expression vector, discussed in Section
\ref{expression-vector}, which I recommend turning into a list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.list}\NormalTok{(}\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =}\NormalTok{ x1))}
\CommentTok{#> [[1]]}
\CommentTok{#> y <- x + 10}
\end{Highlighting}
\end{Shaded}

The inverse of parsing is \textbf{deparsing}: given an expression, you
want the string that would generate it. This happens automatically when
you print an expression, and you can get the string yourself with
\texttt{rlang::expr\_text()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(y <-}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{10}\NormalTok{)}
\KeywordTok{expr_text}\NormalTok{(z)}
\CommentTok{#> [1] "y <- x + 10"}
\end{Highlighting}
\end{Shaded}

Parsing and deparsing are not perfectly symmetric because parsing
generates an \emph{abstract} syntax tree. This means we lose backticks
around ordinary names, comments, and whitespace:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cat}\NormalTok{(}\KeywordTok{expr_text}\NormalTok{(}\KeywordTok{expr}\NormalTok{(\{}
  \CommentTok{# This is a comment}
\NormalTok{  x <-}\StringTok{             `}\DataTypeTok{x}\StringTok{`} \OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{\})))}
\CommentTok{#> \{}
\CommentTok{#>     x <- x + 1}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

Be careful when using the base R equivalent, \texttt{deparse()}: it
returns a character vector with one element for each line. Whenever you
use it, remember that the length of the output might be greater than
one, and plan accordingly.

\hypertarget{exercises-52}{%
\subsection{Exercises}\label{exercises-52}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  R uses parentheses in two slightly different ways as illustrated by
  these two calls:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{((}\DecValTok{1}\NormalTok{))}
\StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  Compare and contrast the two uses by referencing the AST.
\item
  \texttt{=} can also be used in two ways. Construct a simple example
  that shows both uses.
\item
  Does \texttt{-2\^{}2} yield 4 or -4? Why?
\item
  What does \texttt{!1\ +\ !1} return? Why?
\item
  Why does
  \texttt{x1\ \textless{}-\ x2\ \textless{}-\ x3\ \textless{}-\ 0} work?
  Describe the two reasons.
\item
  Compare the ASTs of \texttt{x\ +\ y\ \%+\%\ z} and
  \texttt{x\ \^{}\ y\ \%+\%\ z}. What have you learned about the
  precedence of custom infix functions?
\item
  What happens if you call \texttt{parse\_expr()} with a string that
  generates multiple expressions? e.g.
  \texttt{parse\_expr("x\ +\ 1;\ y\ +\ 1")}
\item
  What happens if you attempt to parse an invalid expression? e.g.
  \texttt{"a\ +"} or \texttt{"f())"}.
\item
  \texttt{deparse()} produces vectors when the input is long. For
  example, the following call produces a vector of length two:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{g}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{e }\OperatorTok{+}\StringTok{ }\NormalTok{f }\OperatorTok{+}\StringTok{ }\NormalTok{g }\OperatorTok{+}\StringTok{ }\NormalTok{h }\OperatorTok{+}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\NormalTok{k }\OperatorTok{+}\StringTok{ }\NormalTok{l }\OperatorTok{+}\StringTok{ }\NormalTok{m }\OperatorTok{+}
\StringTok{  }\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{o }\OperatorTok{+}\StringTok{ }\NormalTok{p }\OperatorTok{+}\StringTok{ }\NormalTok{q }\OperatorTok{+}\StringTok{ }\NormalTok{r }\OperatorTok{+}\StringTok{ }\NormalTok{s }\OperatorTok{+}\StringTok{ }\NormalTok{t }\OperatorTok{+}\StringTok{ }\NormalTok{u }\OperatorTok{+}\StringTok{ }\NormalTok{v }\OperatorTok{+}\StringTok{ }\NormalTok{w }\OperatorTok{+}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z))}

\KeywordTok{deparse}\NormalTok{(expr)}
\end{Highlighting}
\end{Shaded}

  What does \texttt{expr\_text()} do instead?
\item
  \texttt{pairwise.t.test()} assumes that \texttt{deparse()} always
  returns a length one character vector. Can you construct an input that
  violates this expectation? What happens?
\end{enumerate}

\hypertarget{ast-funs}{%
\section{Walking the AST with recursive functions}\label{ast-funs}}

\index{recursion!over ASTs}

To conclude the chapter I'm going to pull together everything that
you've learned about ASTs and use that knowledge to solve more
complicated problems. The inspiration comes from the base codetools
package, which provides two interesting functions:

\begin{itemize}
\item
  \texttt{findGlobals()} locates all global variables used by a
  function. This can be useful if you want to check that your function
  doesn't inadvertently rely on variables defined in their parent
  environment.
\item
  \texttt{checkUsage()} checks for a range of common problems including
  unused local variables, unused parameters, and the use of partial
  argument matching.
\end{itemize}

Getting all of the details of these functions correct is fiddly, so we
won't fully develop the ideas. Instead we'll focus on the big underlying
idea: recursion on the AST. Recursive functions are a natural fit to
tree-like data structures because a recursive function is made up of two
parts that correspond to the two parts of the tree:

\begin{itemize}
\item
  The \textbf{recursive case} handles the nodes in the tree. Typically,
  you'll do something to each child of node, usually calling the
  recursive function again, and then combine the results back together
  again. For expressions, you'll need to handle calls and pairlists
  (function arguments).
\item
  The \textbf{base case} handles the leaves of the tree. The base cases
  ensure that the function eventually terminates, by solving the
  simplest cases directly. For expressions, you need to handle symbols
  and constants in the base case.
\end{itemize}

To make this pattern easier to see, we'll need two helper functions.
First we define \texttt{expr\_type()} which will return ``constant'' for
constant, ``symbol'' for symbols, ``call'', for calls, ``pairlist'' for
pairlists, and the ``type'' of anything else:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr_type <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (rlang}\OperatorTok{::}\KeywordTok{is_syntactic_literal}\NormalTok{(x)) \{}
    \StringTok{"constant"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.symbol}\NormalTok{(x)) \{}
    \StringTok{"symbol"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \StringTok{"call"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \StringTok{"pairlist"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{typeof}\NormalTok{(x)}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{expr_type}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\StringTok{"a"}\NormalTok{))}
\CommentTok{#> [1] "constant"}
\KeywordTok{expr_type}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)))}
\CommentTok{#> [1] "call"}
\end{Highlighting}
\end{Shaded}

We'll couple this with a wrapper around the switch function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{switch_expr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \ControlFlowTok{switch}\NormalTok{(}\KeywordTok{expr_type}\NormalTok{(x), }
\NormalTok{    ..., }
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)  }
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

With these two functions in hand, the basic template for any function
that walks the AST is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{recurse_call <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x, }
    \CommentTok{# Base cases}
    \DataTypeTok{symbol =}\NormalTok{ ,}
    \DataTypeTok{constant =}\NormalTok{ ,}
    
    \CommentTok{# Recursive cases}
    \DataTypeTok{call =}\NormalTok{ ,}
    \DataTypeTok{pairlist =} 
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Typically, solving the base case is easy, so we'll do that first, then
check the results. The recursive cases are a little more tricky.
Typically you'll think about the structure of final output and then find
the correct purrr function to produce it. To that end, make sure you're
familiar with \protect\hyperlink{functionals}{Functionals} before
continuing.

\hypertarget{finding-f-and-t}{%
\subsection{Finding F and T}\label{finding-f-and-t}}

We'll start simple with a function that determines whether a function
uses the logical abbreviations \texttt{T} and \texttt{F}: it will return
\texttt{TRUE} if it finds a logical abbreviation, and \texttt{FALSE}
otherwise. Using \texttt{T} and \texttt{F} is generally considered to be
poor coding practice, and is something that \texttt{R\ CMD\ check} will
warn about.

Let's first compare the AST for \texttt{T} vs. \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> TRUE}
\KeywordTok{ast}\NormalTok{(T)}
\CommentTok{#> T}
\end{Highlighting}
\end{Shaded}

\texttt{TRUE} is parsed as a logical vector of length one, while
\texttt{T} is parsed as a name. This tells us how to write our base
cases for the recursive function: a constant is never a logical
abbreviation, and a symbol is an abbreviation if it's ``F'' or ``T'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{logical_abbr_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x, }
    \DataTypeTok{constant =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{symbol =} \KeywordTok{as_string}\NormalTok{(x) }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{, }\StringTok{"T"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{logical_abbr_rec}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> [1] FALSE}
\KeywordTok{logical_abbr_rec}\NormalTok{(}\KeywordTok{expr}\NormalTok{(T))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

I've written \texttt{logical\_abbr\_rec()} function assuming that the
input will be an expression as this will make the recursive operation
simpler. However, when writing a recursive function it's common to write
a wrapper that provides defaults or makes the function a little easier
to use. Here we'll typically make a wrapper that quotes its input (we'll
learn more about that in the next chapter), so we don't need to use
\texttt{expr()} every time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{logical_abbr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{logical_abbr_rec}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(x))}
\NormalTok{\}}

\KeywordTok{logical_abbr}\NormalTok{(T)}
\CommentTok{#> [1] TRUE}
\KeywordTok{logical_abbr}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

Next we need to implement the recursive cases. Here it's simple because
we want to do the same thing for calls and for pairlists: recursively
apply the function to each subcomponent, and return \texttt{TRUE} if any
subcomponent contains a logical abbreviation. This is made easy by
\texttt{purrr::some()}, which iterates over a list and returns
\texttt{TRUE} if the predicate function is true for any element.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{logical_abbr_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x,}
    \CommentTok{# Base cases}
    \DataTypeTok{constant =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{symbol =} \KeywordTok{as_string}\NormalTok{(x) }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{, }\StringTok{"T"}\NormalTok{),}
    
    \CommentTok{# Recursive cases}
    \DataTypeTok{call =}\NormalTok{ ,}
    \DataTypeTok{pairlist =}\NormalTok{ purrr}\OperatorTok{::}\KeywordTok{some}\NormalTok{(x, logical_abbr_rec)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ T))}
\CommentTok{#> [1] TRUE}
\KeywordTok{logical_abbr}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{na.rm =}\NormalTok{ T) }\OtherTok{FALSE}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{finding-all-variables-created-by-assignment}{%
\subsection{Finding all variables created by
assignment}\label{finding-all-variables-created-by-assignment}}

\texttt{logical\_abbr()} is very simple: it only returns a single
\texttt{TRUE} or \texttt{FALSE}. The next task, listing all variables
created by assignment, is a little more complicated. We'll start simply,
and then make the function progressively more rigorous.
\indexc{find\_assign()}

We start by looking at the AST for assignment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(x <-}\StringTok{ }\DecValTok{10}\NormalTok{)}
\CommentTok{#> █─`<-` }
\CommentTok{#> ├─x }
\CommentTok{#> └─10}
\end{Highlighting}
\end{Shaded}

Assignment is a call object where the first element is the symbol
\texttt{\textless{}-}, the second is the name of variable, and the third
is the value to be assigned.

Next, we need to decide what data structure we're going to use for the
results. Here I think it will be easiest if we return a character
vector. If we return symbols, we'll need to use a \texttt{list()} and
that makes things a little more complicated.

With that in hand we can start by implementing the base cases and
providing a helpful wrapper around the recursive function. The base
cases here are really simple!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x, }
    \DataTypeTok{constant =}\NormalTok{ ,}
    \DataTypeTok{symbol =} \KeywordTok{character}\NormalTok{()}
\NormalTok{  )  }
\NormalTok{\}}
\NormalTok{find_assign <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{find_assign_rec}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(x))}

\KeywordTok{find_assign}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> character(0)}
\KeywordTok{find_assign}\NormalTok{(x)}
\CommentTok{#> character(0)}
\end{Highlighting}
\end{Shaded}

Next we implement the recursive cases. This is made easier by a function
that should exist in purrr, but currently doesn't.
\texttt{flat\_map\_chr()} expects \texttt{.f} to return a character
vector of arbitrary length, and flattens all results into a single
character vector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flat_map_chr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.x, .f, ...) \{}
\NormalTok{  purrr}\OperatorTok{::}\KeywordTok{flatten_chr}\NormalTok{(purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(.x, .f, ...))}
\NormalTok{\}}

\KeywordTok{flat_map_chr}\NormalTok{(letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{], }\OperatorTok{~}\StringTok{ }\KeywordTok{rep}\NormalTok{(., }\KeywordTok{sample}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] "a" "b" "b" "b" "c" "c"}
\end{Highlighting}
\end{Shaded}

The recursive case for pairlists is simple: we iterate over every
element of the pairlist (i.e.~each function argument) and combine the
results. The case for calls is a little bit more complex - if this is a
call to \texttt{\textless{}-} then we should return the second element
of the call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x,}
    \CommentTok{# Base cases}
    \DataTypeTok{constant =}\NormalTok{ ,}
    \DataTypeTok{symbol =} \KeywordTok{character}\NormalTok{(),}
    
    \CommentTok{# Recursive cases}
    \DataTypeTok{pairlist =} \KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x), find_assign_rec),}
    \DataTypeTok{call =}\NormalTok{ \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x, }\StringTok{"<-"}\NormalTok{)) \{}
        \KeywordTok{as_string}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x), find_assign_rec)}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{find_assign}\NormalTok{(a <-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] "a"}
\KeywordTok{find_assign}\NormalTok{(\{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  \{}
\NormalTok{    b <-}\StringTok{ }\DecValTok{2}
\NormalTok{  \}}
\NormalTok{\})}
\CommentTok{#> [1] "a" "b"}
\end{Highlighting}
\end{Shaded}

Now we need to make our function more robust by coming up with examples
intended to break it. What happens when we assign to the same variable
multiple times?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{find_assign}\NormalTok{(\{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  a <-}\StringTok{ }\DecValTok{2}
\NormalTok{\})}
\CommentTok{#> [1] "a" "a"}
\end{Highlighting}
\end{Shaded}

It's easiest to fix this at the level of the wrapper function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{unique}\NormalTok{(}\KeywordTok{find_assign_rec}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(x)))}

\KeywordTok{find_assign}\NormalTok{(\{}
\NormalTok{  a <-}\StringTok{ }\DecValTok{1}
\NormalTok{  a <-}\StringTok{ }\DecValTok{2}
\NormalTok{\})}
\CommentTok{#> [1] "a"}
\end{Highlighting}
\end{Shaded}

What happens if we have nested calls to \texttt{\textless{}-}? Currently
we only return the first. That's because when \texttt{\textless{}-}
occurs we immediately terminate recursion.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{find_assign}\NormalTok{(\{}
\NormalTok{  a <-}\StringTok{ }\NormalTok{b <-}\StringTok{ }\NormalTok{c <-}\StringTok{ }\DecValTok{1}
\NormalTok{\})}
\CommentTok{#> [1] "a"}
\end{Highlighting}
\end{Shaded}

Instead we need to take a more rigorous approach. I think it's best to
keep the recursive function focused on the tree structure, so I'm going
to extract out \texttt{find\_assign\_call()} into a separate function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign_call <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x, }\StringTok{"<-"}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\KeywordTok{is_symbol}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])) \{}
\NormalTok{    lhs <-}\StringTok{ }\KeywordTok{as_string}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
\NormalTok{    children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    lhs <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
\NormalTok{    children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)}
\NormalTok{  \}}
  
  \KeywordTok{c}\NormalTok{(lhs, }\KeywordTok{flat_map_chr}\NormalTok{(children, find_assign_rec))}
\NormalTok{\}}

\NormalTok{find_assign_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x,}
    \CommentTok{# Base cases}
    \DataTypeTok{constant =}\NormalTok{ ,}
    \DataTypeTok{symbol =} \KeywordTok{character}\NormalTok{(),}
    
    \CommentTok{# Recursive cases}
    \DataTypeTok{pairlist =} \KeywordTok{flat_map_chr}\NormalTok{(x, find_assign_rec),}
    \DataTypeTok{call =} \KeywordTok{find_assign_call}\NormalTok{(x)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{find_assign}\NormalTok{(a <-}\StringTok{ }\NormalTok{b <-}\StringTok{ }\NormalTok{c <-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] "a" "b" "c"}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{system.time}\NormalTok{(x <-}\StringTok{ }\KeywordTok{print}\NormalTok{(y <-}\StringTok{ }\DecValTok{5}\NormalTok{)))}
\CommentTok{#> [1] "x" "y"}
\end{Highlighting}
\end{Shaded}

While the complete version of this function is quite complicated, it's
important to remember we wrote it by working our way up by writing
simple component parts.

\hypertarget{exercises-53}{%
\subsection{Exercises}\label{exercises-53}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{logical\_abbr()} returns \texttt{TRUE} for
  \texttt{T(1,\ 2,\ 3)}. How could you modify
  \texttt{logical\_abbr\_rec()} so that it ignores function calls that
  use \texttt{T} or \texttt{F}?
\item
  \texttt{logical\_abbr()} works with expressions. It currently fails
  when you give it a function. Why not? How could you modify
  \texttt{logical\_abbr()} to make it work? What components of a
  function will you need to recurse over?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{logical_abbr}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \OtherTok{TRUE}\NormalTok{) \{}
  \KeywordTok{g}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{T)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}
\item
  Modify find assignment to also detect assignment using replacement
  functions, i.e. \texttt{names(x)\ \textless{}-\ y}.
\item
  Write a function that extracts all calls to a specified function.
\end{enumerate}

\hypertarget{specialised-data-structures}{%
\section{Specialised data
structures}\label{specialised-data-structures}}

There are two data structures and one special symbol that we need to
cover for the sake of completeness. They are not usually important in
practice.

\hypertarget{pairlists}{%
\subsection{Pairlists}\label{pairlists}}

\index{pairlists}

Pairlists are a remnant of R's past and have been replaced by lists
almost everywhere. The only place you are likely to see pairlists in
R\footnote{If you're working in C, you'll encounter pairlists more
  often. For example, call objects are also implemented using pairlists.}
is when working with calls to the ``function'' function, as the formal
arguments to a function are stored in a pairlist:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{y =} \DecValTok{10}\NormalTok{) x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}

\NormalTok{args <-}\StringTok{ }\NormalTok{f[[}\DecValTok{2}\NormalTok{]]}
\NormalTok{args}
\CommentTok{#> $x}
\CommentTok{#> }
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> [1] 10}
\KeywordTok{typeof}\NormalTok{(args)}
\CommentTok{#> [1] "pairlist"}
\end{Highlighting}
\end{Shaded}

Fortunately, whenever you encounter a pairlist, you can treat it just
like a regular list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pl <-}\StringTok{ }\KeywordTok{pairlist}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\KeywordTok{length}\NormalTok{(pl)}
\CommentTok{#> [1] 2}
\NormalTok{pl}\OperatorTok{$}\NormalTok{x}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

Behind the scenes pairlists are implemented using a different data
structure, a linked list instead of an array. That makes subsetting a
pairlist much slower than subsetting a list, but this has little
practical impact.

\hypertarget{empty-symbol}{%
\subsection{Missing arguments}\label{empty-symbol}}

\index{symbol|empty} \index{missing argument}

There's one special symbol that needs a little extra discussion: the
empty symbol, which is used to represent missing arguments (not missing
values!). You only need to care about the missing symbol if you're
programmatically creating functions with missing arguments; we'll come
back to that in Section \ref{unquote-missing}. You can make an empty
symbol with \texttt{missing\_arg()} (or \texttt{expr()}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{missing_arg}\NormalTok{()}
\KeywordTok{typeof}\NormalTok{(}\KeywordTok{missing_arg}\NormalTok{())}
\CommentTok{#> [1] "symbol"}
\end{Highlighting}
\end{Shaded}

An empty symbol doesn't print anything, so check if you have one with
\texttt{rlang::is\_missing()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_missing}\NormalTok{(}\KeywordTok{missing_arg}\NormalTok{())}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

And you'll find them in the wild in function formals:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{y =} \DecValTok{10}\NormalTok{) x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\NormalTok{args <-}\StringTok{ }\NormalTok{f[[}\DecValTok{2}\NormalTok{]]}
\KeywordTok{is_missing}\NormalTok{(args[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

The empty symbol has a peculiar property: if you bind it to a variable,
then access that variable, you will get an error:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\KeywordTok{missing_arg}\NormalTok{()}
\NormalTok{m}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   argument "m" is missing, with no default}
\end{Highlighting}
\end{Shaded}

This is the same error you get when referring to a missing argument
inside a function, and indeed this is the magic that powers missing
arguments.

If you need to preserve the missingness of a variable,
\texttt{rlang::maybe\_missing()} is often helpful. It allows you to
refer to a potentially missing variable without triggering the error.

\hypertarget{expression-vectors}{%
\subsection{Expression vectors}\label{expression-vectors}}

\index{expression vector} \indexc{expression()} \indexc{parse()}

Finally, we need to briefly discuss the expression vector. Expression
vectors are produced by only two base functions: \texttt{expression()}
and \texttt{parse()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp1 <-}\StringTok{ }\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =} \KeywordTok{c}\NormalTok{(}\StringTok{"}
\StringTok{x <- 4}
\StringTok{x}
\StringTok{"}\NormalTok{))}
\NormalTok{exp2 <-}\StringTok{ }\KeywordTok{expression}\NormalTok{(x <-}\StringTok{ }\DecValTok{4}\NormalTok{, x)}

\KeywordTok{typeof}\NormalTok{(exp1)}
\CommentTok{#> [1] "expression"}
\KeywordTok{typeof}\NormalTok{(exp2)}
\CommentTok{#> [1] "expression"}

\NormalTok{exp1}
\CommentTok{#> expression(x <- 4, x)}
\NormalTok{exp2}
\CommentTok{#> expression(x <- 4, x)}
\end{Highlighting}
\end{Shaded}

Like calls and pairlists, expression vectors behave like a list:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(exp1)}
\CommentTok{#> [1] 2}
\NormalTok{exp1[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> x <- 4}
\end{Highlighting}
\end{Shaded}

Conceptually, an expression vector is just a list of expressions. The
only difference is that calling \texttt{eval()} on an expression
evaluates each individual expression. I don't believe this advantage
merits introducing a new data structure, so instead of expression
vectors I just use lists of expressions.

\hypertarget{quasiquotation}{%
\chapter{Quasiquotation}\label{quasiquotation}}

\hypertarget{introduction-16}{%
\section{Introduction}\label{introduction-16}}

Now that you understand the tree structure of R code, it's time to come
back to one of the fundamental ideas that make \texttt{expr()} and
\texttt{ast()} work: quasiquotation. \textbf{Quasiquotation} is made up
of two parts:

\begin{itemize}
\item
  \textbf{Quotation} is the act of capturing an unevaluated expression.
\item
  \textbf{Unquotation} is the ability to selectively evaluate evaluate
  parts of an otherwise quoted expression.
\end{itemize}

The combination of these two ideas makes it easy create functions that
combine code written by the function author with code written by the
function user, and helps to solve a wide variety of challenging
problems.

Quasiquotation is one of the three components of tidy evaluation. You'll
learn learn about the other two components (quosures and the data mask)
in Chapter \ref{evaulation}. By itself, quasiquotation is mostly useful
for programming, particularly for generating code; when combined with
the other techniques, tidy evalation is a powerful tool for data
analysis.

\hypertarget{outline-14}{%
\subsection*{Outline}\label{outline-14}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  Section \ref{quasi-motivation} motivates the development of
  quasiquotation with a function, \texttt{cement()}, that works like
  \texttt{paste()} but automatically ``quotes'' its arguments so that
  you don't have to.
\item
  Section \ref{quoting} gvies you the tools to quote expressions,
  whether they come from you or the user, or whether you use rlang or
  base R tools.
\item
  Section \ref{unquoting} introduces the biggest difference between
  rlang quoting functions and base quoting function: unquoting with
  \texttt{!!} and \texttt{!!!}.
\item
  Section \ref{base-nonquote} discusses the three main ``non-quoting''
  techniques that base R functions uses to disable quoting behaviour.
\item
  Section \ref{tidy-dots} explores another place that you can use
  \texttt{!!!}, functions that take \texttt{...}. It also introduces the
  special \texttt{:=} operator, which allows you to dynamically change
  argument names.
\item
  Section \ref{expr-case-studies} shows a few practical uses of quoting
  to solve problems that naturally require some code generation.
\end{itemize}

\hypertarget{prerequisites-10}{%
\subsection*{Prerequisites}\label{prerequisites-10}}
\addcontentsline{toc}{subsection}{Prerequisites}

Make sure you've read the metaprogramming overview in Chapter \ref{meta}
to get a broad overview of the motivation and the basic vocabulary, and
that you're familiar with the tree structure of expressions as described
in Section \ref{expressions}.

Code-wise, we'll mostly be using the tools from rlang, but at the end of
the chapter you'll also see some powerful applications in conjunction
with purrr.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\KeywordTok{library}\NormalTok{(purrr)}
\end{Highlighting}
\end{Shaded}

\hypertarget{related-work}{%
\subsection*{Related work}\label{related-work}}
\addcontentsline{toc}{subsection}{Related work}

\index{macros} \index{fexprs}

Quoting functions have deep connections to Lisp \textbf{macros}. But
macros are usually run at compile-time, which doesn't exist in R, and
they always input and output ASTs. See Lumley
(\protect\hyperlink{ref-lumley-2001}{2001}) for one approach to
implementing them in R. Quoting functions are more closely related to
Lisp \href{http://en.wikipedia.org/wiki/Fexpr}{\textbf{fexprs}},
functions where all arguments are quoted by default. These terms are
useful to know when looking for related techniques in other programming
languages.

\hypertarget{quasi-motivation}{%
\section{Motivation}\label{quasi-motivation}}

We'll start with a simple and concrete example that helps motivate the
need for unquoting, and hence quasiquotation. Imagine you're creating a
lot of strings by joining together words:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(}\StringTok{"Good"}\NormalTok{, }\StringTok{"morning"}\NormalTok{, }\StringTok{"Hadley"}\NormalTok{)}
\CommentTok{#> [1] "Good morning Hadley"}
\KeywordTok{paste}\NormalTok{(}\StringTok{"Good"}\NormalTok{, }\StringTok{"afternoon"}\NormalTok{, }\StringTok{"Alice"}\NormalTok{)}
\CommentTok{#> [1] "Good afternoon Alice"}
\end{Highlighting}
\end{Shaded}

You are sick and tired of writing all those quotes, and instead you just
want to use bare words. To that end, you've written the following
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cement <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{ensyms}\NormalTok{(...)}
  \KeywordTok{paste}\NormalTok{(purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(args, as_string), }\DataTypeTok{collapse =} \StringTok{" "}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{cement}\NormalTok{(Good, morning, Hadley)}
\CommentTok{#> [1] "Good morning Hadley"}
\KeywordTok{cement}\NormalTok{(Good, afternoon, Alice)}
\CommentTok{#> [1] "Good afternoon Alice"}
\end{Highlighting}
\end{Shaded}

(You'll learn what \texttt{ensyms()} does shortly; for now just look at
the results.)

Formally, this function \emph{quotes} the arguments in \texttt{...}. You
can think of it as automatically putting quotation marks around each
argument. That's not precisely true as the intermediate objects it
generates are expressions, not strings, but it's a useful approximation,
and meaning at the root of the term ``quote''.

This function is nice because we no longer need to type quotation marks.
The problem, however, comes when we want to use variables. It's easy to
use variables with \texttt{paste()}: just don't surround them with
quotation marks.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name <-}\StringTok{ "Hadley"}
\NormalTok{time <-}\StringTok{ "morning"}

\KeywordTok{paste}\NormalTok{(}\StringTok{"Good"}\NormalTok{, time, name)}
\CommentTok{#> [1] "Good morning Hadley"}
\end{Highlighting}
\end{Shaded}

Obviously this doesn't work with \texttt{cement()} because every input
is automatically quoted:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cement}\NormalTok{(Good, time, name)}
\CommentTok{#> [1] "Good time name"}
\end{Highlighting}
\end{Shaded}

We need some way to explicitly \emph{unquote} the input, to tell
\texttt{cement()} to remove the automatic quote marks. Here we need
\texttt{time} and \texttt{name} to be treated differently to
\texttt{Good}. Quasiquotation gives us a standard tool to do so:
\texttt{!!}, called ``unquote'', and pronounced bang-bang. \texttt{!!}
tells a quoting function to drop the implicit quotes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cement}\NormalTok{(Good, }\OperatorTok{!!}\NormalTok{time, }\OperatorTok{!!}\NormalTok{name)}
\CommentTok{#> [1] "Good morning Hadley"}
\end{Highlighting}
\end{Shaded}

It's useful to compare \texttt{cement()} and \texttt{paste()} directly.
\texttt{paste()} evaluates its arguments, so we need to quote where
needed; \texttt{cement()} quotes its arguments, so we need to unquote
where needed.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(}\StringTok{"Good"}\NormalTok{, time, name)}
\KeywordTok{cement}\NormalTok{(Good, }\OperatorTok{!!}\NormalTok{time, }\OperatorTok{!!}\NormalTok{name)}
\end{Highlighting}
\end{Shaded}

\hypertarget{vocabulary-1}{%
\subsection{Vocabulary}\label{vocabulary-1}}

The distinction between quoted and evaluated arguments is important:

\begin{itemize}
\item
  An \textbf{evaluated} argument obeys R's usual evaluation rules.
\item
  A \textbf{quoted} argument is captured by the function and something
  unusual will happen.
\end{itemize}

\texttt{paste()} evaluates all its arguments; \texttt{cement()} quotes
all its arguments.

If you're ever unsure about whether an argument is quoted or evaluated,
try executing the code outside of the function. If it doesn't work (or
does something profoundly different), then that argument is quoted. For
example, you can use this technique to determine that the first argument
to \texttt{library()} is quoted:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# works}
\KeywordTok{library}\NormalTok{(MASS)}

\CommentTok{# fails}
\NormalTok{MASS}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'MASS' not found}
\end{Highlighting}
\end{Shaded}

Talking about whether an argument is quoted or evaluated is a more
precise way of stating whether or not a function uses non-standard
evaluation (NSE). I will sometimes use ``quoting function'' as
short-hand for a ``function that quotes one or more arguments'', but
generally, I'll refer to quoted arguments since that is the level at
which the difference applies.

\hypertarget{history}{%
\subsection{History}\label{history}}

The idea of quasiquotation is an old one. It was first developed by a
philosopher, Willard van Orman Quine\footnote{You might be familiar with
  the name Quine from ``quines'', computer programs that return a copy
  of their own source when run.}, in the early 1940s. It's needed in
philosophy\footnote{A fun connection between philosophy and R is in
  \url{https://johnmacfarlane.net/142/substitutional-quantifiers.pdf};
  this article is written by philosophy professor John MacFarlane, the
  author of pandoc, which powers RMarkdown.} because it helps when
precisely delineating the use and mention of words, i.e.~between the
object and the words we use to refer to that object.

Quasiquotation was first used in a programming language, LISP, in the
mid-1970s (Bawden \protect\hyperlink{ref-bawden-1999}{1999}). LISP has
one quoting function \texttt{\textasciigrave{}}, and uses \texttt{,} for
unquoting. Most languages with a LISP heritage behave similarly. For
example, racket (\texttt{\textasciigrave{}} and \texttt{@}), clojure
(\texttt{\textasciigrave{}} and \texttt{\textasciitilde{}}), and julia
(\texttt{:} and \texttt{@}) all have quasiquotation tools that differ
only slightly from LISP. These languages have a single quoting function
and you must call it explicitly.

In R, however, many functions quote one or more inputs. This introduces
ambiguity (because you need to read the documentation to determine if an
argument is quoted or not), but allows for concise and elegant data
exploration code. In base R, only one function supports quasiquotation:
\texttt{bquote()}, written in 2003 by Thomas Lumley. But
\texttt{bquote()} is not used anywhere in base R, and has had relatively
little impact on how R code is written. There are three challenges to
effective use of \texttt{bquote()}:

\begin{itemize}
\item
  It is only easily used with your code; it is hard to apply it to
  abitrary code supplied by a user.
\item
  It does not provide an unquote-splice operator that allows you to
  unquote multiple expressions stored in a list.
\item
  It lacks the ability to handle code accompanied by an environment,
  which is crucial for functions that evaluate code in the context of a
  data frame, like \texttt{subset()} and friends.
\end{itemize}

Figuring out how to fix the first and second challenges lead to my
lazyeval package (2014-2015). Identifying and remedying the third
challenge (the topic of Chapter \ref{evaluation} lead to the tidy
evaluation framework taught in this book and implemented in the rlang
package by Lionel Henry, during 2017. Despite the newness of tidy eval,
I teach it here because it is a rich and powerful theory that, once you
master it, makes many hard problems much easier.

\hypertarget{exercises-54}{%
\subsection{Exercises}\label{exercises-54}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  For each function in the following base R code, identify which
  arguments are quoted and which are evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(MASS)}

\NormalTok{mtcars2 <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(mtcars, cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{)}

\KeywordTok{with}\NormalTok{(mtcars2, }\KeywordTok{sum}\NormalTok{(vs))}
\KeywordTok{sum}\NormalTok{(mtcars2}\OperatorTok{$}\NormalTok{am)}

\KeywordTok{rm}\NormalTok{(mtcars2)}
\end{Highlighting}
\end{Shaded}
\item
  For each function in the following tidyverse code, identify which
  arguments are quoted and which are evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{library}\NormalTok{(ggplot2)}

\NormalTok{by_cyl <-}\StringTok{ }\NormalTok{mtcars }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(cyl) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(mpg))}

\KeywordTok{ggplot}\NormalTok{(by_cyl, }\KeywordTok{aes}\NormalTok{(cyl, mean)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{quoting}{%
\section{Quoting}\label{quoting}}

The first part of quasiquotation is quotation: capturing an expression
without evaluating it. There are two components to this: capturing an
expression supplied directly, and capturing an expression supplied
indirectly in a lazily-evaluated function argument. We'll discuss two
sets of tools for these two ways of capturing: those provided by rlang,
and those provided by base R.

\hypertarget{capturing-expressions}{%
\subsection{Capturing expressions}\label{capturing-expressions}}

There are four important quoting functions. For interactive exploration,
the most important quoting function is \texttt{expr()}. It captures its
argument exactly as provided:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> x + y}
\KeywordTok{expr}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2} \OperatorTok{/}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> 1/2/3}
\end{Highlighting}
\end{Shaded}

(Remember that white space and comments are not part of the expression,
so will not be captured by a quoting function.)

\texttt{expr()} is great for interactive exploration, because it
captures what you, the developer, typed. It's not so useful inside a
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{expr}\NormalTok{(x)}
\KeywordTok{f1}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c)}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

We need another function to solve this problem: \texttt{enexpr()}. This
captures what the caller supplied to the function by looking at the
internal promise object that powers lazy evaluation (Section
\ref{promises}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{enexpr}\NormalTok{(x)}
\KeywordTok{f2}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c)}
\CommentTok{#> a + b + c}
\end{Highlighting}
\end{Shaded}

To capture multiple arguments (e.g.~all arguments in \texttt{...}), use
\texttt{enexprs()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{enexprs}\NormalTok{(...)}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{10} \OperatorTok{*}\StringTok{ }\NormalTok{z)}
\CommentTok{#> $x}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> 10 * z}
\end{Highlighting}
\end{Shaded}

Finally, \texttt{exprs()} is useful interactively to make a list of
expressions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ y }\OperatorTok{^}\StringTok{ }\DecValTok{3}\NormalTok{, }\DataTypeTok{z =}\NormalTok{ z }\OperatorTok{^}\StringTok{ }\DecValTok{4}\NormalTok{)}
\CommentTok{#> $x}
\CommentTok{#> x^2}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> y^3}
\CommentTok{#> }
\CommentTok{#> $z}
\CommentTok{#> z^4}
\CommentTok{# shorthand for}
\CommentTok{# list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))}
\end{Highlighting}
\end{Shaded}

In short, use \texttt{enexpr()} and \texttt{enexprs()} to capture the
expressions supplied as arguments \emph{by the user}. Use
\texttt{expr()} and \texttt{exprs()} to capture expressions that
\emph{you} supply.

\hypertarget{capturing-symbols}{%
\subsection{Capturing symbols}\label{capturing-symbols}}

Sometimes you only want to allow the user to specify a variable name,
not an arbtirary expression. In this case, you can use \texttt{ensym()}
or \texttt{ensyms()}. These are variants of \texttt{enexpr()} and
\texttt{enexprs()} that check the captured expression is either symbol
or a string (which is converted to symbol\footnote{This is for
  compatibility with base R, which allows you to provide a string
  instead of a symbol in many places: \texttt{"x"\ \textless{}-\ 1},
  \texttt{"foo"(x,\ y)}, \texttt{c("x"\ =\ 1)}.}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{ensyms}\NormalTok{(...)}
\KeywordTok{f}\NormalTok{(x)}
\CommentTok{#> [[1]]}
\CommentTok{#> x}
\KeywordTok{f}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> [[1]]}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

\texttt{ensym()} and \texttt{ensyms()} throw an error if given anything
else.

\hypertarget{with-base-r}{%
\subsection{With base R}\label{with-base-r}}

The base equivalent of \texttt{expr()} is \texttt{quote()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{quote}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> x + y}
\KeywordTok{quote}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2} \OperatorTok{/}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> 1/2/3}
\end{Highlighting}
\end{Shaded}

It is identical to \texttt{expr()} except that it does not support
unquoting (which we'll talk about very soon). This makes it is a quoting
function, not a quasiquoting function.

The base function closest to \texttt{enexpr()} is \texttt{substitute()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{substitute}\NormalTok{(x)}
\KeywordTok{f3}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\CommentTok{#> x + y + z}
\end{Highlighting}
\end{Shaded}

\textbf{Substitution}

You'll most often see \texttt{substitute()} used to capture unevaluated
arguments. However, as well as quoting, \texttt{substitute()} also does
``substitution'': if you give it an expression, rather than a symbol, it
will substitute in the values of symbols defined in the current
environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f4 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{substitute}\NormalTok{(x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{)}
\KeywordTok{f4}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c)}
\CommentTok{#> (a + b + c) * 2}
\end{Highlighting}
\end{Shaded}

I think this makes code hard to understand, because, taken out of
context, you can't tell if the goal of \texttt{substitute(x\ +\ y)} is
to replace \texttt{x}, or, \texttt{y}, or both. If you do want to use
\texttt{substitute()} for substitution, I recommend that you use the 2nd
argument to make your goal clear:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substitute}\NormalTok{(x }\OperatorTok{*}\StringTok{ }\NormalTok{y }\OperatorTok{*}\StringTok{ }\NormalTok{z, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{quote}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b)))}
\CommentTok{#> 10 * (a + b) * z}
\end{Highlighting}
\end{Shaded}

The base equivalent to \texttt{exprs()} is \texttt{alist()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{alist}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ x }\OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> $x}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> x + 2}
\end{Highlighting}
\end{Shaded}

There the equivalent to \texttt{enexprs()} is an undocumented feature of
\texttt{substitute()}\footnote{Discovered by Peter Meilstrup and
  described in
  \href{http://r.789695.n4.nabble.com/substitute-on-arguments-in-ellipsis-quot-dot-dot-dot-quot-td4751658.html}{R-devel
  on 2018-08-13}.}: you can pretend \texttt{...} is a function to
capture all arguments in \texttt{...}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{as.list}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(}\KeywordTok{...}\NormalTok{()))}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{10} \OperatorTok{*}\StringTok{ }\NormalTok{z)}
\CommentTok{#> $x}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> 10 * z}
\end{Highlighting}
\end{Shaded}

There are two other important base quoting functions that we'll cover
elsewhere:

\begin{itemize}
\item
  \texttt{bquote()} provides a limited form of quasiquotation, and is
  discussed in Section \ref{base-nonquote}.
\item
  \texttt{\textasciitilde{}}, the formula, is a quoting function that
  also captures the environment. It's the inspiration for quosures, the
  topic of the next chapter, and is discussed in Section
  \ref{quosure-impl}.
\end{itemize}

\hypertarget{summary}{%
\subsection{Summary}\label{summary}}

When quoting (i.e.~capturing code), there are two important
distinctions:

\begin{itemize}
\item
  Is it supplied by the developer of the code or the user of the code?
  i.e.~is it fixed or varying, supplied in the body of the function or
  via an argument?
\item
  Do you want to capture a single expression or multiple expressions?
\end{itemize}

This leads to a 2 x 2 table of function for rlang and base R:

\begin{itemize}
\item
  rlang:

  \begin{longtable}[]{@{}lll@{}}
  \toprule
  & Developer & User\tabularnewline
  \midrule
  \endhead
  One & \texttt{expr()} & \texttt{enexpr()}\tabularnewline
  Many & \texttt{exprs()} & \texttt{enexprs()}\tabularnewline
  \bottomrule
  \end{longtable}
\item
  base R:

  \begin{longtable}[]{@{}lll@{}}
  \toprule
  & Developer & User\tabularnewline
  \midrule
  \endhead
  One & \texttt{quote()} & \texttt{substitute()}\tabularnewline
  Many & \texttt{alist()} &
  \texttt{eval(substitute(alist()))}\tabularnewline
  \bottomrule
  \end{longtable}
\end{itemize}

\hypertarget{exercises-55}{%
\subsection{Exercises}\label{exercises-55}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What does the following command return? What information is lost? Why?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(\{}
\NormalTok{  x }\OperatorTok{+}\StringTok{              }\NormalTok{y }\CommentTok{# comment  }
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}
\item
  How is \texttt{expr()} implemented?
\item
  Compare and contrast the following two functions. Can you predict the
  output before running them?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
  \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)}
\NormalTok{\}}
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
  \KeywordTok{enexprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b, c }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\KeywordTok{f2}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b, c }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\end{Highlighting}
\end{Shaded}
\item
  What happens if you try to use \texttt{enexpr()} with an expression
  (i.e. \texttt{enexpr(x\ +\ y)} ? What happens if \texttt{enexpr()} is
  passed a missing argument?
\item
  How are \texttt{exprs(a)} and \texttt{exprs(a\ =\ )} different? Think
  about both the input and the output.
\item
  What are other differences between \texttt{exprs()} and
  \texttt{alist()}? Read the documentation for the named arguments of
  \texttt{exprs()} to find out.
\item
  The documentation for \texttt{substitute()} says:

  \begin{quote}
  Substitution takes place by examining each component of the parse tree
  as follows:

  \begin{itemize}
  \tightlist
  \item
    If it is not a bound symbol in \texttt{env}, it is unchanged.
  \item
    If it is a promise object (i.e., a formal argument to a function)
    the expression slot of the promise replaces the symbol.
  \item
    If it is an ordinary variable, its value is substituted;
  \item
    Unless \texttt{env} is .GlobalEnv in which case the symbol is left
    unchanged.
  \end{itemize}
  \end{quote}

  Create four examples that illustrate each of the different cases.
\end{enumerate}

\hypertarget{unquoting}{%
\section{Unquoting}\label{unquoting}}

So far, you've only seen relatively small advantages of the rlang
quoting functions over the base R quoting functions: they have a more
consistent naming scheme. The big difference is that rlang quoting
functions are actually \textbf{quasiquoting} functions, because they
support unquoting with \texttt{!!} (called ``unquote'', and pronounced
bang-bang).

Unquoting allows you to selectively execute, or evaluate, parts of the
expression that would otherwise be quoted, and it effectively allows you
to merge together ASTs using a template AST. Since base functions don't
use unquoting, they instead use a variety of other techniques, which
you'll learnn about in Section \ref{base-nonquote}.

Unquoting is one inverse of quoting. It allows you to selectively
evaluate code inside \texttt{expr()}, so that \texttt{expr(!!x)} is
equivalent to \texttt{x}. In Chapter \ref{evaluation}, you'll learn
about another inverse, evaluation. Evaluation happens outside
\texttt{expr()}, so that \texttt{eval(expr(x))} is equivalent to
\texttt{x}.

\hypertarget{unquoting-one-argument}{%
\subsection{Unquoting one argument}\label{unquoting-one-argument}}

Use \texttt{!!} to unquote a single argument in a function call.
\texttt{!!} takes a single expression, evaluates it, and inlines the
result in to the AST.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c)}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\OperatorTok{!!}\NormalTok{x, y))}
\CommentTok{#> f(a + b + c, y)}
\end{Highlighting}
\end{Shaded}

I think this is easiest to understand with a diagram. \texttt{!!}
introduces a placeholder in the AST, shown with dotted borders. Here the
placeholder \texttt{x} is replaced by an AST, illustrated by a dotted
connection.

\begin{center}\includegraphics[width=2.7in]{diagrams/quotation/bang-bang} \end{center}

As well as call objects, \texttt{!!} also works with symbols and
constants:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{sym}\NormalTok{(}\StringTok{"y"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\DecValTok{1}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\OperatorTok{!!}\NormalTok{a, }\OperatorTok{!!}\NormalTok{b))}
\CommentTok{#> f(y, 1)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=2.36in]{diagrams/quotation/simple} \end{center}

Note that the right-hand side of \texttt{!!} can be a function call.
\texttt{!!} will evaluate the call and insert the results in the AST:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean_rm <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(var) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{ensym}\NormalTok{(var)}
  \KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\OperatorTok{!!}\NormalTok{var, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\NormalTok{\}}
\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\KeywordTok{mean_rm}\NormalTok{(x) }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\KeywordTok{mean_rm}\NormalTok{(y))}
\CommentTok{#> mean(x, na.rm = TRUE) + mean(y, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

Note that \texttt{!!} preserves operator precedence because it works
with expressions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)}

\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{x1 }\OperatorTok{/}\StringTok{ }\OperatorTok{!!}\NormalTok{x2)}
\CommentTok{#> (x + 1)/(x + 2)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=4.47in]{diagrams/quotation/infix} \end{center}

If we simply pasted the text of the expressions together, we'd end up
with \texttt{x\ +\ 1\ /\ x\ +\ 2}, which has a very different AST:

\begin{center}\includegraphics[width=2.95in]{diagrams/quotation/infix-bad} \end{center}

\hypertarget{unquoting-a-function}{%
\subsection{Unquoting a function}\label{unquoting-a-function}}

\texttt{!!} is most commonly used to replace the arguments to a
function, but you can also use it to replace the function itself. The
only challenge here is operator precedence: \texttt{expr(!!f(x,\ y))}
unquotes the result of \texttt{f(x,\ y)}, so you need an extra pair of
parentheses.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(foo)}
\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{f)(x, y, z))}
\CommentTok{#> foo(x, y, z)}
\end{Highlighting}
\end{Shaded}

This also works when \texttt{f} is itself a call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(pkg}\OperatorTok{::}\NormalTok{foo)}
\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{f)(x, y, z))}
\CommentTok{#> pkg::foo(x, y, z)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.1in]{diagrams/quotation/fun} \end{center}

Because of the large number of parentheses involved, it can be more
clear to use \texttt{rlang::call2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(pkg}\OperatorTok{::}\NormalTok{foo)}
\KeywordTok{call2}\NormalTok{(f, }\KeywordTok{expr}\NormalTok{(x), }\KeywordTok{expr}\NormalTok{(y))}
\CommentTok{#> pkg::foo(x, y)}
\end{Highlighting}
\end{Shaded}

\hypertarget{unquote-missing}{%
\subsection{Unquoting a missing argument}\label{unquote-missing}}

Very occasionally it is useful to unquote a missing argument (Section
\ref{empty-symbol}), but the naive approach doesn't work:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arg <-}\StringTok{ }\KeywordTok{missing_arg}\NormalTok{()}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\OperatorTok{!!}\NormalTok{arg, }\OperatorTok{!!}\NormalTok{arg))}
\CommentTok{#> Error in enexpr(expr):}
\CommentTok{#>   argument "arg" is missing, with no default}
\end{Highlighting}
\end{Shaded}

You can work around this with the \texttt{maybe\_missing()} helper:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\OperatorTok{!!}\KeywordTok{maybe_missing}\NormalTok{(arg), }\OperatorTok{!!}\KeywordTok{maybe_missing}\NormalTok{(arg)))}
\CommentTok{#> foo(, )}
\end{Highlighting}
\end{Shaded}

\hypertarget{unquoting-in-special-forms}{%
\subsection{Unquoting in special
forms}\label{unquoting-in-special-forms}}

There are a few special forms where unquoting is a syntax error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(df}\OperatorTok{$!!}\NormalTok{x)}
\CommentTok{#> Error: unexpected '!' in "expr(df$!"}
\end{Highlighting}
\end{Shaded}

Here you need to use the prefix form:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x)}
\KeywordTok{expr}\NormalTok{(}\StringTok{`}\DataTypeTok{$}\StringTok{`}\NormalTok{(df, }\OperatorTok{!!}\NormalTok{x))}
\CommentTok{#> df$x}
\end{Highlighting}
\end{Shaded}

\hypertarget{unquoting-many-arguments}{%
\subsection{Unquoting many arguments}\label{unquoting-many-arguments}}

\texttt{!!} is a one-to-one replacement. \texttt{!!!} (called
``unquote-splice'', and pronounced bang-bang-bang) is a one-to-many
replacement. It takes a list of expressions and inserts them at the
location of the \texttt{!!!}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xs <-}\StringTok{ }\KeywordTok{exprs}\NormalTok{(}\DecValTok{1}\NormalTok{, a, }\OperatorTok{-}\NormalTok{b)}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\OperatorTok{!!!}\NormalTok{xs, y))}
\CommentTok{#> f(1, a, -b, y)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=3.89in]{diagrams/quotation/bang-bang-bang} \end{center}

\texttt{!!!} can be used in any rlang function that takes \texttt{...}
regardless of whether or not \texttt{...} is quoted or evaluated. We'll
come back to this in Section \ref{tidy-dots}; for now note that this can
be useful in \texttt{call2()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\OperatorTok{!!!}\NormalTok{xs, }\KeywordTok{expr}\NormalTok{(y))}
\CommentTok{#> f(1, a, -b, y)}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-polite-fiction-of}{%
\subsection{\texorpdfstring{The polite fiction of
\texttt{!!}}{The polite fiction of !!}}\label{the-polite-fiction-of}}

So far we have acted as if \texttt{!!} and \texttt{!!!} are regular
prefix operators like \texttt{+} , \texttt{-}, and \texttt{!}. They're
not. From R's perspective, \texttt{!!} and \texttt{!!!} are simply the
repeated application of \texttt{!}:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{!!}\OtherTok{TRUE}
\CommentTok{#> [1] TRUE}
\OperatorTok{!!!}\OtherTok{TRUE}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

\texttt{!!} and \texttt{!!!} behave specially inside all quoting
functions powered by rlang, where they behave like real operators with
precedence equivalent to unary \texttt{+} and \texttt{-}. This requires
considerable work inside rlang, but means that you can write
\texttt{!!x\ +\ !!y} instead of \texttt{(!!x)\ +\ (!!y)}.

The biggest downside\footnote{Prior to R 3.5.1, there was another major
  downside: the R deparser treated \texttt{!!x} as \texttt{!(!x)}. This
  is why in old versions of R you might see extra parentheses when
  printing expressions. The good news is that these parentheses are not
  real and can be safely ignored most of the time. The bad news is that
  they will become real if you reparse that printed output to R code.
  These roundtripped functions will not work as expected since
  \texttt{!(!x)} does not unquote.} to using a fake operator is that you
might get silent errors when misusing \texttt{!!} outside of
quasiquoting functions. Most of the time this is not an issue because
\texttt{!!} is typically used to unquote expressions or quosures. Since
expressions are not supported by the negation operator, you will get an
argument type error in this case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(variable)}
\OperatorTok{!!}\NormalTok{x}
\CommentTok{#> Error in !x:}
\CommentTok{#>   invalid argument type}
\end{Highlighting}
\end{Shaded}

But you can get silently incorrect results when working with numeric
values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\DecValTok{100}
\KeywordTok{with}\NormalTok{(df, x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{y)}
\CommentTok{#> [1] 2 3 4 5 6}
\end{Highlighting}
\end{Shaded}

Given these drawbacks, you might wonder why we introduced new syntax
instead of using regular function calls. Indeed, early versions of tidy
eval used function calls like \texttt{UQ()} and \texttt{UQS()}, however
they're not really function calls, and pretending they leads to a
misleading mental mode. We chose \texttt{!!} and \texttt{!!!} as the
least-worst solution:

\begin{itemize}
\item
  The are visually strong and don't look like existing syntax. When you
  see \texttt{!!x} or \texttt{!!!x} it's clear that something unusual is
  happenning.
\item
  They overrides a rarely used piece of syntax, as double negation is
  not a common pattern in R\footnote{Unlike, say, javascript, where
    \texttt{!!x} is a commonly used shortcut to convert an integer into
    a logical.}. If you you do need it, you can just add parentheses
  \texttt{!(!x)}.
\end{itemize}

\hypertarget{non-standard-ast}{%
\subsection{Non-standard ASTs}\label{non-standard-ast}}

With unquoting, it's easy to create non-standard ASTs, i.e.~ASTs that
contain components that are not expressions. (It is also possible to
create non-standard ASTs by directly manipulating the underlying
objects, but it's harder to do so accidentally.) These are valid, and
occasionally useful, but their correct use is beyond the scope of this
book. It's important to learn about them, however, because they can be
deparsed, and hence printed, in misleading ways.

For example, if you inline more complex objects, their attributes are
not printed. This can lead to confusing output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{class}\NormalTok{(}\OperatorTok{!!}\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{)))}
\NormalTok{x1}
\CommentTok{#> class(list(x = 10))}
\KeywordTok{eval}\NormalTok{(x1)}
\CommentTok{#> [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

You have two main tools to reduce this confusion:
\texttt{rlang::expr\_print()} and \texttt{lobstr::ast()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr_print}\NormalTok{(x1)}
\CommentTok{#> class(<data.frame>)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!!}\NormalTok{x1)}
\CommentTok{#> █─class }
\CommentTok{#> └─<inline data.frame>}
\end{Highlighting}
\end{Shaded}

Another confusing case arises if you inline an integer sequence:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\OperatorTok{!!}\KeywordTok{c}\NormalTok{(1L, 2L, 3L, 4L, 5L)))}
\NormalTok{x2}
\CommentTok{#> f(1:5)}
\KeywordTok{expr_print}\NormalTok{(x2)}
\CommentTok{#> f(<int: 1L, 2L, 3L, 4L, 5L>)}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!!}\NormalTok{x2)}
\CommentTok{#> █─f }
\CommentTok{#> └─<inline integer>}
\end{Highlighting}
\end{Shaded}

It's also possible to create regular ASTs that can not be generated from
code because of operator precedence. In this case, R will print
parentheses that do not exist in the AST:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x3 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\OperatorTok{!!}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{))}
\NormalTok{x3}
\CommentTok{#> 1 + (2 + 3)}

\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!!}\NormalTok{x3)}
\CommentTok{#> █─`+` }
\CommentTok{#> ├─1 }
\CommentTok{#> └─█─`+` }
\CommentTok{#>   ├─2 }
\CommentTok{#>   └─3}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-56}{%
\subsection{Exercises}\label{exercises-56}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Given the following components:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xy <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\NormalTok{xz <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\NormalTok{yz <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\NormalTok{abc <-}\StringTok{ }\KeywordTok{exprs}\NormalTok{(a, b, c)}
\end{Highlighting}
\end{Shaded}

  Use quasiquotation to construct the following calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y) }\OperatorTok{/}\StringTok{ }\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\OperatorTok{-}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{z) }\OperatorTok{^}\StringTok{ }\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y) }\OperatorTok{+}\StringTok{ }\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z) }\OperatorTok{-}\StringTok{ }\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\KeywordTok{atan2}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y, y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\KeywordTok{sum}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y, x }\OperatorTok{+}\StringTok{ }\NormalTok{y, y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\KeywordTok{sum}\NormalTok{(a, b, c)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(a, b, c), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{foo}\NormalTok{(}\DataTypeTok{a =}\NormalTok{ x }\OperatorTok{+}\StringTok{ }\NormalTok{y, }\DataTypeTok{b =}\NormalTok{ y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\end{Highlighting}
\end{Shaded}
\item
  Explain why both \texttt{!0\ +\ !0} and \texttt{!1\ +\ !1} return
  \texttt{FALSE} while \texttt{!0\ +\ !1} returns \texttt{TRUE}.
\item
  Base functions \texttt{match.fun()}, \texttt{page()}, and
  \texttt{ls()} all try to automatically determine whether you want
  standard or non-standard evaluation. Each uses a different approach.
  Figure out the essence of each approach by reading the source code,
  then compare and contrast the techniques.
\item
  The following two calls print the same, but are actually different:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(1:10)}
\NormalTok{(b <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\OperatorTok{!!}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{))))}
\CommentTok{#> mean(1:10)}
\KeywordTok{identical}\NormalTok{(a, b)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

  What's the difference? Which one is more natural?
\end{enumerate}

\hypertarget{base-nonquote}{%
\section{Non-quoting in base R}\label{base-nonquote}}

Base R has one function that implements quasiquotation:
\texttt{bquote()}. It uses \texttt{.()} for unquoting:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xyz <-}\StringTok{ }\KeywordTok{bquote}\NormalTok{((x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z))}
\KeywordTok{bquote}\NormalTok{(}\OperatorTok{-}\NormalTok{.(xyz) }\OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> -(x + y + z)/2}
\end{Highlighting}
\end{Shaded}

However, \texttt{bquote()} isn't used in any other function in base R.
Instead functions that quote an argument use some other technique to
allow indirect specification. Rather than using use unquoting all base R
approaches selectively turn quoting off, so I call them
\textbf{non-quoting} techniques.

There are four basic forms seen in base R:

\begin{itemize}
\item
  A pair of quoting and non-quoting functions. For example, \texttt{\$}
  has two arguments, and the second argument is quoted. This is easier
  to see if you write in prefix form: \texttt{mtcars\$cyl} is equivalent
  to \texttt{\textasciigrave{}\$\textasciigrave{}(mtcars,\ cyl)}. If you
  want to refer to a variable indirectly, you use \texttt{{[}{[}}, as it
  takes the name of a variable as a string.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{var =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\NormalTok{var <-}\StringTok{ "y"}

\NormalTok{x}\OperatorTok{$}\NormalTok{var}
\CommentTok{#> [1] 1}
\NormalTok{x[[var]]}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

  There are three other quoting functions closely related to
  \texttt{\$}: \texttt{subset()}, \texttt{transform()}, and
  \texttt{with()}. These are seen as wrappers around \texttt{\$} only
  suitable for interactive use so they all have the same non-quoting
  alternative: \texttt{{[}}

  \texttt{\textless{}-}/\texttt{assign()} and
  \texttt{::}/\texttt{getExportedValue()} work similarly to
  \texttt{\$}/\texttt{{[}}.
\item
  A pair of quoting and non-quoting arguments. For example,
  \texttt{rm()} allows you to provide bare variable names in
  \texttt{...}, or a character vector of variable names in
  \texttt{list}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\KeywordTok{rm}\NormalTok{(x)}

\NormalTok{y <-}\StringTok{ }\DecValTok{2}
\NormalTok{vars <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"y"}\NormalTok{, }\StringTok{"vars"}\NormalTok{)}
\KeywordTok{rm}\NormalTok{(}\DataTypeTok{list =}\NormalTok{ vars)}
\end{Highlighting}
\end{Shaded}

  \texttt{data()} and \texttt{save()} work similarly.
\item
  An argument that controls whether a different argument is quoting or
  non-quoting. For example, in \texttt{library()}, the
  \texttt{character.only} argument controls the quoting behaviour of the
  first argument, \texttt{package}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(MASS)}

\NormalTok{pkg <-}\StringTok{ "MASS"}
\KeywordTok{library}\NormalTok{(pkg, }\DataTypeTok{character.only =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \texttt{demo()}, \texttt{detach()}, \texttt{example()}, and
  \texttt{require()} work similarly.
\item
  Quoting if evaluation fails. For example, the first argument to
  \texttt{help()} is non-quoting if it evaluates to a string; if
  evaluation fails, the first argument is quoted.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Shows help for var}
\KeywordTok{help}\NormalTok{(var)}

\NormalTok{var <-}\StringTok{ "mean"}
\CommentTok{# Shows help for mean}
\KeywordTok{help}\NormalTok{(var)}

\NormalTok{var <-}\StringTok{ }\DecValTok{10}
\CommentTok{# Shows help for var}
\KeywordTok{help}\NormalTok{(var)}
\end{Highlighting}
\end{Shaded}

  \texttt{ls()}, \texttt{page()}, and \texttt{match.fun()} work
  similarly.
\end{itemize}

Another important class of quoting functions are the base modelling and
plotting functions, which follow the so-called standard non-standard
evaluation rules:
\url{http://developer.r-project.org/nonstandard-eval.pdf}. For example,
\texttt{lm()} quotes the \texttt{weight} and \texttt{subset} arguments,
and when used with a formula argument, the plotting function quotes the
aesthetic arguments (\texttt{col}, \texttt{cex}, etc):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{palette}\NormalTok{(RColorBrewer}\OperatorTok{::}\KeywordTok{brewer.pal}\NormalTok{(}\DecValTok{3}\NormalTok{, }\StringTok{"Set1"}\NormalTok{))}
\KeywordTok{plot}\NormalTok{(}
  \DataTypeTok{data =}\NormalTok{ iris, }
\NormalTok{  Sepal.Length }\OperatorTok{~}\StringTok{ }\NormalTok{Petal.Length, }\DataTypeTok{col =}\NormalTok{ Species, }
  \DataTypeTok{pch =} \DecValTok{20}\NormalTok{, }\DataTypeTok{cex =} \DecValTok{2}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{Quotation_files/figure-latex/unnamed-chunk-59-1} \end{center}

These functions have no built-in options for indirect specification, but
you'll learn how to simulate unquoting in Section \ref{base-unquote}.

\hypertarget{tidy-dots}{%
\section{\texorpdfstring{Dot-dot-dot
(\texttt{...})}{Dot-dot-dot (...)}}\label{tidy-dots}}

\texttt{!!!} is useful because it's not uncommon to have a list of
expressions that you want to insert into a call. It turns out that this
pattern is common elsewhere. Take the following two motivating problems:

\begin{itemize}
\item
  What do you do if the elements you want to put in \texttt{...} are
  already stored in a list? For example, imagine you have a list of data
  frames that you want to \texttt{rbind()} together:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dfs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{),}
  \DataTypeTok{b =} \KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{4}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  You could solve this specific case with
  \texttt{rbind(dfs\$a,\ df\$b)}, but how do you generalise that
  solution to a list of arbitrary length?
\item
  What do you do if you want to supply the argument name indirectly? For
  example, imagine you want to create a single column data frame where
  the name of the column is specified in a variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ "x"}
\NormalTok{val <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  In this case, you could create a data frame and then change names
  (i.e. \texttt{setNames(data.frame(val),\ var)}), but this feels
  inelegant. How can we do better?
\end{itemize}

One way to think about these problems is to draw explicit parallels to
quasiquotation:

\begin{itemize}
\item
  Row-binding multiple data frames is like unquote-splicing: we want to
  inline individual elements of the list into the call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{bind_rows}\NormalTok{(}\OperatorTok{!!!}\NormalTok{dfs)}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 2}
\CommentTok{#> 2 3 4}
\end{Highlighting}
\end{Shaded}

  When used in this context, the behaviour of \texttt{!!!} is known as
  spatting in Ruby, Go, PHP, and Julia. It is closely related to
  \texttt{*args} (star-args) and \texttt{**kwarg} (star-star-kwargs) in
  Python, which are sometimes called argument unpacking.
\item
  The second problem is like unquoting the left-hand side of \texttt{=}:
  rather than interpreting \texttt{var} literally, we want to use the
  value stored in the variable called \texttt{var}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tibble}\NormalTok{(}\OperatorTok{!!}\NormalTok{var }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\NormalTok{val)}
\CommentTok{#> Warning: `list_len()` is soft-deprecated as of rlang 0.2.0.}
\CommentTok{#> Please use `new_list()` instead}
\CommentTok{#> This warning is displayed once per session.}
\CommentTok{#> # A tibble: 3 x 1}
\CommentTok{#>       x}
\CommentTok{#>   <dbl>}
\CommentTok{#> 1     4}
\CommentTok{#> 2     3}
\CommentTok{#> 3     9}
\end{Highlighting}
\end{Shaded}

  Note the use of \texttt{:=} (pronounced colon-equals) rather than
  \texttt{=}. Unfortunately we need this new operation because R's
  grammar does not allow expressions as argument names:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tibble}\NormalTok{(}\OperatorTok{!!}\DataTypeTok{var =}\NormalTok{ value)}
\CommentTok{#> Error: unexpected '=' in "tibble::tibble(!!var ="}
\end{Highlighting}
\end{Shaded}

  \texttt{:=} is like a vestigial organ: it's recognised by R's parser,
  but it doesn't have any code associated with it. It looks like an
  \texttt{=} but allows expressions on either side, making it a more
  flexible alternative to \texttt{=}. It is used in data.table for
  similar reasons.
\end{itemize}

Base R takes a different approach, which we'll come back to Section
@ref\{do-call\}.

We say functions that support these tools, without quoting arguments,
have \textbf{tidy dots}\footnote{This is admittedly not the most
  creative of names, but it clearly suggests it's something that has
  been added to R after the fact.}. To gain tidy dots behaviour in your
own function, all you need to do is use \texttt{list2()}.

\hypertarget{examples}{%
\subsection{Examples}\label{examples}}

One place we could use \texttt{list2()} is to create a wrapper around
\texttt{attributes()} that allows us to flexibly set attributes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{set_attr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.x, ...) \{}
\NormalTok{  attr <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{list2}\NormalTok{(...)}
  \KeywordTok{attributes}\NormalTok{(.x) <-}\StringTok{ }\NormalTok{attr}
\NormalTok{  .x}
\NormalTok{\}}

\NormalTok{attrs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\NormalTok{attr_name <-}\StringTok{ "z"}

\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%>%}
\StringTok{  }\KeywordTok{set_attr}\NormalTok{(}\DataTypeTok{w =} \DecValTok{0}\NormalTok{, }\OperatorTok{!!!}\NormalTok{attrs, }\OperatorTok{!!}\NormalTok{attr_name }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\DecValTok{3}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{str}\NormalTok{()}
\CommentTok{#>  int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{#>  - attr(*, "w")= num 0}
\CommentTok{#>  - attr(*, "x")= num 1}
\CommentTok{#>  - attr(*, "y")= num 2}
\CommentTok{#>  - attr(*, "z")= num 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{exec}{%
\subsection{\texorpdfstring{\texttt{exec()}}{exec()}}\label{exec}}

What if you want to use this technique with a function that doesn't have
tidy dots? One option is to use \texttt{rlang::exec()} which makes it
easy to call functions with some arguments supplied directly (in
\ldots{}) and others indirectly (in a list):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Directly}
\KeywordTok{exec}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{)}
\CommentTok{#> [1] 5.5}

\CommentTok{# Indirectly}
\NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{)}
\KeywordTok{exec}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\OperatorTok{!!!}\NormalTok{args)}
\CommentTok{#> [1] 5.5}

\CommentTok{# Mixed}
\NormalTok{params <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{)}
\KeywordTok{exec}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OperatorTok{!!!}\NormalTok{params)}
\CommentTok{#> [1] 5.5}
\end{Highlighting}
\end{Shaded}

And also makes it possible to supply argument names indirectly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arg_name <-}\StringTok{ "na.rm"}
\NormalTok{arg_val <-}\StringTok{ }\OtherTok{TRUE}
\KeywordTok{exec}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OperatorTok{!!}\NormalTok{arg_name }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\NormalTok{arg_val)}
\CommentTok{#> [1] 5.5}
\end{Highlighting}
\end{Shaded}

And finally, it's useful if you have a vector of function names or a
list of functions that you want to call with the same arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{), }\OtherTok{NA}\NormalTok{)}
\NormalTok{funs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\StringTok{"median"}\NormalTok{, }\StringTok{"sd"}\NormalTok{)}

\NormalTok{purrr}\OperatorTok{:::}\KeywordTok{map_dbl}\NormalTok{(funs, exec, x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 0.444 0.482 0.298}
\end{Highlighting}
\end{Shaded}

\texttt{exec()} is closely related to \texttt{call2()}; where
\texttt{call2()} returns an expression, \texttt{exec()} evaluates it.

\hypertarget{dots_list}{%
\subsection{\texorpdfstring{\texttt{dots\_list()}}{dots\_list()}}\label{dots_list}}

\texttt{list2()} provides one other handy feature: by default it will
ignore any empty arguments at the end. This is useful in functions like
\texttt{tibble::tibble()} because it means that you can easily change
the order of variables without worrying about the final comma:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Can easily move x to first entry:}
\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}
  \DataTypeTok{z =} \DecValTok{3}\OperatorTok{:-}\DecValTok{1}\NormalTok{,}
  \DataTypeTok{x =} \DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{,}
\NormalTok{)}

\CommentTok{# Need to remove comma from z and add comma to x}
\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}
  \DataTypeTok{z =} \DecValTok{3}\OperatorTok{:-}\DecValTok{1}\NormalTok{,}
  \DataTypeTok{x =} \DecValTok{5}\OperatorTok{:}\DecValTok{1}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{list2()} is a wrapper around \texttt{rlang::dots\_list()} with
defaults set to the most commonly used settings. You can get more
control by calling \texttt{dots\_list()} directly:

\begin{itemize}
\item
  \texttt{.ignore\_empty} allows you to control exaclty which arguments
  are ignored. The default ignores a single trailing argument to get the
  behaviour describe above, but you can choose to ignore all missing
  arguments, or no missing arguments.
\item
  \texttt{.homonoyms} controls what happens if multiple arguments use
  the same name:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{dots_list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{x =} \DecValTok{2}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ x: num 1}
\CommentTok{#>  $ x: num 2}
\KeywordTok{str}\NormalTok{(}\KeywordTok{dots_list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{x =} \DecValTok{2}\NormalTok{, }\DataTypeTok{.homonyms =} \StringTok{"first"}\NormalTok{))}
\CommentTok{#> List of 1}
\CommentTok{#>  $ x: num 1}
\KeywordTok{str}\NormalTok{(}\KeywordTok{dots_list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{x =} \DecValTok{2}\NormalTok{, }\DataTypeTok{.homonyms =} \StringTok{"last"}\NormalTok{))}
\CommentTok{#> List of 1}
\CommentTok{#>  $ x: num 2}
\KeywordTok{str}\NormalTok{(}\KeywordTok{dots_list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{x =} \DecValTok{2}\NormalTok{, }\DataTypeTok{.homonyms =} \StringTok{"error"}\NormalTok{))}
\CommentTok{#> Error: Arguments can't have the same name.}
\CommentTok{#> We found multiple arguments named `x` at positions 1 and 2}
\end{Highlighting}
\end{Shaded}
\item
  If there are empty arguments that are not ignored,
  \texttt{.preserve\_empty} controls what to do with them. The default
  throws an error; setting \texttt{.preserve\_empty\ =\ TRUE} instead
  returns missing symbols. This is useful if you're using
  \texttt{dots\_list()} to generate function calls.
\end{itemize}

\hypertarget{do-call}{%
\subsection{With base R}\label{do-call}}

Base R provides a swiss-army knife to solve these problems:
\texttt{do.call()}. \texttt{do.call()} has two main arguments. The first
argument, \texttt{what}, gives a function to call. The second argument,
\texttt{args}, is a list of arguments to pass to that function, and so
\texttt{do.call("f",\ list(x,\ y,\ z))} is equivalent to
\texttt{f(x,\ y,\ z)}.

\begin{itemize}
\item
  \texttt{do.call()} gives a straightforward solution to
  \texttt{rbind()}ing together many data frames:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{do.call}\NormalTok{(}\StringTok{"rbind"}\NormalTok{, dfs)}
\CommentTok{#>   x y}
\CommentTok{#> a 1 2}
\CommentTok{#> b 3 4}
\end{Highlighting}
\end{Shaded}
\item
  With a little more work, we can use \texttt{do.call()} to solve the
  second problem. We first create a list of arguments, then name that,
  then use \texttt{do.call()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(val)}
\KeywordTok{names}\NormalTok{(args) <-}\StringTok{ }\NormalTok{var}

\KeywordTok{do.call}\NormalTok{(}\StringTok{"data.frame"}\NormalTok{, args)}
\CommentTok{#>   x}
\CommentTok{#> 1 4}
\CommentTok{#> 2 3}
\CommentTok{#> 3 9}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Some base functions (including \texttt{interaction()},
\texttt{expand.grid()}, \texttt{options()}, and \texttt{par()}) use a
trick to avoid \texttt{do.call()}: if the first component of
\texttt{...} is a list, they'll take its components instead of looking
at the other elements of \texttt{...}. The implementation looks
something like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(dots) }\OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{&&}\StringTok{ }\KeywordTok{is.list}\NormalTok{(dots[[}\DecValTok{1}\NormalTok{]])) \{}
\NormalTok{    dots <-}\StringTok{ }\NormalTok{dots[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{  \}}
  
  \CommentTok{# Do something}
\NormalTok{  ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Another approach to avoiding \texttt{do.call()} is found in the
\texttt{RCurl::getURL()} function written by Duncan Temple Lang.
\texttt{getURL()} takes both \texttt{...} and \texttt{.opts} which are
concatenated together. This looks something like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., .dots) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\KeywordTok{list}\NormalTok{(...), .dots)}
  \CommentTok{# Do something}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

At the time I discovered it, I found this technique particularly
compelling so you can see it used throughout the tidyverse. Now,
however, I prefer the approach described next.

\hypertarget{exercises-57}{%
\subsection{Exercises}\label{exercises-57}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  One way to implement \texttt{exec()} below. Describe how it works.
  What are the key ideas?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, ..., }\DataTypeTok{.env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{list2}\NormalTok{(...)}
  \KeywordTok{do.call}\NormalTok{(f, args, }\DataTypeTok{envir =}\NormalTok{ .env)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Carefully read the source code for \texttt{interaction()},
  \texttt{expand.grid()}, and \texttt{par()}. Compare and contrast the
  techniques they use for switching between dots and list behaviour.
\item
  Explain the problem with this definition of \texttt{set\_attr()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{set_attr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{  attr <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{list2}\NormalTok{(...)}
  \KeywordTok{attributes}\NormalTok{(x) <-}\StringTok{ }\NormalTok{attr}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{set_attr}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{x =} \DecValTok{10}\NormalTok{)}
\CommentTok{#> Error in attributes(x) <- attr:}
\CommentTok{#>   attributes must be named}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{expr-case-studies}{%
\section{Case studies}\label{expr-case-studies}}

To make the ideas of quasiquotation concrete, this section contains a
few smaller case studies that show how you can use it to solve real
problems. Some of the case studies also use purrr: I find the
combination of quasiquotation and functional programming to be
particularly elegant.

Most users of quasiquotation will not involve \texttt{expr()} or
\texttt{exprs()} but will instead involve a function that calls
\texttt{enexpr()} or \texttt{enexprs()}. You should be able tell if a
function uses quasiquotation because the documentation will mention it,
and consequently if you use \texttt{enexpr()} in a documented function,
make sure to mention quasiquotation.

This technique allows you to write functions that wrap around
quasiquotation functions with a simple pattern: quote with
\texttt{enexpr()} then unquote with \texttt{!!}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cv <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(x)}
  \KeywordTok{expr}\NormalTok{(}\KeywordTok{sd}\NormalTok{(}\OperatorTok{!!}\NormalTok{x) }\OperatorTok{/}\StringTok{ }\KeywordTok{mean}\NormalTok{(}\OperatorTok{!!}\NormalTok{x))}
\NormalTok{\}}

\KeywordTok{cv}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> sd(x + y)/mean(x + y)}
\end{Highlighting}
\end{Shaded}

\hypertarget{lobstrast}{%
\subsection{\texorpdfstring{\texttt{lobstr::ast()}}{lobstr::ast()}}\label{lobstrast}}

Quasiquotation allows us to solve an annoying problem with
\texttt{lobstr::ast()}: what happens if we've already captured the
expression?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(x, y))}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(z)}
\CommentTok{#> z}
\end{Highlighting}
\end{Shaded}

Because \texttt{ast()} supports quasiquotation, we can use \texttt{!!}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\OperatorTok{!!}\NormalTok{z)}
\CommentTok{#> █─foo }
\CommentTok{#> ├─x }
\CommentTok{#> └─y}
\end{Highlighting}
\end{Shaded}

\hypertarget{map-reduce-to-generate-code}{%
\subsection{Map-reduce to generate
code}\label{map-reduce-to-generate-code}}

Quasiquotation gives us powerful tools for generating code, particularly
when combined with \texttt{purrr::map()} and \texttt{purr::reduce()}.
For example, assume you have a linear model specified by the following
coefficients:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{intercept <-}\StringTok{ }\DecValTok{10}
\NormalTok{coefs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{x1 =} \DecValTok{5}\NormalTok{, }\DataTypeTok{x2 =} \DecValTok{-4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And you want to convert it into an expression like
\texttt{10\ +\ (5\ *\ x1)\ +\ (-4\ *\ x2)}. The first thing we need to
do is turn the character names vector into a list of symbols.
\texttt{rlang::syms()} is designed precisely for this case:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{coef_sym <-}\StringTok{ }\KeywordTok{syms}\NormalTok{(}\KeywordTok{names}\NormalTok{(coefs))}
\NormalTok{coef_sym}
\CommentTok{#> [[1]]}
\CommentTok{#> x1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> x2}
\end{Highlighting}
\end{Shaded}

Next we need to combine each variable name with its coefficient. We can
do this by combining \texttt{rlang::expr()} with \texttt{purrr::map2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summands <-}\StringTok{ }\KeywordTok{map2}\NormalTok{(coef_sym, coefs, }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{.x }\OperatorTok{*}\StringTok{ }\OperatorTok{!!}\NormalTok{.y)))}
\NormalTok{summands}
\CommentTok{#> [[1]]}
\CommentTok{#> (x1 * 5)}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> (x2 * -4)}
\end{Highlighting}
\end{Shaded}

In this case, the intercept is also a part of the sum, although it
doesn't involve a multiplication. We can just add it to the start of the
\texttt{summands} vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(intercept, summands)}
\NormalTok{summands}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 10}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> (x1 * 5)}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> (x2 * -4)}
\end{Highlighting}
\end{Shaded}

Finally, we need to reduce the individual terms into a single sum by
adding the pieces together:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eq <-}\StringTok{ }\KeywordTok{reduce}\NormalTok{(summands, }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{.x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{.y))}
\NormalTok{eq}
\CommentTok{#> 10 + (x1 * 5) + (x2 * -4)}
\end{Highlighting}
\end{Shaded}

We could make this even more general by allowing the user to supply the
name of the coefficient, and instead of assuming many different
variables, index into a single one.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(y)}
\NormalTok{coef_sym <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\KeywordTok{seq_along}\NormalTok{(coefs), }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{var)[[}\OperatorTok{!!}\NormalTok{.x]]))}
\NormalTok{coef_sym}
\CommentTok{#> [[1]]}
\CommentTok{#> y[[1L]]}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> y[[2L]]}
\end{Highlighting}
\end{Shaded}

And finish by wrapping this up into a function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{linear <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(var, val) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{ensym}\NormalTok{(var)}
\NormalTok{  coef_name <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\KeywordTok{seq_along}\NormalTok{(val[}\OperatorTok{-}\DecValTok{1}\NormalTok{]), }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{var)[[}\OperatorTok{!!}\NormalTok{.x]]))}

\NormalTok{  summands <-}\StringTok{ }\KeywordTok{map2}\NormalTok{(coefs, coef_name, }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{.x }\OperatorTok{*}\StringTok{ }\OperatorTok{!!}\NormalTok{.y)))}
\NormalTok{  summands <-}\StringTok{ }\KeywordTok{c}\NormalTok{(val[[}\DecValTok{1}\NormalTok{]], summands)}

  \KeywordTok{reduce}\NormalTok{(summands, }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{.x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{.y))}
\NormalTok{\}}

\KeywordTok{linear}\NormalTok{(x, }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{-4}\NormalTok{))}
\CommentTok{#> 10 + (5 * x[[1L]]) + (-4 * x[[2L]])}
\end{Highlighting}
\end{Shaded}

Note the use of \texttt{ensym()}. We want the user to supply the name of
a single variable, not a more complex expression.

We could even make this into a function-generating function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{linear_fun <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(var, val) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{ensym}\NormalTok{(var)}
  
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{set_names}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{missing_arg}\NormalTok{()), var), }
    \KeywordTok{linear}\NormalTok{(}\OperatorTok{!!}\NormalTok{var, val),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\KeywordTok{linear_fun}\NormalTok{(x, }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{-4}\NormalTok{))}
\CommentTok{#> function (x) }
\CommentTok{#> 10 + (5 * x[[1L]]) + (-4 * x[[2L]])}
\end{Highlighting}
\end{Shaded}

\hypertarget{slicing-an-array}{%
\subsection{Slicing an array}\label{slicing-an-array}}

An occassionally useful tool missing from base R is the ability to
extract a slice of an array given a dimension and an index. For example,
we'd like to write \texttt{slice(x,\ 2,\ 1)} to extract the first slice
along the second dimension, which you can write as
\texttt{x{[},\ 1,\ {]}}. This is a moderately challenging problem
because it requires working with missing arguments.

We'll need to generate a call with multiple missing arguments.
Fortunately that's easy with \texttt{rep()} and \texttt{missing\_arg()}.
Once we have those arguments, we can unquote-splice them into a call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{indices <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{missing_arg}\NormalTok{()), }\DecValTok{3}\NormalTok{)}
\KeywordTok{expr}\NormalTok{(x[}\OperatorTok{!!!}\NormalTok{indices])}
\CommentTok{#> x[, , ]}
\end{Highlighting}
\end{Shaded}

Then we use subset-assignment to insert the index in the desired
position:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{indices[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\DecValTok{1}
\KeywordTok{expr}\NormalTok{(x[}\OperatorTok{!!!}\NormalTok{indices])}
\CommentTok{#> x[, 1, ]}
\end{Highlighting}
\end{Shaded}

We then wrap this into a function, using a couple of
\texttt{stopifnot()}s to make the interface clear:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{slice <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, along, index) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(along) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(index) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
    
\NormalTok{  nd <-}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{dim}\NormalTok{(x))}
\NormalTok{  indices <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{missing_arg}\NormalTok{()), nd)}
\NormalTok{  indices[[along]] <-}\StringTok{ }\NormalTok{index}
  
  \KeywordTok{expr}\NormalTok{(x[}\OperatorTok{!!!}\NormalTok{indices])}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\KeywordTok{sample}\NormalTok{(}\DecValTok{30}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\KeywordTok{slice}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> x[3, , ]}
\KeywordTok{slice}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> x[, 2, ]}
\KeywordTok{slice}\NormalTok{(x, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{#> x[, , 1]}
\end{Highlighting}
\end{Shaded}

A real \texttt{slice()} would evaluate the generated call, but here I
think it's more illuminating to see the code that's generated, as that's
the hard part of the challenge.

\hypertarget{new-function}{%
\subsection{Creating functions}\label{new-function}}

\index{anaphoric functions} \index{functions!anaphoric}

Another powerful application of quotation is creating functions ``by
hand'', using \texttt{rlang::new\_function()}. It's a function that
create a function from its three components (Section
\ref{function-components}) arguments, body, and (optionally)
environment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{new_function}\NormalTok{(}
  \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ , }\DataTypeTok{y =}\NormalTok{ ), }
  \KeywordTok{expr}\NormalTok{(\{x }\OperatorTok{+}\StringTok{ }\NormalTok{y\})}
\NormalTok{)}
\CommentTok{#> function (x, y) }
\CommentTok{#> \{}
\CommentTok{#>     x + y}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

One use of \texttt{new\_function()} is as an alternative to function
factories with scalar or symbol arguments. For example, we could write a
function that generates functions that raise a function to the power of
a number.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(exponent) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ ), }
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      x }\OperatorTok{^}\StringTok{ }\OperatorTok{!!}\NormalTok{exponent}
\NormalTok{    \}), }
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\KeywordTok{power}\NormalTok{(}\FloatTok{0.5}\NormalTok{)}
\CommentTok{#> function (x) }
\CommentTok{#> \{}
\CommentTok{#>     x^0.5}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

(Note that \texttt{power()} is not a quotating function. It inlines the
\emph{value} of \texttt{exponent}, not the expression that generates
it.)

Another application of \texttt{new\_function()} for functions that work
like \texttt{graphics::curve()}. \texttt{curve()} allows you to plot a
mathematical expression, without creating a function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{curve}\NormalTok{(}\KeywordTok{sin}\NormalTok{(}\KeywordTok{exp}\NormalTok{(}\DecValTok{4} \OperatorTok{*}\StringTok{ }\NormalTok{x)), }\DataTypeTok{n =} \DecValTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{Quotation_files/figure-latex/curve-demo-1} \end{center}

Here \texttt{x} is a pronoun: it doesn't represent a single concrete
value, but is instead a placeholder that varies over the range of the
plot. One way to implement \texttt{curve()} is to turn that expression
into a function with a single argument, \texttt{x}, then call that
function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{curve2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{n =} \DecValTok{100}\NormalTok{) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(expr)}
\NormalTok{  f <-}\StringTok{ }\KeywordTok{new_function}\NormalTok{(}\KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ ), expr)}
  
\NormalTok{  x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(xlim[}\DecValTok{1}\NormalTok{], xlim[}\DecValTok{2}\NormalTok{], }\DataTypeTok{length =}\NormalTok{ n)}
\NormalTok{  y <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x)}

  \KeywordTok{plot}\NormalTok{(x, y, }\DataTypeTok{type =} \StringTok{"l"}\NormalTok{, }\DataTypeTok{ylab =} \KeywordTok{expr_text}\NormalTok{(expr))}
\NormalTok{\}}
\KeywordTok{curve2}\NormalTok{(}\KeywordTok{sin}\NormalTok{(}\KeywordTok{exp}\NormalTok{(}\DecValTok{4} \OperatorTok{*}\StringTok{ }\NormalTok{x)), }\DataTypeTok{n =} \DecValTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Functions, like \texttt{curve()}, that use an expression containing a
pronoun are known as \textbf{anaphoric} functions\footnote{Anaphoric
  comes from the linguistics term ``anaphora'', an expression that is
  context dependent. Anaphoric functions are found in
  \href{http://www.arcfn.com/doc/anaphoric.html}{Arc} (a LISP like
  language),
  \href{http://www.perlmonks.org/index.pl?node_id=666047}{Perl}, and
  \href{http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit}{Clojure}.}.

\hypertarget{exercises-58}{%
\subsection{Exercises}\label{exercises-58}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In the linear-model example, we could replace the \texttt{expr()} in
  \texttt{reduce(summands,\ \textasciitilde{}\ expr(!!.x\ +\ !!.y))}
  with \texttt{call2()}: \texttt{reduce(summands,\ call2,\ "+")}.
  Compare and constrast the two approaches. Which do you think is easier
  to read?
\item
  Re-implement the Box-Cox transform defined below using unquoting and
  \texttt{new\_function()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bc <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lambda) \{}
  \ControlFlowTok{if}\NormalTok{ (lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{log}\NormalTok{(x)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{^}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{lambda}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Re-implement the simple \texttt{compose()} defined below using
  quasiquotation and \texttt{new\_function()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compose <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, g) \{}
  \ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(...))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{evaluation}{%
\chapter{Evaluation}\label{evaluation}}

\hypertarget{introduction-17}{%
\section{Introduction}\label{introduction-17}}

The user-facing inverse of quotation is unquotation: it gives the
\emph{user} the ability to selectively evaluate parts of an otherwise
quoted argument. The developer-facing complement of quotation is
evaluation: this gives the \emph{developer} the ability to evaluate
quoted expressions in custom environments to achieve specific goals.

This chapter begins with a discussion of evaluation in its purest form
with \texttt{rlang::eval\_bare()} which evaluates an expression in given
environment. We'll then see how these ideas are used to implement a
handful of base R functions, and then learn about the similar
\texttt{base::eval()}.

The meat of the chapter focusses on extensions needed to implement
evaluation robustly. There are two big new ideas:

\begin{itemize}
\item
  We need a new data structure that captures both the expression
  \textbf{and} the environment associated with each function argument.
  We call this data structure a \textbf{quosure}.
\item
  \texttt{base::eval()} supports evaluating an expression in the context
  of a data frame and an environment. We formalise this idea by naming
  it the \textbf{data mask} and introduce the idea of data pronouns to
  resolve the ambiguity it creates.
\end{itemize}

Together, quasiquotation, quosures, and data masks form what we call
\textbf{tidy evaluation}, or tidy eval for short. Tidy eval provides a
principled approach to NSE that makes it possible to use such functions
both interactively and embedded with other functions. We'll finish off
the chapter showing the basic pattern you use to wrap quasiquoting
functions, and how you can adapt that pattern to base R NSE functions.

\hypertarget{outline-15}{%
\subsection*{Outline}\label{outline-15}}
\addcontentsline{toc}{subsection}{Outline}

\hypertarget{prerequisites-11}{%
\subsection*{Prerequisites}\label{prerequisites-11}}
\addcontentsline{toc}{subsection}{Prerequisites}

As well as the ideas in the previous two chapters, environments play a
very important role in evaluation, so make sure you're familiar with the
basics in Chapter \ref{environments}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\KeywordTok{library}\NormalTok{(purrr)}
\CommentTok{#> }
\CommentTok{#> Attaching package: 'purrr'}
\CommentTok{#> The following objects are masked from 'package:rlang':}
\CommentTok{#> }
\CommentTok{#>     %@%, %||%, as_function, flatten, flatten_chr,}
\CommentTok{#>     flatten_dbl, flatten_int, flatten_lgl, invoke,}
\CommentTok{#>     list_along, modify, prepend, rep_along, splice}
\end{Highlighting}
\end{Shaded}

\hypertarget{eval}{%
\section{Evaluation basics}\label{eval}}

In the previous chapter, we briefly mentioned \texttt{eval()}. Here,
however, we're going to start with \texttt{rlang::eval\_bare()} which is
the purest evocation of the idea of evaluation. It has two arguments:
\texttt{expr} and \texttt{env}.

The first argument, \texttt{expr}, is an expression to evaluate. This
will usually be either a symbol or expression. None of the evaluation
functions quote their inputs, so you'll usually use them with
\texttt{expr()} or similar:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\KeywordTok{eval_bare}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x))}
\CommentTok{#> [1] 10}

\NormalTok{y <-}\StringTok{ }\DecValTok{2}
\KeywordTok{eval_bare}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y))}
\CommentTok{#> [1] 12}
\end{Highlighting}
\end{Shaded}

All other objects yield themselves when evaluated:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval_bare}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 10}

\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\KeywordTok{eval_bare}\NormalTok{(f)}
\CommentTok{#> function(x) x + 1}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{)}
\KeywordTok{eval_bare}\NormalTok{(df)}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 2}
\end{Highlighting}
\end{Shaded}

The second argument, \texttt{env}, gives the environment in which the
expression should be evaluated, i.e.~where should the values of
\texttt{x}, \texttt{y}, and \texttt{+} be looked for? By default, this
is the current environment, i.e.~the calling environment of
\texttt{eval\_bare()}, but you can override it if you want:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval_bare}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1000}\NormalTok{))}
\CommentTok{#> [1] 1002}
\end{Highlighting}
\end{Shaded}

Because R looks up functions in the same way as variables, we can also
override the meaning of functions. This is a very useful technique if
you want to translate R code into something else, as you'll learn about
Chapter \ref{translation}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval_bare}\NormalTok{(}
  \KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }
  \KeywordTok{env}\NormalTok{(}\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{ =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\KeywordTok{paste0}\NormalTok{(x, }\StringTok{" + "}\NormalTok{, y))}
\NormalTok{)}
\CommentTok{#> [1] "10 + 2"}
\end{Highlighting}
\end{Shaded}

Note that the first argument to \texttt{eval\_bare()} (and to
\texttt{base::eval()}) is evaluated, not quoted. This can lead to
confusing results if you forget to quote the input:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval_bare}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> [1] 12}
\KeywordTok{eval_bare}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y, }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1000}\NormalTok{))}
\CommentTok{#> [1] 12}
\end{Highlighting}
\end{Shaded}

Now that you've seen the basics, let's explore some applications. We'll
focus primarily on base R functions that you might have used before; now
you can learn how they work. To focus on the underlying principles,
we'll extract out their essence, and rewrite to use rlang functions.
Once you've seen some applications, we'll circle back and talk more
about \texttt{base::eval()}.

\hypertarget{application-local}{%
\subsection{\texorpdfstring{Application:
\texttt{local()}}{Application: local()}}\label{application-local}}

\index{local()}

Sometimes you want to perform a chunk of calculation that creates a
bunch of intermediate variables. The intermediate variables have no
long-term use and could be quite large, so you'd rather not keep them
around. One approach is to clean up after yourself using \texttt{rm()};
another approach is to wrap the code in a function, and just call it
once. A more elegant approach is to use \texttt{local()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Clean up variables created earlier}
\KeywordTok{rm}\NormalTok{(x, y)}

\NormalTok{foo <-}\StringTok{ }\KeywordTok{local}\NormalTok{(\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{10}
\NormalTok{  y <-}\StringTok{ }\DecValTok{200}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\NormalTok{\})}

\NormalTok{foo}
\CommentTok{#> [1] 210}
\NormalTok{x}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'x' not found}
\NormalTok{y}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'y' not found}
\end{Highlighting}
\end{Shaded}

The essence of \texttt{local()} is quite simple. We capture the input
expression, and create a new environment in which to evaluate it. This
inherits from the caller environment so it can access the current
lexical scope.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{local2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  env <-}\StringTok{ }\KeywordTok{child_env}\NormalTok{(}\KeywordTok{caller_env}\NormalTok{())}
  \KeywordTok{eval_bare}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(expr), env)}
\NormalTok{\}}

\NormalTok{foo <-}\StringTok{ }\KeywordTok{local2}\NormalTok{(\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{10}
\NormalTok{  y <-}\StringTok{ }\DecValTok{200}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\NormalTok{\})}

\NormalTok{foo}
\CommentTok{#> [1] 210}
\NormalTok{x}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'x' not found}
\NormalTok{y}
\CommentTok{#> Error in eval(expr, envir, enclos):}
\CommentTok{#>   object 'y' not found}
\end{Highlighting}
\end{Shaded}

Understanding how \texttt{base::local()} works is harder, as it uses
\texttt{eval()} and \texttt{substitute()} together in rather complicated
ways. Figuring out exactly what's going on is good practice if you
really want to understand the subtleties of \texttt{substitute()} and
the base \texttt{eval()} functions, so is included in the exercises
below.

\hypertarget{application-source}{%
\subsection{\texorpdfstring{Application:
\texttt{source()}}{Application: source()}}\label{application-source}}

\index{source()}

We can create a simple version of \texttt{source()} by combining
\texttt{parse\_expr()} and \texttt{eval\_bare()}. We read in the file
from disk, use \texttt{parse\_expr()} to parse the string into a list of
expressions, and then use \texttt{eval\_bare()} to evaluate each
component in turn. This version evaluates the code in the caller
environment, and invisibly returns the result of the last expression in
the file like \texttt{source()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{source2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(path, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  file <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{readLines}\NormalTok{(path, }\DataTypeTok{warn =} \OtherTok{FALSE}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  exprs <-}\StringTok{ }\KeywordTok{parse_exprs}\NormalTok{(file)}

\NormalTok{  res <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(exprs)) \{}
\NormalTok{    res <-}\StringTok{ }\KeywordTok{eval_bare}\NormalTok{(exprs[[i]], env)}
\NormalTok{  \}}
  
  \KeywordTok{invisible}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The real \texttt{source()} is considerably more complicated because it
can \texttt{echo} input and output, and has many other settings that
control its behaviour.

\hypertarget{gotcha-function}{%
\subsection{\texorpdfstring{Gotcha:
\texttt{function()}}{Gotcha: function()}}\label{gotcha-function}}

There's one small gotcha that you should be aware of if you're using
\texttt{eval\_bare()} and \texttt{expr()} to generate functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{y <-}\StringTok{ }\DecValTok{20}
\NormalTok{f <-}\StringTok{ }\KeywordTok{eval_bare}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x, y) }\OperatorTok{!!}\NormalTok{x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{y))}
\NormalTok{f}
\CommentTok{#> function(x, y) !!x + !!y}
\end{Highlighting}
\end{Shaded}

This function doesn't look like it will work, but it does:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> [1] 30}
\end{Highlighting}
\end{Shaded}

This is because, if available, functions print their \texttt{srcref}.
The source reference is a base R feature that doesn't know about
quasiquotation. To work around this problem, I recommend using
\texttt{new\_function()} as shown in the previous chapter.
Alternatively, you can remove the \texttt{srcref} attribute:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attr}\NormalTok{(f, }\StringTok{"srcref"}\NormalTok{) <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{f}
\CommentTok{#> function (x, y) }
\CommentTok{#> 10 + 20}
\end{Highlighting}
\end{Shaded}

\hypertarget{evaluation-vs.unquotation}{%
\subsection{Evaluation
vs.~unquotation}\label{evaluation-vs.unquotation}}

Evaluation provides an alternative to unquoting.

Popularised by data.table (Dowle and Srinivasan
\protect\hyperlink{ref-data.table}{2018})

Notice the difference in timing; need to make sure the expression is
stored in a variable with a different name to anything in the dataset.

\hypertarget{base-r}{%
\subsection{Base R}\label{base-r}}

The base function equivalent to \texttt{eval\_bare()} is the
two-argument form of \texttt{eval()}: \texttt{eval(expr,\ envir)}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1000}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] 1001}
\end{Highlighting}
\end{Shaded}

The final argument, \texttt{enclos}, provides support for data masks,
which you'll learn about in Section \ref{tidy-evaluation}.

\texttt{eval()} is paired with two helper functions:

\begin{itemize}
\item
  \texttt{evalq(x,\ env)} quotes its first argument, and is hence a
  shortcut for \texttt{eval(quote(x),\ env)}.
\item
  \texttt{eval.parent(expr,\ n)} is a shortcut for
  \texttt{eval(expr,\ env\ =\ parent.frame(n))}.
\end{itemize}

In most cases, there is no reason to prefer \texttt{rlang::eval\_bare()}
over \texttt{eval()}; I just used it here because it's a more minimal
interface.

\textbf{Expression vectors}

\texttt{base::eval()} has special behaviour for expression
\emph{vectors}, evaluating each component in turn. This makes for a very
compact implementation of \texttt{source2()} because
\texttt{base::parse()} also returns an expression object:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{source3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(file, }\DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{()) \{}
\NormalTok{  lines <-}\StringTok{ }\KeywordTok{parse}\NormalTok{(file)}
\NormalTok{  res <-}\StringTok{ }\KeywordTok{eval}\NormalTok{(lines, }\DataTypeTok{envir =}\NormalTok{ env)}
  \KeywordTok{invisible}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

While \texttt{source3()} is considerably more concise than
\texttt{source2()}, this one use case is the strongest argument for
expression objects, and overall we don't believe this one benefit
outweighs the cost of introducing a new data structure. That's why this
book has relegated expression vectors to a secondary role.

\hypertarget{exercises-59}{%
\subsection{Exercises}\label{exercises-59}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Carefully read the documentation for \texttt{source()}. What
  environment does it use by default? What if you supply
  \texttt{local\ =\ TRUE}? How do you provide a custom argument?
\item
  Predict the results of the following lines of code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{))))))}
\KeywordTok{eval}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)))))))}
\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)))))))}
\end{Highlighting}
\end{Shaded}
\item
  Write an equivalent to \texttt{get()} using \texttt{sym()} and
  \texttt{eval\_bare()}. Write an equivalent to \texttt{assign()} using
  \texttt{sym()}, \texttt{expr()}, and \texttt{eval\_bare()}. (Don't
  worry about the multiple ways of choosing an environment that
  \texttt{get()} and \texttt{assign()} support; assume that the user
  supplies it explicitly.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# name is a string}
\NormalTok{get2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, env) \{\}}
\NormalTok{assign2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, value, env) \{\}}
\end{Highlighting}
\end{Shaded}
\item
  Modify \texttt{source2()} so it returns the result of \emph{every}
  expression, not just the last one. Can you eliminate the for loop?
\item
  The code generated by \texttt{source2()} lacks source references. Read
  the source code for \texttt{sys.source()} and the help for
  \texttt{srcfilecopy()}, then modify \texttt{source2()} to preserve
  source references. You can test your code by sourcing a function that
  contains a comment. If successful, when you look at the function,
  you'll see the comment and not just the source code.
\item
  We can make \texttt{base::local()} slightly easier to understand by
  spreading out over multiple lines:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{local3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{envir =} \KeywordTok{new.env}\NormalTok{()) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(expr), envir))}
  \KeywordTok{eval}\NormalTok{(call, }\DataTypeTok{envir =} \KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

  Explain how \texttt{local()} works in words. (Hint: you might want to
  \texttt{print(call)} to help understand what \texttt{substitute()} is
  doing, and read the documentation to remind yourself what environment
  \texttt{new.env()} will inherit from.)
\end{enumerate}

\hypertarget{quosures}{%
\section{Quosures}\label{quosures}}

The simplest form of evaluation combines an expression and an
environment. This coupling is so important that it's useful to develop a
data structure that can hold both pieces.

To fill this gap, rlang provides the \textbf{quosure}, an object that
contains an expression and an environment. The name is a portmanteau of
quoting and closure, because a quosure both quotes the expression and
encloses the environment. Quosures reify the internal promise object
(Section \ref{promise}) into something that you can program with.

In this section, you'll learn how to create and manipulate quosures, and
a little about how they are implemented.

\hypertarget{creating}{%
\subsection{Creating}\label{creating}}

There are three ways to create quosures:

\begin{itemize}
\item
  Use \texttt{enquo()} and \texttt{enquos()} to capture user-supplied
  expressions, as shown above. The vast majority of quosures should be
  created this way.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{enquo}\NormalTok{(x)}
\KeywordTok{foo}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b)}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^a + b}
\CommentTok{#> env:  global}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{quo()} and \texttt{quos()} exist to match to \texttt{expr()}
  and \texttt{exprs()}, but they are included only for the sake of
  completeness and are needed very rarely.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{quo}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x + y + z}
\CommentTok{#> env:  global}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{new\_quosure()} create a quosures from its components: an
  expression and an environment. This is rarely needed in practice, but
  is useful for learning about the system so are over represented in
  this chapter.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{10}\NormalTok{))}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x + y}
\CommentTok{#> env:  0x6effa80}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\hypertarget{evaluating}{%
\subsection{Evaluating}\label{evaluating}}

Evaluate a quosure with \texttt{eval\_tidy()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q1 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{10}\NormalTok{))}
\KeywordTok{eval_tidy}\NormalTok{(q1)}
\CommentTok{#> [1] 11}
\end{Highlighting}
\end{Shaded}

Compared to \texttt{eval\_bare()}, which has separate arguments
expression and environment, \texttt{eval\_tidy()} expects them to be
bundled into a single object: a quosure. (\texttt{eval\_tidy()} does
have an \texttt{env} argument, but it's only needed in very special
cases.)

For this simple case, \texttt{eval\_tidy()} is basically a shortcut for
\texttt{eval\_bare()} using the expression and environment stored in the
quosure. But \texttt{eval\_tidy()} does much more. As well as providing
data masks, which you'll learn about shortly, it also allows you to
embedded quosures anywhere in the AST.

Take this example, which inlines two quosures into an expression:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q2 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{))}
\NormalTok{q3 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{))}

\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{q2 }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{q3)}
\end{Highlighting}
\end{Shaded}

It evaluates correctly with \texttt{eval\_tidy()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval_tidy}\NormalTok{(x)}
\CommentTok{#> [1] 11}
\end{Highlighting}
\end{Shaded}

Even though when you print it, you only see the \texttt{x}s:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\CommentTok{#> (~x) + ~x}
\end{Highlighting}
\end{Shaded}

When printing an expression containing quosures, you'll see
\texttt{\textasciitilde{}} in front of each quosure. That's because, as
you'll learn next, quosures are implemented using formulas. You can get
a better display with \texttt{rlang::expr\_print()} (Section
\ref{non-standard-ast}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr_print}\NormalTok{(x)}
\CommentTok{#> (^x) + (^x)}
\end{Highlighting}
\end{Shaded}

When you use \texttt{expr\_print()} in the console, quosures are
coloured according to their environment, making it easier to spot when
symbols are bound to different variables.

\hypertarget{dots}{%
\subsection{Dots}\label{dots}}

Quosures are typically just a convenience: they make code cleaner by
bundling together an expression and its environment. They are, however,
essential when it comes to working with \texttt{...} because it's
possible for each argument passed to \ldots{} to have a different
environment associated with it. In the following example note that both
quosures have the same expression, \texttt{x}, but a different
environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{1}
  \KeywordTok{g}\NormalTok{(..., }\DataTypeTok{f =}\NormalTok{ x)}
\NormalTok{\}}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
  \KeywordTok{enquos}\NormalTok{(...)}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\DecValTok{0}
\NormalTok{qs <-}\StringTok{ }\KeywordTok{f}\NormalTok{(}\DataTypeTok{global =}\NormalTok{ x)}
\NormalTok{qs}
\CommentTok{#> <list_of<quosure>>}
\CommentTok{#> }
\CommentTok{#> $global}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x}
\CommentTok{#> env:  global}
\CommentTok{#> }
\CommentTok{#> $f}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x}
\CommentTok{#> env:  0x566b038}
\end{Highlighting}
\end{Shaded}

That means that when you evaluate them, you get the correct results:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map}\NormalTok{(qs, eval_tidy)}
\CommentTok{#> $global}
\CommentTok{#> [1] 0}
\CommentTok{#> }
\CommentTok{#> $f}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{quosure-impl}{%
\subsection{Under the hood}\label{quosure-impl}}

Quosures were inspired by R's formulas, because formulas capture an
expression and an environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ErrorTok{~}\KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\KeywordTok{str}\NormalTok{(f)}
\CommentTok{#> Class 'formula'  language ~runif(3)}
\CommentTok{#>   ..- attr(*, ".Environment")=<environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

Quosures are a subclass of formulas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q4 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z))}
\KeywordTok{class}\NormalTok{(q4)}
\CommentTok{#> [1] "quosure" "formula"}
\end{Highlighting}
\end{Shaded}

More precisely, this makes them a call to \texttt{\textasciitilde{}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_call}\NormalTok{(q4)}
\CommentTok{#> [1] TRUE}

\NormalTok{q4[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> `~`}
\NormalTok{q4[[}\DecValTok{2}\NormalTok{]]}
\CommentTok{#> x + y + z}
\end{Highlighting}
\end{Shaded}

With an attribute that stores the environment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attr}\NormalTok{(q4, }\StringTok{".environent"}\NormalTok{)}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

If you need to extract the expression or environment, don't rely on the
precise details of the implementation. Instead use the
\texttt{quo\_get\_} helpers which provide a convenient interface:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{quo_get_env}\NormalTok{(q4)}
\CommentTok{#> <environment: R_GlobalEnv>}
\KeywordTok{quo_get_expr}\NormalTok{(q4)}
\CommentTok{#> x + y + z}
\end{Highlighting}
\end{Shaded}

An early version of tidy evaluation used formulas instead of quosures,
as an attractive feature of \texttt{\textasciitilde{}} is that it
provides quoting with a single keystroke. Unfortunately, however, there
is no clean way to make \texttt{\textasciitilde{}} a quasiquoting
function.

\hypertarget{exercises-60}{%
\subsection{Exercises}\label{exercises-60}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Predict what evaluating each of the following quosures will return.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q1 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{))}
\NormalTok{q1}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x}
\CommentTok{#> env:  0x6df5580}

\NormalTok{q2 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{q1), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{))}
\NormalTok{q2}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x + (^x)}
\CommentTok{#> env:  0x6fc3400}

\NormalTok{q3 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{q2), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{100}\NormalTok{))}
\NormalTok{q3}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x + (^x + (^x))}
\CommentTok{#> env:  0x7293d60}
\end{Highlighting}
\end{Shaded}
\item
  Write an \texttt{enenv()} function that captures the environment
  associated with an argument.
\end{enumerate}

\hypertarget{data-masks}{%
\section{Data masks}\label{data-masks}}

So far, you've learned about quosures and \texttt{eval\_tidy()}. In this
section, you'll learn about the \textbf{data mask}, a data frame where
the evaluated code will look first for variable definitions. The data
mask is the key idea that powers base functions like \texttt{with()},
\texttt{subset()} and \texttt{transform()}, and is used throughout the
tidyverse in functions like \texttt{dplyr::arrange()} and
\texttt{ggplot2::aes()}.

\hypertarget{basics-3}{%
\subsection{Basics}\label{basics-3}}

The data mask allows you to mingle variables from an environment and and
data frame in a single expression. You supply the data mask as the
second argument to \texttt{eval\_tidy()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q1 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{*}\StringTok{ }\NormalTok{y), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{100}\NormalTok{))}
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}

\KeywordTok{eval_tidy}\NormalTok{(q1, df)}
\CommentTok{#>  [1]  100  200  300  400  500  600  700  800  900 1000}
\end{Highlighting}
\end{Shaded}

But there's a lot of syntax here because we're creating everything from
scratch. It's easier to see what's going on if we make a little wrapper.
I call this \texttt{with2()} because it's equivalent to
\texttt{base::with()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, expr) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(expr)}
  \KeywordTok{eval_tidy}\NormalTok{(expr, data)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can now rewrite the code above as below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\KeywordTok{with2}\NormalTok{(df, x }\OperatorTok{*}\StringTok{ }\NormalTok{y)}
\CommentTok{#>  [1]  10  20  30  40  50  60  70  80  90 100}
\end{Highlighting}
\end{Shaded}

\texttt{base::eval()} has similar functionality, although it doesn't
call it a data mask. Instead you can supply a data frame to the
\texttt{envir} argument and an environment to the \texttt{enclos}
argument. That gives the following basic implementation of
\texttt{with()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, expr) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(expr)}
  \KeywordTok{eval}\NormalTok{(expr, data, }\DataTypeTok{enclos =} \KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Compared to \texttt{eval\_tidy()} you have to manage the expression and
environment separately, and while it's usally correct, there's no
guarantee that the \texttt{parent.frame()} (aka the caller environment)
is the correct environment.

\hypertarget{pronouns}{%
\subsection{Pronouns}\label{pronouns}}

The data mask introduces ambiguity. For example, in the following code
you can't know whether \texttt{x} will come from the data mask or the
environment, unless you know what variables are found in \texttt{df.}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with2}\NormalTok{(df, x)}
\end{Highlighting}
\end{Shaded}

That makes code harder to reason about (because you need to know more
context), and can introduce bugs. To resolve that issue, the data mask
provides two two pronouns: \texttt{.data} and \texttt{.env}.

\begin{itemize}
\tightlist
\item
  \texttt{.data\$x} always refers to \texttt{x} in the data mask, or
  dies trying.
\item
  \texttt{.env\$x} always refers to \texttt{x} in the environment, or
  dies trying.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{2}\NormalTok{)}

\KeywordTok{with2}\NormalTok{(df, .data}\OperatorTok{$}\NormalTok{x)}
\CommentTok{#> [1] 2}
\KeywordTok{with2}\NormalTok{(df, .env}\OperatorTok{$}\NormalTok{x)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

You can also subset using \texttt{{[}{[}}. Otherwise the pronouns are
special objects and you shouldn't expect them to behave like data frames
or environments.

These also are safe in the sense that they error if the object isn't
found:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with2}\NormalTok{(df, .data}\OperatorTok{$}\NormalTok{y)}
\CommentTok{#> Error: Column `y` not found in `.data`}
\end{Highlighting}
\end{Shaded}

Pronouns are particularly important when using tidy evaluation, and
we'll come back to them in Section \ref{pronouns}.

\hypertarget{subset}{%
\subsection{\texorpdfstring{Application:
\texttt{subset()}}{Application: subset()}}\label{subset}}

We'll explore tidy evaluation in the context of \texttt{base::subset()},
because it's a simple yet powerful function that encapsulates one of the
central ideas that makes R so elegant for data analysis. If you haven't
used it before, \texttt{subset()}, like \texttt{dplyr::filter()},
provides a convenient way of selecting rows of a data frame. You give it
some data, along with an expression that is evaluated in the context of
that data. This considerably reduces the number of times you need to
type the name of the data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sample_df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{b =} \DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{, }\DataTypeTok{c =} \KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{))}

\CommentTok{# Shorthand for sample_df[sample_df$a >= 4, ]}
\KeywordTok{subset}\NormalTok{(sample_df, a }\OperatorTok{>=}\StringTok{ }\DecValTok{4}\NormalTok{)}
\CommentTok{#>   a b c}
\CommentTok{#> 4 4 2 4}
\CommentTok{#> 5 5 1 1}

\CommentTok{# Shorthand for sample_df[sample_df$b == sample_df$c, ]}
\KeywordTok{subset}\NormalTok{(sample_df, b }\OperatorTok{==}\StringTok{ }\NormalTok{c)}
\CommentTok{#>   a b c}
\CommentTok{#> 1 1 5 5}
\CommentTok{#> 5 5 1 1}
\end{Highlighting}
\end{Shaded}

The core of our version of \texttt{subset()}, \texttt{subset2()}, is
quite simple. It takes two arguments: a data frame, \texttt{data}, and
an expression, \texttt{rows}. We evaluate \texttt{rows} using
\texttt{df} as a data mask, then use the results to subset the data
frame with \texttt{{[}}. I've included a very simple check to ensure the
result is a logical vector; real code would do more to create an
informative error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subset2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, rows) \{}
\NormalTok{  rows <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(rows)}
  
\NormalTok{  rows_val <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(rows, data)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.logical}\NormalTok{(rows_val))}
  
\NormalTok{  data[rows_val, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}

\KeywordTok{subset2}\NormalTok{(sample_df, b }\OperatorTok{==}\StringTok{ }\NormalTok{c)}
\CommentTok{#>   a b c}
\CommentTok{#> 1 1 5 5}
\CommentTok{#> 5 5 1 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{application-transform}{%
\subsection{Application: transform}\label{application-transform}}

A more complicated situation is \texttt{base::transform()} which allows
you to add new variables to data frame, evaluating their expressions in
the context of the existing variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{runif}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\KeywordTok{transform}\NormalTok{(df, }\DataTypeTok{x =} \OperatorTok{-}\NormalTok{x, }\DataTypeTok{y2 =} \DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{y)}
\CommentTok{#>    x     y   y2}
\CommentTok{#> 1 -2 0.773 1.55}
\CommentTok{#> 2 -3 0.875 1.75}
\CommentTok{#> 3 -1 0.175 0.35}
\end{Highlighting}
\end{Shaded}

Implementing \texttt{transform2()} is again quite straightforward. We
capture the unevalated \texttt{...} with \texttt{enquos(...)}, and then
evaluate each expression using a for loop. Real code would need to do
more error checking, ensure that each input is named, and evaluates to a
vector the same length as \texttt{data}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{transform2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.data, ..., }\DataTypeTok{.na.last =} \OtherTok{TRUE}\NormalTok{) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{enquos}\NormalTok{(...)}
  
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(dots)) \{}
\NormalTok{    name <-}\StringTok{ }\KeywordTok{names}\NormalTok{(dots)[[i]]}
\NormalTok{    dot <-}\StringTok{ }\NormalTok{dots[[i]]}
    
\NormalTok{    .data[[name]] <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(dot, }\DataTypeTok{data =}\NormalTok{ .data)}
\NormalTok{  \}}
  
\NormalTok{  .data}
\NormalTok{\}}

\KeywordTok{transform2}\NormalTok{(df, }\DataTypeTok{x2 =}\NormalTok{ x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{, }\DataTypeTok{y =} \OperatorTok{-}\NormalTok{y)}
\CommentTok{#>   x      y x2}
\CommentTok{#> 1 2 -0.773  4}
\CommentTok{#> 2 3 -0.875  6}
\CommentTok{#> 3 1 -0.175  2}
\end{Highlighting}
\end{Shaded}

Note that I named the first argument \texttt{.data}. This avoids
problems if the user tried to create a variable called \texttt{data};
similar to the reasoning that leads to \texttt{map()} having \texttt{.x}
and \texttt{.f} arguments (Section \ref{argument-names}).

\hypertarget{application-select}{%
\subsection{\texorpdfstring{Application:
\texttt{select()}}{Application: select()}}\label{application-select}}

Typically, the data mask will be a data frame. But it's sometimes useful
to provide a list filled with more exotic contents. This is basically
how the \texttt{select} argument \texttt{base::subset()} works. It
allows you to refer to variables as if they were numbers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{, }\DataTypeTok{d =} \DecValTok{4}\NormalTok{, }\DataTypeTok{e =} \DecValTok{5}\NormalTok{)}
\KeywordTok{subset}\NormalTok{(df, }\DataTypeTok{select =}\NormalTok{ b}\OperatorTok{:}\NormalTok{d)}
\CommentTok{#>   b c d}
\CommentTok{#> 1 2 3 4}
\end{Highlighting}
\end{Shaded}

The key idea is to create a named list where each component gives the
position of the corresponing variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vars <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(}\KeywordTok{seq_along}\NormalTok{(df), }\KeywordTok{names}\NormalTok{(df)))}
\KeywordTok{str}\NormalTok{(vars)}
\CommentTok{#> List of 5}
\CommentTok{#>  $ a: int 1}
\CommentTok{#>  $ b: int 2}
\CommentTok{#>  $ c: int 3}
\CommentTok{#>  $ d: int 4}
\CommentTok{#>  $ e: int 5}
\end{Highlighting}
\end{Shaded}

Then it's a straight application of \texttt{enquo()} and
\texttt{eval\_tidy()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{select2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, ...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{enquos}\NormalTok{(...)}
  
\NormalTok{  vars <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(}\KeywordTok{seq_along}\NormalTok{(data), }\KeywordTok{names}\NormalTok{(data)))}
\NormalTok{  cols <-}\StringTok{ }\KeywordTok{unlist}\NormalTok{(}\KeywordTok{map}\NormalTok{(dots, eval_tidy, }\DataTypeTok{data =}\NormalTok{ vars))}
  
\NormalTok{  df[, cols, drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}
\KeywordTok{select2}\NormalTok{(df, b}\OperatorTok{:}\NormalTok{d)}
\CommentTok{#>   b c d}
\CommentTok{#> 1 2 3 4}
\end{Highlighting}
\end{Shaded}

\texttt{dplyr::select()} takes this idea and runs with it, providing a
number of helpers that allow you to select variables based on their
names (e.g. \texttt{starts\_with("x")}, \texttt{ends\_with("\_a"})).

\hypertarget{exercises-61}{%
\subsection{Exercises}\label{exercises-61}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What the difference between using a for loop and a map function in
  \texttt{transform2()}? Consider
  \texttt{transform2(df,\ x\ =\ x\ *\ 2,\ x\ =\ x\ *\ 2)}.
\item
  Here's an alternative implementation of \texttt{subset2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subset3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, rows) \{}
\NormalTok{  rows <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(rows)}
  \KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{expr}\NormalTok{(data[}\OperatorTok{!!}\NormalTok{rows, , }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{]), }\DataTypeTok{data =}\NormalTok{ data)}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\KeywordTok{subset3}\NormalTok{(df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  Compare and constrast \texttt{subset3()} to \texttt{subset2()}. What
  are its advantages and disadvantages.
\item
  The following function implements the basics of
  \texttt{dplyr::arrange()}.\\
  Annotate each line with a comment explaining what it does. Can you
  explain why \texttt{!!.na.last} is strictly correct, but omitting the
  \texttt{!!} is unlikely to cause problems?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arrange2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.df, ..., }\DataTypeTok{.na.last =} \OtherTok{TRUE}\NormalTok{) \{}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{enquos}\NormalTok{(...)}

\NormalTok{  order_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{order}\NormalTok{(}\OperatorTok{!!!}\NormalTok{args, }\DataTypeTok{na.last =} \OperatorTok{!!}\NormalTok{.na.last))}

\NormalTok{  ord <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(order_call, .df)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(ord) }\OperatorTok{==}\StringTok{ }\KeywordTok{nrow}\NormalTok{(.df))}

\NormalTok{  .df[ord, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{using-tidy-evaluation}{%
\section{Using tidy evaluation}\label{using-tidy-evaluation}}

While it's useful to understand how \texttt{eval\_tidy()} works, most of
the time you won't call it directly. Instead, in most cases you'll use
tidy evaluation indirectly; using a function that uses
\texttt{eval\_tidy()}. Tidy evaluation is infectious: the root always
involves a call to \texttt{eval\_tidy()} but that may be several levels
away.

In this section we'll explore how tidy evalution faciliates this
division of responsibility, and you'll learn how to create safe and
useful wrapper functions.

\hypertarget{quoting-and-unquoting}{%
\subsection{Quoting and unquoting}\label{quoting-and-unquoting}}

Imagine we have written a function that bootstraps a function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bootstrap <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, n) \{}
\NormalTok{  idx <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), n, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  df[idx, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

And we want to create a new function that allows us to boostrap and
subset in a single step. Our naive approach doesn't work:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bootset <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, cond, }\DataTypeTok{n =} \KeywordTok{nrow}\NormalTok{(df)) \{}
\NormalTok{  df2 <-}\StringTok{ }\KeywordTok{subset2}\NormalTok{(df, cond)}
  \KeywordTok{bootstrap}\NormalTok{(df2, n)}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{), }\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\KeywordTok{bootset}\NormalTok{(df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#>     x y}
\CommentTok{#> 1   1 1}
\CommentTok{#> 2   1 2}
\CommentTok{#> 3   1 3}
\CommentTok{#> 1.1 1 1}
\CommentTok{#> 3.1 1 3}
\end{Highlighting}
\end{Shaded}

\texttt{bootset()} doesn't quote any arguments so \texttt{cond} is
evaluated normally (not in a data mask), and we get an error when it
tries to find a binding for \texttt{x}. To fix this problem we need to
quote \texttt{cond}, and then unquote it when we pass it on ot
\texttt{subset2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bootset <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, cond, }\DataTypeTok{n =} \KeywordTok{nrow}\NormalTok{(df)) \{}
\NormalTok{  cond <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(cond)}
  
\NormalTok{  df2 <-}\StringTok{ }\KeywordTok{subset2}\NormalTok{(df, }\OperatorTok{!!}\NormalTok{cond)}
  \KeywordTok{bootstrap}\NormalTok{(df2, n)}
\NormalTok{\}}

\KeywordTok{bootset}\NormalTok{(df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#>     x y}
\CommentTok{#> 1   1 1}
\CommentTok{#> 2   1 2}
\CommentTok{#> 3   1 3}
\CommentTok{#> 1.1 1 1}
\CommentTok{#> 3.1 1 3}
\end{Highlighting}
\end{Shaded}

This is a very common pattern; whenever you call a quoting function with
arguments from the user, you need to quote them yourself and then
unquote.

\hypertarget{pronouns}{%
\subsection{Handling ambiguity}\label{pronouns}}

In the case above, we needed to think about tidy eval because of
quasiquotation. We also need to think tidy evaluation even when the
wrapper doesn't need to quote any arguments. Take this wrapper around
\texttt{subset2()} for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_x <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, val) \{}
  \KeywordTok{subset2}\NormalTok{(df, x }\OperatorTok{>=}\StringTok{ }\NormalTok{val)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function can silently return an incorrect result in two situations:

\begin{itemize}
\item
  When \texttt{x} exists in the calling environment, but not in
  \texttt{df}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{no_x <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\KeywordTok{threshold_x}\NormalTok{(no_x, }\DecValTok{2}\NormalTok{)}
\CommentTok{#>   y}
\CommentTok{#> 1 1}
\CommentTok{#> 2 2}
\CommentTok{#> 3 3}
\end{Highlighting}
\end{Shaded}
\item
  When \texttt{val} exists in \texttt{df}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{has_val <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{val =} \DecValTok{9}\OperatorTok{:}\DecValTok{11}\NormalTok{)}
\KeywordTok{threshold_x}\NormalTok{(has_val, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] x   val}
\CommentTok{#> <0 rows> (or 0-length row.names)}
\end{Highlighting}
\end{Shaded}
\end{itemize}

These failure modes arise because tidy evaluation is ambiguous: each
variable can be found in \textbf{either} the data mask \textbf{or} the
environment. To make this function safe we need to remove the ambiguity
using the \texttt{.data} and \texttt{.env} pronouns:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_x <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, val) \{}
  \KeywordTok{subset2}\NormalTok{(df, .data}\OperatorTok{$}\NormalTok{x }\OperatorTok{>=}\StringTok{ }\NormalTok{.env}\OperatorTok{$}\NormalTok{val)}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\KeywordTok{threshold_x}\NormalTok{(no_x, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> Error: Column `x` not found in `.data`}
\KeywordTok{threshold_x}\NormalTok{(has_val, }\DecValTok{2}\NormalTok{)}
\CommentTok{#>   x val}
\CommentTok{#> 2 2  10}
\CommentTok{#> 3 3  11}
\end{Highlighting}
\end{Shaded}

Generally, whenever you use the \texttt{.env} pronoun, you can use
unquoting instead:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_x <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, val) \{}
  \KeywordTok{subset2}\NormalTok{(df, .data}\OperatorTok{$}\NormalTok{x }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

There are subtle differences in when \texttt{val} is evaluated. If you
unquote, \texttt{val} will be early evaluated by \texttt{enquo()}; if
you use a pronoun, \texttt{val} will be lazily evaluated by
\texttt{eval\_tidy()}. These differences are usually unimportant, so
pick the form that looks most natural.

\hypertarget{quoting-and-ambiguity}{%
\subsection{Quoting and ambiguity}\label{quoting-and-ambiguity}}

To finish our discussion let's consider the case where we have both
quoting and potential ambiguity. Let's generalise
\texttt{threshold\_x()} slightly so that the user can pick the variable
used for thresholding?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_var <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, var, val) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{as_string}\NormalTok{(}\KeywordTok{ensym}\NormalTok{(var))}
  \KeywordTok{subset2}\NormalTok{(df, .data[[var]] }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val)}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\KeywordTok{threshold_var}\NormalTok{(df, x, }\DecValTok{8}\NormalTok{)}
\CommentTok{#>     x}
\CommentTok{#> 8   8}
\CommentTok{#> 9   9}
\CommentTok{#> 10 10}
\end{Highlighting}
\end{Shaded}

Note that it is not always the responsibility of the function author to
avoid ambiguity. Imagine we generalise further to allow thresholding
based on any expression:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_expr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, expr, val) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(expr)}
  \KeywordTok{subset2}\NormalTok{(df, }\OperatorTok{!!}\NormalTok{expr }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It's not possible to evaluate \texttt{expr} only the data mask, because
the data mask doesn't include any funtions like \texttt{+} or
\texttt{==}. Here, it's the user's responsibility to avoid ambiguity. As
a general rule of thumb, as a function author it's your responsibility
to avoid ambiguity with any expressions that you create; it's the user's
responsibility to avoid ambiguity in expressions that they create.

\hypertarget{exercises-62}{%
\subsection{Exercises}\label{exercises-62}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  I've included an alternative implementation of
  \texttt{threshold\_var()} below. What makes it different to the
  approach I used above? What make it harder?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_var <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, var, val) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{ensym}\NormalTok{(var)}
  \KeywordTok{subset2}\NormalTok{(df, }\StringTok{`}\DataTypeTok{$}\StringTok{`}\NormalTok{(.data, }\OperatorTok{!!}\NormalTok{var) }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{base-evaluation}{%
\section{Base evaluation}\label{base-evaluation}}

To understand the benefits of the full tidy evaluation stack, it's worth
comparing it to a non-tidy alternative: \texttt{subset()}.

Unfortunately, things are bit more complex if you want to wrap a base R
function that quotes an argument. We can no longer rely on tidy
evaluation everywhere, because the semantics of NSE functions are not
quite rich enough, but we can use it to generate a mostly correct
solution. The wrappers that we create can be used interactively, but can
not in turn be easily wrapped. This makes them useful for reducing
duplication in your analysis code, but not suitable for inclusion in a
package.

\hypertarget{substitute}{%
\subsection{\texorpdfstring{\texttt{substitute()}}{substitute()}}\label{substitute}}

\texttt{subset()} is a useful tool, but still simple enough to submit to
analysis. \texttt{substitute()} + \texttt{eval()} +
\texttt{parent.frame()} (or \texttt{rlang::caller\_env()})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subset_base <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, rows) \{}
\NormalTok{  rows <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(rows)}

\NormalTok{  rows_val <-}\StringTok{ }\KeywordTok{eval}\NormalTok{(rows, data, }\KeywordTok{parent.frame}\NormalTok{())}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.logical}\NormalTok{(rows_val))}
  
\NormalTok{  data[rows_val, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{drawbacks}{%
\subsection{Drawbacks}\label{drawbacks}}

The documentation of \texttt{subset()} includes the following warning:

\begin{quote}
This is a convenience function intended for use interactively. For
programming it is better to use the standard subsetting functions like
\texttt{{[}}, and in particular the non-standard evaluation of argument
\texttt{subset} can have unanticipated consequences.
\end{quote}

Why is \texttt{subset()} dangerous for programming and how does tidy
evaluation help us avoid those dangers? First, let's extract out the key
parts{[}\^{}select{]} of \texttt{subset.data.frame()} into a new
function, \texttt{subset\_base()}:

There are three problems with this implementation:

\begin{itemize}
\item
  \texttt{subset()} doesn't support unquoting, so wrapping the function
  is hard. First, you use \texttt{substitute()} to capture the complete
  expression, then you evaluate it. Because \texttt{substitute()}
  doesn't use a syntactic marker for unquoting, it is hard to see
  exactly what's happening here.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df1, expr) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{subset_base}\NormalTok{(df1, expr))}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}

\NormalTok{my_df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \DecValTok{3}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\KeywordTok{f1a}\NormalTok{(my_df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 3}
\end{Highlighting}
\end{Shaded}

  I think the tidy evaluation equivalent is easier to understand because
  the quoting and unquoting is explicit, and the environment is tied to
  the expression.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1b <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, expr) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(expr)}
  \KeywordTok{subset2}\NormalTok{(df, }\OperatorTok{!!}\NormalTok{expr)}
\NormalTok{\}}
\KeywordTok{f1b}\NormalTok{(my_df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 3}
\end{Highlighting}
\end{Shaded}

  This also leads to cleaner tracebacks in the event of an error.
\item
  \texttt{base::subset()} always evaluates \texttt{rows} in the calling
  environment, but if \texttt{...} has been used, then the expression
  might need to be evaluated elsewhere:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, ...) \{}
\NormalTok{  xval <-}\StringTok{ }\DecValTok{3}
  \KeywordTok{subset_base}\NormalTok{(df, ...)}
\NormalTok{\}}

\NormalTok{xval <-}\StringTok{ }\DecValTok{1}
\KeywordTok{f}\NormalTok{(my_df, x }\OperatorTok{==}\StringTok{ }\NormalTok{xval)}
\CommentTok{#>   x y}
\CommentTok{#> 3 3 1}
\end{Highlighting}
\end{Shaded}

  Because \texttt{enquo()} captures the environment of the argument as
  well as its expression, this is not a problem with \texttt{subset2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, ...) \{}
\NormalTok{  xval <-}\StringTok{ }\DecValTok{10}
  \KeywordTok{subset_base}\NormalTok{(df, ...)}
\NormalTok{\}}

\NormalTok{xval <-}\StringTok{ }\DecValTok{1}
\KeywordTok{f}\NormalTok{(my_df, x }\OperatorTok{==}\StringTok{ }\NormalTok{xval)}
\CommentTok{#> [1] x y}
\CommentTok{#> <0 rows> (or 0-length row.names)}
\end{Highlighting}
\end{Shaded}

  This may seems like an esoteric concern, but it means that
  \texttt{subset\_base()} cannot reliably work with functionals like
  \texttt{map()} or \texttt{lapply()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{local}\NormalTok{(\{}
\NormalTok{  y <-}\StringTok{ }\DecValTok{2}
\NormalTok{  dfs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{), }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{4}\OperatorTok{:}\DecValTok{6}\NormalTok{))}
  \KeywordTok{lapply}\NormalTok{(dfs, subset_base, x }\OperatorTok{==}\StringTok{ }\NormalTok{y)}
\NormalTok{\})}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] x}
\CommentTok{#> <0 rows> (or 0-length row.names)}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] x}
\CommentTok{#> <0 rows> (or 0-length row.names)}
\end{Highlighting}
\end{Shaded}
\item
  Finally, \texttt{eval()} doesn't provide any pronouns so there's no
  way to write a safe version of \texttt{threshold\_x()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_x <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, val) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{subset_base}\NormalTok{(df1, x }\OperatorTok{>}\StringTok{ }\NormalTok{val))}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{itemize}

You might wonder if all this rigamorale is worth it when you can just
use \texttt{{[}}. Firstly, it seems unappealing to have functions that
can only be used safely in an interactive context. That would mean that
every interactive function needs to be paired with function suitable for
programming. Secondly, even the simple \texttt{subset()} function
provides two useful features compared to \texttt{{[}}:

\begin{itemize}
\item
  It sets \texttt{drop\ =\ FALSE} by default, so it's guaranteed to
  return a data frame.
\item
  It drops rows where the condition evaluates to \texttt{NA}.
\end{itemize}

That means \texttt{subset(df,\ x\ ==\ y)} is not equivalent to
\texttt{df{[}x\ ==\ y,{]}} as you might expect. Instead, it is
equivalent to
\texttt{df{[}x\ ==\ y\ \&\ !is.na(x\ ==\ y),\ ,\ drop\ =\ FALSE{]}}:
that's a lot more typing!

Real-life alternatives to \texttt{subset()}, like
\texttt{dplyr::filter()}, do even more. For example,
\texttt{dplyr::filter()} can translate R expressions to SQL so that they
can be executed in a database. This makes programming with
\texttt{filter()} relatively more important (because it does more behind
the scenes that you want to take advantage of). Remember we picked
\texttt{subset()} because it's easy to understand, not because it's
particularly featureful.

\hypertarget{base-unquote}{%
\subsection{\texorpdfstring{Wrapping \texttt{subset()} with tidy
eval}{Wrapping subset() with tidy eval}}\label{base-unquote}}

Sometimes it's simpler to create wrappers around base R functions using
quasiquotation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_x <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, val) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{subset_base}\NormalTok{(df1, x }\OperatorTok{>}\StringTok{ }\NormalTok{val))}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}

\NormalTok{threshold_x <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, val) \{}
\NormalTok{  df <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(df)}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{subset}\NormalTok{(}\OperatorTok{!!}\NormalTok{df, x }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val))}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code is more verbose, but is a little easier to understand because
the unquoting in \texttt{expr()} is explict, unlike in
\texttt{substitute()}. This also allows to inline the value of the
\texttt{val}, not the expression used to generate it, eliminating one
source of ambiguity.

\hypertarget{match.call}{%
\subsection{\texorpdfstring{\texttt{match.call()}}{match.call()}}\label{match.call}}

Another form which we'll come to back to in the next section (because it
poses some specific challenges) uses \texttt{match.call()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{write.csv <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{match.call}\NormalTok{(}\DataTypeTok{expand.dots =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  call[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(write.table)}
\NormalTok{  call}\OperatorTok{$}\NormalTok{sep <-}\StringTok{ ","}
\NormalTok{  call}\OperatorTok{$}\NormalTok{dec <-}\StringTok{ "."}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{wrapping-modelling-functions}{%
\subsection{Wrapping modelling
functions}\label{wrapping-modelling-functions}}

Next we'll pivot to consider wrapping modelling functions. This is a
common need, and illustrates the spectrum of challenges you'll need to
overcome for other base functions.

Let's start with a very simple wrapper around \texttt{lm()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
  \KeywordTok{lm}\NormalTok{(formula, data)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This wrapper works, but is suboptimal because \texttt{lm()} captures its
call, and displays it when printing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lm2}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = formula, data = data)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)         disp  }
\CommentTok{#>     29.5999      -0.0412}
\end{Highlighting}
\end{Shaded}

This is important because this call is the chief way that you see the
model specification when printing the model. To overcome this problem,
we need to capture the arguments, create the call to \texttt{lm()} using
unquoting, then evaluate that call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(data)}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{data))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{lm3}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}
\CommentTok{#> lm(mpg ~ disp, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = mpg ~ disp, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)         disp  }
\CommentTok{#>     29.5999      -0.0412}
\end{Highlighting}
\end{Shaded}

To make it easier to see what's going on, I'll also print the expression
we generate. This will become more useful as the calls get more
complicated.

Note that we're evaluating the call in the caller environment. That
means we have to also quote data, because if we leave it as is,
\texttt{data} will not be found. We'll come back to this shortly.

As well as wrapping \texttt{lm()} in a way that preserves the call,
these wrappers also allow us to use unquoting to generate formulas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resp <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(mpg)}
\NormalTok{disp1 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(vs)}
\NormalTok{disp2 <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(wt)}
\KeywordTok{lm3}\NormalTok{(}\OperatorTok{!!}\NormalTok{resp }\OperatorTok{~}\StringTok{ }\OperatorTok{!!}\NormalTok{disp1 }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{disp2, mtcars)}
\CommentTok{#> lm(mpg ~ vs + wt, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = mpg ~ vs + wt, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)           vs           wt  }
\CommentTok{#>       33.00         3.15        -4.44}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-evaluation-environment}{%
\subsection{The evaluation
environment}\label{the-evaluation-environment}}

What if you want to mingle objects supplied by the user with objects
that you create in the function? For example, imagine you want to make
an auto-bootstrapping version of \texttt{lm()}. You might write it like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_lm0 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  boot_data <-}\StringTok{ }\NormalTok{data[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(data), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =}\NormalTok{ boot_data))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{y =} \DecValTok{5} \OperatorTok{+}\StringTok{ }\DecValTok{3} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\KeywordTok{boot_lm0}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x, }\DataTypeTok{data =}\NormalTok{ df)}
\CommentTok{#> lm(y ~ x, data = boot_data)}
\CommentTok{#> Error in is.data.frame(data):}
\CommentTok{#>   object 'boot_data' not found}
\end{Highlighting}
\end{Shaded}

Why doesn't this code work? It's because we're evaluating
\texttt{lm\_call} in the caller environment, but \texttt{boot\_data}
exists in the execution environment. We could instead evaluate in the
execution environment of \texttt{boot\_lm0()}, but there's no guarantee
that \texttt{formula} could be evaluated in that environment.

There are two basic ways to overcome this challenge:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Unquote the data frame into the call. This means that no lookup has to
  occur, but has all the problems of inlining expressions. For modelling
  functions this means that the captured call is suboptimal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_lm1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  boot_data <-}\StringTok{ }\NormalTok{data[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(data), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}

\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{boot_data))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{boot_lm1}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x, }\DataTypeTok{data =}\NormalTok{ df)}\OperatorTok{$}\NormalTok{call}
\CommentTok{#> lm(y ~ x, data = <data.frame>)}
\CommentTok{#> lm(formula = y ~ x, data = list(x = c(2L, 6L, 5L, 8L, 3L, 8L, }
\CommentTok{#> 1L, 4L, 9L, 3L), y = c(13.0650248953592, 22.4779874852545, 18.1369885079317, }
\CommentTok{#> 29.5429963426611, 12.3690105979178, 29.5429963426611, 8.62898204203601, }
\CommentTok{#> 17.5124269498518, 31.0859251727401, 12.3690105979178)))}
\end{Highlighting}
\end{Shaded}
\item
  Alternatively you can create a new environment that inherits from the
  caller, and you can bind variables that you've created inside the
  function to that environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_lm2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  boot_data <-}\StringTok{ }\NormalTok{data[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(data), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}

\NormalTok{  lm_env <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\KeywordTok{caller_env}\NormalTok{(), }\DataTypeTok{boot_data =}\NormalTok{ boot_data)}
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =}\NormalTok{ boot_data))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, lm_env)}
\NormalTok{\}}
\KeywordTok{boot_lm2}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x, }\DataTypeTok{data =}\NormalTok{ df)}
\CommentTok{#> lm(y ~ x, data = boot_data)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = y ~ x, data = boot_data)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)            x  }
\CommentTok{#>        5.19         2.92}
\end{Highlighting}
\end{Shaded}

  This is more work, but gives the cleanest specification.
\item
  A third and final option is to continue to evaluate in the parent
  environment, and do the calculation there too. Note that if you ever
  update this model, the data will resample; this feels like an
  undesirable property to me.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_lm2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(data)}
\NormalTok{  boot_data <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{(}
    \OperatorTok{!!}\NormalTok{data, }
    \KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(}\OperatorTok{!!}\NormalTok{data), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), , }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  )}

\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{boot_data))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{boot_lm2}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x, }\DataTypeTok{data =}\NormalTok{ df)}
\CommentTok{#> lm(y ~ x, data = df[sample(nrow(df), replace = TRUE)])}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = y ~ x, data = df[sample(nrow(df), replace = TRUE), }
\CommentTok{#>     , drop = FALSE])}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)            x  }
\CommentTok{#>        5.87         2.79}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{quoted-arguments}{%
\subsection{Quoted arguments}\label{quoted-arguments}}

Quoting and unquoting works for all the arguments, even those that are
quoted and follow the ``standard non-standard'' rules of evaluation.
This includes the \texttt{subset} argument which allows you fit a model
to only a subset of the data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm4 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data, }\DataTypeTok{subset =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(data)}
\NormalTok{  subset <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(subset)}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{data, }\DataTypeTok{subset =} \OperatorTok{!!}\NormalTok{subset))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{coef}\NormalTok{(}\KeywordTok{lm4}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars))}
\CommentTok{#> lm(mpg ~ disp, data = mtcars, subset = NULL)}
\CommentTok{#> (Intercept)        disp }
\CommentTok{#>     29.5999     -0.0412}
\KeywordTok{coef}\NormalTok{(}\KeywordTok{lm4}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars, }\DataTypeTok{subset =}\NormalTok{ cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{))}
\CommentTok{#> lm(mpg ~ disp, data = mtcars, subset = cyl == 4)}
\CommentTok{#> (Intercept)        disp }
\CommentTok{#>      40.872      -0.135}
\end{Highlighting}
\end{Shaded}

Note that I've supplied a default argument to \texttt{subset}. I think
this is good practice because it clearly indicates that \texttt{subset}
is optional: arguments with no default are usually required.
\texttt{NULL} has two nice properties here:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{lm()} already knows how to handle \texttt{subset\ =\ NULL}: it
  treats it the same way as a missing \texttt{subset}.
\item
  \texttt{expr(NULL)} is \texttt{NULL} which makes it easy to detect in
  quoted arguments.
\end{enumerate}

However, the current approach has one small downside:
\texttt{subset\ =\ NULL} is shown in the call.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm4}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}
\CommentTok{#> lm(mpg ~ disp, data = mtcars, subset = NULL)}
\end{Highlighting}
\end{Shaded}

It's possible, if a little more work, to generate a call where
\texttt{subset} is simply absent. This leads to \texttt{lm5()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm5 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data, }\DataTypeTok{subset =} \OtherTok{NULL}\NormalTok{) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(data)}
\NormalTok{  subset <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(subset)}

\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{data))}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(subset)) \{}
\NormalTok{    lm_call}\OperatorTok{$}\NormalTok{subset <-}\StringTok{ }\NormalTok{subset}
\NormalTok{  \}}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm5}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}
\CommentTok{#> lm(mpg ~ disp, data = mtcars)}
\end{Highlighting}
\end{Shaded}

I probably wouldn't bother with it here, but it's a useful technique to
have in your back pocket.

\hypertarget{making-formulas}{%
\subsection{Making formulas}\label{making-formulas}}

One final aspect to wrapping modelling functions is generating formulas.
You just need to learn about one small wrinkle and then you can use the
techniques you learned in {[}Quotation{]}. Formulas print the same when
evaluated and unevaluated:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y }\OperatorTok{~}\StringTok{ }\NormalTok{x}
\CommentTok{#> y ~ x}
\KeywordTok{expr}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x)}
\CommentTok{#> y ~ x}
\end{Highlighting}
\end{Shaded}

Instead, check the class to make sure you have an actual formula:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x)}
\CommentTok{#> [1] "formula"}
\KeywordTok{class}\NormalTok{(}\KeywordTok{expr}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x))}
\CommentTok{#> [1] "call"}
\KeywordTok{class}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x)))}
\CommentTok{#> [1] "formula"}
\end{Highlighting}
\end{Shaded}

This is important when you start to mix data and environment variables,
which only tends to happen when you start using more complex models:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{3}
\NormalTok{y }\OperatorTok{~}\StringTok{ }\KeywordTok{ns}\NormalTok{(x, n)}
\CommentTok{#> y ~ ns(x, n)}
\end{Highlighting}
\end{Shaded}

Once you understand this, you can generate formulas with unquoting and
\texttt{reduce()}. Just remember to evaluate the result before returning
it. Like in another base NSE wrapper, you should use
\texttt{caller\_env()} as the evaluation environment.

Here's a simple example that generates a formula by combining a response
variable with a set of predictors.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{build_formula <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(resp, ...) \{}
\NormalTok{  resp <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(resp)}
\NormalTok{  preds <-}\StringTok{ }\KeywordTok{enexprs}\NormalTok{(...)}
  
\NormalTok{  pred_sum <-}\StringTok{ }\NormalTok{purrr}\OperatorTok{::}\KeywordTok{reduce}\NormalTok{(preds, }\OperatorTok{~}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{.x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{.y))}
  \KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{resp }\OperatorTok{~}\StringTok{ }\OperatorTok{!!}\NormalTok{pred_sum), }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{build_formula}\NormalTok{(y, a, b, c)}
\CommentTok{#> y ~ a + b + c}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-63}{%
\subsection{Exercises}\label{exercises-63}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Why does this function fail?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm3a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}

\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =}\NormalTok{ data))}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{lm3}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}\OperatorTok{$}\NormalTok{call}
\CommentTok{#> lm(mpg ~ disp, data = mtcars)}
\CommentTok{#> lm(formula = mpg ~ disp, data = mtcars)}
\end{Highlighting}
\end{Shaded}
\item
  When model building, typically the response and data are relatively
  constant while you rapidly experiment with different predictors. Write
  a small wrapper that allows you to reduce duplication in this
  situation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pred_mpg <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(resp, ...) \{}

\NormalTok{\}}
\KeywordTok{pred_mpg}\NormalTok{(}\OperatorTok{~}\StringTok{ }\NormalTok{disp)}
\KeywordTok{pred_mpg}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp))}
\KeywordTok{pred_mpg}\NormalTok{(}\OperatorTok{~}\StringTok{ }\NormalTok{disp }\OperatorTok{*}\StringTok{ }\NormalTok{cyl)}
\end{Highlighting}
\end{Shaded}
\item
  Another way to way to write \texttt{boot\_lm()} would be to include
  the boostrapping expression
  (\texttt{data{[}sample(nrow(data),\ replace\ =\ TRUE),\ ,\ drop\ =\ FALSE{]}})
  in the data argument. Implement that approach. What are the
  advantages? What are the disadvantages?
\item
  To make these functions somewhat more robust, instead of always using
  the \texttt{caller\_env()} we could capture a quosure, and then use
  its environment. However, if there are multiple arguments, they might
  be associated with different environments. Write a function that takes
  a list of quosures, and returns the common environment, if they have
  one, or otherwise throws an error.
\item
  Write a function that takes a data frame and a list of formulas,
  fitting a linear model with each formula, generating a useful model
  call.
\item
  Create a formula generation function that allows you to optionally
  supply a transformation function (e.g. \texttt{log()}) to the response
  or the predictors.
\item
  What does \texttt{transform()} do? Read the documentation. How does it
  work? Read the source code for \texttt{transform.data.frame()}. What
  does \texttt{substitute(list(...))} do? Extract it into it's own
  function and perform experiments to find out.
\item
  What does \texttt{with()} do? How does it work? Read the source code
  for \texttt{with.default()}. What does \texttt{within()} do? How does
  it work? Read the source code for \texttt{within.data.frame()}. Why is
  the code so much more complex than \texttt{with()}?
\item
  Implement a version of \texttt{within.data.frame()} that uses tidy
  evaluation. Read the documentation and make sure that you understand
  what \texttt{within()} does, then read the source code.
\end{enumerate}

\hypertarget{translation}{%
\chapter{Translating R code}\label{translation}}

\hypertarget{introduction-18}{%
\section{Introduction}\label{introduction-18}}

The combination of first-class environments, lexical scoping, and
metaprogramming gives us a powerful toolkit for translating R code into
other languages. One fully-fledged example of this idea is dbplyr.
dbplyr powers the database backends for dplyr, allowing us to express
data maniplation in R and automatically translating it into SQL. An
important part of dbplyr is \texttt{translate\_sql()} which turns vector
R code in to the equivalent SQL:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dbplyr)}
\KeywordTok{translate_sql}\NormalTok{(x }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> <SQL> POWER("x", 2.0)}
\KeywordTok{translate_sql}\NormalTok{(x }\OperatorTok{<}\StringTok{ }\DecValTok{5} \OperatorTok{&}\StringTok{ }\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(x))}
\CommentTok{#> <SQL> "x" < 5.0 AND NOT((("x") IS NULL))}
\KeywordTok{translate_sql}\NormalTok{(}\OperatorTok{!}\NormalTok{first }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Roger"}\NormalTok{, }\StringTok{"Robert"}\NormalTok{))}
\CommentTok{#> <SQL> NOT("first" IN ('John', 'Roger', 'Robert'))}
\KeywordTok{translate_sql}\NormalTok{(select }\OperatorTok{==}\StringTok{ }\DecValTok{7}\NormalTok{)}
\CommentTok{#> <SQL> "select" = 7.0}
\end{Highlighting}
\end{Shaded}

This chapter will develop two simple, but useful DSLs: one to generate
HTML, and the other to turn mathematical expressions from R code into
LaTeX.

If you're interested in learning more about domain specific languages in
general, I highly recommend \emph{Domain Specific Languages} (Fowler
\protect\hyperlink{ref-dsls}{2010}). It discusses many options for
creating a DSL and provides many examples of different languages.

\hypertarget{outline-16}{%
\subsection*{Outline}\label{outline-16}}
\addcontentsline{toc}{subsection}{Outline}

\hypertarget{prequisites}{%
\subsection*{Prequisites}\label{prequisites}}
\addcontentsline{toc}{subsection}{Prequisites}

This chapter together pulls together many techniques discussed elsewhere
in the book. In particular, you'll need to understand environments,
metaprogramming, and a little functional programming and S3. We'll use
rlang for its metaprogramming tools, and purrr for its mapping
functions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\KeywordTok{library}\NormalTok{(purrr)}
\CommentTok{#> }
\CommentTok{#> Attaching package: 'purrr'}
\CommentTok{#> The following objects are masked from 'package:rlang':}
\CommentTok{#> }
\CommentTok{#>     %@%, %||%, as_function, flatten, flatten_chr,}
\CommentTok{#>     flatten_dbl, flatten_int, flatten_lgl, invoke,}
\CommentTok{#>     list_along, modify, prepend, rep_along, splice}
\end{Highlighting}
\end{Shaded}

\hypertarget{html}{%
\section{HTML}\label{html}}

HTML (hypertext markup language) is the language that underlies the
majority of the web. It's a special case of SGML (standard generalised
markup language), and it's similar but not identical to XML (extensible
markup language). HTML looks like this: \index{HTML}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<body>}
  \KeywordTok{<h1}\OtherTok{ id=}\StringTok{'first'}\KeywordTok{>}\NormalTok{A heading}\KeywordTok{</h1>}
  \KeywordTok{<p>}\NormalTok{Some text }\DecValTok{&amp;} \KeywordTok{<b>}\NormalTok{some bold text.}\KeywordTok{</b></p>}
  \KeywordTok{<img}\OtherTok{ src=}\StringTok{'myimg.png'}\OtherTok{ width=}\StringTok{'100'}\OtherTok{ height=}\StringTok{'100'} \KeywordTok{/>}
\KeywordTok{</body>}
\end{Highlighting}
\end{Shaded}

Even if you've never looked at HTML before, you can still see that the
key component of its coding structure is tags:
\texttt{\textless{}tag\textgreater{}\textless{}/tag\textgreater{}}. Tags
can be nested within other tags and intermingled with text. There are
over 100 HTML tags, but in this chapter we'll focus on just a handful:

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}body\textgreater{}} is the top-level tag that
  contains all content.
\item
  \texttt{\textless{}h1\textgreater{}} defines a top level heading.
\item
  \texttt{\textless{}p\textgreater{}} defines a paragraph.
\item
  \texttt{\textless{}b\textgreater{}} emboldens text.
\item
  \texttt{\textless{}img\textgreater{}} embeds an image.
\end{itemize}

Tags can also have named \textbf{attributes} which look like
\texttt{\textless{}tag\ name1=\textquotesingle{}value1\textquotesingle{}\ name2=\textquotesingle{}value2\textquotesingle{}\textgreater{}\textless{}/tag\textgreater{}}.
Two important attributes used with just about every tag are \texttt{id}
and \texttt{class}. These are used in conjunction with CSS (cascading
style sheets) in order to control the visual appearance of the page.

\textbf{Void tags}, like \texttt{\textless{}img\textgreater{}}, don't
have any content, and are written
\texttt{\textless{}img\ /\textgreater{}}, not
\texttt{\textless{}img\textgreater{}\textless{}/img\textgreater{}}.
Since they have no content, attributes are more important, and
\texttt{img} has three that are used with almost every image:
\texttt{src} (where the image lives), \texttt{width}, and
\texttt{height}.

Because \texttt{\textless{}} and \texttt{\textgreater{}} have special
meanings in HTML, you can't write them directly. Instead you have to use
the HTML \textbf{escapes}: \texttt{\&gt;} and \texttt{\&lt;}. And, since
those escapes use \texttt{\&}, if you want a literal ampersand you have
to escape it with \texttt{\&amp;}.

\hypertarget{goal}{%
\subsection{Goal}\label{goal}}

Our goal is to make it easy to generate HTML from R. To give a concrete
example, we want to generate the following HTML:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<body>}
  \KeywordTok{<h1}\OtherTok{ id=}\StringTok{'first'}\KeywordTok{>}\NormalTok{A heading}\KeywordTok{</h1>}
  \KeywordTok{<p>}\NormalTok{Some text }\DecValTok{&amp;} \KeywordTok{<b>}\NormalTok{some bold text.}\KeywordTok{</b></p>}
  \KeywordTok{<img}\OtherTok{ src=}\StringTok{'myimg.png'}\OtherTok{ width=}\StringTok{'100'}\OtherTok{ height=}\StringTok{'100'} \KeywordTok{/>}
\KeywordTok{</body>}
\end{Highlighting}
\end{Shaded}

And we want the structure of the R code to match the structure of the
HTML as closely as possible. To that end, we will work our way up to the
following DSL:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_html}\NormalTok{(}
  \KeywordTok{body}\NormalTok{(}
    \KeywordTok{h1}\NormalTok{(}\StringTok{"A heading"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"first"}\NormalTok{),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Some text &"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text."}\NormalTok{)),}
    \KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimg.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This DSL has the following three properties:

\begin{itemize}
\item
  The nesting of function calls matches the nesting of tags.
\item
  Unnamed arguments become the content of the tag, and named arguments
  become their attributes.
\item
  We can automatically escape \texttt{\&} and other special characters
  because tags and text are clearly distinct.
\end{itemize}

\hypertarget{escaping}{%
\subsection{Escaping}\label{escaping}}

Escaping is so fundamental to translation that it'll be our first topic.
There are two related challenges:

\begin{itemize}
\item
  In user input, we need to automatically escape \texttt{\&},
  \texttt{\textless{}} and \texttt{\textgreater{}}.
\item
  At the same time we need to make sure that the \texttt{\&},
  \texttt{\textless{}} and \texttt{\textgreater{}} we generate are not
  double-escaped (i.e.~to \texttt{\&amp;amp;}, \texttt{\&amp;lt;} and
  \texttt{\&amp;gt;}).
\end{itemize}

The easiest way to do this is to create an S3 class that distinguishes
between regular text (that needs escaping) and HTML (that doesn't).
\index{escaping}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"advr_html"}\NormalTok{)}
\NormalTok{cat_line <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{cat}\NormalTok{(..., }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}

\NormalTok{print.advr_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"<HTML> "}\NormalTok{, x)}
  \KeywordTok{cat_line}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\KeywordTok{strwrap}\NormalTok{(out), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We then write an escape generic. It has two important methods:

\begin{itemize}
\item
  \texttt{escape.character()} takes a regular character vector and
  returns an HTML vector with special characters (\texttt{\&},
  \texttt{\textless{}}, \texttt{\textgreater{}}) escaped.
\item
  \texttt{escape.advr\_html()} which leaves already escaped HTML as is.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{escape <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"escape"}\NormalTok{)}

\NormalTok{escape.character <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"&"}\NormalTok{, }\StringTok{"&amp;"}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"<"}\NormalTok{, }\StringTok{"&lt;"}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{">"}\NormalTok{, }\StringTok{"&gt;"}\NormalTok{, x)}

  \KeywordTok{html}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{escape.advr_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}
\end{Highlighting}
\end{Shaded}

Now we check that it works

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{escape}\NormalTok{(}\StringTok{"This is some text."}\NormalTok{)}
\CommentTok{#> <HTML> This is some text.}
\KeywordTok{escape}\NormalTok{(}\StringTok{"x > 1 & y < 2"}\NormalTok{)}
\CommentTok{#> <HTML> x &gt; 1 &amp; y &lt; 2}

\CommentTok{# Double escaping is not a problem}
\KeywordTok{escape}\NormalTok{(}\KeywordTok{escape}\NormalTok{(}\StringTok{"This is some text. 1 > 2"}\NormalTok{))}
\CommentTok{#> <HTML> This is some text. 1 &gt; 2}

\CommentTok{# And text we know is HTML doesn't get escaped.}
\KeywordTok{escape}\NormalTok{(}\KeywordTok{html}\NormalTok{(}\StringTok{"<hr />"}\NormalTok{))}
\CommentTok{#> <HTML> <hr />}
\end{Highlighting}
\end{Shaded}

Conveniently this also gives the user a way to opt-out of our escaping
if they know the content is already escaped.

\hypertarget{basic-tag-functions}{%
\subsection{Basic tag functions}\label{basic-tag-functions}}

Next, we'll write a few simple tag functions then figure out how to
generalise these functions to cover all possible tags.

Let's start with \texttt{\textless{}p\textgreater{}}. HTML tags can have
both attributes (e.g., id or class) and children (like
\texttt{\textless{}b\textgreater{}} or
\texttt{\textless{}i\textgreater{}}). We need some way of separating
these in the function call. Given that attributes are named values and
children don't have names, it seems natural to separate using named
arguments from unnamed ones. For example, a call to \texttt{p()} might
look like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text. "}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\KeywordTok{i}\NormalTok{(}\StringTok{"some bold italic text"}\NormalTok{)), }\DataTypeTok{class =} \StringTok{"mypara"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We could list all the possible attributes of the
\texttt{\textless{}p\textgreater{}} tag in the function definition. But
that's hard not only because there are many attributes, but also because
it's possible to use
\href{http://html5doctor.com/html5-custom-data-attributes/}{custom
attributes}. Instead, we'll just use \texttt{...} and separate the
components based on whether or not they are named. With this in mind, we
create a helper function that wraps around \texttt{rlang::dots\_list()}
(so we can use \texttt{!!} and \texttt{!!!}) and returns named and
unnamed components separately:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dots_partition <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{dots_list}\NormalTok{(...)}

\NormalTok{  is_named <-}\StringTok{ }\KeywordTok{names}\NormalTok{(dots) }\OperatorTok{!=}\StringTok{ ""}
  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{named =}\NormalTok{ dots[is_named],}
    \DataTypeTok{unnamed =}\NormalTok{ dots[}\OperatorTok{!}\NormalTok{is_named]}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{str}\NormalTok{(}\KeywordTok{dots_partition}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DataTypeTok{b =} \DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ named  :List of 2}
\CommentTok{#>   ..$ a: num 1}
\CommentTok{#>   ..$ b: num 3}
\CommentTok{#>  $ unnamed:List of 2}
\CommentTok{#>   ..$ : num 2}
\CommentTok{#>   ..$ : num 4}
\end{Highlighting}
\end{Shaded}

We can now create our \texttt{p()} function. Notice that there's one new
function here: \texttt{html\_attributes()}. It takes a named list and
returns the HTML attribute specification as a string. It's a little
complicated (in part, because it deals with some idiosyncracies of HTML
that I haven't mentioned.), but it's not that important and doesn't
introduce any new programming ideas, so I won't discuss it here (you can
find the
\href{https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r}{source
online}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{source}\NormalTok{(}\StringTok{"dsl-html-attributes.r"}\NormalTok{, }\DataTypeTok{local =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{p <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
\NormalTok{  attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
\NormalTok{  children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed, escape)}
  
  \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"<p"}\NormalTok{, attribs, }\StringTok{">"}\NormalTok{,}
    \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
    \StringTok{"</p>"}
\NormalTok{  ))}
\NormalTok{\}}

\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{)}
\CommentTok{#> <HTML> <p>Some text</p>}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"myid"}\NormalTok{)}
\CommentTok{#> <HTML> <p id='myid'>Some text</p>}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"important"}\NormalTok{, }\StringTok{`}\DataTypeTok{data-value}\StringTok{`}\NormalTok{ =}\StringTok{ }\DecValTok{10}\NormalTok{)}
\CommentTok{#> <HTML> <p class='important' data-value='10'>Some text</p>}
\end{Highlighting}
\end{Shaded}

\hypertarget{tag-functions}{%
\subsection{Tag functions}\label{tag-functions}}

It's straightforward to adapt \texttt{p()} to other tags: we just need
to replace \texttt{"p"} with the name of the tag. One elegant way to do
that is to manually create a function with
\texttt{rlang::new\_function()}, using unquoting with \texttt{paste0()}
to generate the starting and ending tags.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed, escape)}
  
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{">"}\NormalTok{,}
        \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{)}
\NormalTok{      ))}
\NormalTok{    \}),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\KeywordTok{tag}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
\CommentTok{#> function (...) }
\CommentTok{#> \{}
\CommentTok{#>     dots <- dots_partition(...)}
\CommentTok{#>     attribs <- html_attributes(dots$named)}
\CommentTok{#>     children <- map_chr(dots$unnamed, escape)}
\CommentTok{#>     html(paste0("<b", attribs, ">", paste(children, collapse = ""), }
\CommentTok{#>         "</b>"))}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

Now we can run our earlier example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"p"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
\NormalTok{i <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"i"}\NormalTok{)}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text. "}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\KeywordTok{i}\NormalTok{(}\StringTok{"some bold italic text"}\NormalTok{)), }\DataTypeTok{class =} \StringTok{"mypara"}\NormalTok{)}
\CommentTok{#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic}
\CommentTok{#> text</i></b></p>}
\end{Highlighting}
\end{Shaded}

Before we generate functions for every possible HTML tag, we need to
create a variant of \texttt{tag()} for void tags. It's very similar to
\texttt{tag()}, but it will throw an error if there are any unnamed
tags, and the tag itself looks a little different.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void_tag <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ), }
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
        \KeywordTok{stop}\NormalTok{(}\OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag, }\StringTok{"> must not have unnamed arguments"}\NormalTok{), }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{      \}}
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
  
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{" />"}\NormalTok{))}
\NormalTok{    \}),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{img <-}\StringTok{ }\KeywordTok{void_tag}\NormalTok{(}\StringTok{"img"}\NormalTok{)}
\KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimage.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\CommentTok{#> <HTML> <img src='myimage.png' width='100' height='100' />}
\end{Highlighting}
\end{Shaded}

\hypertarget{processing-all-tags}{%
\subsection{Processing all tags}\label{processing-all-tags}}

Next we need a list of all the HTML tags:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"abbr"}\NormalTok{, }\StringTok{"address"}\NormalTok{, }\StringTok{"article"}\NormalTok{, }\StringTok{"aside"}\NormalTok{, }\StringTok{"audio"}\NormalTok{, }
  \StringTok{"b"}\NormalTok{,}\StringTok{"bdi"}\NormalTok{, }\StringTok{"bdo"}\NormalTok{, }\StringTok{"blockquote"}\NormalTok{, }\StringTok{"body"}\NormalTok{, }\StringTok{"button"}\NormalTok{, }\StringTok{"canvas"}\NormalTok{, }
  \StringTok{"caption"}\NormalTok{,}\StringTok{"cite"}\NormalTok{, }\StringTok{"code"}\NormalTok{, }\StringTok{"colgroup"}\NormalTok{, }\StringTok{"data"}\NormalTok{, }\StringTok{"datalist"}\NormalTok{, }
  \StringTok{"dd"}\NormalTok{, }\StringTok{"del"}\NormalTok{,}\StringTok{"details"}\NormalTok{, }\StringTok{"dfn"}\NormalTok{, }\StringTok{"div"}\NormalTok{, }\StringTok{"dl"}\NormalTok{, }\StringTok{"dt"}\NormalTok{, }\StringTok{"em"}\NormalTok{, }
  \StringTok{"eventsource"}\NormalTok{,}\StringTok{"fieldset"}\NormalTok{, }\StringTok{"figcaption"}\NormalTok{, }\StringTok{"figure"}\NormalTok{, }\StringTok{"footer"}\NormalTok{, }
  \StringTok{"form"}\NormalTok{, }\StringTok{"h1"}\NormalTok{, }\StringTok{"h2"}\NormalTok{, }\StringTok{"h3"}\NormalTok{, }\StringTok{"h4"}\NormalTok{, }\StringTok{"h5"}\NormalTok{, }\StringTok{"h6"}\NormalTok{, }\StringTok{"head"}\NormalTok{, }\StringTok{"header"}\NormalTok{, }
  \StringTok{"hgroup"}\NormalTok{, }\StringTok{"html"}\NormalTok{, }\StringTok{"i"}\NormalTok{,}\StringTok{"iframe"}\NormalTok{, }\StringTok{"ins"}\NormalTok{, }\StringTok{"kbd"}\NormalTok{, }\StringTok{"label"}\NormalTok{, }
  \StringTok{"legend"}\NormalTok{, }\StringTok{"li"}\NormalTok{, }\StringTok{"mark"}\NormalTok{, }\StringTok{"map"}\NormalTok{,}\StringTok{"menu"}\NormalTok{, }\StringTok{"meter"}\NormalTok{, }\StringTok{"nav"}\NormalTok{, }
  \StringTok{"noscript"}\NormalTok{, }\StringTok{"object"}\NormalTok{, }\StringTok{"ol"}\NormalTok{, }\StringTok{"optgroup"}\NormalTok{, }\StringTok{"option"}\NormalTok{, }\StringTok{"output"}\NormalTok{, }
  \StringTok{"p"}\NormalTok{, }\StringTok{"pre"}\NormalTok{, }\StringTok{"progress"}\NormalTok{, }\StringTok{"q"}\NormalTok{, }\StringTok{"ruby"}\NormalTok{, }\StringTok{"rp"}\NormalTok{,}\StringTok{"rt"}\NormalTok{, }\StringTok{"s"}\NormalTok{, }\StringTok{"samp"}\NormalTok{, }
  \StringTok{"script"}\NormalTok{, }\StringTok{"section"}\NormalTok{, }\StringTok{"select"}\NormalTok{, }\StringTok{"small"}\NormalTok{, }\StringTok{"span"}\NormalTok{, }\StringTok{"strong"}\NormalTok{, }
  \StringTok{"style"}\NormalTok{, }\StringTok{"sub"}\NormalTok{, }\StringTok{"summary"}\NormalTok{, }\StringTok{"sup"}\NormalTok{, }\StringTok{"table"}\NormalTok{, }\StringTok{"tbody"}\NormalTok{, }\StringTok{"td"}\NormalTok{, }
  \StringTok{"textarea"}\NormalTok{, }\StringTok{"tfoot"}\NormalTok{, }\StringTok{"th"}\NormalTok{, }\StringTok{"thead"}\NormalTok{, }\StringTok{"time"}\NormalTok{, }\StringTok{"title"}\NormalTok{, }\StringTok{"tr"}\NormalTok{,}
  \StringTok{"u"}\NormalTok{, }\StringTok{"ul"}\NormalTok{, }\StringTok{"var"}\NormalTok{, }\StringTok{"video"}\NormalTok{)}

\NormalTok{void_tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"area"}\NormalTok{, }\StringTok{"base"}\NormalTok{, }\StringTok{"br"}\NormalTok{, }\StringTok{"col"}\NormalTok{, }\StringTok{"command"}\NormalTok{, }\StringTok{"embed"}\NormalTok{,}
  \StringTok{"hr"}\NormalTok{, }\StringTok{"img"}\NormalTok{, }\StringTok{"input"}\NormalTok{, }\StringTok{"keygen"}\NormalTok{, }\StringTok{"link"}\NormalTok{, }\StringTok{"meta"}\NormalTok{, }\StringTok{"param"}\NormalTok{, }
  \StringTok{"source"}\NormalTok{, }\StringTok{"track"}\NormalTok{, }\StringTok{"wbr"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you look at this list carefully, you'll see there are quite a few
tags that have the same name as base R functions (\texttt{body},
\texttt{col}, \texttt{q}, \texttt{source}, \texttt{sub},
\texttt{summary}, \texttt{table}), and others that have the same name as
popular packages (e.g., \texttt{map}). This means we don't want to make
all the functions available by default, in either the global environment
or in a package. Instead, we'll put them in a list and then provide a
helper to make it easy to use them when desired. First, we make a named
list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html_tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
\NormalTok{  tags }\OperatorTok{%>%}\StringTok{ }\KeywordTok{set_names}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{map}\NormalTok{(tag),}
\NormalTok{  void_tags }\OperatorTok{%>%}\StringTok{ }\KeywordTok{set_names}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{map}\NormalTok{(void_tag)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This gives us an explicit (but verbose) way to call tag functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html_tags}\OperatorTok{$}\KeywordTok{p}\NormalTok{(}
  \StringTok{"Some text. "}\NormalTok{, }
\NormalTok{  html_tags}\OperatorTok{$}\KeywordTok{b}\NormalTok{(html_tags}\OperatorTok{$}\KeywordTok{i}\NormalTok{(}\StringTok{"some bold italic text"}\NormalTok{)), }
  \DataTypeTok{class =} \StringTok{"mypara"}
\NormalTok{)}
\CommentTok{#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic}
\CommentTok{#> text</i></b></p>}
\end{Highlighting}
\end{Shaded}

We can then finish off our HTML DSL with a function that allows us to
evaluate code in the context of that list. Here we slightly abuse the
data mask, passing it a list of functions rather than a data frame. This
is quick hack to mingle the execution environment of \texttt{code} with
the functions in \texttt{html\_tags}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  code <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(code)}
  \KeywordTok{eval_tidy}\NormalTok{(code, html_tags)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This gives us a succinct API which allows us to write HTML when we need
it but doesn't clutter up the namespace when we don't.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_html}\NormalTok{(}
  \KeywordTok{body}\NormalTok{(}
    \KeywordTok{h1}\NormalTok{(}\StringTok{"A heading"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"first"}\NormalTok{),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Some text &"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text."}\NormalTok{)),}
    \KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimg.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> <HTML> <body><h1 id='first'>A heading</h1><p>Some text}
\CommentTok{#> &amp;<b>some bold text.</b></p><img src='myimg.png'}
\CommentTok{#> width='100' height='100' /></body>}
\end{Highlighting}
\end{Shaded}

If you want to access the R function overridden by an HTML tag with the
same name inside \texttt{with\_html()}, you can use the full
\texttt{package::function} specification.

\hypertarget{exercises-64}{%
\subsection{Exercises}\label{exercises-64}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The escaping rules for \texttt{\textless{}script\textgreater{}} and
  \texttt{\textless{}style\textgreater{}} tags are different: you don't
  want to escape angle brackets or ampersands, but you do want to escape
  \texttt{\textless{}/script\textgreater{}} or
  \texttt{\textless{}/style\textgreater{}}. Adapt the code above to
  follow these rules.
\item
  The use of \texttt{...} for all functions has some big downsides.
  There's no input validation and there will be little information in
  the documentation or autocomplete about how they are used in the
  function. Create a new function that, when given a named list of tags
  and their\\
  attribute names (like below), creates functions which address this
  problem.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"href"}\NormalTok{),}
  \DataTypeTok{img =} \KeywordTok{c}\NormalTok{(}\StringTok{"src"}\NormalTok{, }\StringTok{"width"}\NormalTok{, }\StringTok{"height"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  All tags should get \texttt{class} and \texttt{id} attributes.
\item
  Currently the HTML doesn't look terribly pretty, and it's hard to see
  the structure. How could you adapt \texttt{tag()} to do indenting and
  formatting?
\item
  Reason about the following code that calls \texttt{with\_html()}
  referencing objects from the environment. Will it work or fail? Why?
  Run the code to verify your predictions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greeting <-}\StringTok{ "Hello!"}
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{p}\NormalTok{(greeting))}

\NormalTok{address <-}\StringTok{ "123 anywhere street"}
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{p}\NormalTok{(address))}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{latex}{%
\section{LaTeX}\label{latex}}

The next DSL will convert R expressions into their LaTeX math
equivalents. (This is a bit like \texttt{?plotmath}, but for text
instead of plots.) LaTeX is the lingua franca of mathematicians and
statisticians: it's common to use LaTeX notation whenever you want to
express an equation in text (e.g., in an email). Since many reports are
produced using both R and LaTeX, it might be useful to be able to
automatically convert mathematical expressions from one language to the
other. \index{LaTeX}

Because we need to convert both functions and names, this mathematical
DSL will be more complicated than the HTML DSL. We'll also need to
create a ``default'' conversion, so that functions we don't know about
get a standard conversion. Like the HTML DSL, we'll also use
metaprogramming to make it easier to generate the translators.

We can no longer just use eval: we also need to walk the tree. Ideally
this would not be necessary. ObjectTables (see objectable package)
almost make it possible to eliminate the tree walking but:

\begin{itemize}
\item
  They currently have a big performance penalty
\item
  There's no way to distinguish symbols used in function calls vs.~other
  symbols.
\end{itemize}

Before we begin, let's quickly cover how formulas are expressed in
LaTeX.

\hypertarget{latex-mathematics}{%
\subsection{LaTeX mathematics}\label{latex-mathematics}}

The full spectrum of LaTeX mathematical notation is complex.
Fortunately, they are
\href{http://en.wikibooks.org/wiki/LaTeX/Mathematics}{well documented},
and the most common commands have a fairly simple structure:

\begin{itemize}
\item
  Most simple mathematical equations are written in the same way you'd
  type them in R: \texttt{x\ *\ y}, \texttt{z\ \^{}\ 5}. Subscripts are
  written using \texttt{\_} (e.g., \texttt{x\_1}).
\item
  Special characters start with a \texttt{\textbackslash{}}:
  \texttt{\textbackslash{}pi} = π, \texttt{\textbackslash{}pm} = ±, and
  so on. There are a huge number of symbols available in LaTeX. Googling
  for \texttt{latex\ math\ symbols} will return many
  \href{http://www.sunilpatel.co.uk/latex-type/latex-math-symbols/}{lists}.
  There's even \href{http://detexify.kirelabs.org/classify.html}{a
  service} that will look up the symbol you sketch in the browser.
\item
  More complicated functions look like
  \texttt{\textbackslash{}name\{arg1\}\{arg2\}}. For example, to write a
  fraction you'd use \texttt{\textbackslash{}frac\{a\}\{b\}}. To write a
  square root, you'd use \texttt{\textbackslash{}sqrt\{a\}}.
\item
  To group elements together use \texttt{\{\}}: i.e.,
  \texttt{x\ \^{}\ a\ +\ b} vs. \texttt{x\ \^{}\ \{a\ +\ b\}}.
\item
  In good math typesetting, a distinction is made between variables and
  functions. But without extra information, LaTeX doesn't know whether
  \texttt{f(a\ *\ b)} represents calling the function \texttt{f} with
  input \texttt{a\ *\ b}, or is shorthand for \texttt{f\ *\ (a\ *\ b)}.
  If \texttt{f} is a function, you can tell LaTeX to typeset it using an
  upright font with \texttt{\textbackslash{}textrm\{f\}(a\ *\ b)}.
\end{itemize}

\hypertarget{goal-1}{%
\subsection{Goal}\label{goal-1}}

Our goal is to use these rules to automatically convert an R expression
to its appropriate LaTeX representation. We'll tackle this in four
stages:

\begin{itemize}
\item
  Convert known symbols: \texttt{pi} -\textgreater{}
  \texttt{\textbackslash{}pi}
\item
  Leave other symbols unchanged: \texttt{x} -\textgreater{} \texttt{x},
  \texttt{y} -\textgreater{} \texttt{y}
\item
  Convert known functions to their special forms:
  \texttt{sqrt(frac(a,\ b))} -\textgreater{}
  \texttt{\textbackslash{}sqrt\{\textbackslash{}frac\{a,\ b\}\}}
\item
  Wrap unknown functions with \texttt{\textbackslash{}textrm}:
  \texttt{f(a)} -\textgreater{} \texttt{\textbackslash{}textrm\{f\}(a)}
\end{itemize}

We'll code this translation in the opposite direction of what we did
with the HTML DSL. We'll start with infrastructure, because that makes
it easy to experiment with our DSL, and then work our way back down to
generate the desired output.

\hypertarget{to_math}{%
\subsection{\texorpdfstring{\texttt{to\_math}}{to\_math}}\label{to_math}}

To begin, we need a wrapper function that will convert R expressions
into LaTeX math expressions. This will work similarly to
\texttt{to\_html()}: capture the unevaluated expression and evaluate it
in a special environment. Two main differences:

\begin{itemize}
\item
  Environment is no longer constant, it will vary depending on the
  expression. We do this in order to specially handle unknown symbols
  and functions.
\item
  Don't use quosure.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{to_math <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(x)}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{eval_bare}\NormalTok{(expr, }\KeywordTok{latex_env}\NormalTok{(expr))}
  
  \KeywordTok{latex}\NormalTok{(out)}
\NormalTok{\}}

\NormalTok{latex <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"advr_latex"}\NormalTok{)}
\NormalTok{print.advr_latex <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{cat_line}\NormalTok{(}\StringTok{"<LATEX> "}\NormalTok{, x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{known-symbols}{%
\subsection{Known symbols}\label{known-symbols}}

Our first step is to create an environment that will convert the special
LaTeX symbols used for Greek, e.g., \texttt{pi} to
\texttt{\textbackslash{}pi}. We'll use the same basic trick as used by
\texttt{subset} to make it possible to select column ranges by name
(\texttt{subset(mtcars,\ ,\ cyl:wt)}): bind a name to a string in a
special environment.

We create that environment by naming a vector, converting the vector
into a list, and converting the list into an environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greek <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"alpha"}\NormalTok{, }\StringTok{"theta"}\NormalTok{, }\StringTok{"tau"}\NormalTok{, }\StringTok{"beta"}\NormalTok{, }\StringTok{"vartheta"}\NormalTok{, }\StringTok{"pi"}\NormalTok{, }\StringTok{"upsilon"}\NormalTok{,}
  \StringTok{"gamma"}\NormalTok{, }\StringTok{"varpi"}\NormalTok{, }\StringTok{"phi"}\NormalTok{, }\StringTok{"delta"}\NormalTok{, }\StringTok{"kappa"}\NormalTok{, }\StringTok{"rho"}\NormalTok{,}
  \StringTok{"varphi"}\NormalTok{, }\StringTok{"epsilon"}\NormalTok{, }\StringTok{"lambda"}\NormalTok{, }\StringTok{"varrho"}\NormalTok{, }\StringTok{"chi"}\NormalTok{, }\StringTok{"varepsilon"}\NormalTok{,}
  \StringTok{"mu"}\NormalTok{, }\StringTok{"sigma"}\NormalTok{, }\StringTok{"psi"}\NormalTok{, }\StringTok{"zeta"}\NormalTok{, }\StringTok{"nu"}\NormalTok{, }\StringTok{"varsigma"}\NormalTok{, }\StringTok{"omega"}\NormalTok{, }\StringTok{"eta"}\NormalTok{,}
  \StringTok{"xi"}\NormalTok{, }\StringTok{"Gamma"}\NormalTok{, }\StringTok{"Lambda"}\NormalTok{, }\StringTok{"Sigma"}\NormalTok{, }\StringTok{"Psi"}\NormalTok{, }\StringTok{"Delta"}\NormalTok{, }\StringTok{"Xi"}\NormalTok{, }
  \StringTok{"Upsilon"}\NormalTok{, }\StringTok{"Omega"}\NormalTok{, }\StringTok{"Theta"}\NormalTok{, }\StringTok{"Pi"}\NormalTok{, }\StringTok{"Phi"}\NormalTok{)}
\NormalTok{greek_list <-}\StringTok{ }\KeywordTok{set_names}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{, greek), greek)}
\NormalTok{greek_env <-}\StringTok{ }\KeywordTok{as_env}\NormalTok{(greek_list)}
\CommentTok{#> Warning: `as_env()` is soft-deprecated as of rlang 0.2.0.}
\CommentTok{#> This warning is displayed once per session.}
\end{Highlighting}
\end{Shaded}

We can then check it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  greek_env}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(pi)}
\CommentTok{#> <LATEX> \textbackslash{}pi}
\KeywordTok{to_math}\NormalTok{(beta)}
\CommentTok{#> <LATEX> \textbackslash{}beta}
\end{Highlighting}
\end{Shaded}

Looks good so far!

\hypertarget{unknown-symbols}{%
\subsection{Unknown symbols}\label{unknown-symbols}}

If a symbol isn't Greek, we want to leave it as is. This is tricky
because we don't know in advance what symbols will be used, and we can't
possibly generate them all. So we'll use the approach described in
\protect\hyperlink{ast-funs}{walking the tree}. The \texttt{all\_names}
function takes an expression and does the following: if it's a name, it
converts it to a string; if it's a call, it recurses down through its
arguments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_names_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x,}
    \DataTypeTok{constant =} \KeywordTok{character}\NormalTok{(),}
    \DataTypeTok{symbol =}   \KeywordTok{as.character}\NormalTok{(x),}
    \DataTypeTok{pairlist =}\NormalTok{ ,}
    \DataTypeTok{call =}     \KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x[}\OperatorTok{-}\DecValTok{1}\NormalTok{]), all_names)}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{all_names <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{unique}\NormalTok{(}\KeywordTok{all_names_rec}\NormalTok{(x))}
\NormalTok{\}}

\KeywordTok{all_names}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\KeywordTok{f}\NormalTok{(a, b, c, }\DecValTok{10}\NormalTok{)))}
\CommentTok{#> [1] "x" "y" "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

We now want to take that list of symbols, and convert it to an
environment so that each symbol is mapped to its corresponding string
representation (e.g., so \texttt{eval(quote(x),\ env)} yields
\texttt{"x"}). We again use the pattern of converting a named character
vector to a list, then converting the list to an environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_env}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names))}

\NormalTok{  symbol_env}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(x)}
\CommentTok{#> <LATEX> x}
\KeywordTok{to_math}\NormalTok{(longvariablename)}
\CommentTok{#> <LATEX> longvariablename}
\KeywordTok{to_math}\NormalTok{(pi)}
\CommentTok{#> <LATEX> pi}
\end{Highlighting}
\end{Shaded}

This works, but we need to combine it with the Greek symbols
environment. Since we want to give preference to Greek over defaults
(e.g., \texttt{to\_math(pi)} should give
\texttt{"\textbackslash{}\textbackslash{}pi"}, not \texttt{"pi"}),
\texttt{symbol\_env} needs to be the parent of \texttt{greek\_env}. To
do that, we need to make a copy of \texttt{greek\_env} with a new
parent.

This gives us a function that can convert both known (Greek) and unknown
symbols.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \CommentTok{# Unknown symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_env}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names))}

  \CommentTok{# Known symbols}
  \KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(x)}
\CommentTok{#> <LATEX> x}
\KeywordTok{to_math}\NormalTok{(longvariablename)}
\CommentTok{#> <LATEX> longvariablename}
\KeywordTok{to_math}\NormalTok{(pi)}
\CommentTok{#> <LATEX> \textbackslash{}pi}
\end{Highlighting}
\end{Shaded}

\hypertarget{known-functions}{%
\subsection{Known functions}\label{known-functions}}

Next we'll add functions to our DSL. We'll start with a couple of helper
closures that make it easy to add new unary and binary operators. These
functions are very simple: they only assemble strings. (Again we use
\texttt{force()} to make sure the arguments are evaluated at the right
time.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unary_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(left, right) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{e1 =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(}
      \KeywordTok{paste0}\NormalTok{(}\OperatorTok{!!}\NormalTok{left, e1, }\OperatorTok{!!}\NormalTok{right)  }
\NormalTok{    ),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{binary_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(sep) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{e1 =}\NormalTok{ , }\DataTypeTok{e2 =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(}
      \KeywordTok{paste0}\NormalTok{(e1, }\OperatorTok{!!}\NormalTok{sep, e2)  }
\NormalTok{    ),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sqrt\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{)}
\CommentTok{#> function (e1) }
\CommentTok{#> paste0("\textbackslash{}\textbackslash{}sqrt\{", e1, "\}")}
\KeywordTok{binary_op}\NormalTok{(}\StringTok{"+"}\NormalTok{)}
\CommentTok{#> function (e1, e2) }
\CommentTok{#> paste0(e1, "+", e2)}
\end{Highlighting}
\end{Shaded}

Using these helpers, we can map a few illustrative examples of
converting R to LaTeX. Note that with R's lexical scoping rules helping
us, we can easily provide new meanings for standard functions like
\texttt{+}, \texttt{-}, and \texttt{*}, and even \texttt{(} and
\texttt{\{}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Binary operators}
\NormalTok{f_env <-}\StringTok{ }\KeywordTok{child_env}\NormalTok{(}
  \DataTypeTok{.parent =} \KeywordTok{empty_env}\NormalTok{(),}
  \StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" + "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{-}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" - "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" * "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{/}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" / "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{^}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{"^"}\NormalTok{),}
  \StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{"_"}\NormalTok{),}
  
  \CommentTok{# Grouping}
  \StringTok{`}\DataTypeTok{\{}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left\{ "}\NormalTok{, }\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right\}"}\NormalTok{),}
  \StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left( "}\NormalTok{, }\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right)"}\NormalTok{),}
  \DataTypeTok{paste =}\NormalTok{ paste,}
  
  \CommentTok{# Other math functions}
  \DataTypeTok{sqrt =} \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sqrt\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{),}
  \DataTypeTok{sin =}  \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sin("}\NormalTok{, }\StringTok{")"}\NormalTok{),}
  \DataTypeTok{log =}  \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{log("}\NormalTok{, }\StringTok{")"}\NormalTok{),}
  \DataTypeTok{abs =}  \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left| "}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right| "}\NormalTok{),}
  \DataTypeTok{frac =} \ControlFlowTok{function}\NormalTok{(a, b) \{}
    \KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{frac\{"}\NormalTok{, a, }\StringTok{"\}\{"}\NormalTok{, b, }\StringTok{"\}"}\NormalTok{)}
\NormalTok{  \},}
  
  \CommentTok{# Labelling}
  \DataTypeTok{hat =}   \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{hat\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{),}
  \DataTypeTok{tilde =} \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{tilde\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We again modify \texttt{latex\_env()} to include this environment. It
should be the last environment R looks for names in: in other words,
\texttt{sin(sin)} should work.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \CommentTok{# Known functions}
\NormalTok{  f_env}

  \CommentTok{# Default symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_env}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names), }\DataTypeTok{parent =}\NormalTok{ f_env)}

  \CommentTok{# Known symbols}
\NormalTok{  greek_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{pi))}
\CommentTok{#> <LATEX> \textbackslash{}sin(x + \textbackslash{}pi)}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{log}\NormalTok{(x_i }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{))}
\CommentTok{#> <LATEX> \textbackslash{}log(x_i^2)}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(sin))}
\CommentTok{#> <LATEX> \textbackslash{}sin(sin)}
\end{Highlighting}
\end{Shaded}

\hypertarget{unknown-functions}{%
\subsection{Unknown functions}\label{unknown-functions}}

Finally, we'll add a default for functions that we don't yet know about.
Like the unknown names, we can't know in advance what these will be, so
we again use a little metaprogramming to figure them out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_calls_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x, }
    \DataTypeTok{constant =}\NormalTok{ ,}
    \DataTypeTok{symbol =}   \KeywordTok{character}\NormalTok{(),}
    \DataTypeTok{call =}\NormalTok{ \{}
\NormalTok{      fname <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]])}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x[}\OperatorTok{-}\DecValTok{1}\NormalTok{]), all_calls)}
      \KeywordTok{c}\NormalTok{(fname, children)}
\NormalTok{    \},}
    \DataTypeTok{pairlist =} \KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x[}\DecValTok{1}\NormalTok{]), all_calls)}
\NormalTok{  )}
\NormalTok{\}}
\NormalTok{all_calls <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{unique}\NormalTok{(}\KeywordTok{all_calls_rec}\NormalTok{(x))}
\NormalTok{\}}

\KeywordTok{all_calls}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(g }\OperatorTok{+}\StringTok{ }\NormalTok{b, c, }\KeywordTok{d}\NormalTok{(a))))}
\CommentTok{#> [1] "f" "+" "d"}
\end{Highlighting}
\end{Shaded}

And we need a closure that will generate the functions for each unknown
call.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unknown_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(op) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      contents <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(..., }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{)}
      \KeywordTok{paste0}\NormalTok{(}\OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{mathrm\{"}\NormalTok{, op, }\StringTok{"\}("}\NormalTok{), contents, }\StringTok{")"}\NormalTok{)}
\NormalTok{    \})}
\NormalTok{  )}
\NormalTok{\}}
\KeywordTok{unknown_op}\NormalTok{(}\StringTok{"foo"}\NormalTok{)}
\CommentTok{#> function (...) }
\CommentTok{#> \{}
\CommentTok{#>     contents <- paste(..., collapse = ", ")}
\CommentTok{#>     paste0("\textbackslash{}\textbackslash{}mathrm\{foo\}(", contents, ")")}
\CommentTok{#> \}}
\CommentTok{#> <environment: 0x105ee60>}
\end{Highlighting}
\end{Shaded}

And again we update \texttt{latex\_env()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  calls <-}\StringTok{ }\KeywordTok{all_calls}\NormalTok{(expr)}
\NormalTok{  call_list <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(calls), unknown_op)}
\NormalTok{  call_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(call_list)}

  \CommentTok{# Known functions}
\NormalTok{  f_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(f_env, call_env)}

  \CommentTok{# Default symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_env}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names), }\DataTypeTok{parent =}\NormalTok{ f_env)}

  \CommentTok{# Known symbols}
\NormalTok{  greek_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(}\KeywordTok{f}\NormalTok{(a }\OperatorTok{*}\StringTok{ }\NormalTok{b))}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{f\}(a * b)}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-65}{%
\subsection{Exercises}\label{exercises-65}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add escaping. The special symbols that should be escaped by adding a
  backslash in front of them are \texttt{\textbackslash{}}, \texttt{\$},
  and \texttt{\%}. Just as with HTML, you'll need to make sure you don't
  end up double-escaping. So you'll need to create a small S3 class and
  then use that in function operators. That will also allow you to embed
  arbitrary LaTeX if needed.
\item
  Complete the DSL to support all the functions that \texttt{plotmath}
  supports.
\end{enumerate}

\hypertarget{part-techniques}{%
\part{Techniques}\label{part-techniques}}

\hypertarget{debugging}{%
\chapter{Debugging}\label{debugging}}

\hypertarget{introduction-19}{%
\section{Introduction}\label{introduction-19}}

What happens when something goes wrong with your R code? What do you do?
What tools do you have to address the problem? This chapter will teach
you how to fix unanticipated problems (debugging), show you how
functions can communicate problems and how you can take action based on
those communications (condition handling), and teach you how to avoid
common problems before they occur (defensive programming).

Debugging is the art and science of fixing unexpected problems in your
code. In this section you'll learn the tools and techniques that help
you get to the root cause of an error. You'll learn general strategies
for debugging, useful R functions like \texttt{traceback()} and
\texttt{browser()}, and interactive tools in RStudio.

The chapter concludes with a discussion of ``defensive'' programming:
ways to avoid common errors before they occur. In the short run you'll
spend more time writing code, but in the long run you'll save time
because error messages will be more informative and will let you narrow
in on the root cause more quickly. The basic principle of defensive
programming is to ``fail fast'', to raise an error as soon as something
goes wrong. In R, this takes three particular forms: checking that
inputs are correct, avoiding non-standard evaluation, and avoiding
functions that can return different types of output.

\hypertarget{outline-17}{%
\subsection*{Outline}\label{outline-17}}
\addcontentsline{toc}{subsection}{Outline}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \protect\hyperlink{debugging-techniques}{Debugging techniques}
  outlines a general approach for finding and resolving bugs.
\item
  \protect\hyperlink{debugging-tools}{Debugging tools} introduces you to
  the R functions and RStudio features that help you locate exactly
  where an error occurred.
\item
  \protect\hyperlink{defensive-programming}{Defensive programming}
  introduces you to some important techniques for defensive programming,
  techniques that help prevent bugs from occurring in the first place.
\end{enumerate}

\hypertarget{debugging-techniques}{%
\section{Techniques}\label{debugging-techniques}}

\begin{quote}
``Finding your bug is a process of confirming the many things that you
believe are true --- until you find one which is not true.''

\hspace*{\fill} ---Norm Matloff
\end{quote}

Debugging code is challenging. Many bugs are subtle and hard to find.
Indeed, if a bug was obvious, you probably would've been able to avoid
it in the first place. While it's true that with a good technique, you
can productively debug a problem with just \texttt{print()}, there are
times when additional help would be welcome. In this section, we'll
discuss some useful tools, which R and RStudio provide, and outline a
general procedure for debugging. \index{debugging} \index{bugs}

While the procedure below is by no means foolproof, it will hopefully
help you to organise your thoughts when debugging. There are four steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Realise that you have a bug}

  If you're reading this chapter, you've probably already completed this
  step. It is a surprisingly important one: you can't fix a bug until
  you know it exists. This is one reason why automated test suites are
  important when producing high-quality code. Unfortunately, automated
  testing is outside the scope of this book, but you can read more about
  it at \url{http://r-pkgs.had.co.nz/tests.html}.
\item
  \textbf{Make it repeatable}

  Once you've determined you have a bug, you need to be able to
  reproduce it on command. Without this, it becomes extremely difficult
  to isolate its cause and to confirm that you've successfully fixed it.

  Generally, you will start with a big block of code that you know
  causes the error and then slowly whittle it down to get to the
  smallest possible snippet that still causes the error. Binary search
  is particularly useful for this. To do a binary search, you repeatedly
  remove half of the code until you find the bug. This is fast because,
  with each step, you reduce the amount of code to look through by half.

  If it takes a long time to generate the bug, it's also worthwhile to
  figure out how to generate it faster. The quicker you can do this, the
  quicker you can figure out the cause.

  As you work on creating a minimal example, you'll also discover
  similar inputs that don't trigger the bug. Make note of them: they
  will be helpful when diagnosing the cause of the bug.

  If you're using automated testing, this is also a good time to create
  an automated test case. If your existing test coverage is low, take
  the opportunity to add some nearby tests to ensure that existing good
  behaviour is preserved. This reduces the chances of creating a new
  bug.
\item
  \textbf{Figure out where it is}

  If you're lucky, one of the tools in the following section will help
  you to quickly identify the line of code that's causing the bug.
  Usually, however, you'll have to think a bit more about the problem.
  It's a great idea to adopt the scientific method. Generate hypotheses,
  design experiments to test them, and record your results. This may
  seem like a lot of work, but a systematic approach will end up saving
  you time. I often waste a lot of time relying on my intuition to solve
  a bug (``oh, it must be an off-by-one error, so I'll just subtract 1
  here''), when I would have been better off taking a systematic
  approach.
\item
  \textbf{Fix it and test it}

  Once you've found the bug, you need to figure out how to fix it and to
  check that the fix actually worked. Again, it's very useful to have
  automated tests in place. Not only does this help to ensure that
  you've actually fixed the bug, it also helps to ensure you haven't
  introduced any new bugs in the process. In the absence of automated
  tests, make sure to carefully record the correct output, and check
  against the inputs that previously failed.
\end{enumerate}

\hypertarget{debugging-tools}{%
\section{Tools}\label{debugging-tools}}

To implement a strategy of debugging, you'll need tools. In this
section, you'll learn about the tools provided by R and the RStudio IDE.
RStudio's integrated debugging support makes life easier by exposing
existing R tools in a user friendly way. I'll show you both the R and
RStudio ways so that you can work with whatever environment you use. You
may also want to refer to the official
\href{https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio}{RStudio
debugging documentation} which always reflects the tools in the latest
version of RStudio.

There are three key debugging tools:

\begin{itemize}
\item
  RStudio's error inspector and \texttt{traceback()} which list the
  sequence of calls that lead to the error.
\item
  RStudio's ``Rerun with Debug'' tool and
  \texttt{options(error\ =\ browser)} which open an interactive session
  where the error occurred.
\item
  RStudio's breakpoints and \texttt{browser()} which open an interactive
  session at an arbitrary location in the code.
\end{itemize}

I'll explain each tool in more detail below.

You shouldn't need to use these tools when writing new functions. If you
find yourself using them frequently with new code, you may want to
reconsider your approach. Instead of trying to write one big function
all at once, work interactively on small pieces. If you start small, you
can quickly identify why something doesn't work. But if you start large,
you may end up struggling to identify the source of the problem.

\hypertarget{determining-the-sequence-of-calls}{%
\subsection{Determining the sequence of
calls}\label{determining-the-sequence-of-calls}}

The first tool is the \textbf{call stack}, the sequence of calls that
lead up to an error. Here's a simple example: you can see that
\texttt{f()} calls \texttt{g()} calls \texttt{h()} calls \texttt{i()}
which adds together a number and a string creating an error:
\index{call stack} \indexc{traceback()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a) }\KeywordTok{g}\NormalTok{(a)}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(b) }\KeywordTok{h}\NormalTok{(b)}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(c) }\KeywordTok{i}\NormalTok{(c)}
\NormalTok{i <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(d) }\StringTok{"a"} \OperatorTok{+}\StringTok{ }\NormalTok{d}
\KeywordTok{f}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

When we run this code in RStudio we see:

\begin{center}\includegraphics[width=0.7\linewidth]{screenshots/traceback-hidden} \end{center}

Two options appear to the right of the error message: ``Show Traceback''
and ``Rerun with Debug''. If you click ``Show traceback'' you see:

\begin{center}\includegraphics[width=0.7\linewidth]{screenshots/traceback-shown} \end{center}

If you're not using RStudio, you can use \texttt{traceback()} to get the
same information:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{traceback}\NormalTok{()}
\CommentTok{# 4: i(c) at exceptions-example.R#3}
\CommentTok{# 3: h(b) at exceptions-example.R#2}
\CommentTok{# 2: g(a) at exceptions-example.R#1}
\CommentTok{# 1: f(10)}
\end{Highlighting}
\end{Shaded}

Read the call stack from bottom to top: the initial call is
\texttt{f()}, which calls \texttt{g()}, then \texttt{h()}, then
\texttt{i()}, which triggers the error. If you're calling code that you
\texttt{source()}d into R, the traceback will also display the location
of the function, in the form \texttt{filename.r\#linenumber}. These are
clickable in RStudio, and will take you to the corresponding line of
code in the editor.

Sometimes this is enough information to let you track down the error and
fix it. However, it's usually not. \texttt{traceback()} shows you where
the error occurred, but not why. The next useful tool is the interactive
debugger, which allows you to pause execution of a function and
interactively explore its state.

\hypertarget{browsing-on-error}{%
\subsection{Browsing on error}\label{browsing-on-error}}

The easiest way to enter the interactive debugger is through RStudio's
``Rerun with Debug'' tool. This reruns the command that created the
error, pausing execution where the error occurred. You're now in an
interactive state inside the function, and you can interact with any
object defined there. You'll see the corresponding code in the editor
(with the statement that will be run next highlighted), objects in the
current environment in the ``Environment'' pane, the call stack in a
``Traceback'' pane, and you can run arbitrary R code in the console.
\index{debugger, interactive}

As well as any regular R function, there are a few special commands you
can use in debug mode. You can access them either with the RStudio
toolbar
(\includegraphics[width=\textwidth,height=0.20833in]{screenshots/debug-toolbar.png})
or with the keyboard:

\begin{itemize}
\item
  Next, \texttt{n}: executes the next step in the function. Be careful
  if you have a variable named \texttt{n}; to print it you'll need to do
  \texttt{print(n)}.
\item
  Step into,
  \includegraphics[width=\textwidth,height=0.20833in]{screenshots/step-into.png}
  or \texttt{s}: works like next, but if the next step is a function, it
  will step into that function so you can work through each line.
\item
  Finish,
  \includegraphics[width=\textwidth,height=0.20833in]{screenshots/finish-loop.png}
  or \texttt{f}: finishes execution of the current loop or function.
\item
  Continue, \texttt{c}: leaves interactive debugging and continues
  regular execution of the function. This is useful if you've fixed the
  bad state and want to check that the function proceeds correctly.
\item
  Stop, \texttt{Q}: stops debugging, terminates the function, and
  returns to the global workspace. Use this once you've figured out
  where the problem is, and you're ready to fix it and reload the code.
\end{itemize}

There are two other slightly less useful commands that aren't available
in the toolbar:

\begin{itemize}
\item
  Enter: repeats the previous command. I find this too easy to activate
  accidentally, so I turn it off using
  \texttt{options(browserNLdisabled\ =\ TRUE)}.
\item
  \texttt{where}: prints stack trace of active calls (the interactive
  equivalent of \texttt{traceback}).
\end{itemize}

To enter this style of debugging outside of RStudio, you can use the
\texttt{error} option which specifies a function to run when an error
occurs. The function most similar to RStudio's debug is
\texttt{browser()}: this will start an interactive console in the
environment where the error occurred. Use
\texttt{options(error\ =\ browser)} to turn it on, re-run the previous
command, then use \texttt{options(error\ =\ NULL)} to return to the
default error behaviour. You could automate this with the
\texttt{browseOnce()} function as defined below: \indexc{options(error)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{browseOnce <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  old <-}\StringTok{ }\KeywordTok{getOption}\NormalTok{(}\StringTok{"error"}\NormalTok{)}
  \ControlFlowTok{function}\NormalTok{() \{}
    \KeywordTok{options}\NormalTok{(}\DataTypeTok{error =}\NormalTok{ old)}
    \KeywordTok{browser}\NormalTok{()}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{options}\NormalTok{(}\DataTypeTok{error =} \KeywordTok{browseOnce}\NormalTok{())}

\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{stop}\NormalTok{(}\StringTok{"!"}\NormalTok{)}
\CommentTok{# Enters browser}
\KeywordTok{f}\NormalTok{()}
\CommentTok{# Runs normally}
\KeywordTok{f}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

(You'll learn more about functions that return functions in
\protect\hyperlink{functional-programming}{Functional programming}.)

There are two other useful functions that you can use with the
\texttt{error} option:

\begin{itemize}
\item
  \texttt{recover} is a step up from \texttt{browser}, as it allows you
  to enter the environment of any of the calls in the call stack. This
  is useful because often the root cause of the error is a number of
  calls back. \indexc{recover()}
\item
  \texttt{dump.frames} is an equivalent to \texttt{recover} for
  non-interactive code. It creates a \texttt{last.dump.rda} file in the
  current working directory. Then, in a later interactive R session, you
  load that file, and use \texttt{debugger()} to enter an interactive
  debugger with the same interface as \texttt{recover()}. This allows
  interactive debugging of batch code. \indexc{dump.frames()}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# In batch R process ----}
\NormalTok{dump_and_quit <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \CommentTok{# Save debugging info to file last.dump.rda}
  \KeywordTok{dump.frames}\NormalTok{(}\DataTypeTok{to.file =} \OtherTok{TRUE}\NormalTok{)}
  \CommentTok{# Quit R with error status}
  \KeywordTok{q}\NormalTok{(}\DataTypeTok{status =} \DecValTok{1}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{options}\NormalTok{(}\DataTypeTok{error =}\NormalTok{ dump_and_quit)}

\CommentTok{# In a later interactive session ----}
\KeywordTok{load}\NormalTok{(}\StringTok{"last.dump.rda"}\NormalTok{)}
\KeywordTok{debugger}\NormalTok{()}
\end{Highlighting}
\end{Shaded}
\end{itemize}

To reset error behaviour to the default, use
\texttt{options(error\ =\ NULL)}. Then errors will print a message and
abort function execution.

\hypertarget{browsing-arbitrary-code}{%
\subsection{Browsing arbitrary code}\label{browsing-arbitrary-code}}

As well as entering an interactive console on error, you can enter it at
an arbitrary code location by using either an RStudio breakpoint or
\texttt{browser()}. You can set a breakpoint in RStudio by clicking to
the left of the line number, or pressing \texttt{Shift\ +\ F9}.
Equivalently, add \texttt{browser()} where you want execution to pause.
Breakpoints behave similarly to \texttt{browser()} but they are easier
to set (one click instead of nine key presses), and you don't run the
risk of accidentally including a \texttt{browser()} statement in your
source code. There are two small downsides to breakpoints:
\indexc{browser()} \index{breakpoints}

\begin{itemize}
\item
  There are a few unusual situations in which breakpoints will not work:
  read
  \href{http://www.rstudio.com/ide/docs/debugging/breakpoint-troubleshooting}{breakpoint
  troubleshooting} for more details.
\item
  RStudio currently does not support conditional breakpoints, whereas
  you can always put \texttt{browser()} inside an \texttt{if} statement.
\end{itemize}

As well as adding \texttt{browser()} yourself, there are two other
functions that will add it to code:

\begin{itemize}
\item
  \texttt{debug()} inserts a browser statement in the first line of the
  specified function. \texttt{undebug()} removes it. Alternatively, you
  can use \texttt{debugonce()} to browse only on the next run.
  \indexc{debug()}
\item
  \texttt{utils::setBreakpoint()} works similarly, but instead of taking
  a function name, it takes a file name and line number and finds the
  appropriate function for you. \indexc{setBreakpoint()}
\end{itemize}

These two functions are both special cases of \texttt{trace()}, which
inserts arbitrary code at any position in an existing function.
\texttt{trace()} is occasionally useful when you're debugging code that
you don't have the source for. To remove tracing from a function, use
\texttt{untrace()}. You can only perform one trace per function, but
that one trace can call multiple functions. \indexc{trace()}

\hypertarget{the-call-stack-traceback-where-and-recover}{%
\subsection{\texorpdfstring{The call stack: \texttt{traceback()},
\texttt{where}, and
\texttt{recover()}}{The call stack: traceback(), where, and recover()}}\label{the-call-stack-traceback-where-and-recover}}

Unfortunately, the call stacks printed by \texttt{traceback()},
\texttt{browser()} + \texttt{where}, and \texttt{recover()} are not
consistent. The following table shows how the call stacks from a simple
nested set of calls are displayed by the three tools. \index{call stack}

\begin{longtable}[]{@{}lll@{}}
\toprule
\texttt{traceback()} & \texttt{where} &
\texttt{recover()}\tabularnewline
\midrule
\endhead
\texttt{4:\ stop("Error")} & \texttt{where\ 1:\ stop("Error")} &
\texttt{1:\ f()}\tabularnewline
\texttt{3:\ h(x)} & \texttt{where\ 2:\ h(x)} &
\texttt{2:\ g(x)}\tabularnewline
\texttt{2:\ g(x)} & \texttt{where\ 3:\ g(x)} &
\texttt{3:\ h(x)}\tabularnewline
\texttt{1:\ f()} & \texttt{where\ 4:\ f()} &\tabularnewline
\bottomrule
\end{longtable}

Note that numbering is different between \texttt{traceback()} and
\texttt{where}, and that \texttt{recover()} displays calls in the
opposite order, and omits the call to \texttt{stop()}. RStudio displays
calls in the same order as \texttt{traceback()} but omits the numbers.

\hypertarget{other-types-of-failure}{%
\subsection{Other types of failure}\label{other-types-of-failure}}

There are other ways for a function to fail apart from throwing an error
or returning an incorrect result.

\begin{itemize}
\item
  A function may generate an unexpected warning. The easiest way to
  track down warnings is to convert them into errors with
  \texttt{options(warn\ =\ 2)} and use the regular debugging tools. When
  you do this you'll see some extra calls in the call stack, like
  \texttt{doWithOneRestart()}, \texttt{withOneRestart()},
  \texttt{withRestarts()}, and \texttt{.signalSimpleWarning()}. Ignore
  these: they are internal functions used to turn warnings into errors.
  \index{debugging!warnings}
\item
  A function may generate an unexpected message. There's no built-in
  tool to help solve this problem, but it's possible to create one:
  \index{debugging!messages}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) }\KeywordTok{stop}\NormalTok{(e))}
\NormalTok{\}}

\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{g}\NormalTok{()}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\KeywordTok{message}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{)}
\KeywordTok{f}\NormalTok{()}
\CommentTok{# Hi!}
\KeywordTok{message2error}\NormalTok{(}\KeywordTok{f}\NormalTok{())}
\CommentTok{# Error in message("Hi!"): Hi!}
\KeywordTok{traceback}\NormalTok{()}
\CommentTok{# 11: stop(e) at #2}
\CommentTok{# 10: (function (e) }
\CommentTok{#     stop(e))(list(message = "Hi!\textbackslash{}n", call = message("Hi!")))}
\CommentTok{# 9: signalCondition(cond)}
\CommentTok{# 8: doWithOneRestart(return(expr), restart)}
\CommentTok{# 7: withOneRestart(expr, restarts[[1L]])}
\CommentTok{# 6: withRestarts(\{}
\CommentTok{#        signalCondition(cond)}
\CommentTok{#        defaultHandler(cond)}
\CommentTok{#    \}, muffleMessage = function() NULL)}
\CommentTok{# 5: message("Hi!") at #1}
\CommentTok{# 4: g() at #1}
\CommentTok{# 3: f() at #2}
\CommentTok{# 2: withCallingHandlers(code, message = function(e) stop(e)) at #2}
\CommentTok{# 1: message2error(f())}
\end{Highlighting}
\end{Shaded}

  As with warnings, you'll need to ignore some of the calls on the
  traceback (i.e., the first two and the last six).
\item
  A function might never return. This is particularly hard to debug
  automatically, but sometimes terminating the function and looking at
  the call stack is informative. Otherwise, use the basic debugging
  strategies described above.
\item
  The worst scenario is that your code might crash R completely, leaving
  you with no way to interactively debug your code. This indicates a bug
  in the underlying C code. This is hard to debug. Sometimes an
  interactive debugger, like \texttt{gdb}, can be useful, but describing
  how to use it is beyond the scope of this book.
  \index{debugging!C code}

  If the crash is caused by base R code, post a reproducible example to
  R-help. If it's in a package, contact the package maintainer. If it's
  your own C or C++ code, you'll need to use numerous \texttt{print()}
  statements to narrow down the location of the bug, and then you'll
  need to use many more print statements to figure out which data
  structure doesn't have the properties that you expect.
\end{itemize}

\hypertarget{performance}{%
\chapter{Performance}\label{performance}}

R is not a fast language. This is not an accident. R was purposely
designed to make data analysis and statistics easier for you to do. It
was not designed to make life easier for your computer. While R is slow
compared to other programming languages, for most purposes, it's fast
enough. \index{performance}

The goal of this part of the book is to give you a deeper understanding
of R's performance characteristics. In this chapter, you'll learn about
some of the trade-offs that R has made, valuing flexibility over
performance. The following four chapters will give you the skills to
improve the speed of your code when you need to:

\begin{itemize}
\item
  In \protect\hyperlink{profiling}{Profiling}, you'll learn how to
  systematically make your code faster. First you figure what's slow,
  and then you apply some general techniques to make the slow parts
  faster.
\item
  For really high-performance code, you can move outside of R and use
  another programming language. \protect\hyperlink{rcpp}{Rcpp} will
  teach you the absolute minimum you need to know about C++ so you can
  write fast code using the Rcpp package.
\item
  To really understand the performance of built-in base functions,
  you'll need to learn a little bit about R's C API. In
  \protect\hyperlink{c-api}{R's C interface}, you'll learn a little
  about R's C internals.
\end{itemize}

Let's get started by learning more about why R is slow.

\hypertarget{why-is-r-slow}{%
\section{Why is R slow?}\label{why-is-r-slow}}

To understand R's performance, it helps to think about R as both a
language and as an implementation of that language. The R-language is
abstract: it defines what R code means and how it should work. The
implementation is concrete: it reads R code and computes a result. The
most popular implementation is the one from
\href{http://r-project.org}{r-project.org}. I'll call that
implementation GNU-R to distinguish it from R-language, and from the
other implementations I'll discuss later in the chapter.
\index{language definition}

The distinction between R-language and GNU-R is a bit murky because the
R-language is not formally defined. While there is the
\href{http://cran.r-project.org/doc/manuals/R-lang.html}{R language
definition}, it is informal and incomplete. The R-language is mostly
defined in terms of how GNU-R works. This is in contrast to other
languages, like \href{http://isocpp.org/std/the-standard}{C++} and
\href{http://www.ecma-international.org/publications/standards/Ecma-262.htm}{JavaScript},
that make a clear distinction between language and implementation by
laying out formal specifications that describe in minute detail how
every aspect of the language should work. Nevertheless, the distinction
between R-language and GNU-R is still useful: poor performance due to
the language is hard to fix without breaking existing code; fixing poor
performance due to the implementation is easier.

In \protect\hyperlink{language-performance}{Language performance}, I
discuss some of the ways in which the design of the R-language imposes
fundamental constraints on R's speed. In
\protect\hyperlink{implementation-performance}{Implementation
performance}, I discuss why GNU-R is currently far from the theoretical
maximum, and why improvements in performance happen so slowly. While
it's hard to know exactly how much faster a better implementation could
be, a \textgreater{}10x improvement in speed seems achievable. In
\protect\hyperlink{faster-r}{alternative implementations}, I discuss
some of the promising new implementations of R, and describe one
important technique they use to make R code run faster.

Beyond performance limitations due to design and implementation, it has
to be said that a lot of R code is slow simply because it's poorly
written. Few R users have any formal training in programming or software
development. Fewer still write R code for a living. Most people use R to
understand data: it's more important to get an answer quickly than to
develop a system that will work in a wide variety of situations. This
means that it's relatively easy to make most R code much faster, as
we'll see in the following chapters.

Before we examine some of the slower parts of the R-language and GNU-R,
we need to learn a little about benchmarking so that we can give our
intuitions about performance a concrete foundation.

\hypertarget{microbenchmarking}{%
\section{Microbenchmarking}\label{microbenchmarking}}

A microbenchmark is a measurement of the performance of a very small
piece of code, something that might take microseconds (µs) or
nanoseconds (ns) to run. I'm going to use microbenchmarks to demonstrate
the performance of very low-level pieces of R code, which help develop
your intuition for how R works. This intuition, by-and-large, is not
useful for increasing the speed of real code. The observed differences
in microbenchmarks will typically be dominated by higher-order effects
in real code; a deep understanding of subatomic physics is not very
helpful when baking. Don't change the way you code because of these
microbenchmarks. Instead wait until you've read the practical advice in
the following chapters. \index{microbenchmarks}

The best tool for microbenchmarking in R is the
\href{http://cran.r-project.org/web/packages/microbenchmark/}{microbenchmark}
package. It provides very precise timings, making it possible to compare
operations that only take a tiny amount of time. For example, the
following code compares the speed of two ways of computing a square
root.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(microbenchmark)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{sqrt}\NormalTok{(x),}
\NormalTok{  x }\OperatorTok{^}\StringTok{ }\FloatTok{0.5}
\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>     expr   min    lq  mean median     uq    max neval}
\CommentTok{#>  sqrt(x)   942 1,130  1448  1,310  1,530  9,440   100}
\CommentTok{#>    x^0.5 9,210 9,590 10239  9,810 10,100 39,500   100}
\end{Highlighting}
\end{Shaded}

By default, \texttt{microbenchmark()} runs each expression 100 times
(controlled by the \texttt{times} parameter). In the process, it also
randomises the order of the expressions. It summarises the results with
a minimum (\texttt{min}), lower quartile (\texttt{lq}), median, upper
quartile (\texttt{uq}), and maximum (\texttt{max}). Focus on the median,
and use the upper and lower quartiles (\texttt{lq} and \texttt{uq}) to
get a feel for the variability. In this example, you can see that using
the special purpose \texttt{sqrt()} function is faster than the general
exponentiation operator.

As with all microbenchmarks, pay careful attention to the units: here,
each computation takes about 1,000 ns, 1,000 billionths of a second. To
help calibrate the impact of a microbenchmark on run time, it's useful
to think about how many times a function needs to run before it takes a
second. If a microbenchmark takes:

\begin{itemize}
\tightlist
\item
  1 ms, then one thousand calls takes a second
\item
  1 µs, then one million calls takes a second
\item
  1 ns, then one billion calls takes a second
\end{itemize}

The \texttt{sqrt()} function takes about 1,000 ns, or 1 µs, to compute
the square root of 100 numbers. That means if you repeated the operation
a million times, it would take 1 s. So changing the way you compute the
square root is unlikely to significantly affect real code.

\hypertarget{exercises-66}{%
\subsection{Exercises}\label{exercises-66}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Instead of using \texttt{microbenchmark()}, you could use the built-in
  function \texttt{system.time()}. But \texttt{system.time()} is much
  less precise, so you'll need to repeat each operation many times with
  a loop, and then divide to find the average time of each operation, as
  in the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\FloatTok{1e6}
\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) }\KeywordTok{sqrt}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) x }\OperatorTok{^}\StringTok{ }\FloatTok{0.5}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\end{Highlighting}
\end{Shaded}

  How do the estimates from \texttt{system.time()} compare to those from
  \texttt{microbenchmark()}? Why are they different?
\item
  Here are two other ways to compute the square root of a vector. Which
  do you think will be fastest? Which will be slowest? Use
  microbenchmarking to test your answers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\KeywordTok{exp}\NormalTok{(}\KeywordTok{log}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  Use microbenchmarking to rank the basic arithmetic operators
  (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, and \texttt{\^{}}) in
  terms of their speed. Visualise the results. Compare the speed of
  arithmetic on integers vs.~doubles.
\item
  You can change the units in which the microbenchmark results are
  expressed with the \texttt{unit} parameter. Use
  \texttt{unit\ =\ "eps"} to show the number of evaluations needed to
  take 1 second. Repeat the benchmarks above with the eps unit. How does
  this change your intuition for performance?
\end{enumerate}

\hypertarget{language-performance}{%
\section{Language performance}\label{language-performance}}

In this section, I'll explore three trade-offs that limit the
performance of the R-language: extreme dynamism, name lookup with
mutable environments, and lazy evaluation of function arguments. I'll
illustrate each trade-off with a microbenchmark, showing how it slows
GNU-R down. I benchmark GNU-R because you can't benchmark the R-language
(it can't run code). This means that the results are only suggestive of
the cost of these design decisions, but are nevertheless useful. I've
picked these three examples to illustrate some of the trade-offs that
are key to language design: the designer must balance speed,
flexibility, and ease of implementation.

If you'd like to learn more about the performance characteristics of the
R-language and how they affect real code, I highly recommend
\href{http://r.cs.purdue.edu/pub/ecoop12.pdf}{``Evaluating the Design of
the R Language''} by Floreal Morandat, Brandon Hill, Leo Osvald, and Jan
Vitek. It uses a powerful methodology that combines a modified R
interpreter and a wide set of code found in the wild.

\hypertarget{extreme-dynamism}{%
\subsection{Extreme dynamism}\label{extreme-dynamism}}

R is an extremely dynamic programming language. Almost anything can be
modified after it is created. To give just a few examples, you can:

\begin{itemize}
\tightlist
\item
  Change the body, arguments, and environment of functions.
\item
  Change the S4 methods for a generic.
\item
  Add new fields to an S3 object, or even change its class.
\item
  Modify objects outside of the local environment with
  \texttt{\textless{}\textless{}-}.
\end{itemize}

Pretty much the only things you can't change are objects in sealed
namespaces, which are created when you load a package.

The advantage of dynamism is that you need minimal upfront planning. You
can change your mind at any time, iterating your way to a solution
without having to start afresh. The disadvantage of dynamism is that
it's difficult to predict exactly what will happen with a given function
call. This is a problem because the easier it is to predict what's going
to happen, the easier it is for an interpreter or compiler to make an
optimisation. (If you'd like more details, Charles Nutter expands on
this idea at
\href{http://blog.headius.com/2013/05/on-languages-vms-optimization-and-way.html}{On
Languages, VMs, Optimization, and the Way of the World}.) If an
interpreter can't predict what's going to happen, it has to consider
many options before it finds the right one. For example, the following
loop is slow in R, because R doesn't know that \texttt{x} is always an
integer. That means R has to look for the right \texttt{+} method (i.e.,
is it adding doubles, or integers?) in every iteration of the loop.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\NormalTok{0L}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\FloatTok{1e6}\NormalTok{) \{}
\NormalTok{  x <-}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The cost of finding the right method is higher for non-primitive
functions. The following microbenchmark illustrates the cost of method
dispatch for S3, S4, and RC. I create a generic and a method for each OO
system, then call the generic and see how long it takes to find and call
the method. I also time how long it takes to call the bare function for
comparison. \index{methods!cost of dispatch}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\OtherTok{NULL}

\NormalTok{s3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"s3"}\NormalTok{)}
\NormalTok{s3.integer <-}\StringTok{ }\NormalTok{f}

\NormalTok{A <-}\StringTok{ }\KeywordTok{setClass}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{a =} \StringTok{"list"}\NormalTok{))}
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"s4"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"s4"}\NormalTok{))}
\KeywordTok{setMethod}\NormalTok{(s4, }\StringTok{"A"}\NormalTok{, f)}

\NormalTok{B <-}\StringTok{ }\KeywordTok{setRefClass}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\DataTypeTok{methods =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{rc =}\NormalTok{ f))}

\NormalTok{a <-}\StringTok{ }\KeywordTok{A}\NormalTok{()}
\NormalTok{b <-}\StringTok{ }\NormalTok{B}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{fun =} \KeywordTok{f}\NormalTok{(),}
  \DataTypeTok{S3 =} \KeywordTok{s3}\NormalTok{(1L),}
  \DataTypeTok{S4 =} \KeywordTok{s4}\NormalTok{(a),}
  \DataTypeTok{RC =}\NormalTok{ b}\OperatorTok{$}\KeywordTok{rc}\NormalTok{()}
\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>  expr    min     lq  mean median     uq       max neval}
\CommentTok{#>   fun    182    216   432    238    256    16,900   100}
\CommentTok{#>    S3  1,010  1,170 11164  1,230  1,500   952,000   100}
\CommentTok{#>    S4 12,000 12,500 29372 12,900 14,400 1,040,000   100}
\CommentTok{#>    RC  8,210  8,620 41290  8,780  9,270 3,180,000   100}
\end{Highlighting}
\end{Shaded}

The bare function takes about 200 ns. S3 method dispatch takes an
additional 1,000 ns; S4 dispatch, 10,000 ns; and RC dispatch, 9,000 ns.
S3 and S4 method dispatch are expensive because R must search for the
right method every time the generic is called; it might have changed
between this call and the last. R could do better by caching methods
between calls, but caching is hard to do correctly and a notorious
source of bugs.

\hypertarget{name-lookup-with-mutable-environments}{%
\subsection{Name lookup with mutable
environments}\label{name-lookup-with-mutable-environments}}

It's surprisingly difficult to find the value associated with a name in
the R-language. This is due to combination of lexical scoping and
extreme dynamism. Take the following example. Each time we print
\texttt{a} it comes from a different environment:
\index{names!cost of lookup}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
    \KeywordTok{print}\NormalTok{(a)}
    \KeywordTok{assign}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DataTypeTok{envir =} \KeywordTok{parent.frame}\NormalTok{())}
    \KeywordTok{print}\NormalTok{(a)}
\NormalTok{    a <-}\StringTok{ }\DecValTok{3}
    \KeywordTok{print}\NormalTok{(a)}
\NormalTok{  \}}
  \KeywordTok{g}\NormalTok{()}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> [1] 1}
\CommentTok{#> [1] 2}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

This means that you can't do name lookup just once: you have to start
from scratch each time. This problem is exacerbated by the fact that
almost every operation is a lexically scoped function call. You might
think the following simple function calls two functions: \texttt{+} and
\texttt{\^{}}. In fact, it calls four because \texttt{\{} and \texttt{(}
are regular functions in R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{  (x }\OperatorTok{+}\StringTok{ }\NormalTok{y) }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Since these functions are in the global environment, R has to look
through every environment in the search path, which could easily be 10
or 20 environments. The following microbenchmark hints at the
performance costs. We create four versions of \texttt{f()}, each with
one more environment (containing 26 bindings) between the environment of
\texttt{f()} and the base environment where \texttt{+}, \texttt{\^{}},
\texttt{(}, and \texttt{\{} are defined.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{random_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{parent =} \KeywordTok{globalenv}\NormalTok{()) \{}
\NormalTok{  letter_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{26}\NormalTok{)), LETTERS)}
  \KeywordTok{list2env}\NormalTok{(letter_list, }\DataTypeTok{envir =} \KeywordTok{new.env}\NormalTok{(}\DataTypeTok{parent =}\NormalTok{ parent))}
\NormalTok{\}}
\NormalTok{set_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, e) \{}
  \KeywordTok{environment}\NormalTok{(f) <-}\StringTok{ }\NormalTok{e}
\NormalTok{  f}
\NormalTok{\}}
\NormalTok{f2 <-}\StringTok{ }\KeywordTok{set_env}\NormalTok{(f, }\KeywordTok{random_env}\NormalTok{())}
\NormalTok{f3 <-}\StringTok{ }\KeywordTok{set_env}\NormalTok{(f, }\KeywordTok{random_env}\NormalTok{(}\KeywordTok{environment}\NormalTok{(f2)))}
\NormalTok{f4 <-}\StringTok{ }\KeywordTok{set_env}\NormalTok{(f, }\KeywordTok{random_env}\NormalTok{(}\KeywordTok{environment}\NormalTok{(f3)))}

\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
  \KeywordTok{f2}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
  \KeywordTok{f3}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
  \KeywordTok{f4}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{times =} \DecValTok{10000}
\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>      expr min  lq mean median  uq       max neval}
\CommentTok{#>   f(1, 2) 376 418  718    426 450 2,040,000 10000}
\CommentTok{#>  f2(1, 2) 681 715 1123    725 771 2,890,000 10000}
\CommentTok{#>  f3(1, 2) 703 745  867    758 809    39,800 10000}
\CommentTok{#>  f4(1, 2) 749 793  920    807 855    56,300 10000}
\end{Highlighting}
\end{Shaded}

Each additional environment between \texttt{f()} and the base
environment makes the function slower by about 30 ns.

It might be possible to implement a caching system so that R only needs
to look up the value of each name once. This is hard because there are
so many ways to change the value associated with a name:
\texttt{\textless{}\textless{}-}, \texttt{assign()}, \texttt{eval()},
and so on. Any caching system would have to know about these functions
to make sure the cache was correctly invalidated and you didn't get an
out-of-date value. \indexc{<<-}

Another simple fix would be to add more built-in constants that you
can't override. This, for example, would mean that R always knew exactly
what \texttt{+}, \texttt{-}, \texttt{\{}, and \texttt{(} meant, and you
wouldn't have to repeatedly look up their definitions. That would make
the interpreter more complicated (because there are more special cases)
and hence harder to maintain, and the language less flexible. This would
change the R-language, but it would be unlikely to affect much existing
code because it's such a bad idea to override functions like \texttt{\{}
and \texttt{(}.

\hypertarget{lazy-evaluation-overhead}{%
\subsection{Lazy evaluation overhead}\label{lazy-evaluation-overhead}}

In R, function arguments are evaluated lazily (as discussed in
\protect\hyperlink{lazy-evaluation}{lazy evaluation} and
\protect\hyperlink{capturing-expressions}{capturing expressions}). To
implement lazy evaluation, R uses a promise object that contains the
expression needed to compute the result and the environment in which to
perform the computation. Creating these objects has some overhead, so
each additional argument to a function decreases its speed a little.
\index{lazy evaluation!overhead of}

The following microbenchmark compares the runtime of a very simple
function. Each version of the function has one additional argument. This
suggests that adding an additional argument slows the function down by
\textasciitilde{}20 ns.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f0 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\OtherTok{NULL}
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{) }\OtherTok{NULL}
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\NormalTok{) }\OtherTok{NULL}
\NormalTok{f3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{) }\OtherTok{NULL}
\NormalTok{f4 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{4}\NormalTok{, }\DataTypeTok{d =} \DecValTok{4}\NormalTok{) }\OtherTok{NULL}
\NormalTok{f5 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{4}\NormalTok{, }\DataTypeTok{d =} \DecValTok{4}\NormalTok{, }\DataTypeTok{e =} \DecValTok{5}\NormalTok{) }\OtherTok{NULL}
\KeywordTok{microbenchmark}\NormalTok{(}\KeywordTok{f0}\NormalTok{(), }\KeywordTok{f1}\NormalTok{(), }\KeywordTok{f2}\NormalTok{(), }\KeywordTok{f3}\NormalTok{(), }\KeywordTok{f4}\NormalTok{(), }\KeywordTok{f5}\NormalTok{(), }\DataTypeTok{times =} \DecValTok{10000}\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>  expr min  lq mean median  uq       max neval}
\CommentTok{#>  f0() 158 183  263    187 192   437,000 10000}
\CommentTok{#>  f1() 180 203  312    208 216   474,000 10000}
\CommentTok{#>  f2() 219 235  359    241 252   477,000 10000}
\CommentTok{#>  f3() 246 260  470    265 276   905,000 10000}
\CommentTok{#>  f4() 286 299  788    304 318 3,040,000 10000}
\CommentTok{#>  f5() 313 326  533    333 350   530,000 10000}
\end{Highlighting}
\end{Shaded}

In most other programming languages there is little overhead for adding
extra arguments. Many compiled languages will even warn you if arguments
are never used (like in the above example), and automatically remove
them from the function.

\hypertarget{exercises-67}{%
\subsection{Exercises}\label{exercises-67}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{scan()} has the most arguments (21) of any base function.
  About how much time does it take to make 21 promises each time scan is
  called? Given a simple input (e.g.,
  \texttt{scan(text\ =\ "1\ 2\ 3",\ quiet\ =\ TRUE)}) what proportion of
  the total run time is due to creating those promises?
\item
  Read \href{http://r.cs.purdue.edu/pub/ecoop12.pdf}{``Evaluating the
  Design of the R Language''}. What other aspects of the R-language slow
  it down? Construct microbenchmarks to illustrate.
\item
  How does the performance of S3 method dispatch change with the length
  of the class vector? How does performance of S4 method dispatch change
  with number of superclasses? How about RC?
\item
  What is the cost of multiple inheritance and multiple dispatch on S4
  method dispatch?
\item
  Why is the cost of name lookup less for functions in the base package?
\end{enumerate}

\hypertarget{implementation-performance}{%
\section{Implementation performance}\label{implementation-performance}}

The design of the R language limits its maximum theoretical performance,
but GNU-R is currently nowhere near that maximum. There are many things
that can (and will) be done to improve performance. This section
discusses some aspects of GNU-R that are slow not because of their
definition, but because of their implementation.

R is over 20 years old. It contains nearly 800,000 lines of code (about
45\% C, 19\% R, and 17\% Fortran). Changes to base R can only be made by
members of the R Core Team (or R-core for short). Currently R-core has
\href{http://www.r-project.org/contributors.html}{twenty members}, but
only six are active in day-to-day development. No one on R-core works
full time on R. Most are statistics professors who can only spend a
relatively small amount of their time on R. Because of the care that
must be taken to avoid breaking existing code, R-core tends to be very
conservative about accepting new code. It can be frustrating to see
R-core reject proposals that would improve performance. However, the
overriding concern for R-core is not to make R fast, but to build a
stable platform for data analysis and statistics. \index{R-core}

Below, I'll show two small, but illustrative, examples of parts of R
that are currently slow but could, with some effort, be made faster.
They are not critical parts of base R, but they have been sources of
frustration for me in the past. As with all microbenchmarks, these won't
affect the performance of most code, but can be important for special
cases.

\hypertarget{extracting-a-single-value-from-a-data-frame}{%
\subsection{Extracting a single value from a data
frame}\label{extracting-a-single-value-from-a-data-frame}}

The following microbenchmark shows five ways to access a single value
(the number in the bottom-right corner) from the built-in
\texttt{mtcars} dataset. The variation in performance is startling: the
slowest method takes 30x longer than the fastest. There's no reason that
there has to be such a huge difference in performance. It's simply that
no one has had the time to fix it. \index{subsetting!performance}
\indexc{[}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \StringTok{"[32, 11]"}\NormalTok{      =}\StringTok{ }\NormalTok{mtcars[}\DecValTok{32}\NormalTok{, }\DecValTok{11}\NormalTok{],}
  \StringTok{"$carb[32]"}\NormalTok{     =}\StringTok{ }\NormalTok{mtcars}\OperatorTok{$}\NormalTok{carb[}\DecValTok{32}\NormalTok{],}
  \StringTok{"[[c(11, 32)]]"}\NormalTok{ =}\StringTok{ }\NormalTok{mtcars[[}\KeywordTok{c}\NormalTok{(}\DecValTok{11}\NormalTok{, }\DecValTok{32}\NormalTok{)]],}
  \StringTok{"[[11]][32]"}\NormalTok{    =}\StringTok{ }\NormalTok{mtcars[[}\DecValTok{11}\NormalTok{]][}\DecValTok{32}\NormalTok{],}
  \StringTok{".subset2"}\NormalTok{      =}\StringTok{ }\KeywordTok{.subset2}\NormalTok{(mtcars, }\DecValTok{11}\NormalTok{)[}\DecValTok{32}\NormalTok{]}
\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>           expr   min    lq  mean median     uq     max neval}
\CommentTok{#>       [32, 11] 9,400 9,830 11086 10,000 10,300  56,200   100}
\CommentTok{#>      $carb[32] 5,040 5,270  6188  5,500  5,880  40,400   100}
\CommentTok{#>  [[c(11, 32)]] 4,200 4,480 10366  4,690  5,030 520,000   100}
\CommentTok{#>     [[11]][32] 3,960 4,210  4609  4,450  4,650  11,200   100}
\CommentTok{#>       .subset2   279   353   416    376    402   2,530   100}
\end{Highlighting}
\end{Shaded}

\hypertarget{ifelse-pmin-and-pmax}{%
\subsection{\texorpdfstring{\texttt{ifelse()}, \texttt{pmin()}, and
\texttt{pmax()}}{ifelse(), pmin(), and pmax()}}\label{ifelse-pmin-and-pmax}}

Some base functions are known to be slow. For example, take the
following three implementations of \texttt{squish()}, a function that
ensures that the smallest value in a vector is at least \texttt{a} and
its largest value is at most \texttt{b}. The first implementation,
\texttt{squish\_ife()}, uses \texttt{ifelse()}. \texttt{ifelse()} is
known to be slow because it is relatively general and must evaluate all
arguments fully. The second implementation, \texttt{squish\_p()}, uses
\texttt{pmin()} and \texttt{pmax()}. Because these two functions are so
specialised, one might expect that they would be fast. However, they're
actually rather slow. This is because they can take any number of
arguments and they have to do some relatively complicated checks to
determine which method to use. The final implementation uses basic
subassignment. \indexc{ifelse()} \indexc{pmin()} \indexc{pmax()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{squish_ife <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, a, b) \{}
  \KeywordTok{ifelse}\NormalTok{(x }\OperatorTok{<=}\StringTok{ }\NormalTok{a, a, }\KeywordTok{ifelse}\NormalTok{(x }\OperatorTok{>=}\StringTok{ }\NormalTok{b, b, x))}
\NormalTok{\}}
\NormalTok{squish_p <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, a, b) \{}
  \KeywordTok{pmax}\NormalTok{(}\KeywordTok{pmin}\NormalTok{(x, b), a)}
\NormalTok{\}}
\NormalTok{squish_in_place <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, a, b) \{}
\NormalTok{  x[x }\OperatorTok{<=}\StringTok{ }\NormalTok{a] <-}\StringTok{ }\NormalTok{a}
\NormalTok{  x[x }\OperatorTok{>=}\StringTok{ }\NormalTok{b] <-}\StringTok{ }\NormalTok{b}
\NormalTok{  x}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{, }\FloatTok{-1.5}\NormalTok{, }\FloatTok{1.5}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{squish_ife      =} \KeywordTok{squish_ife}\NormalTok{(x, }\DecValTok{-1}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \DataTypeTok{squish_p        =} \KeywordTok{squish_p}\NormalTok{(x, }\DecValTok{-1}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \DataTypeTok{squish_in_place =} \KeywordTok{squish_in_place}\NormalTok{(x, }\DecValTok{-1}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \DataTypeTok{unit =} \StringTok{"us"}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>             expr   min    lq mean median    uq   max neval}
\CommentTok{#>       squish_ife 20.60 23.90 55.5  29.20 32.40 2,490   100}
\CommentTok{#>         squish_p 12.40 13.20 37.9  13.80 15.50 1,670   100}
\CommentTok{#>  squish_in_place  2.87  3.21 33.9   3.82  4.66 2,970   100}
\end{Highlighting}
\end{Shaded}

Using \texttt{pmin()} and \texttt{pmax()} is about 2x faster than
\texttt{ifelse()}, and using subsetting directly is about 4x as fast
again. We can often do even better by using C++. The following example
compares the best R implementation to a relatively simple, if verbose,
implementation in C++. Even if you've never used C++, you should still
be able to follow the basic strategy: loop over every element in the
vector and perform a different action depending on whether or not the
value is less than \texttt{a} and/or greater than \texttt{b}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector squish_cpp(NumericVector x, }\DataTypeTok{double}\NormalTok{ a, }\DataTypeTok{double}\NormalTok{ b) \{}
  \DataTypeTok{int}\NormalTok{ n = x.length();}
\NormalTok{  NumericVector out(n);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \DataTypeTok{double}\NormalTok{ xi = x[i];}
    \ControlFlowTok{if}\NormalTok{ (xi < a) \{}
\NormalTok{      out[i] = a;}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (xi > b) \{}
\NormalTok{      out[i] = b;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      out[i] = xi;}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(You'll learn how to access this C++ code from R in
\protect\hyperlink{rcpp}{Rcpp}.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{squish_in_place =} \KeywordTok{squish_in_place}\NormalTok{(x, }\DecValTok{-1}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \DataTypeTok{squish_cpp      =} \KeywordTok{squish_cpp}\NormalTok{(x, }\DecValTok{-1}\NormalTok{, }\DecValTok{1}\NormalTok{),}
  \DataTypeTok{unit =} \StringTok{"us"}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>             expr  min   lq  mean median   uq     max neval}
\CommentTok{#>  squish_in_place 3.78 4.55  5.46   4.94 5.50    31.2   100}
\CommentTok{#>       squish_cpp 2.45 3.10 17.54   3.33 3.63 1,390.0   100}
\end{Highlighting}
\end{Shaded}

The C++ implementation is around 1x faster than the best pure R
implementation.

\hypertarget{exercises-68}{%
\subsection{Exercises}\label{exercises-68}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The performance characteristics of \texttt{squish\_ife()},
  \texttt{squish\_p()}, and \texttt{squish\_in\_place()} vary
  considerably with the size of \texttt{x}. Explore the differences.
  Which sizes lead to the biggest and smallest differences?
\item
  Compare the performance costs of extracting an element from a list, a
  column from a matrix, and a column from a data frame. Do the same for
  rows.
\end{enumerate}

\hypertarget{faster-r}{%
\section{Alternative R implementations}\label{faster-r}}

There are some exciting new implementations of R. While they all try to
stick as closely as possible to the existing language definition, they
improve speed by using ideas from modern interpreter design. The four
most mature open-source projects are:
\index{alternative implementations}

\begin{itemize}
\item
  \href{http://www.pqr-project.org/}{pqR} (pretty quick R) by Radford
  Neal. Built on top of R 2.15.0, it fixes many obvious performance
  issues, and provides better memory management and some support for
  automatic multithreading. \index{pqR}
\item
  \href{http://www.renjin.org/}{Renjin} by BeDataDriven. Renjin uses the
  Java virtual machine, and has an extensive
  \href{http://packages.renjin.org/}{test suite}. \index{Renjin}
\item
  \href{https://github.com/allr/fastr}{FastR} by a team from Purdue.
  FastR is similar to Renjin, but it makes more ambitious optimisations
  and is somewhat less mature. \index{FastR}
\item
  \href{https://github.com/jtalbot/riposte}{Riposte} by Justin Talbot
  and Zachary DeVito. Riposte is experimental and ambitious. For the
  parts of R it implements, it is extremely fast. Riposte is described
  in more detail in
  \href{http://www.justintalbot.com/wp-content/uploads/2012/10/pact080talbot.pdf}{Riposte:
  A Trace-Driven Compiler and Parallel VM for Vector Code in R}.
  \index{Riposte}
\end{itemize}

These are roughly ordered from most practical to most ambitious. Another
project, \href{http://www.cs.kent.ac.uk/projects/cxxr/}{CXXR} by Andrew
Runnalls, does not provide any performance improvements. Instead, it
aims to refactor R's internal C code in order to build a stronger
foundation for future development, to keep behaviour identical to GNU-R,
and to create better, more extensible documentation of its internals.
\index{CXXR}

R is a huge language and it's not clear whether any of these approaches
will ever become mainstream. It's a hard task to make an alternative
implementation run all R code in the same way as GNU-R. Can you imagine
having to reimplement every function in base R to be not only faster,
but also to have exactly the same documented bugs? However, even if
these implementations never make a dent in the use of GNU-R, they still
provide benefits:

\begin{itemize}
\item
  Simpler implementations make it easy to validate new approaches before
  porting to GNU-R.
\item
  Knowing which aspects of the language can be changed with minimal
  impact on existing code and maximal impact on performance can help to
  guide us to where we should direct our attention.
\item
  Alternative implementations put pressure on the R-core to incorporate
  performance improvements.
\end{itemize}

One of the most important approaches that pqR, Renjin, FastR, and
Riposte are exploring is the idea of deferred evaluation. As Justin
Talbot, the author of Riposte, points out: ``for long vectors, R's
execution is completely memory bound. It spends almost all of its time
reading and writing vector intermediates to memory''. If we could
eliminate these intermediate vectors, we could improve performance and
reduce memory usage. \index{deferred evaluation}

The following example shows a very simple example of how deferred
evaluation can help. We have three vectors, \texttt{x}, \texttt{y},
\texttt{z}, each containing 1 million elements, and we want to find the
sum of \texttt{x} + \texttt{y} where \texttt{z} is TRUE. (This
represents a simplification of a pretty common sort of data analysis
question.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\NormalTok{z <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F), }\FloatTok{1e6}\NormalTok{, }\DataTypeTok{rep =} \OtherTok{TRUE}\NormalTok{)}

\KeywordTok{sum}\NormalTok{((x }\OperatorTok{+}\StringTok{ }\NormalTok{y)[z])}
\end{Highlighting}
\end{Shaded}

In R, this creates two big temporary vectors: \texttt{x\ +\ y}, 1
million elements long, and \texttt{(x\ +\ y){[}z{]}}, about 500,000
elements long. This means you need to have extra memory available for
the intermediate calculation, and you have to shuttle the data back and
forth between the CPU and memory. This slows computation down because
the CPU can't work at maximum efficiency if it's always waiting for more
data to come in.

However, if we rewrote the function using a loop in a language like C++,
we only need one intermediate value: the sum of all the values we've
seen:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ cond_sum_cpp(NumericVector x, NumericVector y, }
\NormalTok{                    LogicalVector z) \{}
  \DataTypeTok{double}\NormalTok{ sum = }\DecValTok{0}\NormalTok{;}
  \DataTypeTok{int}\NormalTok{ n = x.length();}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; i++) \{}
    \ControlFlowTok{if}\NormalTok{ (!z[i]) }\ControlFlowTok{continue}\NormalTok{;}
\NormalTok{    sum += x[i] + y[i];}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ sum;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cond_sum_r <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y, z) \{}
  \KeywordTok{sum}\NormalTok{((x }\OperatorTok{+}\StringTok{ }\NormalTok{y)[z])}
\NormalTok{\}}

\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{cond_sum_cpp =} \KeywordTok{cond_sum_cpp}\NormalTok{(x, y, z),}
  \DataTypeTok{cond_sum_r =} \KeywordTok{cond_sum_r}\NormalTok{(x, y, z),}
  \DataTypeTok{unit =} \StringTok{"ms"}
\NormalTok{)}
\CommentTok{#> Unit: milliseconds}
\CommentTok{#>          expr   min    lq mean median    uq    max neval}
\CommentTok{#>  cond_sum_cpp  5.29  5.32  5.4   5.35  5.41   7.01   100}
\CommentTok{#>    cond_sum_r 13.70 15.10 16.7  15.30 15.50 152.00   100}
\end{Highlighting}
\end{Shaded}

On my computer, this approach is about 3x faster than the vectorised R
equivalent, which is already pretty fast.

The goal of deferred evaluation is to perform this transformation
automatically, so you can write concise R code and have it automatically
translated into efficient machine code. Sophisticated translators can
also figure out how to make the most of multiple cores. In the above
example, if you have four cores, you could split \texttt{x}, \texttt{y},
and \texttt{z} into four pieces performing the conditional sum on each
core, then adding together the four individual results. Deferred
evaluation can also work with for loops, automatically discovering
operations that can be vectorised.

This chapter has discussed some of the fundamental reasons that R is
slow. The following chapters will give you the tools to do something
about it when it impacts your code.

\hypertarget{profiling}{%
\chapter{Optimising code}\label{profiling}}

\hypertarget{introduction-20}{%
\section{Introduction}\label{introduction-20}}

\begin{quote}
``Programmers waste enormous amounts of time thinking about, or worrying
about, the speed of noncritical parts of their programs, and these
attempts at efficiency actually have a strong negative impact when
debugging and maintenance are considered.''

\hspace*{\fill} --- Donald Knuth.
\end{quote}

Optimising code to make it run faster is an iterative process:
\index{optimisation}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Find the biggest bottleneck (the slowest part of your code).
\item
  Try to eliminate it (you may not succeed but that's ok).
\item
  Repeat until your code is ``fast enough.''
\end{enumerate}

This sounds easy, but it's not.

Even experienced programmers have a hard time identifying bottlenecks in
their code. Instead of relying on your intuition, you should
\textbf{profile} your code: use realistic inputs and measure the
run-time of each individual operation. Only once you've identified the
most important bottlenecks can you attempt to eliminate them. It's
difficult to provide general advice on improving performance, but I try
my best with six techniques that can be applied in many situations. I'll
also suggest a general strategy for performance optimisation that helps
ensure that your faster code will still be correct code.

It's easy to get caught up in trying to remove all bottlenecks. Don't!
Your time is valuable and is better spent analysing your data, not
eliminating possible inefficiencies in your code. Be pragmatic: don't
spend hours of your time to save seconds of computer time. To enforce
this advice, you should set a goal time for your code and optimise only
up to that goal. This means you will not eliminate all bottlenecks. Some
you will not get to because you've met your goal. Others you may need to
pass over and accept either because there is no quick and easy solution
or because the code is already well optimised and no significant
improvement is possible. Accept these possibilities and move on to the
next candidate. \index{bottlenecks}

\hypertarget{outline-18}{%
\subsection*{Outline}\label{outline-18}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  \protect\hyperlink{measure-perf}{Measuring performance} describes how
  to find the bottlenecks in your code using line profiling.
\item
  \protect\hyperlink{improve-perf}{Improving performance} outlines seven
  general strategies for improving the performance of your code.
\item
  \protect\hyperlink{code-organisation}{Code organisation} teaches you
  how to organise your code to make optimisation as easy, and bug free,
  as possible.
\item
  \protect\hyperlink{already-solved}{Already solved} reminds you to look
  for existing solutions.
\item
  \protect\hyperlink{be-lazy}{Do as little as possible} emphasises the
  importance of being lazy: often the easiest way to make a function
  faster is to let it to do less work.
\item
  \protect\hyperlink{vectorise}{Vectorise} concisely defines
  vectorisation, and shows you how to make the most of built-in
  functions.
\item
  \protect\hyperlink{avoid-copies}{Avoid copies} discusses the
  performance perils of copying data.
\item
  \protect\hyperlink{byte-code}{Byte code compilation} shows you how to
  take advantage of R's byte code compiler.
\item
  \protect\hyperlink{t-test}{Case study: t-test} pulls all the pieces
  together into a case study showing how to speed up repeated t-tests by
  \textasciitilde{}1000x.
\item
  \protect\hyperlink{parallelise}{Parallelise} teaches you how to use
  parallelisation to spread computation across all the cores in your
  computer.
\item
  \protect\hyperlink{more-techniques}{Other techniques} finishes the
  chapter with pointers to more resources that will help you write fast
  code.
\end{itemize}

\hypertarget{prerequisites-12}{%
\subsection*{Prerequisites}\label{prerequisites-12}}
\addcontentsline{toc}{subsection}{Prerequisites}

In this chapter we'll be using the \texttt{lineprof} package to
understand the performance of R code. Get it with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"hadley/lineprof"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{measure-perf}{%
\section{Measuring performance}\label{measure-perf}}

To understand performance, you use a profiler. There are a number of
different types of profilers. R uses a fairly simple type called a
sampling or statistical profiler. A sampling profiler stops the
execution of code every few milliseconds and records which function is
currently executing (along with which function called that function, and
so on). For example, consider \texttt{f()}, below: \index{profiling}
\index{performance!measuring}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lineprof)}
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{pause}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
  \KeywordTok{g}\NormalTok{()}
  \KeywordTok{h}\NormalTok{()}
\NormalTok{\}}
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{pause}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
  \KeywordTok{h}\NormalTok{()}
\NormalTok{\}}
\NormalTok{h <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{pause}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(I use \texttt{lineprof::pause()} instead of \texttt{Sys.sleep()}
because \texttt{Sys.sleep()} does not appear in profiling outputs
because as far as R can tell, it doesn't use up any computing time.)
\indexc{pause()}

If we profiled the execution of \texttt{f()}, stopping the execution of
code every 0.1 s, we'd see a profile like below. Each line represents
one ``tick'' of the profiler (0.1 s in this case), and function calls
are nested with \texttt{\textgreater{}}. It shows that the code spends
0.1 s running \texttt{f()}, then 0.2 s running \texttt{g()}, then 0.1 s
running \texttt{h()}.

\begin{verbatim}
f() 
f() > g()
f() > g() > h()
f() > h()
\end{verbatim}

If we actually profile \texttt{f()}, using the code below, we're
unlikely to get such a clear result.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\KeywordTok{Rprof}\NormalTok{(tmp, }\DataTypeTok{interval =} \FloatTok{0.1}\NormalTok{)}
\KeywordTok{f}\NormalTok{()}
\KeywordTok{Rprof}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

That's because profiling is hard to do accurately without slowing your
code down by many orders of magnitude. The compromise that
\texttt{RProf()} makes, sampling, only has minimal impact on the overall
performance, but is fundamentally stochastic. There's some variability
in both the accuracy of the timer and in the time taken by each
operation, so each time you profile you'll get a slightly different
answer. Fortunately, pinpoint accuracy is not needed to identify the
slowest parts of your code. \indexc{RProf()}

Rather than focussing on individual calls, we'll visualise aggregates
using the lineprof package. There are a number of other options, like
\texttt{summaryRprof()}, the proftools package, and the profr package,
but these tools are beyond the scope of this book. I wrote the
\texttt{lineprof} package as a simpler way to visualise profiling data.
As the name suggests, the fundamental unit of analysis in
\texttt{lineprof()} is a line of code. This makes lineprof less precise
than the alternatives (because a line of code can contain multiple
function calls), but it's easier to understand the context.

To use \texttt{lineprof}, we first save the code in a file and
\texttt{source()} it. Here \texttt{profiling-example.R} contains the
definition of \texttt{f()}, \texttt{g()}, and \texttt{h()}. Note that
you \emph{must} use \texttt{source()} to load the code. This is because
lineprof uses srcrefs to match up the code to the profile, and the
needed srcrefs are only created when you load code from disk. We then
use \texttt{lineprof()} to run our function and capture the timing
output. Printing this object shows some basic information. For now,
we'll just focus on the time column which estimates how long each line
took to run and the ref column which tells us which line of code was
run. The estimates aren't perfect, but the ratios look about right.
\index{line profiling}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lineprof)}
\KeywordTok{source}\NormalTok{(}\StringTok{"profiling-example.R"}\NormalTok{)}
\NormalTok{l <-}\StringTok{ }\KeywordTok{lineprof}\NormalTok{(}\KeywordTok{f}\NormalTok{())}
\NormalTok{l}
\CommentTok{#>    time alloc release dups           ref     src}
\CommentTok{#> 1 0.074 0.001       0    0 profiling.R#2 f/pause}
\CommentTok{#> 2 0.143 0.002       0    0 profiling.R#3 f/g    }
\CommentTok{#> 3 0.071 0.000       0    0 profiling.R#4 f/h   }
\end{Highlighting}
\end{Shaded}

lineprof provides some functions to navigate through this data
structure, but they're a bit clumsy. Instead, we'll start an interactive
explorer using the shiny package. \texttt{shine(l)} will open a new web
page (or if you're using RStudio, a new pane) that shows your source
code annotated with information about how long each line took to run.
\texttt{shine()} starts a shiny app which ``blocks'' your R session. To
exit, you'll need to stop the process using escape or ctrl + c.

\begin{center}\includegraphics[width=0.7\linewidth]{screenshots/profiling-lineprof-f} \end{center}

The \texttt{t} column visualises how much time is spent on each line.
(You'll learn about the other columns in
\protect\hyperlink{memory-profiling}{memory profiling}.) While not
precise, it allows you to spot bottlenecks, and you can get precise
numbers by hovering over each bar. This shows that twice as much time is
spent on \texttt{g()} as on \texttt{h()}, so it would make sense to
drill down into \texttt{g()} for more details. To do so, click
\texttt{g()}:

\begin{center}\includegraphics[width=0.7\linewidth]{screenshots/profiling-lineprof-g} \end{center}

Then \texttt{h()}:

\begin{center}\includegraphics[width=0.7\linewidth]{screenshots/profiling-lineprof-h} \end{center}

This technique should allow you to quickly identify the major
bottlenecks in your code.

\hypertarget{limitations}{%
\subsection{Limitations}\label{limitations}}

There are some other limitations to profiling:

\begin{itemize}
\item
  Profiling does not extend to C code. You can see if your R code calls
  C/C++ code but not what functions are called inside of your C/C++
  code. Unfortunately, tools for profiling compiled code are beyond the
  scope of this book (i.e., I have no idea how to do it).
\item
  Similarly, you can't see what's going on inside primitive functions or
  byte code compiled code.
\item
  If you're doing a lot of functional programming with anonymous
  functions, it can be hard to figure out exactly which function is
  being called. The easiest way to work around this is to name your
  functions.
\item
  Lazy evaluation means that arguments are often evaluated inside
  another function. For example, in the following code, profiling would
  make it seem like \texttt{i()} was called by \texttt{j()} because the
  argument isn't evaluated until it's needed by \texttt{j()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{pause}\NormalTok{(}\FloatTok{0.1}\NormalTok{)}
  \DecValTok{10}
\NormalTok{\}}
\NormalTok{j <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x }\OperatorTok{+}\StringTok{ }\DecValTok{10}
\NormalTok{\}}
\KeywordTok{j}\NormalTok{(}\KeywordTok{i}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

  If this is confusing, you can create temporary variables to force
  computation to happen earlier.
\end{itemize}

\hypertarget{memory-profiling}{%
\section{Memory profiling with lineprof}\label{memory-profiling}}

\texttt{mem\_change()} captures the net change in memory when running a
block of code. Sometimes, however, we may want to measure incremental
change. One way to do this is to use memory profiling to capture usage
every few milliseconds. This functionality is provided by
\texttt{utils::Rprof()} but it doesn't provide a very useful display of
the results. Instead we'll use the
\href{https://github.com/hadley/lineprof}{lineprof} package. It is
powered by \texttt{Rprof()}, but displays the results in a more
informative manner. \index{memory!profiling}

To demonstrate \texttt{lineprof}, we're going to explore a bare-bones
implementation of \texttt{read.delim()} with only three arguments:
\indexc{read\_delim()}

We'll also create a sample csv file:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{write.csv}\NormalTok{(diamonds, }\StringTok{"diamonds.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Using lineprof is straightforward. \texttt{source()} the code, apply
\texttt{lineprof()} to an expression, then use \texttt{shine()} to view
the results. Note that you \emph{must} use \texttt{source()} to load the
code. This is because lineprof uses srcrefs to match up the code and run
times. The needed srcrefs are only created when you load code from disk.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lineprof)}

\KeywordTok{source}\NormalTok{(}\StringTok{"code/read-delim.R"}\NormalTok{)}
\NormalTok{prof <-}\StringTok{ }\KeywordTok{lineprof}\NormalTok{(}\KeywordTok{read_delim}\NormalTok{(}\StringTok{"diamonds.csv"}\NormalTok{))}
\KeywordTok{shine}\NormalTok{(prof)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{screenshots/memory-lineprof} \end{center}

\texttt{shine()} will also open a new web page (or if you're using
RStudio, a new pane) that shows your source code annotated with
information about memory usage. \texttt{shine()} starts a shiny app
which will ``block'' your R session. To exit, press escape or ctrl +
break.

Next to the source code, four columns provide details about the
performance of the code:

\begin{itemize}
\item
  \texttt{t}, the time (in seconds) spent on that line of code
  (explained in \protect\hyperlink{measure-perf}{measuring
  performance}).
\item
  \texttt{a}, the memory (in megabytes) allocated by that line of code.
\item
  \texttt{r}, the memory (in megabytes) released by that line of code.
  While memory allocation is deterministic, memory release is
  stochastic: it depends on when the GC was run. This means that memory
  release only tells you that the memory released was no longer needed
  before this line.
\item
  \texttt{d}, the number of vector duplications that occurred. A vector
  duplication occurs when R copies a vector as a result of its copy on
  modify semantics.
\end{itemize}

You can hover over any of the bars to get the exact numbers. In this
example, looking at the allocations tells us most of the story:

\begin{itemize}
\item
  \texttt{scan()} allocates about 2.5 MB of memory, which is very close
  to the 2.8 MB of space that the file occupies on disk. You wouldn't
  expect the two numbers to be identical because R doesn't need to store
  the commas and because the global string pool will save some memory.
\item
  Converting the columns allocates another 0.6 MB of memory. You'd also
  expect this step to free some memory because we've converted string
  columns into integer and numeric columns (which occupy less space),
  but we can't see those releases because GC hasn't been triggered yet.
\item
  Finally, calling \texttt{as.data.frame()} on a list allocates about
  1.6 megabytes of memory and performs over 600 duplications. This is
  because \texttt{as.data.frame()} isn't terribly efficient and ends up
  copying the input multiple times. We'll discuss duplication more in
  the next section.
\end{itemize}

There are two downsides to profiling:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{read\_delim()} only takes around half a second, but profiling
  can, at best, capture memory usage every 1 ms. This means we'll only
  get about 500 samples.
\item
  Since GC is lazy, we can never tell exactly when memory is no longer
  needed.
\end{enumerate}

You can work around both problems by using \texttt{torture\ =\ TRUE},
which forces R to run GC after every allocation (see
\texttt{gctorture()} for more details). This helps with both problems
because memory is freed as soon as possible, and R runs 10--100x slower.
This effectively makes the resolution of the timer greater, so that you
can see smaller allocations and exactly when memory is no longer needed.

\hypertarget{exercises-69}{%
\subsection{Exercises}\label{exercises-69}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When the input is a list, we can make a more efficient
  \texttt{as.data.frame()} by using special knowledge. A data frame is a
  list with class \texttt{data.frame} and \texttt{row.names} attribute.
  \texttt{row.names} is either a character vector or vector of
  sequential integers, stored in a special format created by
  \texttt{.set\_row\_names()}. This leads to an alternative
  \texttt{as.data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{to_df <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ "data.frame"}
  \KeywordTok{attr}\NormalTok{(x, }\StringTok{"row.names"}\NormalTok{) <-}\StringTok{ }\KeywordTok{.set_row_names}\NormalTok{(}\KeywordTok{length}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]]))}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

  What impact does this function have on \texttt{read\_delim()}? What
  are the downsides of this function?
\item
  Line profile the following function with \texttt{torture\ =\ TRUE}.
  What is surprising? Read the source code of \texttt{rm()} to figure
  out what's going on.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{n =} \FloatTok{1e5}\NormalTok{) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, n)}
  \KeywordTok{rm}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hypertarget{improve-perf}{%
\section{Improving performance}\label{improve-perf}}

\begin{quote}
``We should forget about small efficiencies, say about 97\% of the time:
premature optimization is the root of all evil. Yet we should not pass
up our opportunities in that critical 3\%. A good programmer will not be
lulled into complacency by such reasoning, he will be wise to look
carefully at the critical code; but only after that code has been
identified.''

\hspace*{\fill} --- Donald Knuth.
\end{quote}

Once you've used profiling to identify a bottleneck, you need to make it
faster. The following sections introduce you to a number of techniques
that I've found broadly useful: \index{improving performance}
\index{performance!improving}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Look for existing solutions.
\item
  Do less work.
\item
  Vectorise.
\item
  Parallelise.
\item
  Avoid copies.
\item
  Byte-code compile.
\end{enumerate}

A final technique is to rewrite in a faster language, like C++. That's a
big topic and is covered in \protect\hyperlink{rcpp}{Rcpp}.

Before we get into specific techniques, I'll first describe a general
strategy and organisational style that's useful when working on
performance.

\hypertarget{code-organisation}{%
\section{Code organisation}\label{code-organisation}}

There are two traps that are easy to fall into when trying to make your
code faster:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Writing faster but incorrect code.
\item
  Writing code that you think is faster, but is actually no better.
\end{enumerate}

The strategy outlined below will help you avoid these pitfalls.
\index{improving performance!strategy}

When tackling a bottleneck, you're likely to come up with multiple
approaches. Write a function for each approach, encapsulating all
relevant behaviour. This makes it easier to check that each approach
returns the correct result and to time how long it takes to run. To
demonstrate the strategy, I'll compare two approaches for computing the
mean:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(x)}
\NormalTok{mean2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

I recommend that you keep a record of everything you try, even the
failures. If a similar problem occurs in the future, it'll be useful to
see everything you've tried. To do this I often use R Markdown, which
makes it easy to intermingle code with detailed comments and notes.

Next, generate a representative test case. The case should be big enough
to capture the essence of your problem but small enough that it takes
only a few seconds to run. You don't want it to take too long because
you'll need to run the test case many times to compare approaches. On
the other hand, you don't want the case to be too small because then
results might not scale up to the real problem.

Use this test case to quickly check that all variants return the same
result. An easy way to do so is with \texttt{stopifnot()} and
\texttt{all.equal()}. For real problems with fewer possible outputs, you
may need more tests to make sure that an approach doesn't accidentally
return the correct answer. That's unlikely for the mean.
\indexc{stopifnot()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{mean1}\NormalTok{(x), }\KeywordTok{mean2}\NormalTok{(x)))}
\end{Highlighting}
\end{Shaded}

Finally, use the \texttt{microbenchmark} package to compare how long
each variation takes to run. For bigger problems, reduce the
\texttt{times} parameter so that it only takes a couple of seconds to
run. Focus on the median time, and use the upper and lower quartiles to
gauge the variability of the measurement. \indexc{microbenchmark()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{mean1}\NormalTok{(x),}
  \KeywordTok{mean2}\NormalTok{(x)}
\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>      expr   min    lq  mean median    uq       max neval}
\CommentTok{#>  mean1(x) 3,130 3,200 14535  3,310 3,540 1,100,000   100}
\CommentTok{#>  mean2(x)   647   722 24850    823   902 2,400,000   100}
\end{Highlighting}
\end{Shaded}

(You might be surprised by the results: \texttt{mean(x)} is considerably
slower than \texttt{sum(x)\ /\ length(x)}. This is because, among other
reasons, \texttt{mean(x)} makes two passes over the vector to be more
numerically accurate.)

Before you start experimenting, you should have a target speed that
defines when the bottleneck is no longer a problem. Setting such a goal
is important because you don't want to spend valuable time
over-optimising your code.

If you'd like to see this strategy in action, I've used it a few times
on stackoverflow:

\begin{itemize}
\tightlist
\item
  \url{http://stackoverflow.com/questions/22515525\#22518603}
\item
  \url{http://stackoverflow.com/questions/22515175\#22515856}
\item
  \url{http://stackoverflow.com/questions/3476015\#22511936}
\end{itemize}

\hypertarget{already-solved}{%
\section{Has someone already solved the problem?}\label{already-solved}}

Once you've organised your code and captured all the variations you can
think of, it's natural to see what others have done. You are part of a
large community, and it's quite possible that someone has already
tackled the same problem. If your bottleneck is a function in a package,
it's worth looking at other packages that do the same thing. Two good
places to start are:

\begin{itemize}
\item
  \href{http://cran.rstudio.com/web/views/}{CRAN task views}. If there's
  a CRAN task view related to your problem domain, it's worth looking at
  the packages listed there.
\item
  Reverse dependencies of Rcpp, as listed on its
  \href{http://cran.r-project.org/web/packages/Rcpp}{CRAN page}. Since
  these packages use C++, it's possible to find a solution to your
  bottleneck written in a higher performance language.
\end{itemize}

Otherwise, the challenge is describing your bottleneck in a way that
helps you find related problems and solutions. Knowing the name of the
problem or its synonyms will make this search much easier. But because
you don't know what it's called, it's hard to search for it! By reading
broadly about statistics and algorithms, you can build up your own
knowledge base over time. Alternatively, ask others. Talk to your
colleagues and brainstorm some possible names, then search on Google and
stackoverflow. It's often helpful to restrict your search to R related
pages. For Google, try \href{http://www.rseek.org/}{rseek}. For
stackoverflow, restrict your search by including the R tag,
\texttt{{[}R{]}}, in your search. \index{searching}

As discussed above, record all solutions that you find, not just those
that immediately appear to be faster. Some solutions might be initially
slower, but because they are easier to optimise they end up being
faster. You may also be able to combine the fastest parts from different
approaches. If you've found a solution that's fast enough,
congratulations! If appropriate, you may want to share your solution
with the R community. Otherwise, read on.

\hypertarget{exercises-70}{%
\subsection{Exercises}\label{exercises-70}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What are faster alternatives to \texttt{lm}? Which are specifically
  designed to work with larger datasets?
\item
  What package implements a version of \texttt{match()} that's faster
  for repeated lookups? How much faster is it?
\item
  List four functions (not just those in base R) that convert a string
  into a date time object. What are their strengths and weaknesses?
\item
  How many different ways can you compute a 1d density estimate in R?
\item
  Which packages provide the ability to compute a rolling mean?
\item
  What are the alternatives to \texttt{optim()}?
\end{enumerate}

\hypertarget{be-lazy}{%
\section{Do as little as possible}\label{be-lazy}}

The easiest way to make a function faster is to let it do less work. One
way to do that is use a function tailored to a more specific type of
input or output, or a more specific problem. For example:

\begin{itemize}
\item
  \texttt{rowSums()}, \texttt{colSums()}, \texttt{rowMeans()}, and
  \texttt{colMeans()} are faster than equivalent invocations that use
  \texttt{apply()} because they are vectorised (the topic of the next
  section).
\item
  \texttt{vapply()} is faster than \texttt{sapply()} because it
  pre-specifies the output type.
\item
  If you want to see if a vector contains a single value,
  \texttt{any(x\ ==\ 10)} is much faster than \texttt{10\ \%in\%\ x}.
  This is because testing equality is simpler than testing inclusion in
  a set.
\end{itemize}

Having this knowledge at your fingertips requires knowing that
alternative functions exist: you need to have a good vocabulary. Start
with \protect\hyperlink{vocabulary}{the basics}, and expand your vocab
by regularly reading R code. Good places to read code are the
\href{https://stat.ethz.ch/mailman/listinfo/r-help}{R-help mailing list}
and \href{http://stackoverflow.com/questions/tagged/r}{stackoverflow}.

Some functions coerce their inputs into a specific type. If your input
is not the right type, the function has to do extra work. Instead, look
for a function that works with your data as it is, or consider changing
the way you store your data. The most common example of this problem is
using \texttt{apply()} on a data frame. \texttt{apply()} always turns
its input into a matrix. Not only is this error prone (because a data
frame is more general than a matrix), it is also slower.

Other functions will do less work if you give them more information
about the problem. It's always worthwhile to carefully read the
documentation and experiment with different arguments. Some examples
that I've discovered in the past include:

\begin{itemize}
\item
  \texttt{read.csv()}: specify known column types with
  \texttt{colClasses}.
\item
  \texttt{factor()}: specify known levels with \texttt{levels}.
\item
  \texttt{cut()}: don't generate labels with \texttt{labels\ =\ FALSE}
  if you don't need them, or, even better, use \texttt{findInterval()}
  as mentioned in the ``see also'' section of the documentation.
\item
  \texttt{unlist(x,\ use.names\ =\ FALSE)} is much faster than
  \texttt{unlist(x)}.
\item
  \texttt{interaction()}: if you only need combinations that exist in
  the data, use \texttt{drop\ =\ TRUE}.
\end{itemize}

Sometimes you can make a function faster by avoiding method dispatch. As
we saw in (\protect\hyperlink{extreme-dynamism}{Extreme dynamism}),
method dispatch in R can be costly. If you're calling a method in a
tight loop, you can avoid some of the costs by doing the method lookup
only once: \index{methods!cost of dispatch, avoiding}

\begin{itemize}
\item
  For S3, you can do this by calling \texttt{generic.class()} instead of
  \texttt{generic()}.
\item
  For S4, you can do this by using \texttt{getMethod()} to find the
  method, saving it to a variable, and then calling that function.
\end{itemize}

For example, calling \texttt{mean.default()} is quite a bit faster than
calling \texttt{mean()} for small vectors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e2}\NormalTok{)}

\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{mean}\NormalTok{(x),}
  \KeywordTok{mean.default}\NormalTok{(x)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>             expr  min   lq mean median   uq   max neval}
\CommentTok{#>          mean(x) 2.78 2.85 3.63   2.94 3.24 51.90   100}
\CommentTok{#>  mean.default(x) 1.21 1.27 1.45   1.32 1.42  5.52   100}
\end{Highlighting}
\end{Shaded}

This optimisation is a little risky. While \texttt{mean.default()} is
almost twice as fast, it'll fail in surprising ways if \texttt{x} is not
a numeric vector. You should only use it if you know for sure what
\texttt{x} is.

Knowing that you're dealing with a specific type of input can be another
way to write faster code. For example, \texttt{as.data.frame()} is quite
slow because it coerces each element into a data frame and then
\texttt{rbind()}s them together. If you have a named list with vectors
of equal length, you can directly transform it into a data frame. In
this case, if you're able to make strong assumptions about your input,
you can write a method that's about 20x faster than the default.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{quickdf <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(l) \{}
  \KeywordTok{class}\NormalTok{(l) <-}\StringTok{ "data.frame"}
  \KeywordTok{attr}\NormalTok{(l, }\StringTok{"row.names"}\NormalTok{) <-}\StringTok{ }\KeywordTok{.set_row_names}\NormalTok{(}\KeywordTok{length}\NormalTok{(l[[}\DecValTok{1}\NormalTok{]]))}
\NormalTok{  l}
\NormalTok{\}}

\NormalTok{l <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{26}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e3}\NormalTok{))}
\KeywordTok{names}\NormalTok{(l) <-}\StringTok{ }\NormalTok{letters}

\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{quick_df      =} \KeywordTok{quickdf}\NormalTok{(l),}
  \DataTypeTok{as.data.frame =} \KeywordTok{as.data.frame}\NormalTok{(l)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>           expr     min       lq   mean  median      uq   max neval}
\CommentTok{#>       quick_df     6.7     9.36   51.2    17.5    22.9 3,310   100}
\CommentTok{#>  as.data.frame 1,060.0 1,100.00 1275.1 1,140.0 1,190.0 5,480   100}
\end{Highlighting}
\end{Shaded}

Again, note the trade-off. This method is fast because it's dangerous.
If you give it bad inputs, you'll get a corrupt data frame:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{quickdf}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{))}
\CommentTok{#> Warning in format.data.frame(x, digits = digits, na.encode = FALSE):}
\CommentTok{#> corrupt data frame: columns will be truncated or padded with NAs}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 1}
\end{Highlighting}
\end{Shaded}

To come up with this minimal method, I carefully read through and then
rewrote the source code for \texttt{as.data.frame.list()} and
\texttt{data.frame()}. I made many small changes, each time checking
that I hadn't broken existing behaviour. After several hours work, I was
able to isolate the minimal code shown above. This is a very useful
technique. Most base R functions are written for flexibility and
functionality, not performance. Thus, rewriting for your specific need
can often yield substantial improvements. To do this, you'll need to
read the source code. It can be complex and confusing, but don't give
up!

The following example shows a progressive simplification of the
\texttt{diff()} function if you only want computing differences between
adjacent values. At each step, I replace one argument with a specific
case, and then check to see that the function still works. The initial
function is long and complicated, but by restricting the arguments I not
only make it around twice as fast, I also make it easier to understand.

First, I take the code of \texttt{diff()} and reformat it to my style:
\indexc{diff()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diff1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x, }\DataTypeTok{lag =}\NormalTok{ 1L, }\DataTypeTok{differences =}\NormalTok{ 1L) \{}
\NormalTok{  ismat <-}\StringTok{ }\KeywordTok{is.matrix}\NormalTok{(x)}
\NormalTok{  xlen <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (ismat) }\KeywordTok{dim}\NormalTok{(x)[1L] }\ControlFlowTok{else} \KeywordTok{length}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(lag) }\OperatorTok{>}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }\KeywordTok{length}\NormalTok{(differences) }\OperatorTok{>}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }
\StringTok{      }\NormalTok{lag }\OperatorTok{<}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }\NormalTok{differences }\OperatorTok{<}\StringTok{ }\NormalTok{1L)}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"'lag' and 'differences' must be integers >= 1"}\NormalTok{)}

  \ControlFlowTok{if}\NormalTok{ (lag }\OperatorTok{*}\StringTok{ }\NormalTok{differences }\OperatorTok{>=}\StringTok{ }\NormalTok{xlen) \{}
    \KeywordTok{return}\NormalTok{(x[0L])}
\NormalTok{  \}}

\NormalTok{  r <-}\StringTok{ }\KeywordTok{unclass}\NormalTok{(x)}
\NormalTok{  i1 <-}\StringTok{ }\OperatorTok{-}\KeywordTok{seq_len}\NormalTok{(lag)}
  \ControlFlowTok{if}\NormalTok{ (ismat) \{}
    \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_len}\NormalTok{(differences)) \{}
\NormalTok{      r <-}\StringTok{ }\NormalTok{r[i1, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{] }\OperatorTok{-}\StringTok{ }
\StringTok{        }\NormalTok{r[}\OperatorTok{-}\KeywordTok{nrow}\NormalTok{(r)}\OperatorTok{:-}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(r) }\OperatorTok{-}\StringTok{ }\NormalTok{lag }\OperatorTok{+}\StringTok{ }\NormalTok{1L), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_len}\NormalTok{(differences)) \{}
\NormalTok{      r <-}\StringTok{ }\NormalTok{r[i1] }\OperatorTok{-}\StringTok{ }\NormalTok{r[}\OperatorTok{-}\KeywordTok{length}\NormalTok{(r)}\OperatorTok{:-}\NormalTok{(}\KeywordTok{length}\NormalTok{(r) }\OperatorTok{-}\StringTok{ }\NormalTok{lag }\OperatorTok{+}\StringTok{ }\NormalTok{1L)]}
\NormalTok{    \}}
\NormalTok{  \}}
  \KeywordTok{class}\NormalTok{(r) <-}\StringTok{ }\KeywordTok{oldClass}\NormalTok{(x)}
\NormalTok{  r}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Next, I assume vector input. This allows me to remove the
\texttt{is.matrix()} test and the method that uses matrix subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diff2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x, }\DataTypeTok{lag =}\NormalTok{ 1L, }\DataTypeTok{differences =}\NormalTok{ 1L) \{}
\NormalTok{  xlen <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(lag) }\OperatorTok{>}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }\KeywordTok{length}\NormalTok{(differences) }\OperatorTok{>}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }
\StringTok{      }\NormalTok{lag }\OperatorTok{<}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }\NormalTok{differences }\OperatorTok{<}\StringTok{ }\NormalTok{1L)}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"'lag' and 'differences' must be integers >= 1"}\NormalTok{)}

  \ControlFlowTok{if}\NormalTok{ (lag }\OperatorTok{*}\StringTok{ }\NormalTok{differences }\OperatorTok{>=}\StringTok{ }\NormalTok{xlen) \{}
    \KeywordTok{return}\NormalTok{(x[0L])}
\NormalTok{  \}}

\NormalTok{  i1 <-}\StringTok{ }\OperatorTok{-}\KeywordTok{seq_len}\NormalTok{(lag)}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_len}\NormalTok{(differences)) \{}
\NormalTok{    x <-}\StringTok{ }\NormalTok{x[i1] }\OperatorTok{-}\StringTok{ }\NormalTok{x[}\OperatorTok{-}\KeywordTok{length}\NormalTok{(x)}\OperatorTok{:-}\NormalTok{(}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\NormalTok{lag }\OperatorTok{+}\StringTok{ }\NormalTok{1L)]}
\NormalTok{  \}}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{diff2}\NormalTok{(}\KeywordTok{cumsum}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

I now assume that \texttt{differences\ =\ 1L}. This simplifies input
checking and eliminates the for loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diff3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x, }\DataTypeTok{lag =}\NormalTok{ 1L) \{}
\NormalTok{  xlen <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(lag) }\OperatorTok{>}\StringTok{ }\NormalTok{1L }\OperatorTok{||}\StringTok{ }\NormalTok{lag }\OperatorTok{<}\StringTok{ }\NormalTok{1L)}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"'lag' must be integer >= 1"}\NormalTok{)}

  \ControlFlowTok{if}\NormalTok{ (lag }\OperatorTok{>=}\StringTok{ }\NormalTok{xlen) \{}
    \KeywordTok{return}\NormalTok{(x[0L])}
\NormalTok{  \}}

\NormalTok{  i1 <-}\StringTok{ }\OperatorTok{-}\KeywordTok{seq_len}\NormalTok{(lag)}
\NormalTok{  x[i1] }\OperatorTok{-}\StringTok{ }\NormalTok{x[}\OperatorTok{-}\KeywordTok{length}\NormalTok{(x)}\OperatorTok{:-}\NormalTok{(}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\NormalTok{lag }\OperatorTok{+}\StringTok{ }\NormalTok{1L)]}
\NormalTok{\}}
\KeywordTok{diff3}\NormalTok{(}\KeywordTok{cumsum}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Finally I assume \texttt{lag\ =\ 1L}. This eliminates input checking and
simplifies subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diff4 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x) \{}
\NormalTok{  xlen <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ (xlen }\OperatorTok{<=}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{return}\NormalTok{(x[0L])}

\NormalTok{  x[}\OperatorTok{-}\DecValTok{1}\NormalTok{] }\OperatorTok{-}\StringTok{ }\NormalTok{x[}\OperatorTok{-}\NormalTok{xlen]}
\NormalTok{\}}
\KeywordTok{diff4}\NormalTok{(}\KeywordTok{cumsum}\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Now \texttt{diff4()} is both considerably simpler and considerably
faster than \texttt{diff1()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{diff1}\NormalTok{(x),}
  \KeywordTok{diff2}\NormalTok{(x),}
  \KeywordTok{diff3}\NormalTok{(x),}
  \KeywordTok{diff4}\NormalTok{(x)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>      expr  min   lq   mean median   uq      max neval}
\CommentTok{#>  diff1(x) 3.75 4.35 200.39   4.74 5.50 19,500.0   100}
\CommentTok{#>  diff2(x) 3.26 3.69   4.87   4.04 4.68     48.4   100}
\CommentTok{#>  diff3(x) 2.68 3.25  86.04   3.63 4.09  8,200.0   100}
\CommentTok{#>  diff4(x) 2.04 2.48  39.24   2.81 3.27  3,590.0   100}
\end{Highlighting}
\end{Shaded}

You'll be able to make \texttt{diff()} even faster for this special case
once you've read \protect\hyperlink{rcpp}{Rcpp}.

A final example of doing less work is to use simpler data structures.
For example, when working with rows from a data frame, it's often faster
to work with row indices than data frames. For instance, if you wanted
to compute a bootstrap estimate of the correlation between two columns
in a data frame, there are two basic approaches: you can either work
with the whole data frame or with the individual vectors. The following
example shows that working with vectors is about twice as fast.
\index{bootstrapping}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sample_rows <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, i) }\KeywordTok{sample.int}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), i, }
  \DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}

\CommentTok{# Generate a new data frame containing randomly selected rows}
\NormalTok{boot_cor1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, i) \{}
\NormalTok{  sub <-}\StringTok{ }\NormalTok{df[}\KeywordTok{sample_rows}\NormalTok{(df, i), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
  \KeywordTok{cor}\NormalTok{(sub}\OperatorTok{$}\NormalTok{x, sub}\OperatorTok{$}\NormalTok{y)}
\NormalTok{\}}

\CommentTok{# Generate new vectors from random rows}
\NormalTok{boot_cor2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, i ) \{}
\NormalTok{  idx <-}\StringTok{ }\KeywordTok{sample_rows}\NormalTok{(df, i)}
  \KeywordTok{cor}\NormalTok{(df}\OperatorTok{$}\NormalTok{x[idx], df}\OperatorTok{$}\NormalTok{y[idx])}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{))}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{boot_cor1}\NormalTok{(df, }\DecValTok{10}\NormalTok{),}
  \KeywordTok{boot_cor2}\NormalTok{(df, }\DecValTok{10}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>               expr  min   lq mean median    uq   max neval}
\CommentTok{#>  boot_cor1(df, 10) 84.6 90.8  136   97.5 110.0 2,740   100}
\CommentTok{#>  boot_cor2(df, 10) 56.3 58.6  109   60.1  65.2 2,750   100}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-71}{%
\subsection{Exercises}\label{exercises-71}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How do the results change if you compare \texttt{mean()} and
  \texttt{mean.default()} on 10,000 observations, rather than on 100?
\item
  The following code provides an alternative implementation of
  \texttt{rowSums()}. Why is it faster for this input?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rowSums2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df) \{}
\NormalTok{  out <-}\StringTok{ }\NormalTok{df[[1L]]}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{ncol}\NormalTok{(df) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{return}\NormalTok{(out)}

  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{2}\OperatorTok{:}\KeywordTok{ncol}\NormalTok{(df)) \{}
\NormalTok{    out <-}\StringTok{ }\NormalTok{out }\OperatorTok{+}\StringTok{ }\NormalTok{df[[i]]}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{as.data.frame}\NormalTok{(}
  \KeywordTok{replicate}\NormalTok{(}\FloatTok{1e3}\NormalTok{, }\KeywordTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{, }\FloatTok{1e4}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{))}
\NormalTok{)}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{rowSums}\NormalTok{(df))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.060   0.016   0.076}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{rowSums2}\NormalTok{(df))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.032   0.000   0.032}
\end{Highlighting}
\end{Shaded}
\item
  What's the difference between \texttt{rowSums()} and
  \texttt{.rowSums()}?
\item
  Make a faster version of \texttt{chisq.test()} that only computes the
  chi-square test statistic when the input is two numeric vectors with
  no missing values. You can try simplifying \texttt{chisq.test()} or by
  coding from the
  \href{http://en.wikipedia.org/wiki/Pearson\%27s_chi-squared_test}{mathematical
  definition}.
\item
  Can you make a faster version of \texttt{table()} for the case of an
  input of two integer vectors with no missing values? Can you use it to
  speed up your chi-square test?
\item
  Imagine you want to compute the bootstrap distribution of a sample
  correlation using \texttt{cor\_df()} and the data in the example
  below. Given that you want to run this many times, how can you make
  this code faster? (Hint: the function has three components that you
  can speed up.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\FloatTok{1e6}
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{rnorm}\NormalTok{(n), }\DataTypeTok{b =} \KeywordTok{rnorm}\NormalTok{(n))}

\NormalTok{cor_df <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, n) \{}
\NormalTok{  i <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{seq}\NormalTok{(n), n, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
  \KeywordTok{cor}\NormalTok{(df[i, , }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{])[}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

  Is there a way to vectorise this procedure?
\end{enumerate}

\hypertarget{vectorise}{%
\section{Vectorise}\label{vectorise}}

If you've used R for any length of time, you've probably heard the
admonishment to ``vectorise your code''. But what does that actually
mean? Vectorising your code is not just about avoiding for loops,
although that's often a step. Vectorising is about taking a ``whole
object'' approach to a problem, thinking about vectors, not scalars.
There are two key attributes of a vectorised function:
\index{vectorising code}

\begin{itemize}
\item
  It makes many problems simpler. Instead of having to think about the
  components of a vector, you only think about entire vectors.
\item
  The loops in a vectorised function are written in C instead of R.
  Loops in C are much faster because they have much less overhead.
\end{itemize}

\protect\hyperlink{functionals}{Functionals} stressed the importance of
vectorised code as a higher level abstraction. Vectorisation is also
important for writing fast R code. This doesn't mean simply using
\texttt{apply()} or \texttt{lapply()}, or even \texttt{Vectorise()}.
Those functions improve the interface of a function, but don't
fundamentally change performance. Using vectorisation for performance
means finding the existing R function that is implemented in C and most
closely applies to your problem.

Vectorised functions that apply to many common performance bottlenecks
include:

\begin{itemize}
\item
  \texttt{rowSums()}, \texttt{colSums()}, \texttt{rowMeans()}, and
  \texttt{colMeans()}. These vectorised matrix functions will always be
  faster than using \texttt{apply()}. You can sometimes use these
  functions to build other vectorised functions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rowAny <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{rowSums}\NormalTok{(x) }\OperatorTok{>}\StringTok{ }\DecValTok{0}
\NormalTok{rowAll <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{rowSums}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\KeywordTok{ncol}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}
\item
  Vectorised subsetting can lead to big improvements in speed. Remember
  the techniques behind lookup tables
  (\protect\hyperlink{lookup-tables}{lookup tables}) and matching and
  merging by hand (\protect\hyperlink{matching-merging}{matching and
  merging by hand}). Also remember that you can use subsetting
  assignment to replace multiple values in a single step. If \texttt{x}
  is a vector, matrix or data frame then
  \texttt{x{[}is.na(x){]}\ \textless{}-\ 0} will replace all missing
  values with 0.
\item
  If you're extracting or replacing values in scattered locations in a
  matrix or data frame, subset with an integer matrix. See
  \protect\hyperlink{matrix-subsetting}{matrix subsetting} for more
  details.
\item
  If you're converting continuous values to categorical make sure you
  know how to use \texttt{cut()} and \texttt{findInterval()}.
\item
  Be aware of vectorised functions like \texttt{cumsum()} and
  \texttt{diff()}.
\end{itemize}

Matrix algebra is a general example of vectorisation. There loops are
executed by highly tuned external libraries like BLAS. If you can figure
out a way to use matrix algebra to solve your problem, you'll often get
a very fast solution. The ability to solve problems with matrix algebra
is a product of experience. While this skill is something you'll develop
over time, a good place to start is to ask people with experience in
your domain. \index{matrix algebra}

The downside of vectorisation is that it makes it harder to predict how
operations will scale. The following example measures how long it takes
to use character subsetting to lookup 1, 10, and 100 elements from a
list. You might expect that looking up 10 elements would take 10x as
long as looking up 1, and that looking up 100 elements would take 10x
longer again. In fact, the following example shows that it only takes
about 9 times longer to look up 100 elements than it does to look up 1.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lookup <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(}\KeywordTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{26}\NormalTok{)), letters)}

\NormalTok{x1 <-}\StringTok{ "j"}
\NormalTok{x10 <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(letters, }\DecValTok{10}\NormalTok{)}
\NormalTok{x100 <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(letters, }\DecValTok{100}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}

\KeywordTok{microbenchmark}\NormalTok{(}
\NormalTok{  lookup[x1],}
\NormalTok{  lookup[x10],}
\NormalTok{  lookup[x100]}
\NormalTok{)}
\CommentTok{#> Unit: nanoseconds}
\CommentTok{#>          expr   min    lq mean median    uq    max neval}
\CommentTok{#>    lookup[x1]   540   585  827    712   954  3,490   100}
\CommentTok{#>   lookup[x10] 1,380 1,450 1918  1,590 1,840 26,100   100}
\CommentTok{#>  lookup[x100] 5,100 6,100 7086  6,640 7,340 23,300   100}
\end{Highlighting}
\end{Shaded}

Vectorisation won't solve every problem, and rather than torturing an
existing algorithm into one that uses a vectorised approach, you're
often better off writing your own vectorised function in C++. You'll
learn how to do so in \protect\hyperlink{rcpp}{Rcpp}.

\hypertarget{exercises-72}{%
\subsection{Exercises}\label{exercises-72}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The density functions, e.g., \texttt{dnorm()}, have a common
  interface. Which arguments are vectorised over? What does
  \texttt{rnorm(10,\ mean\ =\ 10:1)} do?
\item
  Compare the speed of \texttt{apply(x,\ 1,\ sum)} with
  \texttt{rowSums(x)} for varying sizes of \texttt{x}.
\item
  How can you use \texttt{crossprod()} to compute a weighted sum? How
  much faster is it than the naive \texttt{sum(x\ *\ w)}?
\end{enumerate}

\hypertarget{avoid-copies}{%
\section{Avoid copies}\label{avoid-copies}}

A pernicious source of slow R code is growing an object with a loop.
Whenever you use \texttt{c()}, \texttt{append()}, \texttt{cbind()},
\texttt{rbind()}, or \texttt{paste()} to create a bigger object, R must
first allocate space for the new object and then copy the old object to
its new home. If you're repeating this many times, like in a for loop,
this can be quite expensive. You've entered Circle 2 of the
\href{http://www.burns-stat.com/pages/Tutor/R_inferno.pdf}{``R
inferno''}. \index{avoiding copies}

Here's a little example that shows the problem. We first generate some
random strings, and then combine them either iteratively with a loop
using \texttt{collapse()}, or in a single pass using \texttt{paste()}.
Note that the performance of \texttt{collapse()} gets relatively worse
as the number of strings grows: combining 100 strings takes almost 30
times longer than combining 10 strings. \indexc{paste()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{random_string <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
  \KeywordTok{paste}\NormalTok{(}\KeywordTok{sample}\NormalTok{(letters, }\DecValTok{50}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}
\NormalTok{strings10 <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{10}\NormalTok{, }\KeywordTok{random_string}\NormalTok{())}
\NormalTok{strings100 <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{100}\NormalTok{, }\KeywordTok{random_string}\NormalTok{())}

\NormalTok{collapse <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(xs) \{}
\NormalTok{  out <-}\StringTok{ ""}
  \ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in}\NormalTok{ xs) \{}
\NormalTok{    out <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(out, x)}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}

\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{loop10  =} \KeywordTok{collapse}\NormalTok{(strings10),}
  \DataTypeTok{loop100 =} \KeywordTok{collapse}\NormalTok{(strings100),}
  \DataTypeTok{vec10   =} \KeywordTok{paste}\NormalTok{(strings10, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
  \DataTypeTok{vec100  =} \KeywordTok{paste}\NormalTok{(strings100, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>     expr   min     lq  mean median     uq     max neval}
\CommentTok{#>   loop10  20.1  21.50  23.3  22.60  24.50    35.7   100}
\CommentTok{#>  loop100 808.0 824.00 863.5 829.00 843.00 3,670.0   100}
\CommentTok{#>    vec10   4.9   5.15   6.2   5.57   6.14    44.7   100}
\CommentTok{#>   vec100  39.9  41.10  44.1  41.70  44.10   144.0   100}
\end{Highlighting}
\end{Shaded}

Modifying an object in a loop, e.g., \texttt{x{[}i{]}\ \textless{}-\ y},
can also create a copy, depending on the class of \texttt{x}.
\protect\hyperlink{modification}{Modification in place} discusses this
issue in more depth and gives you some tools to determine when you're
making copies.

\hypertarget{byte-code}{%
\section{Byte code compilation}\label{byte-code}}

R 2.13.0 introduced a byte code compiler which can increase the speed of
some code. Using the compiler is an easy way to get improvements in
speed. Even if it doesn't work well for your function, you won't have
invested a lot of time in the effort. The following example shows the
pure R version of \texttt{lapply()} from
\protect\hyperlink{lapply}{functionals}. Compiling it gives a
considerable speedup, although it's still not quite as fast as the C
version provided by base R. \index{byte-code compiler} \index{compiler}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lapply2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f, ...) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{    out[[i]] <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x[[i]], ...)}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}

\NormalTok{lapply2_c <-}\StringTok{ }\NormalTok{compiler}\OperatorTok{::}\KeywordTok{cmpfun}\NormalTok{(lapply2)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, letters, }\KeywordTok{c}\NormalTok{(F, T), }\OtherTok{NULL}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{lapply2}\NormalTok{(x, is.null),}
  \KeywordTok{lapply2_c}\NormalTok{(x, is.null),}
  \KeywordTok{lapply}\NormalTok{(x, is.null)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>                   expr  min   lq  mean median   uq      max neval}
\CommentTok{#>    lapply2(x, is.null) 1.82 1.86 42.13   1.94 2.21 3,970.00   100}
\CommentTok{#>  lapply2_c(x, is.null) 1.81 1.86  2.19   1.99 2.37     6.74   100}
\CommentTok{#>     lapply(x, is.null) 2.27 2.40  2.90   2.58 2.90    13.40   100}
\end{Highlighting}
\end{Shaded}

Byte code compilation really helps here, but in most cases you're more
likely to get a 5-10\% improvement. All base R functions are byte code
compiled by default.

\hypertarget{t-test}{%
\section{Case study: t-test}\label{t-test}}

The following case study shows how to make t-tests faster using some of
the techniques described above. It's based on an example in
\href{http://stat-computing.org/newsletter/issues/scgn-18-1.pdf}{``Computing
thousands of test statistics simultaneously in R''} by Holger Schwender
and Tina Müller. I thoroughly recommend reading the paper in full to see
the same idea applied to other tests. \indexc{t.test()}

Imagine we have run 1000 experiments (rows), each of which collects data
on 50 individuals (columns). The first 25 individuals in each experiment
are assigned to group 1 and the rest to group 2. We'll first generate
some random data to represent this problem:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\DecValTok{1000}
\NormalTok{n <-}\StringTok{ }\DecValTok{50}
\NormalTok{X <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(m }\OperatorTok{*}\StringTok{ }\NormalTok{n, }\DataTypeTok{mean =} \DecValTok{10}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{3}\NormalTok{), }\DataTypeTok{nrow =}\NormalTok{ m)}
\NormalTok{grp <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{each =}\NormalTok{ n }\OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

For data in this form, there are two ways to use \texttt{t.test()}. We
can either use the formula interface or provide two vectors, one for
each group. Timing reveals that the formula interface is considerably
slower.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{m) }\KeywordTok{t.test}\NormalTok{(X[i, ] }\OperatorTok{~}\StringTok{ }\NormalTok{grp)}\OperatorTok{$}\NormalTok{statistic)}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.884   0.000   0.884}
\KeywordTok{system.time}\NormalTok{(}
  \ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{m) }\KeywordTok{t.test}\NormalTok{(X[i, grp }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{], X[i, grp }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{])}\OperatorTok{$}\NormalTok{statistic}
\NormalTok{)}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.200   0.000   0.198}
\end{Highlighting}
\end{Shaded}

Of course, a for loop computes, but doesn't save the values. We'll use
\texttt{apply()} to do that. This adds a little overhead:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compT <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, grp)\{}
  \KeywordTok{t.test}\NormalTok{(x[grp }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{], x[grp }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{])}\OperatorTok{$}\NormalTok{statistic}
\NormalTok{\}}
\KeywordTok{system.time}\NormalTok{(t1 <-}\StringTok{ }\KeywordTok{apply}\NormalTok{(X, }\DecValTok{1}\NormalTok{, compT, }\DataTypeTok{grp =}\NormalTok{ grp))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.208   0.000   0.208}
\end{Highlighting}
\end{Shaded}

How can we make this faster? First, we could try doing less work. If you
look at the source code of \texttt{stats:::t.test.default()}, you'll see
that it does a lot more than just compute the t-statistic. It also
computes the p-value and formats the output for printing. We can try to
make our code faster by stripping out those pieces.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_t <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, grp) \{}
\NormalTok{  t_stat <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    m <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
\NormalTok{    n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{    var <-}\StringTok{ }\KeywordTok{sum}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\NormalTok{m) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{m =}\NormalTok{ m, }\DataTypeTok{n =}\NormalTok{ n, }\DataTypeTok{var =}\NormalTok{ var)}
\NormalTok{  \}}

\NormalTok{  g1 <-}\StringTok{ }\KeywordTok{t_stat}\NormalTok{(x[grp }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{])}
\NormalTok{  g2 <-}\StringTok{ }\KeywordTok{t_stat}\NormalTok{(x[grp }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{])}

\NormalTok{  se_total <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(g1}\OperatorTok{$}\NormalTok{var }\OperatorTok{/}\StringTok{ }\NormalTok{g1}\OperatorTok{$}\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{g2}\OperatorTok{$}\NormalTok{var }\OperatorTok{/}\StringTok{ }\NormalTok{g2}\OperatorTok{$}\NormalTok{n)}
\NormalTok{  (g1}\OperatorTok{$}\NormalTok{m }\OperatorTok{-}\StringTok{ }\NormalTok{g2}\OperatorTok{$}\NormalTok{m) }\OperatorTok{/}\StringTok{ }\NormalTok{se_total}
\NormalTok{\}}
\KeywordTok{system.time}\NormalTok{(t2 <-}\StringTok{ }\KeywordTok{apply}\NormalTok{(X, }\DecValTok{1}\NormalTok{, my_t, }\DataTypeTok{grp =}\NormalTok{ grp))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.028   0.000   0.026}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(t1, t2))}
\end{Highlighting}
\end{Shaded}

This gives us about a 6x speed improvement.

Now that we have a fairly simple function, we can make it faster still
by vectorising it. Instead of looping over the array outside the
function, we will modify \texttt{t\_stat()} to work with a matrix of
values. Thus, \texttt{mean()} becomes \texttt{rowMeans()},
\texttt{length()} becomes \texttt{ncol()}, and \texttt{sum()} becomes
\texttt{rowSums()}. The rest of the code stays the same.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rowtstat <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(X, grp)\{}
\NormalTok{  t_stat <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(X) \{}
\NormalTok{    m <-}\StringTok{ }\KeywordTok{rowMeans}\NormalTok{(X)}
\NormalTok{    n <-}\StringTok{ }\KeywordTok{ncol}\NormalTok{(X)}
\NormalTok{    var <-}\StringTok{ }\KeywordTok{rowSums}\NormalTok{((X }\OperatorTok{-}\StringTok{ }\NormalTok{m) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}

    \KeywordTok{list}\NormalTok{(}\DataTypeTok{m =}\NormalTok{ m, }\DataTypeTok{n =}\NormalTok{ n, }\DataTypeTok{var =}\NormalTok{ var)}
\NormalTok{  \}}

\NormalTok{  g1 <-}\StringTok{ }\KeywordTok{t_stat}\NormalTok{(X[, grp }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{])}
\NormalTok{  g2 <-}\StringTok{ }\KeywordTok{t_stat}\NormalTok{(X[, grp }\OperatorTok{==}\StringTok{ }\DecValTok{2}\NormalTok{])}

\NormalTok{  se_total <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(g1}\OperatorTok{$}\NormalTok{var }\OperatorTok{/}\StringTok{ }\NormalTok{g1}\OperatorTok{$}\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{g2}\OperatorTok{$}\NormalTok{var }\OperatorTok{/}\StringTok{ }\NormalTok{g2}\OperatorTok{$}\NormalTok{n)}
\NormalTok{  (g1}\OperatorTok{$}\NormalTok{m }\OperatorTok{-}\StringTok{ }\NormalTok{g2}\OperatorTok{$}\NormalTok{m) }\OperatorTok{/}\StringTok{ }\NormalTok{se_total}
\NormalTok{\}}
\KeywordTok{system.time}\NormalTok{(t3 <-}\StringTok{ }\KeywordTok{rowtstat}\NormalTok{(X, grp))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.012   0.000   0.013}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(t1, t3))}
\end{Highlighting}
\end{Shaded}

That's much faster! It's at least 40x faster than our previous effort,
and around 1000x faster than where we started.

Finally, we could try byte code compilation. Here we'll need to use
\texttt{microbenchmark()} instead of \texttt{system.time()} in order to
get enough accuracy to see a difference:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rowtstat_bc <-}\StringTok{ }\NormalTok{compiler}\OperatorTok{::}\KeywordTok{cmpfun}\NormalTok{(rowtstat)}

\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{rowtstat}\NormalTok{(X, grp),}
  \KeywordTok{rowtstat_bc}\NormalTok{(X, grp),}
  \DataTypeTok{unit =} \StringTok{"ms"}
\NormalTok{)}
\CommentTok{#> Unit: milliseconds}
\CommentTok{#>                 expr   min    lq  mean median    uq  max neval}
\CommentTok{#>     rowtstat(X, grp) 0.575 0.596 0.786  0.876 0.918 1.06   100}
\CommentTok{#>  rowtstat_bc(X, grp) 0.573 0.594 0.759  0.623 0.887 4.48   100}
\end{Highlighting}
\end{Shaded}

In this example, byte code compilation doesn't help at all.

\hypertarget{parallelise}{%
\section{Parallelise}\label{parallelise}}

Parallelisation uses multiple cores to work simultaneously on different
parts of a problem. It doesn't reduce the computing time, but it saves
your time because you're using more of your computer's resources.
Parallel computing is a complex topic, and there's no way to cover it in
depth here. Some resources I recommend are: \index{parallel computing}
\index{multicore}

\begin{itemize}
\item
  \href{http://amzn.com/B005Z29QT4}{\emph{Parallel R}} by Q. Ethan
  McCallum and Stephen Weston.
\item
  \href{http://amzn.com/1466587016}{\emph{Parallel Computing for Data
  Science}} by Norm Matloff.
\end{itemize}

What I want to show is a simple application of parallel computing to
what are called ``embarrassingly parallel problems''. An embarrassingly
parallel problem is one that's made up of many simple problems that can
be solved independently. A great example of this is \texttt{lapply()}
because it operates on each element independently of the others. It's
very easy to parallelise \texttt{lapply()} on Linux and the Mac because
you simply substitute \texttt{mclapply()} for \texttt{lapply()}. The
following code snippet runs a trivial (but slow) function on all cores
of your computer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(parallel)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cores <-}\StringTok{ }\KeywordTok{detectCores}\NormalTok{()}
\NormalTok{cores}
\CommentTok{#> [1] 2}

\NormalTok{pause <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(i) \{}
  \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{Sys.sleep}\NormalTok{(i)}
\NormalTok{\}}

\KeywordTok{system.time}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\KeywordTok{pause}\NormalTok{(}\FloatTok{0.25}\NormalTok{)))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>     0.0     0.0     2.5}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{mclapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\KeywordTok{pause}\NormalTok{(}\FloatTok{0.25}\NormalTok{), }\DataTypeTok{mc.cores =}\NormalTok{ cores))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.008   0.020   1.275}
\end{Highlighting}
\end{Shaded}

Life is a bit harder in Windows. You need to first set up a local
cluster and then use \texttt{parLapply()}: \indexc{mclapply()}
\indexc{parLapply()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cluster <-}\StringTok{ }\KeywordTok{makePSOCKcluster}\NormalTok{(cores)}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{parLapply}\NormalTok{(cluster, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(i) }\KeywordTok{Sys.sleep}\NormalTok{(i)))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.004   0.000  40.064}
\end{Highlighting}
\end{Shaded}

The main difference between \texttt{mclapply()} and
\texttt{makePSOCKcluster()} is that the individual processes generated
by \texttt{mclapply()} inherit from the current process, while those
generated by \texttt{makePSOCKcluster()} start with a fresh session.
This means that most real code will need some setup. Use
\texttt{clusterEvalQ()} to run arbitrary code on each cluster and load
needed packages, and \texttt{clusterExport()} to copy objects in the
current session to the remote sessions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{psock <-}\StringTok{ }\NormalTok{parallel}\OperatorTok{::}\KeywordTok{makePSOCKcluster}\NormalTok{(1L)}
\KeywordTok{clusterEvalQ}\NormalTok{(psock, x)}
\CommentTok{#> Error: one node produced an error: object 'x' not found }

\KeywordTok{clusterExport}\NormalTok{(psock, }\StringTok{"x"}\NormalTok{)}
\KeywordTok{clusterEvalQ}\NormalTok{(psock, x)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

There is some communication overhead with parallel computing. If the
subproblems are very small, then parallelisation might hurt rather than
help. It's also possible to distribute computation over a network of
computers (not just the cores on your local computer) but that's beyond
the scope of this book, because it gets increasingly complicated to
balance computation and communication costs. A good place to start for
more information is the
\href{http://cran.r-project.org/web/views/HighPerformanceComputing.html}{high
performance computing CRAN task view}.

\hypertarget{more-techniques}{%
\section{Other techniques}\label{more-techniques}}

Being able to write fast R code is part of being a good R programmer.
Beyond the specific hints in this chapter, if you want to write fast R
code, you'll need to improve your general programming skills. Some ways
to do this are to:

\begin{itemize}
\item
  \href{http://www.r-bloggers.com/}{Read R blogs} to see what
  performance problems other people have struggled with, and how they
  have made their code faster.
\item
  Read other R programming books, like Norm Matloff's
  \href{http://amzn.com/1593273843}{\emph{The Art of R Programming}} or
  Patrick Burns'
  \href{http://www.burns-stat.com/documents/books/the-r-inferno/}{\emph{R
  Inferno}} to learn about common traps.
\item
  Take an algorithms and data structure course to learn some well known
  ways of tackling certain classes of problems. I have heard good things
  about Princeton's
  \href{https://www.coursera.org/course/algs4partI}{Algorithms course}
  offered on Coursera.
\item
  Read general books about optimisation like
  \href{http://carlos.bueno.org/optimization/mature-optimization.pdf}{\emph{Mature
  optimisation}} by Carlos Bueno, or the
  \href{http://amzn.com/020161622X}{\emph{Pragmatic Programmer}} by
  Andrew Hunt and David Thomas.
\end{itemize}

You can also reach out to the community for help. Stackoverflow can be a
useful resource. You'll need to put some effort into creating an easily
digestible example that also captures the salient features of your
problem. If your example is too complex, few people will have the time
and motivation to attempt a solution. If it's too simple, you'll get
answers that solve the toy problem but not the real problem. If you also
try to answer questions on stackoverflow, you'll quickly get a feel for
what makes a good question.

\hypertarget{rcpp}{%
\chapter{Rewriting R code in C++}\label{rcpp}}

\hypertarget{introduction-21}{%
\section{Introduction}\label{introduction-21}}

Sometimes R code just isn't fast enough. You've used profiling to figure
out where your bottlenecks are, and you've done everything you can in R,
but your code still isn't fast enough. In this chapter you'll learn how
to improve performance by rewriting key functions in C++. This magic
comes by way of the \href{http://www.rcpp.org/}{Rcpp} package, a
fantastic tool written by Dirk Eddelbuettel and Romain Francois (with
key contributions by Doug Bates, John Chambers, and JJ Allaire). Rcpp
makes it very simple to connect C++ to R. While it is \emph{possible} to
write C or Fortran code for use in R, it will be painful by comparison.
Rcpp provides a clean, approachable API that lets you write
high-performance code, insulated from R's arcane C API. \index{Rcpp}
\index{C++}

Typical bottlenecks that C++ can address include:

\begin{itemize}
\item
  Loops that can't be easily vectorised because subsequent iterations
  depend on previous ones.
\item
  Recursive functions, or problems which involve calling functions
  millions of times. The overhead of calling a function in C++ is much
  lower than that in

  \begin{enumerate}
  \def\labelenumi{\Alph{enumi}.}
  \setcounter{enumi}{17}
  \item
  \end{enumerate}
\item
  Problems that require advanced data structures and algorithms that R
  doesn't provide. Through the standard template library (STL), C++ has
  efficient implementations of many important data structures, from
  ordered maps to double-ended queues.
\end{itemize}

The aim of this chapter is to discuss only those aspects of C++ and Rcpp
that are absolutely necessary to help you eliminate bottlenecks in your
code. We won't spend much time on advanced features like object oriented
programming or templates because the focus is on writing small,
self-contained functions, not big programs. A working knowledge of C++
is helpful, but not essential. Many good tutorials and references are
freely available, including \url{http://www.learncpp.com/} and
\url{http://www.cplusplus.com/}. For more advanced topics, the
\emph{Effective C++} series by Scott Meyers is a popular choice. You may
also enjoy Dirk Eddelbuettel's
\href{http://www.springer.com/statistics/computational+statistics/book/978-1-4614-6867-7}{\emph{Seamless
R and C++ integration with Rcpp}}, which goes into much greater detail
into all aspects of Rcpp.

\hypertarget{outline-19}{%
\subsection*{Outline}\label{outline-19}}
\addcontentsline{toc}{subsection}{Outline}

\begin{itemize}
\item
  \protect\hyperlink{rcpp-intro}{Getting started with C++} teaches you
  how to write C++ by converting simple R functions to their C++
  equivalents. You'll learn how C++ differs from R, and what the key
  scalar, vector, and matrix classes are called.
\item
  \protect\hyperlink{sourceCpp}{Using sourceCpp} shows you how to use
  \texttt{sourceCpp()} to load a C++ file from disk in the same way you
  use \texttt{source()} to load a file of R code.
\item
  \protect\hyperlink{rcpp-classes}{Attributes \& other classes}
  discusses how to modify attributes from Rcpp, and mentions some of the
  other important classes.
\item
  \protect\hyperlink{rcpp-na}{Missing values} teaches you how to work
  with R's missing values in C++.
\item
  \protect\hyperlink{rcpp-sugar}{Rcpp sugar} discusses Rcpp ``sugar'',
  which allows you to avoid loops in C++ and write code that looks very
  similar to vectorised R code.
\item
  \protect\hyperlink{stl}{The STL} shows you how to use some of the most
  important data structures and algorithms from the standard template
  library, or STL, built-in to C++.
\item
  \protect\hyperlink{rcpp-case-studies}{Case studies} shows two real
  case studies where Rcpp was used to get considerable performance
  improvements.
\item
  \protect\hyperlink{rcpp-package}{Putting Rcpp in a package} teaches
  you how to add C++ code to a package.
\item
  \protect\hyperlink{rcpp-more}{Learning more} concludes the chapter
  with pointers to more resources to help you learn Rcpp and C++.
\end{itemize}

\hypertarget{prerequistes}{%
\subsection*{Prerequistes}\label{prerequistes}}
\addcontentsline{toc}{subsection}{Prerequistes}

All examples in this chapter need version 0.10.1 or above of the
\texttt{Rcpp} package. This version includes \texttt{cppFunction()} and
\texttt{sourceCpp()}, which makes it very easy to connect C++ to R.
Install the latest version of Rcpp from CRAN with
\texttt{install.packages("Rcpp")}.

You'll also need a working C++ compiler. To get it:

\begin{itemize}
\tightlist
\item
  On Windows, install
  \href{http://cran.r-project.org/bin/windows/Rtools/}{Rtools}.
\item
  On Mac, install Xcode from the app store.
\item
  On Linux, \texttt{sudo\ apt-get\ install\ r-base-dev} or similar.
\end{itemize}

\hypertarget{rcpp-intro}{%
\section{Getting started with C++}\label{rcpp-intro}}

\texttt{cppFunction()} allows you to write C++ functions in R:
\indexc{cppFunction()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(Rcpp)}
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'int add(int x, int y, int z) \{}
\StringTok{  int sum = x + y + z;}
\StringTok{  return sum;}
\StringTok{\}'}\NormalTok{)}
\CommentTok{# add works like a regular R function}
\NormalTok{add}
\CommentTok{#> function (x, y, z) }
\CommentTok{#> .Call(<pointer: 0x7f83e91c8f60>, x, y, z)}
\KeywordTok{add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 6}
\end{Highlighting}
\end{Shaded}

When you run this code, Rcpp will compile the C++ code and construct an
R function that connects to the compiled C++ function. We're going to
use this simple interface to learn how to write C++. C++ is a large
language, and there's no way to cover it all in just one chapter.
Instead, you'll get the basics so that you can start writing useful
functions to address bottlenecks in your R code.

The following sections will teach you the basics by translating simple R
functions to their C++ equivalents. We'll start simple with a function
that has no inputs and a scalar output, and then get progressively more
complicated:

\begin{itemize}
\tightlist
\item
  Scalar input and scalar output
\item
  Vector input and scalar output
\item
  Vector input and vector output
\item
  Matrix input and vector output
\end{itemize}

\hypertarget{no-inputs-scalar-output}{%
\subsection{No inputs, scalar output}\label{no-inputs-scalar-output}}

Let's start with a very simple function. It has no arguments and always
returns the integer 1:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() 1L}
\end{Highlighting}
\end{Shaded}

The equivalent C++ function is:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ one() \{}
  \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can compile and use this from R with \texttt{cppFunction}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'int one() \{}
\StringTok{  return 1;}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This small function illustrates a number of important differences
between R and C++:

\begin{itemize}
\item
  The syntax to create a function looks like the syntax to call a
  function; you don't use assignment to create functions as you do in R.
\item
  You must declare the type of output the function returns. This
  function returns an \texttt{int} (a scalar integer). The classes for
  the most common types of R vectors are: \texttt{NumericVector},
  \texttt{IntegerVector}, \texttt{CharacterVector}, and
  \texttt{LogicalVector}.
\item
  Scalars and vectors are different. The scalar equivalents of numeric,
  integer, character, and logical vectors are: \texttt{double},
  \texttt{int}, \texttt{String}, and \texttt{bool}.
\item
  You must use an explicit \texttt{return} statement to return a value
  from a function.
\item
  Every statement is terminated by a \texttt{;}.
\end{itemize}

\hypertarget{scalar-input-scalar-output}{%
\subsection{Scalar input, scalar
output}\label{scalar-input-scalar-output}}

The next example function implements a scalar version of the
\texttt{sign()} function which returns 1 if the input is positive, and
-1 if it's negative:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \DecValTok{0}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \DecValTok{-1}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'int signC(int x) \{}
\StringTok{  if (x > 0) \{}
\StringTok{    return 1;}
\StringTok{  \} else if (x == 0) \{}
\StringTok{    return 0;}
\StringTok{  \} else \{}
\StringTok{    return -1;}
\StringTok{  \}}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the C++ version:

\begin{itemize}
\item
  We declare the type of each input in the same way we declare the type
  of the output. While this makes the code a little more verbose, it
  also makes it very obvious what type of input the function needs.
\item
  The \texttt{if} syntax is identical --- while there are some big
  differences between R and C++, there are also lots of similarities!
  C++ also has a \texttt{while} statement that works the same way as
  R's. As in R you can use \texttt{break} to exit the loop, but to skip
  one iteration you need to use \texttt{continue} instead of
  \texttt{next}.
\end{itemize}

\hypertarget{vector-input-scalar-output}{%
\subsection{Vector input, scalar
output}\label{vector-input-scalar-output}}

One big difference between R and C++ is that the cost of loops is much
lower in C++. For example, we could implement the \texttt{sum} function
in R using a loop. If you've been programming in R a while, you'll
probably have a visceral reaction to this function!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  total <-}\StringTok{ }\DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{    total <-}\StringTok{ }\NormalTok{total }\OperatorTok{+}\StringTok{ }\NormalTok{x[i]}
\NormalTok{  \}}
\NormalTok{  total}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In C++, loops have very little overhead, so it's fine to use them. In
\protect\hyperlink{stl}{STL}, you'll see alternatives to \texttt{for}
loops that more clearly express your intent; they're not faster, but
they can make your code easier to understand.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'double sumC(NumericVector x) \{}
\StringTok{  int n = x.size();}
\StringTok{  double total = 0;}
\StringTok{  for(int i = 0; i < n; ++i) \{}
\StringTok{    total += x[i];}
\StringTok{  \}}
\StringTok{  return total;}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The C++ version is similar, but:

\begin{itemize}
\item
  To find the length of the vector, we use the \texttt{.size()} method,
  which returns an integer. C++ methods are called with \texttt{.}
  (i.e., a full stop).
\item
  The \texttt{for} statement has a different syntax:
  \texttt{for(init;\ check;\ increment)}. This loop is initialised by
  creating a new variable called \texttt{i} with value 0. Before each
  iteration we check that \texttt{i\ \textless{}\ n}, and terminate the
  loop if it's not. After each iteration, we increment the value of
  \texttt{i} by one, using the special prefix operator \texttt{++} which
  increases the value of \texttt{i} by 1.
\item
  In C++, vector indices start at 0. I'll say this again because it's so
  important: \textbf{IN C++, VECTOR INDICES START AT 0}! This is a very
  common source of bugs when converting R functions to C++.
\item
  Use \texttt{=} for assignment, not \texttt{\textless{}-}.
\item
  C++ provides operators that modify in-place:
  \texttt{total\ +=\ x{[}i{]}} is equivalent to
  \texttt{total\ =\ total\ +\ x{[}i{]}}. Similar in-place operators are
  \texttt{-=}, \texttt{*=}, and \texttt{/=}.
\end{itemize}

This is a good example of where C++ is much more efficient than R. As
shown by the following microbenchmark, \texttt{sumC()} is competitive
with the built-in (and highly optimised) \texttt{sum()}, while
\texttt{sumR()} is several orders of magnitude slower.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e3}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{sum}\NormalTok{(x),}
  \KeywordTok{sumC}\NormalTok{(x),}
  \KeywordTok{sumR}\NormalTok{(x)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>     expr   min    lq  mean median    uq   max neval}
\CommentTok{#>   sum(x)  1.34  1.40  1.63   1.45  1.60     8   100}
\CommentTok{#>  sumC(x)  3.37  3.63 13.98   3.91  4.42   970   100}
\CommentTok{#>  sumR(x) 38.50 38.80 88.50  39.00 43.50 4,450   100}
\end{Highlighting}
\end{Shaded}

\hypertarget{vector-input-vector-output}{%
\subsection{Vector input, vector
output}\label{vector-input-vector-output}}

Next we'll create a function that computes the Euclidean distance
between a value and a vector of values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pdistR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ys) \{}
  \KeywordTok{sqrt}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\NormalTok{ys) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It's not obvious that we want \texttt{x} to be a scalar from the
function definition. We'd need to make that clear in the documentation.
That's not a problem in the C++ version because we have to be explicit
about types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'NumericVector pdistC(double x, NumericVector ys) \{}
\StringTok{  int n = ys.size();}
\StringTok{  NumericVector out(n);}

\StringTok{  for(int i = 0; i < n; ++i) \{}
\StringTok{    out[i] = sqrt(pow(ys[i] - x, 2.0));}
\StringTok{  \}}
\StringTok{  return out;}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This function introduces only a few new concepts:

\begin{itemize}
\item
  We create a new numeric vector of length \texttt{n} with a
  constructor: \texttt{NumericVector\ out(n)}. Another useful way of
  making a vector is to copy an existing one:
  \texttt{NumericVector\ zs\ =\ clone(ys)}.
\item
  C++ uses \texttt{pow()}, not \texttt{\^{}}, for exponentiation.
\end{itemize}

Note that because the R version is fully vectorised, it's already going
to be fast. On my computer, it takes around 8 ms with a 1 million
element \texttt{y} vector. The C++ function is twice as fast,
\textasciitilde{}4 ms, but assuming it took you 10 minutes to write the
C++ function, you'd need to run it \textasciitilde{}150,000 times to
make rewriting worthwhile. The reason why the C++ function is faster is
subtle, and relates to memory management. The R version needs to create
an intermediate vector the same length as y (\texttt{x\ -\ ys}), and
allocating memory is an expensive operation. The C++ function avoids
this overhead because it uses an intermediate scalar.

In the sugar section, you'll see how to rewrite this function to take
advantage of Rcpp's vectorised operations so that the C++ code is almost
as concise as R code.

\hypertarget{matrix-input-vector-output}{%
\subsection{Matrix input, vector
output}\label{matrix-input-vector-output}}

Each vector type has a matrix equivalent: \texttt{NumericMatrix},
\texttt{IntegerMatrix}, \texttt{CharacterMatrix}, and
\texttt{LogicalMatrix}. Using them is straightforward. For example, we
could create a function that reproduces \texttt{rowSums()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'NumericVector rowSumsC(NumericMatrix x) \{}
\StringTok{  int nrow = x.nrow(), ncol = x.ncol();}
\StringTok{  NumericVector out(nrow);}

\StringTok{  for (int i = 0; i < nrow; i++) \{}
\StringTok{    double total = 0;}
\StringTok{    for (int j = 0; j < ncol; j++) \{}
\StringTok{      total += x(i, j);}
\StringTok{    \}}
\StringTok{    out[i] = total;}
\StringTok{  \}}
\StringTok{  return out;}
\StringTok{\}'}\NormalTok{)}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1014}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{), }\DecValTok{10}\NormalTok{)}
\KeywordTok{rowSums}\NormalTok{(x)}
\CommentTok{#>  [1] 458 558 488 458 536 537 488 491 508 528}
\KeywordTok{rowSumsC}\NormalTok{(x)}
\CommentTok{#>  [1] 458 558 488 458 536 537 488 491 508 528}
\end{Highlighting}
\end{Shaded}

The main differences:

\begin{itemize}
\item
  In C++, you subset a matrix with \texttt{()}, not \texttt{{[}{]}}.
\item
  Use \texttt{.nrow()} and \texttt{.ncol()} \emph{methods} to get the
  dimensions of a matrix.
\end{itemize}

\hypertarget{sourceCpp}{%
\subsection{Using sourceCpp}\label{sourceCpp}}

So far, we've used inline C++ with \texttt{cppFunction()}. This makes
presentation simpler, but for real problems, it's usually easier to use
stand-alone C++ files and then source them into R using
\texttt{sourceCpp()}. This lets you take advantage of text editor
support for C++ files (e.g., syntax highlighting) as well as making it
easier to identify the line numbers in compilation errors.
\indexc{sourceCpp()}

Your stand-alone C++ file should have extension \texttt{.cpp}, and needs
to start with:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}
\end{Highlighting}
\end{Shaded}

And for each function that you want available within R, you need to
prefix it with:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// [[Rcpp::export]]}
\end{Highlighting}
\end{Shaded}

Note that the space is mandatory.

If you're familiar with roxygen2, you might wonder how this relates to
\texttt{@export}. \texttt{Rcpp::export} controls whether a function is
exported from C++ to R; \texttt{@export} controls whether a function is
exported from a package and made available to the user.

You can embed R code in special C++ comment blocks. This is really
convenient if you want to run some test code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*** R}
\CommentTok{# This is R code}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

The R code is run with \texttt{source(echo\ =\ TRUE)} so you don't need
to explicitly print output.

To compile the C++ code, use \texttt{sourceCpp("path/to/file.cpp")}.
This will create the matching R functions and add them to your current
session. Note that these functions can not be saved in a \texttt{.Rdata}
file and reloaded in a later session; they must be recreated each time
you restart R. For example, running \texttt{sourceCpp()} on the
following file implements mean in C++ and then compares it to the
built-in \texttt{mean()}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ meanC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  \DataTypeTok{double}\NormalTok{ total = }\DecValTok{0}\NormalTok{;}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    total += x[i];}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ total / n;}
\NormalTok{\}}

\CommentTok{/*** R}
\CommentTok{library(microbenchmark)}
\CommentTok{x <- runif(1e5)}
\CommentTok{microbenchmark(}
\CommentTok{  mean(x),}
\CommentTok{  meanC(x)}
\CommentTok{)}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

NB: if you run this code yourself, you'll notice that \texttt{meanC()}
is much faster than the built-in \texttt{mean()}. This is because it
trades numerical accuracy for speed.

For the remainder of this chapter C++ code will be presented stand-alone
rather than wrapped in a call to \texttt{cppFunction}. If you want to
try compiling and/or modifying the examples you should paste them into a
C++ source file that includes the elements described above.

\hypertarget{exercises-73}{%
\subsection{Exercises}\label{exercises-73}}

With the basics of C++ in hand, it's now a great time to practice by
reading and writing some simple C++ functions. For each of the following
functions, read the code and figure out what the corresponding base R
function is. You might not understand every part of the code yet, but
you should be able to figure out the basics of what the function does.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ f1(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  \DataTypeTok{double}\NormalTok{ y = }\DecValTok{0}\NormalTok{;}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    y += x[i] / n;}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ y;}
\NormalTok{\}}

\NormalTok{NumericVector f2(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n);}

\NormalTok{  out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = out[i - }\DecValTok{1}\NormalTok{] + x[i];}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ f3(LogicalVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \ControlFlowTok{if}\NormalTok{ (x[i]) }\ControlFlowTok{return} \KeywordTok{true}\NormalTok{;}
\NormalTok{  \}}
  \ControlFlowTok{return} \KeywordTok{false}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ f4(Function pred, List x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    LogicalVector res = pred(x[i]);}
    \ControlFlowTok{if}\NormalTok{ (res[}\DecValTok{0}\NormalTok{]) }\ControlFlowTok{return}\NormalTok{ i + }\DecValTok{1}\NormalTok{;}
\NormalTok{  \}}
  \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\NormalTok{NumericVector f5(NumericVector x, NumericVector y) \{}
  \DataTypeTok{int}\NormalTok{ n = }\BuiltInTok{std::}\NormalTok{max(x.size(), y.size());}
\NormalTok{  NumericVector x1 = rep_len(x, n);}
\NormalTok{  NumericVector y1 = rep_len(y, n);}

\NormalTok{  NumericVector out(n);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = }\BuiltInTok{std::}\NormalTok{min(x1[i], y1[i]);}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To practice your function writing skills, convert the following
functions into C++. For now, assume the inputs have no missing values.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{all()}
\item
  \texttt{cumprod()}, \texttt{cummin()}, \texttt{cummax()}.
\item
  \texttt{diff()}. Start by assuming lag 1, and then generalise for lag
  \texttt{n}.
\item
  \texttt{range}.
\item
  \texttt{var}. Read about the approaches you can take on
  \href{http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance}{wikipedia}.
  Whenever implementing a numerical algorithm, it's always good to check
  what is already known about the problem.
\end{enumerate}

\hypertarget{rcpp-classes}{%
\section{Attributes and other classes}\label{rcpp-classes}}

You've already seen the basic vector classes (\texttt{IntegerVector},
\texttt{NumericVector}, \texttt{LogicalVector},
\texttt{CharacterVector}) and their scalar (\texttt{int},
\texttt{double}, \texttt{bool}, \texttt{String}) and matrix
(\texttt{IntegerMatrix}, \texttt{NumericMatrix}, \texttt{LogicalMatrix},
\texttt{CharacterMatrix}) equivalents.

All R objects have attributes, which can be queried and modified with
\texttt{.attr()}. Rcpp also provides \texttt{.names()} as an alias for
the name attribute. The following code snippet illustrates these
methods. Note the use of \texttt{::create()}, a \emph{class} method.
This allows you to create an R vector from C++ scalar values:
\index{attributes!in C++ } \index{names!in C++}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector attribs() \{}
\NormalTok{  NumericVector out = NumericVector::create(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{);}

\NormalTok{  out.names() = CharacterVector::create(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{);}
\NormalTok{  out.attr(}\StringTok{"my-attr"}\NormalTok{) = }\StringTok{"my-value"}\NormalTok{;}
\NormalTok{  out.attr(}\StringTok{"class"}\NormalTok{) = }\StringTok{"my-class"}\NormalTok{;}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For S4 objects, \texttt{.slot()} plays a similar role to
\texttt{.attr()}.

\hypertarget{lists-and-data-frames}{%
\subsection{Lists and data frames}\label{lists-and-data-frames}}

Rcpp also provides classes \texttt{List} and \texttt{DataFrame}, but
they are more useful for output than input. This is because lists and
data frames can contain arbitrary classes but C++ needs to know their
classes in advance. If the list has known structure (e.g., it's an S3
object), you can extract the components and manually convert them to
their C++ equivalents with \texttt{as()}. For example, the object
created by \texttt{lm()}, the function that fits a linear model, is a
list whose components are always of the same type. The following code
illustrates how you might extract the mean percentage error
(\texttt{mpe()}) of a linear model. This isn't a good example of when to
use C++, because it's so easily implemented in R, but it shows how to
work with an important S3 class. Note the use of \texttt{.inherits()}
and the \texttt{stop()} to check that the object really is a linear
model. \index{lists!in C++} \index{data frames!in C++}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ mpe(List mod) \{}
  \ControlFlowTok{if}\NormalTok{ (!mod.inherits(}\StringTok{"lm"}\NormalTok{)) stop(}\StringTok{"Input must be a linear model"}\NormalTok{);}

\NormalTok{  NumericVector resid = as<NumericVector>(mod[}\StringTok{"residuals"}\NormalTok{]);}
\NormalTok{  NumericVector fitted = as<NumericVector>(mod[}\StringTok{"fitted.values"}\NormalTok{]);}

  \DataTypeTok{int}\NormalTok{ n = resid.size();}
  \DataTypeTok{double}\NormalTok{ err = }\DecValTok{0}\NormalTok{;}
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    err += resid[i] / (fitted[i] + resid[i]);}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ err / n;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\KeywordTok{mpe}\NormalTok{(mod)}
\CommentTok{#> [1] -0.0154}
\end{Highlighting}
\end{Shaded}

\hypertarget{functions-rcpp}{%
\subsection{Functions}\label{functions-rcpp}}

You can put R functions in an object of type \texttt{Function}. This
makes calling an R function from C++ straightforward. We first define
our C++ function: \index{functions!in C++}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{RObject callWithOne(Function f) \{}
  \ControlFlowTok{return}\NormalTok{ f(}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then call it from R:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{callWithOne}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 2}
\KeywordTok{callWithOne}\NormalTok{(paste)}
\CommentTok{#> [1] "1"}
\end{Highlighting}
\end{Shaded}

What type of object does an R function return? We don't know, so we use
the catchall type \texttt{RObject}. An alternative is to return a
\texttt{List}. For example, the following code is a basic implementation
of \texttt{lapply} in C++:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List lapply1(List input, Function f) \{}
  \DataTypeTok{int}\NormalTok{ n = input.size();}
\NormalTok{  List out(n);}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; i++) \{}
\NormalTok{    out[i] = f(input[i]);}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Calling R functions with positional arguments is obvious:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f(}\StringTok{"y"}\NormalTok{, }\DecValTok{1}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

But to use named arguments, you need a special syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f(_[}\StringTok{"x"}\NormalTok{] = }\StringTok{"y"}\NormalTok{, _[}\StringTok{"value"}\NormalTok{] = }\DecValTok{1}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\hypertarget{other-types}{%
\subsection{Other types}\label{other-types}}

There are also classes for many more specialised language objects:
\texttt{Environment}, \texttt{ComplexVector}, \texttt{RawVector},
\texttt{DottedPair}, \texttt{Language}, \texttt{Promise},
\texttt{Symbol}, \texttt{WeakReference}, and so on. These are beyond the
scope of this chapter and won't be discussed further.

\hypertarget{rcpp-na}{%
\section{Missing values}\label{rcpp-na}}

If you're working with missing values, you need to know two things:
\index{missing values!in C++}

\begin{itemize}
\tightlist
\item
  how R's missing values behave in C++'s scalars (e.g.,
  \texttt{double}).
\item
  how to get and set missing values in vectors (e.g.,
  \texttt{NumericVector}).
\end{itemize}

\hypertarget{scalars-1}{%
\subsection{Scalars}\label{scalars-1}}

The following code explores what happens when you take one of R's
missing values, coerce it into a scalar, and then coerce back to an R
vector. Note that this kind of experimentation is a useful way to figure
out what any operation does.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List scalar_missings() \{}
  \DataTypeTok{int}\NormalTok{ int_s = NA_INTEGER;}
\NormalTok{  String chr_s = NA_STRING;}
  \DataTypeTok{bool}\NormalTok{ lgl_s = NA_LOGICAL;}
  \DataTypeTok{double}\NormalTok{ num_s = NA_REAL;}

  \ControlFlowTok{return}\NormalTok{ List::create(int_s, chr_s, lgl_s, num_s);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{scalar_missings}\NormalTok{())}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : int NA}
\CommentTok{#>  $ : chr NA}
\CommentTok{#>  $ : logi TRUE}
\CommentTok{#>  $ : num NA}
\end{Highlighting}
\end{Shaded}

With the exception of \texttt{bool}, things look pretty good here: all
of the missing values have been preserved. However, as we'll see in the
following sections, things are not quite as straightforward as they
seem.

\hypertarget{integers}{%
\subsubsection{Integers}\label{integers}}

With integers, missing values are stored as the smallest integer. If you
don't do anything to them, they'll be preserved. But, since C++ doesn't
know that the smallest integer has this special behaviour, if you do
anything to it you're likely to get an incorrect value: for example,
\texttt{evalCpp(\textquotesingle{}NA\_INTEGER\ +\ 1\textquotesingle{})}
gives -2147483647.

So if you want to work with missing values in integers, either use a
length one \texttt{IntegerVector} or be very careful with your code.

\hypertarget{doubles}{%
\subsubsection{Doubles}\label{doubles}}

With doubles, you may be able to get away with ignoring missing values
and working with NaNs (not a number). This is because R's NA is a
special type of IEEE 754 floating point number NaN. So any logical
expression that involves a NaN (or in C++, NAN) always evaluates as
FALSE:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN == 1"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN < 1"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN > 1"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN == NAN"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

But be careful when combining them with boolean values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN && TRUE"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN || FALSE"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

However, in numeric contexts NaNs will propagate NAs:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN + 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN - 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN / 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN * 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\end{Highlighting}
\end{Shaded}

\hypertarget{strings}{%
\subsection{Strings}\label{strings}}

\texttt{String} is a scalar string class introduced by Rcpp, so it knows
how to deal with missing values.

\hypertarget{boolean}{%
\subsection{Boolean}\label{boolean}}

While C++'s \texttt{bool} has two possible values (\texttt{true} or
\texttt{false}), a logical vector in R has three (\texttt{TRUE},
\texttt{FALSE}, and \texttt{NA}). If you coerce a length 1 logical
vector, make sure it doesn't contain any missing values otherwise they
will be converted to TRUE.

\hypertarget{vectors-rcpp}{%
\subsection{Vectors}\label{vectors-rcpp}}

With vectors, you need to use a missing value specific to the type of
vector, \texttt{NA\_REAL}, \texttt{NA\_INTEGER}, \texttt{NA\_LOGICAL},
\texttt{NA\_STRING}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List missing_sampler() \{}
  \ControlFlowTok{return}\NormalTok{ List::create(}
\NormalTok{    NumericVector::create(NA_REAL),}
\NormalTok{    IntegerVector::create(NA_INTEGER),}
\NormalTok{    LogicalVector::create(NA_LOGICAL),}
\NormalTok{    CharacterVector::create(NA_STRING));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{missing_sampler}\NormalTok{())}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : num NA}
\CommentTok{#>  $ : int NA}
\CommentTok{#>  $ : logi NA}
\CommentTok{#>  $ : chr NA}
\end{Highlighting}
\end{Shaded}

To check if a value in a vector is missing, use the class method
\texttt{::is\_na()}:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector is_naC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  LogicalVector out(n);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = NumericVector::is_na(x[i]);}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_naC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\FloatTok{5.4}\NormalTok{, }\FloatTok{3.2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

Another alternative is the sugar function \texttt{is\_na()}, which takes
a vector and returns a logical vector.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector is_naC2(NumericVector x) \{}
  \ControlFlowTok{return}\NormalTok{ is_na(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_naC2}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\FloatTok{5.4}\NormalTok{, }\FloatTok{3.2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{exercises-74}{%
\subsection{Exercises}\label{exercises-74}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Rewrite any of the functions from the first exercise to deal with
  missing values. If \texttt{na.rm} is true, ignore the missing values.
  If \texttt{na.rm} is false, return a missing value if the input
  contains any missing values. Some good functions to practice with are
  \texttt{min()}, \texttt{max()}, \texttt{range()}, \texttt{mean()}, and
  \texttt{var()}.
\item
  Rewrite \texttt{cumsum()} and \texttt{diff()} so they can handle
  missing values. Note that these functions have slightly more
  complicated behaviour.
\end{enumerate}

\hypertarget{rcpp-sugar}{%
\section{Rcpp sugar}\label{rcpp-sugar}}

Rcpp provides a lot of syntactic ``sugar'' to ensure that C++ functions
work very similarly to their R equivalents. In fact, Rcpp sugar makes it
possible to write efficient C++ code that looks almost identical to its
R equivalent. If there's a sugar version of the function you're
interested in, you should use it: it'll be both expressive and well
tested. Sugar functions aren't always faster than a handwritten
equivalent, but they will get faster in the future as more time is spent
on optimising Rcpp.

Sugar functions can be roughly broken down into

\begin{itemize}
\tightlist
\item
  arithmetic and logical operators
\item
  logical summary functions
\item
  vector views
\item
  other useful functions
\end{itemize}

\hypertarget{arithmetic-and-logical-operators}{%
\subsection{Arithmetic and logical
operators}\label{arithmetic-and-logical-operators}}

All the basic arithmetic and logical operators are vectorised:
\texttt{+}, \texttt{*}, \texttt{-}, \texttt{/}, \texttt{pow},
\texttt{\textless{}}, \texttt{\textless{}=}, \texttt{\textgreater{}},
\texttt{\textgreater{}=}, \texttt{==}, \texttt{!=}, \texttt{!}. For
example, we could use sugar to considerably simplify the implementation
of \texttt{pdistC()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pdistR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ys) \{}
  \KeywordTok{sqrt}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\NormalTok{ys) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector pdistC2(}\DataTypeTok{double}\NormalTok{ x, NumericVector ys) \{}
  \ControlFlowTok{return}\NormalTok{ sqrt(pow((x - ys), }\DecValTok{2}\NormalTok{));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{logical-summary-functions}{%
\subsection{Logical summary functions}\label{logical-summary-functions}}

The sugar function \texttt{any()} and \texttt{all()} are fully lazy so
that \texttt{any(x\ ==\ 0)}, for example, might only need to evaluate
one element of a vector, and return a special type that can be converted
into a \texttt{bool} using \texttt{.is\_true()}, \texttt{.is\_false()},
or \texttt{.is\_na()}. We could also use this sugar to write an
efficient function to determine whether or not a numeric vector contains
any missing values. To do this in R, we could use
\texttt{any(is.na(x))}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{any_naR <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{any}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

However, this will do the same amount of work regardless of the location
of the missing value. Here's the C++ implementation:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{bool}\NormalTok{ any_naC(NumericVector x) \{}
  \ControlFlowTok{return}\NormalTok{ is_true(any(is_na(x)));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x0 <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e5}\NormalTok{)}
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x0, }\OtherTok{NA}\NormalTok{)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, x0)}

\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{any_naR}\NormalTok{(x0), }\KeywordTok{any_naC}\NormalTok{(x0),}
  \KeywordTok{any_naR}\NormalTok{(x1), }\KeywordTok{any_naC}\NormalTok{(x1),}
  \KeywordTok{any_naR}\NormalTok{(x2), }\KeywordTok{any_naC}\NormalTok{(x2)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>         expr    min     lq   mean median     uq     max neval}
\CommentTok{#>  any_naR(x0) 603.00 628.00 792.95 640.00 659.00 6,230.0   100}
\CommentTok{#>  any_naC(x0) 487.00 493.00 503.69 503.00 511.00   537.0   100}
\CommentTok{#>  any_naR(x1) 469.00 622.00 632.11 630.00 641.00   726.0   100}
\CommentTok{#>  any_naC(x1) 487.00 490.00 516.53 502.00 511.00 1,700.0   100}
\CommentTok{#>  any_naR(x2) 380.00 473.00 501.34 486.00 502.00 1,800.0   100}
\CommentTok{#>  any_naC(x2)   1.98   3.28   6.03   4.54   6.38    97.2   100}
\end{Highlighting}
\end{Shaded}

\hypertarget{vector-views}{%
\subsection{Vector views}\label{vector-views}}

A number of helpful functions provide a ``view'' of a vector:
\texttt{head()}, \texttt{tail()}, \texttt{rep\_each()},
\texttt{rep\_len()}, \texttt{rev()}, \texttt{seq\_along()}, and
\texttt{seq\_len()}. In R these would all produce copies of the vector,
but in Rcpp they simply point to the existing vector and override the
subsetting operator (\texttt{{[}}) to implement special behaviour. This
makes them very efficient: for instance, \texttt{rep\_len(x,\ 1e6)} does
not have to make a million copies of x.

\hypertarget{other-useful-functions}{%
\subsection{Other useful functions}\label{other-useful-functions}}

Finally, there's a grab bag of sugar functions that mimic frequently
used R functions:

\begin{itemize}
\item
  Math functions: \texttt{abs()}, \texttt{acos()}, \texttt{asin()},
  \texttt{atan()}, \texttt{beta()}, \texttt{ceil()}, \texttt{ceiling()},
  \texttt{choose()}, \texttt{cos()}, \texttt{cosh()},
  \texttt{digamma()}, \texttt{exp()}, \texttt{expm1()},
  \texttt{factorial()}, \texttt{floor()}, \texttt{gamma()},
  \texttt{lbeta()}, \texttt{lchoose()}, \texttt{lfactorial()},
  \texttt{lgamma()}, \texttt{log()}, \texttt{log10()}, \texttt{log1p()},
  \texttt{pentagamma()}, \texttt{psigamma()}, \texttt{round()},
  \texttt{signif()}, \texttt{sin()}, \texttt{sinh()}, \texttt{sqrt()},
  \texttt{tan()}, \texttt{tanh()}, \texttt{tetragamma()},
  \texttt{trigamma()}, \texttt{trunc()}.
\item
  Scalar summaries: \texttt{mean()}, \texttt{min()}, \texttt{max()},
  \texttt{sum()}, \texttt{sd()}, and (for vectors) \texttt{var()}.
\item
  Vector summaries: \texttt{cumsum()}, \texttt{diff()}, \texttt{pmin()},
  and \texttt{pmax()}.
\item
  Finding values: \texttt{match()}, \texttt{self\_match()},
  \texttt{which\_max()}, \texttt{which\_min()}.
\item
  Dealing with duplicates: \texttt{duplicated()}, \texttt{unique()}.
\item
  \texttt{d/q/p/r} for all standard distributions.
\end{itemize}

Finally, \texttt{noNA(x)} asserts that the vector \texttt{x} does not
contain any missing values, and allows optimisation of some mathematical
operations. For example, when computing the mean of a vector with no
missing values, Rcpp doesn't need to check each value is not missing
when computing the sum and the length.

\hypertarget{stl}{%
\section{The STL}\label{stl}}

The real strength of C++ shows itself when you need to implement more
complex algorithms. The standard template library (STL) provides a set
of extremely useful data structures and algorithms. This section will
explain some of the most important algorithms and data structures and
point you in the right direction to learn more. I can't teach you
everything you need to know about the STL, but hopefully the examples
will show you the power of the STL, and persuade you that it's useful to
learn more. \index{standard template library}

If you need an algorithm or data structure that isn't implemented in
STL, a good place to look is \href{http://www.boost.org/doc/}{boost}.
Installing boost on your computer is beyond the scope of this chapter,
but once you have it installed, you can use boost data structures and
algorithms by including the appropriate header file with (e.g.)
\texttt{\#include\ \textless{}boost/array.hpp\textgreater{}}.

\hypertarget{using-iterators}{%
\subsection{Using iterators}\label{using-iterators}}

Iterators are used extensively in the STL: many functions either accept
or return iterators. They are the next step up from basic loops,
abstracting away the details of the underlying data structure. Iterators
have three main operators: \index{iterators}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Advance with \texttt{++}.
\item
  Get the value they refer to, or \textbf{dereference}, with \texttt{*}.
\item
  Compare with \texttt{==}.
\end{enumerate}

For example we could re-write our sum function using iterators:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ sum3(NumericVector x) \{}
  \DataTypeTok{double}\NormalTok{ total = }\DecValTok{0}\NormalTok{;}
  
\NormalTok{  NumericVector::iterator it;}
  \ControlFlowTok{for}\NormalTok{(it = x.begin(); it != x.end(); ++it) \{}
\NormalTok{    total += *it;}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ total;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The main changes are in the for loop:

\begin{itemize}
\item
  We start at \texttt{x.begin()} and loop until we get to
  \texttt{x.end()}. A small optimization is to store the value of the
  end iterator so we don't need to look it up each time. This only saves
  about 2 ns per iteration, so it's only important when the calculations
  in the loop are very simple.
\item
  Instead of indexing into x, we use the dereference operator to get its
  current value: \texttt{*it}.
\item
  Notice the type of the iterator: \texttt{NumericVector::iterator}.
  Each vector type has its own iterator type:
  \texttt{LogicalVector::iterator}, \texttt{CharacterVector::iterator},
  etc.
\end{itemize}

Iterators also allow us to use the C++ equivalents of the apply family
of functions. For example, we could again rewrite \texttt{sum()} to use
the \texttt{accumulate()} function, which takes a starting and an ending
iterator, and adds up all the values in the vector. The third argument
to accumulate gives the initial value: it's particularly important
because this also determines the data type that accumulate uses (so we
use \texttt{0.0} and not \texttt{0} so that accumulate uses a
\texttt{double}, not an \texttt{int}.). To use \texttt{accumulate()} we
need to include the \texttt{\textless{}numeric\textgreater{}} header.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<numeric>}
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ sum4(NumericVector x) \{}
  \ControlFlowTok{return} \BuiltInTok{std::}\NormalTok{accumulate(x.begin(), x.end(), }\FloatTok{0.0}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{accumulate()} (along with the other functions in
\texttt{\textless{}numeric\textgreater{}}, like
\texttt{adjacent\_difference()}, \texttt{inner\_product()}, and
\texttt{partial\_sum()}) is not that important in Rcpp because Rcpp
sugar provides equivalents.

\hypertarget{algorithms}{%
\subsection{Algorithms}\label{algorithms}}

The \texttt{\textless{}algorithm\textgreater{}} header provides a large
number of algorithms that work with iterators. A good reference is
available at \url{http://www.cplusplus.com/reference/algorithm/}. For
example, we could write a basic Rcpp version of \texttt{findInterval()}
that takes two arguments a vector of values and a vector of breaks, and
locates the bin that each x falls into. This shows off a few more
advanced iterator features. Read the code below and see if you can
figure out how it works. \indexc{findInterval()}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<algorithm>}
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{IntegerVector findInterval2(NumericVector x, NumericVector breaks) \{}
\NormalTok{  IntegerVector out(x.size());}

\NormalTok{  NumericVector::iterator it, pos;}
\NormalTok{  IntegerVector::iterator out_it;}

  \ControlFlowTok{for}\NormalTok{(it = x.begin(), out_it = out.begin(); it != x.end(); }
\NormalTok{      ++it, ++out_it) \{}
\NormalTok{    pos = }\BuiltInTok{std::}\NormalTok{upper_bound(breaks.begin(), breaks.end(), *it);}
\NormalTok{    *out_it = }\BuiltInTok{std::}\NormalTok{distance(breaks.begin(), pos);}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The key points are:

\begin{itemize}
\item
  We step through two iterators (input and output) simultaneously.
\item
  We can assign into an dereferenced iterator (\texttt{out\_it}) to
  change the values in \texttt{out}.
\item
  \texttt{upper\_bound()} returns an iterator. If we wanted the value of
  the \texttt{upper\_bound()} we could dereference it; to figure out its
  location, we use the \texttt{distance()} function.
\item
  Small note: if we want this function to be as fast as
  \texttt{findInterval()} in R (which uses handwritten C code), we need
  to compute the calls to \texttt{.begin()} and \texttt{.end()} once and
  save the results. This is easy, but it distracts from this example so
  it has been omitted. Making this change yields a function that's
  slightly faster than R's \texttt{findInterval()} function, but is
  about 1/10 of the code.
\end{itemize}

It's generally better to use algorithms from the STL than hand rolled
loops. In \emph{Effective STL}, Scott Meyers gives three reasons:
efficiency, correctness, and maintainability. Algorithms from the STL
are written by C++ experts to be extremely efficient, and they have been
around for a long time so they are well tested. Using standard
algorithms also makes the intent of your code more clear, helping to
make it more readable and more maintainable.

\hypertarget{data-structures-rcpp}{%
\subsection{Data structures}\label{data-structures-rcpp}}

The STL provides a large set of data structures: \texttt{array},
\texttt{bitset}, \texttt{list}, \texttt{forward\_list}, \texttt{map},
\texttt{multimap}, \texttt{multiset}, \texttt{priority\_queue},
\texttt{queue}, \texttt{deque}, \texttt{set}, \texttt{stack},
\texttt{unordered\_map}, \texttt{unordered\_set},
\texttt{unordered\_multimap}, \texttt{unordered\_multiset}, and
\texttt{vector}. The most important of these data structures are the
\texttt{vector}, the \texttt{unordered\_set}, and the
\texttt{unordered\_map}. We'll focus on these three in this section, but
using the others is similar: they just have different performance
trade-offs. For example, the \texttt{deque} (pronounced ``deck'') has a
very similar interface to vectors but a different underlying
implementation that has different performance trade-offs. You may want
to try them for your problem. A good reference for STL data structures
is \url{http://www.cplusplus.com/reference/stl/} --- I recommend you
keep it open while working with the STL.

Rcpp knows how to convert from many STL data structures to their R
equivalents, so you can return them from your functions without
explicitly converting to R data structures.

\hypertarget{vectors-stl}{%
\subsection{Vectors}\label{vectors-stl}}

An STL vector is very similar to an R vector, except that it grows
efficiently. This makes vectors appropriate to use when you don't know
in advance how big the output will be. Vectors are templated, which
means that you need to specify the type of object the vector will
contain when you create it: \texttt{vector\textless{}int\textgreater{}},
\texttt{vector\textless{}bool\textgreater{}},
\texttt{vector\textless{}double\textgreater{}},
\texttt{vector\textless{}String\textgreater{}}. You can access
individual elements of a vector using the standard \texttt{{[}{]}}
notation, and you can add a new element to the end of the vector using
\texttt{.push\_back()}. If you have some idea in advance how big the
vector will be, you can use \texttt{.reserve()} to allocate sufficient
storage. \index{vectors!in C++}

The following code implements run length encoding (\texttt{rle()}). It
produces two vectors of output: a vector of values, and a vector
\texttt{lengths} giving how many times each element is repeated. It
works by looping through the input vector \texttt{x} comparing each
value to the previous: if it's the same, then it increments the last
value in \texttt{lengths}; if it's different, it adds the value to the
end of \texttt{values}, and sets the corresponding length to 1.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List rleC(NumericVector x) \{}
  \BuiltInTok{std::}\NormalTok{vector<}\DataTypeTok{int}\NormalTok{> lengths;}
  \BuiltInTok{std::}\NormalTok{vector<}\DataTypeTok{double}\NormalTok{> values;}

  \CommentTok{// Initialise first value}
  \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
  \DataTypeTok{double}\NormalTok{ prev = x[}\DecValTok{0}\NormalTok{];}
\NormalTok{  values.push_back(prev);}
\NormalTok{  lengths.push_back(}\DecValTok{1}\NormalTok{);}

\NormalTok{  NumericVector::iterator it;}
  \ControlFlowTok{for}\NormalTok{(it = x.begin() + }\DecValTok{1}\NormalTok{; it != x.end(); ++it) \{}
    \ControlFlowTok{if}\NormalTok{ (prev == *it) \{}
\NormalTok{      lengths[i]++;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      values.push_back(*it);}
\NormalTok{      lengths.push_back(}\DecValTok{1}\NormalTok{);}

\NormalTok{      i++;}
\NormalTok{      prev = *it;}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ List::create(}
\NormalTok{    _[}\StringTok{"lengths"}\NormalTok{] = lengths, }
\NormalTok{    _[}\StringTok{"values"}\NormalTok{] = values}
\NormalTok{  );}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(An alternative implementation would be to replace \texttt{i} with the
iterator \texttt{lengths.rbegin()} which always points to the last
element of the vector. You might want to try implementing that
yourself.)

Other methods of a vector are described at
\url{http://www.cplusplus.com/reference/vector/vector/}.

\hypertarget{sets}{%
\subsection{Sets}\label{sets}}

Sets maintain a unique set of values, and can efficiently tell if you've
seen a value before. They are useful for problems that involve
duplicates or unique values (like \texttt{unique}, \texttt{duplicated},
or \texttt{in}). C++ provides both ordered (\texttt{std::set}) and
unordered sets (\texttt{std::unordered\_set}), depending on whether or
not order matters for you. Unordered sets tend to be much faster
(because they use a hash table internally rather than a tree), so even
if you need an ordered set, you should consider using an unordered set
and then sorting the output. Like vectors, sets are templated, so you
need to request the appropriate type of set for your purpose:
\texttt{unordered\_set\textless{}int\textgreater{}},
\texttt{unordered\_set\textless{}bool\textgreater{}}, etc. More details
are available at \url{http://www.cplusplus.com/reference/set/set/} and
\url{http://www.cplusplus.com/reference/unordered_set/unordered_set/}.
\index{sets}

The following function uses an unordered set to implement an equivalent
to \texttt{duplicated()} for integer vectors. Note the use of
\texttt{seen.insert(x{[}i{]}).second}. \texttt{insert()} returns a pair,
the \texttt{.first} value is an iterator that points to element and the
\texttt{.second} value is a boolean that's true if the value was a new
addition to the set.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// [[Rcpp::plugins(cpp11)]]}
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\PreprocessorTok{#include }\ImportTok{<unordered_set>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector duplicatedC(IntegerVector x) \{}
  \BuiltInTok{std::}\NormalTok{unordered_set<}\DataTypeTok{int}\NormalTok{> seen;}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  LogicalVector out(n);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = !seen.insert(x[i]).second;}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that unordered sets are only available in C++ 11, which means we
need to use the \texttt{cpp11} plugin,
\texttt{{[}{[}Rcpp::plugins(cpp11){]}{]}}.

\hypertarget{map-1}{%
\subsection{Map}\label{map-1}}

A map is similar to a set, but instead of storing presence or absence,
it can store additional data. It's useful for functions like
\texttt{table()} or \texttt{match()} that need to look up a value. As
with sets, there are ordered (\texttt{std::map}) and unordered
(\texttt{std::unordered\_map}) versions. Since maps have a value and a
key, you need to specify both types when initialising a map:
\texttt{map\textless{}double,\ int\textgreater{}},
\texttt{unordered\_map\textless{}int,\ double\textgreater{}}, and so on.
The following example shows how you could use a \texttt{map} to
implement \texttt{table()} for numeric vectors: \index{maps}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\BuiltInTok{std::}\NormalTok{map<}\DataTypeTok{double}\NormalTok{, }\DataTypeTok{int}\NormalTok{> tableC(NumericVector x) \{}
  \BuiltInTok{std::}\NormalTok{map<}\DataTypeTok{double}\NormalTok{, }\DataTypeTok{int}\NormalTok{> counts;}

  \DataTypeTok{int}\NormalTok{ n = x.size();}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; i++) \{}
\NormalTok{    counts[x[i]]++;}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ counts;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that unordered maps are only available in C++ 11, so to use them,
you'll again need \texttt{{[}{[}Rcpp::plugins(cpp11){]}{]}}.

\hypertarget{exercises-75}{%
\subsection{Exercises}\label{exercises-75}}

To practice using the STL algorithms and data structures, implement the
following using R functions in C++, using the hints provided:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{median.default()} using \texttt{partial\_sort}.
\item
  \texttt{\%in\%} using \texttt{unordered\_set} and the \texttt{find()}
  or \texttt{count()} methods.
\item
  \texttt{unique()} using an \texttt{unordered\_set} (challenge: do it
  in one line!).
\item
  \texttt{min()} using \texttt{std::min()}, or \texttt{max()} using
  \texttt{std::max()}.
\item
  \texttt{which.min()} using \texttt{min\_element}, or
  \texttt{which.max()} using \texttt{max\_element}.
\item
  \texttt{setdiff()}, \texttt{union()}, and \texttt{intersect()} for
  integers using sorted ranges and \texttt{set\_union},
  \texttt{set\_intersection} and \texttt{set\_difference}.
\end{enumerate}

\hypertarget{rcpp-case-studies}{%
\section{Case studies}\label{rcpp-case-studies}}

The following case studies illustrate some real life uses of C++ to
replace slow R code.

\hypertarget{gibbs-sampler}{%
\subsection{Gibbs sampler}\label{gibbs-sampler}}

The following case study updates an example
\href{http://dirk.eddelbuettel.com/blog/2011/07/14/}{blogged about} by
Dirk Eddelbuettel, illustrating the conversion of a Gibbs sampler in R
to C++. The R and C++ code shown below is very similar (it only took a
few minutes to convert the R version to the C++ version), but runs about
20 times faster on my computer. Dirk's blog post also shows another way
to make it even faster: using the faster random number generator
functions in GSL (easily accessible from R through the RcppGSL package)
can make it another 2--3x faster. \index{Gibbs sampler}

The R code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gibbs_r <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(N, thin) \{}
\NormalTok{  mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{nrow =}\NormalTok{ N, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
\NormalTok{  x <-}\StringTok{ }\NormalTok{y <-}\StringTok{ }\DecValTok{0}

  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{N) \{}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{thin) \{}
\NormalTok{      x <-}\StringTok{ }\KeywordTok{rgamma}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, y }\OperatorTok{*}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\DecValTok{4}\NormalTok{)}
\NormalTok{      y <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{(x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{), }\DecValTok{1} \OperatorTok{/}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(x }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)))}
\NormalTok{    \}}
\NormalTok{    mat[i, ] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{  \}}
\NormalTok{  mat}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is straightforward to convert to C++. We:

\begin{itemize}
\item
  add type declarations to all variables
\item
  use \texttt{(} instead of \texttt{{[}} to index into the matrix
\item
  subscript the results of \texttt{rgamma} and \texttt{rnorm} to convert
  from a vector into a scalar
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericMatrix gibbs_cpp(}\DataTypeTok{int}\NormalTok{ N, }\DataTypeTok{int}\NormalTok{ thin) \{}
\NormalTok{  NumericMatrix mat(N, }\DecValTok{2}\NormalTok{);}
  \DataTypeTok{double}\NormalTok{ x = }\DecValTok{0}\NormalTok{, y = }\DecValTok{0}\NormalTok{;}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < N; i++) \{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{0}\NormalTok{; j < thin; j++) \{}
\NormalTok{      x = rgamma(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{ / (y * y + }\DecValTok{4}\NormalTok{))[}\DecValTok{0}\NormalTok{];}
\NormalTok{      y = rnorm(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{ / (x + }\DecValTok{1}\NormalTok{), }\DecValTok{1}\NormalTok{ / sqrt(}\DecValTok{2}\NormalTok{ * (x + }\DecValTok{1}\NormalTok{)))[}\DecValTok{0}\NormalTok{];}
\NormalTok{    \}}
\NormalTok{    mat(i, }\DecValTok{0}\NormalTok{) = x;}
\NormalTok{    mat(i, }\DecValTok{1}\NormalTok{) = y;}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{(mat);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Benchmarking the two implementations yields:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{gibbs_r}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{),}
  \KeywordTok{gibbs_cpp}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>                expr   min    lq mean median    uq    max neval}
\CommentTok{#>    gibbs_r(100, 10) 5,690 5,770 6703  5,820 5,980 16,600   100}
\CommentTok{#>  gibbs_cpp(100, 10)   306   336  367    352   369  1,730   100}
\end{Highlighting}
\end{Shaded}

\hypertarget{r-vectorisation-vs.c-vectorisation}{%
\subsection{R vectorisation vs.~C++
vectorisation}\label{r-vectorisation-vs.c-vectorisation}}

This example is adapted from
\href{https://gweissman.github.io/babelgraph/blog/2017/06/15/rcpp-is-smoking-fast-for-agent-based-models-in-data-frames.html}{``Rcpp
is smoking fast for agent-based models in data frames''}. The challenge
is to predict a model response from three inputs. The basic R version of
the predictor looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vacc1a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(age, female, ily) \{}
\NormalTok{  p <-}\StringTok{ }\FloatTok{0.25} \OperatorTok{+}\StringTok{ }\FloatTok{0.3} \OperatorTok{*}\StringTok{ }\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\FloatTok{0.04} \OperatorTok{*}\StringTok{ }\NormalTok{age)) }\OperatorTok{+}\StringTok{ }\FloatTok{0.1} \OperatorTok{*}\StringTok{ }\NormalTok{ily}
\NormalTok{  p <-}\StringTok{ }\NormalTok{p }\OperatorTok{*}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (female) }\FloatTok{1.25} \ControlFlowTok{else} \FloatTok{0.75}
\NormalTok{  p <-}\StringTok{ }\KeywordTok{max}\NormalTok{(}\DecValTok{0}\NormalTok{, p)}
\NormalTok{  p <-}\StringTok{ }\KeywordTok{min}\NormalTok{(}\DecValTok{1}\NormalTok{, p)}
\NormalTok{  p}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We want to be able to apply this function to many inputs, so we might
write a vector-input version using a for loop.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vacc1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(age, female, ily) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(age)}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(n)}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_len}\NormalTok{(n)) \{}
\NormalTok{    out[i] <-}\StringTok{ }\KeywordTok{vacc1a}\NormalTok{(age[i], female[i], ily[i])}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you're familiar with R, you'll have a gut feeling that this will be
slow, and indeed it is. There are two ways we could attack this problem.
If you have a good R vocabulary, you might immediately see how to
vectorise the function (using \texttt{ifelse()}, \texttt{pmin()}, and
\texttt{pmax()}). Alternatively, we could rewrite \texttt{vacc1a()} and
\texttt{vacc1()} in C++, using our knowledge that loops and function
calls have much lower overhead in C++.

Either approach is fairly straightforward. In R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vacc2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(age, female, ily) \{}
\NormalTok{  p <-}\StringTok{ }\FloatTok{0.25} \OperatorTok{+}\StringTok{ }\FloatTok{0.3} \OperatorTok{*}\StringTok{ }\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\FloatTok{0.04} \OperatorTok{*}\StringTok{ }\NormalTok{age)) }\OperatorTok{+}\StringTok{ }\FloatTok{0.1} \OperatorTok{*}\StringTok{ }\NormalTok{ily}
\NormalTok{  p <-}\StringTok{ }\NormalTok{p }\OperatorTok{*}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(female, }\FloatTok{1.25}\NormalTok{, }\FloatTok{0.75}\NormalTok{)}
\NormalTok{  p <-}\StringTok{ }\KeywordTok{pmax}\NormalTok{(}\DecValTok{0}\NormalTok{, p)}
\NormalTok{  p <-}\StringTok{ }\KeywordTok{pmin}\NormalTok{(}\DecValTok{1}\NormalTok{, p)}
\NormalTok{  p}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(If you've worked R a lot you might recognise some potential bottlenecks
in this code: \texttt{ifelse}, \texttt{pmin}, and \texttt{pmax} are
known to be slow, and could be replaced with
\texttt{p\ *\ 0.75\ +\ p\ *\ 0.5\ *\ female},
\texttt{p{[}p\ \textless{}\ 0{]}\ \textless{}-\ 0},
\texttt{p{[}p\ \textgreater{}\ 1{]}\ \textless{}-\ 1}. You might want to
try timing those variations yourself.)

Or in C++:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\DataTypeTok{double}\NormalTok{ vacc3a(}\DataTypeTok{double}\NormalTok{ age, }\DataTypeTok{bool}\NormalTok{ female, }\DataTypeTok{bool}\NormalTok{ ily)\{}
  \DataTypeTok{double}\NormalTok{ p = }\FloatTok{0.25}\NormalTok{ + }\FloatTok{0.3}\NormalTok{ * }\DecValTok{1}\NormalTok{ / (}\DecValTok{1}\NormalTok{ - exp(}\FloatTok{0.04}\NormalTok{ * age)) + }\FloatTok{0.1}\NormalTok{ * ily;}
\NormalTok{  p = p * (female ? }\FloatTok{1.25}\NormalTok{ : }\FloatTok{0.75}\NormalTok{);}
\NormalTok{  p = }\BuiltInTok{std::}\NormalTok{max(p, }\FloatTok{0.0}\NormalTok{);}
\NormalTok{  p = }\BuiltInTok{std::}\NormalTok{min(p, }\FloatTok{1.0}\NormalTok{);}
  \ControlFlowTok{return}\NormalTok{ p;}
\NormalTok{\}}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector vacc3(NumericVector age, LogicalVector female, }
\NormalTok{                    LogicalVector ily) \{}
  \DataTypeTok{int}\NormalTok{ n = age.size();}
\NormalTok{  NumericVector out(n);}

  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = vacc3a(age[i], female[i], ily[i]);}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We next generate some sample data, and check that all three versions
return the same values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1000}
\NormalTok{age <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(n, }\DataTypeTok{mean =} \DecValTok{50}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{10}\NormalTok{)}
\NormalTok{female <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F), n, }\DataTypeTok{rep =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{ily <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F), n, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.8}\NormalTok{, }\FloatTok{0.2}\NormalTok{), }\DataTypeTok{rep =} \OtherTok{TRUE}\NormalTok{)}

\KeywordTok{stopifnot}\NormalTok{(}
  \KeywordTok{all.equal}\NormalTok{(}\KeywordTok{vacc1}\NormalTok{(age, female, ily), }\KeywordTok{vacc2}\NormalTok{(age, female, ily)),}
  \KeywordTok{all.equal}\NormalTok{(}\KeywordTok{vacc1}\NormalTok{(age, female, ily), }\KeywordTok{vacc3}\NormalTok{(age, female, ily))}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The original blog post forgot to do this, and introduced a bug in the
C++ version: it used \texttt{0.004} instead of \texttt{0.04}. Finally,
we can benchmark our three approaches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{vacc1 =} \KeywordTok{vacc1}\NormalTok{(age, female, ily),}
  \DataTypeTok{vacc2 =} \KeywordTok{vacc2}\NormalTok{(age, female, ily),}
  \DataTypeTok{vacc3 =} \KeywordTok{vacc3}\NormalTok{(age, female, ily)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>   expr     min      lq   mean  median      uq   max neval}
\CommentTok{#>  vacc1 1,730.0 1,870.0 2095.7 1,960.0 2,030.0 5,760   100}
\CommentTok{#>  vacc2   116.0   129.0  228.0   155.0   187.0 6,490   100}
\CommentTok{#>  vacc3    30.3    32.5   52.9    38.3    43.1 1,410   100}
\end{Highlighting}
\end{Shaded}

Not surprisingly, our original approach with loops is very slow.
Vectorising in R gives a huge speedup, and we can eke out even more
performance (\textasciitilde{}10x) with the C++ loop. I was a little
surprised that the C++ was so much faster, but it is because the R
version has to create 11 vectors to store intermediate results, where
the C++ code only needs to create 1.

\hypertarget{rcpp-package}{%
\section{Using Rcpp in a package}\label{rcpp-package}}

The same C++ code that is used with \texttt{sourceCpp()} can also be
bundled into a package. There are several benefits of moving code from a
stand-alone C++ source file to a package: \index{Rcpp!in a package}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Your code can be made available to users without C++ development
  tools.
\item
  Multiple source files and their dependencies are handled automatically
  by the R package build system.
\item
  Packages provide additional infrastructure for testing, documentation,
  and consistency.
\end{enumerate}

To add \texttt{Rcpp} to an existing package, you put your C++ files in
the \texttt{src/} directory and modify/create the following
configuration files:

\begin{itemize}
\item
  In \texttt{DESCRIPTION} add

\begin{verbatim}
LinkingTo: Rcpp
Imports: Rcpp
\end{verbatim}
\item
  Make sure your \texttt{NAMESPACE} includes:

\begin{verbatim}
useDynLib(mypackage)
importFrom(Rcpp, sourceCpp)
\end{verbatim}

  We need to import something (anything) from Rcpp so that internal Rcpp
  code is properly loaded. This is a bug in R and hopefully will be
  fixed in the future.
\end{itemize}

To generate a new Rcpp package that includes a simple ``hello world''
function you can use \texttt{Rcpp.package.skeleton()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Rcpp.package.skeleton}\NormalTok{(}\StringTok{"NewPackage"}\NormalTok{, }\DataTypeTok{attributes =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To generate a package based on C++ files that you've been using with
\texttt{sourceCpp()}, use the \texttt{cpp\_files} parameter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Rcpp.package.skeleton}\NormalTok{(}\StringTok{"NewPackage"}\NormalTok{, }\DataTypeTok{example_code =} \OtherTok{FALSE}\NormalTok{,}
                      \DataTypeTok{cpp_files =} \KeywordTok{c}\NormalTok{(}\StringTok{"convolve.cpp"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Before building the package, you'll need to run
\texttt{Rcpp::compileAttributes()}. This function scans the C++ files
for \texttt{Rcpp::export} attributes and generates the code required to
make the functions available in R. Re-run \texttt{compileAttributes()}
whenever functions are added, removed, or have their signatures changed.
This is done automatically by the devtools package and by Rstudio.

For more details see the Rcpp package vignette,
\texttt{vignette("Rcpp-package")}.

\hypertarget{rcpp-more}{%
\section{Learning more}\label{rcpp-more}}

This chapter has only touched on a small part of Rcpp, giving you the
basic tools to rewrite poorly performing R code in C++. The
\href{http://www.rcpp.org/book}{Rcpp book} is the best reference to
learn more about Rcpp. As noted, Rcpp has many other capabilities that
make it easy to interface R to existing C++ code, including:

\begin{itemize}
\item
  Additional features of attributes including specifying default
  arguments, linking in external C++ dependencies, and exporting C++
  interfaces from packages. These features and more are covered in the
  Rcpp attributes vignette, \texttt{vignette("Rcpp-attributes")}.
\item
  Automatically creating wrappers between C++ data structures and R data
  structures, including mapping C++ classes to reference classes. A good
  introduction to this topic is Rcpp modules vignette,
  \texttt{vignette("Rcpp-modules")}
\item
  The Rcpp quick reference guide, \texttt{vignette("Rcpp-quickref")},
  contains a useful summary of Rcpp classes and common programming
  idioms.
\end{itemize}

I strongly recommend keeping an eye on the
\href{http://www.rcpp.org}{Rcpp homepage} and
\href{http://dirk.eddelbuettel.com/code/rcpp.html}{Dirk's Rcpp page} as
well as signing up for the
\href{http://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/rcpp-devel}{Rcpp
mailing list}. Rcpp is still under active development, and is getting
better with every release.

Other resources I've found helpful in learning C++ are:

\begin{itemize}
\item
  \href{http://amzn.com/0321334876?tag=devtools-20}{\emph{Effective
  C++}} and
  \href{http://amzn.com/0201749629?tag=devtools-20}{\emph{Effective
  STL}} by Scott Meyers.
\item
  \href{http://www.icce.rug.nl/documents/cplusplus/cplusplus.html}{\emph{C++
  Annotations}}, aimed at ``knowledgeable users of C (or any other
  language using a C-like grammar, like Perl or Java) who would like to
  know more about, or make the transition to, C++''.
\item
  \href{http://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/}{\emph{Algorithm
  Libraries}}, which provides a more technical, but still concise,
  description of important STL concepts. (Follow the links under notes).
\end{itemize}

Writing performance code may also require you to rethink your basic
approach: a solid understanding of basic data structures and algorithms
is very helpful here. That's beyond the scope of this book, but I'd
suggest the
\href{http://amzn.com/0387948600?tag=devtools-20}{\emph{Algorithm Design
Manual}}, MIT's
\href{http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/}{\emph{Introduction
to Algorithms}}, \emph{Algorithms} by Robert Sedgewick and Kevin Wayne
which has a free \href{http://algs4.cs.princeton.edu/home/}{online
textbook} and a matching
\href{https://www.coursera.org/course/algs4partI}{coursera course}.

\hypertarget{acknowledgments}{%
\section{Acknowledgments}\label{acknowledgments}}

I'd like to thank the Rcpp-mailing list for many helpful conversations,
particularly Romain Francois and Dirk Eddelbuettel who have not only
provided detailed answers to many of my questions, but have been
incredibly responsive at improving Rcpp. This chapter would not have
been possible without JJ Allaire; he encouraged me to learn C++ and then
answered many of my dumb questions along the way.

\hypertarget{references}{%
\chapter*{References}\label{references}}
\addcontentsline{toc}{chapter}{References}

\hypertarget{refs}{}
\leavevmode\hypertarget{ref-SICP}{}%
Abelson, Harold, Gerald Jay Sussman, and Julie Sussman. 1996.
\emph{Structure and Interpretation of Computer Programs}. MIT Press.

\leavevmode\hypertarget{ref-magrittr}{}%
Bache, Stefan Milton, and Hadley Wickham. 2014. \emph{Magrittr: A
Forward-Pipe Operator for R}. \url{http://magrittr.tidyverse.org/}.

\leavevmode\hypertarget{ref-Matrix}{}%
Bates, Douglas, and Martin Maechler. 2018. ``Matrix: Sparse and Dense
Matrix Classes and Methods.''
\url{https://CRAN.R-project.org/package=Matrix}.

\leavevmode\hypertarget{ref-bawden-1999}{}%
Bawden, Alan. 1999. ``Quasiquotation in Lisp.'' In \emph{PEPM '99},
4--12.
\url{http://repository.readscheme.org/ftp/papers/pepm99/bawden.pdf}.

\leavevmode\hypertarget{ref-R.oo}{}%
Bengtsson, Henrik. 2003. ``The R.oo Package - Object-Oriented
Programming with References Using Standard R Code.'' In
\emph{Proceedings of the 3rd International Workshop on Distributed
Statistical Computing (Dsc 2003)}, edited by Kurt Hornik, Friedrich
Leisch, and Achim Zeileis. Vienna, Austria:
https://www.r-project.org/conferences/DSC-2003/Proceedings/.
\url{https://www.r-project.org/conferences/DSC-2003/Proceedings/Bengtsson.pdf}.

\leavevmode\hypertarget{ref-programming-with-data}{}%
Chambers, John M. 1998. \emph{Programming with Data: A Guide to the S
Language}. Springer Science \& Business Media.

\leavevmode\hypertarget{ref-s4da}{}%
---------. 2008. \emph{Software for Data Analysis: Programming with R}.
Springer.

\leavevmode\hypertarget{ref-chambers-2014}{}%
---------. 2014. ``Object-Oriented Programming, Functional Programming
and R.'' \emph{Statistical Science} 29 (2). Institute of Mathematical
Statistics:167--80.
\url{https://projecteuclid.org/download/pdfview_1/euclid.ss/1408368569}.

\leavevmode\hypertarget{ref-extending-R}{}%
---------. 2016. \emph{Extending R}. CRC Press.

\leavevmode\hypertarget{ref-white-book}{}%
Chambers, John M, and Trevor J Hastie. 1992. \emph{Statistical Models in
S}. Wadsworth \& Brooks/Cole Advanced Books \& Software.

\leavevmode\hypertarget{ref-R6}{}%
Chang, Winston. 2017. \emph{R6: Classes with Reference Semantics}.
\url{https://CRAN.R-project.org/package=R6}.

\leavevmode\hypertarget{ref-data.table}{}%
Dowle, Matt, and Arun Srinivasan. 2018. \emph{Data.table: Extension of
`Data.frame`}. \url{http://r-datatable.com}.

\leavevmode\hypertarget{ref-dsls}{}%
Fowler, Martin. 2010. \emph{Domain-Specific Languages}. Pearson
Education. \url{http://amzn.com/0321712943}.

\leavevmode\hypertarget{ref-lubridate}{}%
Grolemund, Garrett, and Hadley Wickham. 2011. ``Dates and Times Made
Easy with lubridate.'' \emph{Journal of Statistical Software} 40
(3):1--25. \url{http://www.jstatsoft.org/v40/i03/}.

\leavevmode\hypertarget{ref-proto}{}%
Grothendieck, Gabor, Louis Kates, and Thomas Petzoldt. 2016.
\emph{Proto: Prototype Object-Based Programming}.
\url{https://CRAN.R-project.org/package=proto}.

\leavevmode\hypertarget{ref-rlang}{}%
Henry, Lionel, and Hadley Wickham. 2018. \emph{Rlang: Functions for Base
Types and Core R and 'Tidyverse' Features}.
\url{https://rlang.r-lib.org}.

\leavevmode\hypertarget{ref-bench}{}%
Hester, Jim. 2018. \emph{Bench: High Precision Timing of R Expressions}.
\url{http://bench.r-lib.org/}.

\leavevmode\hypertarget{ref-pragprog}{}%
Hunt, Andrew, and David Thomas. 1990. \emph{The Pragmatic Programmer}.
Addison Wesley.

\leavevmode\hypertarget{ref-lumley-2001}{}%
Lumley, Thomas. 2001. ``Programmer's Niche: Macros in R.'' \emph{R News}
1 (3):11--13.
\url{https://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf}.

\leavevmode\hypertarget{ref-tibble}{}%
Müller, Kirill, and Hadley Wickham. 2018. \emph{Tibble: Simple Data
Frames}. \url{https://CRAN.R-project.org/package=tibble}.

\leavevmode\hypertarget{ref-r-ints}{}%
R Core Team. 2018a. ``R Internals.'' \emph{R Foundation for Statistical
Computing}.
\url{https://cran.r-project.org/doc/manuals/r-devel/R-exts.html}.

\leavevmode\hypertarget{ref-r-exts}{}%
---------. 2018b. ``Writing R Extensions.'' \emph{R Foundation for
Statistical Computing}.
\url{https://cran.r-project.org/doc/manuals/r-devel/R-ints.html}.

\leavevmode\hypertarget{ref-zeallot}{}%
Teetor, Nathan. 2018. \emph{Zeallot: Multiple, Unpacking, and
Destructuring Assignment}.
\url{https://CRAN.R-project.org/package=zeallot}.

\leavevmode\hypertarget{ref-ctmcp}{}%
Van-Roy, Peter, and Seif Haridi. 2004. \emph{Concepts, Techniques, and
Models of Computer Programming}. MIT press.

\leavevmode\hypertarget{ref-mutatr}{}%
Wickham, Hadley. 2011. ``Mutatr: Mutable Objects for R.''
\emph{Computational Statistics} 26 (3):405--18.
\url{https://doi.org/10.1007/s00180-011-0235-7}.

\leavevmode\hypertarget{ref-forcats}{}%
---------. 2018. \emph{Forcats: Tools for Working with Categorical
Variables (Factors)}. \url{http://forcats.tidyverse.org}.


\end{document}
